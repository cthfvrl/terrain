# 1 "c:\\users\\cathy\\onedrive\\juce terrain\\source\\contentcomponent.cpp"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 323 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "c:\\users\\cathy\\onedrive\\juce terrain\\source\\contentcomponent.cpp" 2
# 1 "C:\\Users\\Cathy\\OneDrive\\JUCE Terrain\\Source/ContentComponent.h" 1

# 1 "C:\\Users\\Cathy\\OneDrive\\JUCE Terrain\\Source/ControlsOverlay.h" 1

# 1 "C:\\Users\\Cathy\\OneDrive\\JUCE Terrain\\Source/../JuceLibraryCode/JuceHeader.h" 1
# 16 "C:\\Users\\Cathy\\OneDrive\\JUCE Terrain\\Source/../JuceLibraryCode/JuceHeader.h"
# 1 "..\\..\\JuceLibraryCode/AppConfig.h" 1
# 16 "C:\\Users\\Cathy\\OneDrive\\JUCE Terrain\\Source/../JuceLibraryCode/JuceHeader.h" 2


# 1 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 1
# 66 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h"
#pragma warning(push)

#pragma warning(disable: 4251 4786 4668 4820)






# 1 "..\\..\\..\\JUCE\\modules\\juce_core/system/juce_TargetPlatform.h" 1
# 74 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2
# 182 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h"
# 1 "..\\..\\..\\JUCE\\modules\\juce_core/system/juce_StandardHeader.h" 1
# 55 "..\\..\\..\\JUCE\\modules\\juce_core/system/juce_StandardHeader.h"
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\memory" 1 3





# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory" 1 3





# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory0" 1 3





# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\cstdint" 1 3




# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\yvals.h" 1 3






# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xkeycheck.h" 1 3
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\yvals.h" 2 3

# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\crtdefs.h" 1 3








# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime.h" 1 3
# 45 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\8.1\\Include\\shared\\sal.h" 1 3
# 2381 "C:\\Program Files (x86)\\Windows Kits\\8.1\\Include\\shared\\sal.h" 3
extern "C" {
# 2987 "C:\\Program Files (x86)\\Windows Kits\\8.1\\Include\\shared\\sal.h" 3
}



# 1 "C:\\Program Files (x86)\\Windows Kits\\8.1\\Include\\shared\\ConcurrencySal.h" 1 3
# 22 "C:\\Program Files (x86)\\Windows Kits\\8.1\\Include\\shared\\ConcurrencySal.h" 3
extern "C" {
# 354 "C:\\Program Files (x86)\\Windows Kits\\8.1\\Include\\shared\\ConcurrencySal.h" 3
}
# 2990 "C:\\Program Files (x86)\\Windows Kits\\8.1\\Include\\shared\\sal.h" 2 3
# 45 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime.h" 2 3

# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vadefs.h" 1 3
# 15 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vadefs.h" 3
#pragma pack(push, 8)


extern "C" {
# 30 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vadefs.h" 3
        typedef unsigned int uintptr_t;
# 39 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vadefs.h" 3
        typedef char* va_list;
# 118 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vadefs.h" 3
}



    extern "C++"
    {
        template <typename _Ty>
        struct __vcrt_va_list_is_reference
        {
            enum : bool { __the_value = false };
        };

        template <typename _Ty>
        struct __vcrt_va_list_is_reference<_Ty&>
        {
            enum : bool { __the_value = true };
        };

        template <typename _Ty>
        struct __vcrt_va_list_is_reference<_Ty&&>
        {
            enum : bool { __the_value = true };
        };

        template <typename _Ty>
        void __vcrt_va_start_verify_argument_type() throw()
        {
            static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
        }
    }
# 157 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vadefs.h" 3
#pragma pack(pop)
# 46 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime.h" 2 3
# 81 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime.h" 3
#pragma pack(push, 8)
# 81 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime.h" 3
 extern "C" {
# 198 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime.h" 3
    typedef unsigned int size_t;
    typedef int ptrdiff_t;
    typedef int intptr_t;



    typedef bool __vcrt_bool;
# 247 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime.h" 3
    extern "C++"
    {
        template <typename _CountofType, size_t _SizeOfArray>
        char (*__countof_helper( _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];


    }
# 298 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime.h" 3
    void __cdecl __security_init_cookie(void);


        void __fastcall __security_check_cookie( uintptr_t _StackCookie);
        __declspec(noreturn) void __cdecl __report_gsfailure(void);






extern uintptr_t __security_cookie;







}
# 317 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime.h" 3
#pragma pack(pop)
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\crtdefs.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt.h" 1 3
# 10 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime.h" 1 3
# 10 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt.h" 2 3


#pragma pack(push, 8)
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt.h" 3
 extern "C" {
# 119 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt.h" 3
extern "C++"
{
    template<bool _Enable, typename _Ty>
    struct _CrtEnableIf;

    template<typename _Ty>
    struct _CrtEnableIf<true, _Ty>
    {
        typedef _Ty _Type;
    };
}



    typedef bool __crt_bool;
# 226 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt.h" 3
             void __cdecl _invalid_parameter_noinfo(void);
         __declspec(noreturn) void __cdecl _invalid_parameter_noinfo_noreturn(void);

__declspec(noreturn)
         void __cdecl _invoke_watson(
               wchar_t const*,
               wchar_t const*,
               wchar_t const*,
               unsigned int,
               uintptr_t);
# 448 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt.h" 3
typedef int errno_t;
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
typedef long __time32_t;
typedef __int64 __time64_t;

typedef struct __crt_locale_data_public
{
      unsigned short const* _locale_pctype;
                        int _locale_mb_cur_max;
               unsigned int _locale_lc_codepage;
} __crt_locale_data_public;

typedef struct __crt_locale_pointers
{
    struct __crt_locale_data* locinfo;
    struct __crt_multibyte_data* mbcinfo;
} __crt_locale_pointers;

typedef __crt_locale_pointers* _locale_t;

typedef struct _Mbstatet
{
    unsigned long _Wchar;
    unsigned short _Byte, _State;
} _Mbstatet;

typedef _Mbstatet mbstate_t;
# 489 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt.h" 3
        typedef __time64_t time_t;
# 499 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt.h" 3
    typedef size_t rsize_t;
# 1901 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt.h" 3
}
# 1901 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt.h" 3
#pragma pack(pop)
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\crtdefs.h" 2 3
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\yvals.h" 2 3


#pragma pack(push,8)
# 253 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\yvals.h" 3
#pragma detect_mismatch("_MSC_VER", "1900")



#pragma detect_mismatch("_ITERATOR_DEBUG_LEVEL", "0")




#pragma detect_mismatch("RuntimeLibrary", "MT_StaticRelease")
# 412 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\yvals.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\use_ansi.h" 1 3
# 57 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\use_ansi.h" 3
#pragma comment(lib, "libcpmt" "" "")
# 412 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\yvals.h" 2 3
# 592 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\yvals.h" 3
typedef long long _Longlong;
typedef unsigned long long _ULonglong;
# 611 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\yvals.h" 3
namespace std {
enum _Uninitialized
 {
 _Noinit
 };



#pragma warning(push)
#pragma warning(disable: 4412)
class _Lockit
 {
public:
# 644 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\yvals.h" 3
 __thiscall _Lockit();
 explicit __thiscall _Lockit(int);
 __thiscall ~_Lockit() noexcept;


 static void __cdecl _Lockit_ctor(int);
 static void __cdecl _Lockit_dtor(int);

private:
 static void __cdecl _Lockit_ctor(_Lockit *);
 static void __cdecl _Lockit_ctor(_Lockit *, int);
 static void __cdecl _Lockit_dtor(_Lockit *);

public:
                    _Lockit(const _Lockit&) = delete;
 _Lockit& operator=(const _Lockit&) = delete;

private:
 int _Locktype;
# 677 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\yvals.h" 3
 };
# 764 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\yvals.h" 3
class _Init_locks
 {
public:
# 780 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\yvals.h" 3
 __thiscall _Init_locks();
 __thiscall ~_Init_locks() noexcept;


private:
 static void __cdecl _Init_locks_ctor(_Init_locks *);
 static void __cdecl _Init_locks_dtor(_Init_locks *);
# 797 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\yvals.h" 3
 };

#pragma warning(pop)
}
# 809 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\yvals.h" 3
         void __cdecl _Atexit(void (__cdecl *)(void));

typedef unsigned long _Uint32t;





#pragma pack(pop)
# 5 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\cstdint" 2 3








# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\stdint.h" 1 3
# 13 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\stdint.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime.h" 1 3
# 13 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\stdint.h" 2 3




typedef signed char int8_t;
typedef short int16_t;
typedef int int32_t;
typedef long long int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef unsigned long long uint64_t;

typedef signed char int_least8_t;
typedef short int_least16_t;
typedef int int_least32_t;
typedef long long int_least64_t;
typedef unsigned char uint_least8_t;
typedef unsigned short uint_least16_t;
typedef unsigned int uint_least32_t;
typedef unsigned long long uint_least64_t;

typedef signed char int_fast8_t;
typedef int int_fast16_t;
typedef int int_fast32_t;
typedef long long int_fast64_t;
typedef unsigned char uint_fast8_t;
typedef unsigned int uint_fast16_t;
typedef unsigned int uint_fast32_t;
typedef unsigned long long uint_fast64_t;

typedef long long intmax_t;
typedef unsigned long long uintmax_t;
# 13 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\cstdint" 2 3




namespace std {
using :: int8_t; using :: int16_t;
using :: int32_t; using :: int64_t;
using :: uint8_t; using :: uint16_t;
using :: uint32_t; using :: uint64_t;

using :: int_least8_t; using :: int_least16_t;
using :: int_least32_t; using :: int_least64_t;
using :: uint_least8_t; using :: uint_least16_t;
using :: uint_least32_t; using :: uint_least64_t;

using :: int_fast8_t; using :: int_fast16_t;
using :: int_fast32_t; using :: int_fast64_t;
using :: uint_fast8_t; using :: uint_fast16_t;
using :: uint_fast32_t; using :: uint_fast64_t;

using :: intmax_t; using :: intptr_t;
using :: uintmax_t; using :: uintptr_t;


 namespace tr1 {
using :: int8_t; using :: int16_t;
using :: int32_t; using :: int64_t;
using :: uint8_t; using :: uint16_t;
using :: uint32_t; using :: uint64_t;

using :: int_least8_t; using :: int_least16_t;
using :: int_least32_t; using :: int_least64_t;
using :: uint_least8_t; using :: uint_least16_t;
using :: uint_least32_t; using :: uint_least64_t;

using :: int_fast8_t; using :: int_fast16_t;
using :: int_fast32_t; using :: int_fast64_t;
using :: uint_fast8_t; using :: uint_fast16_t;
using :: uint_fast32_t; using :: uint_fast64_t;

using :: intmax_t; using :: intptr_t;
using :: uintmax_t; using :: uintptr_t;
 }

}
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory0" 2 3

# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\cstdlib" 1 3
# 13 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\cstdlib" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdlib.h" 1 3
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdlib.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_malloc.h" 1 3
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_malloc.h" 3
#pragma pack(push, 8)
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_malloc.h" 3
 extern "C" {
# 54 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_malloc.h" 3
         __declspec(allocator) __declspec(restrict)
void* __cdecl _calloc_base(
         size_t _Count,
         size_t _Size
    );


                            __declspec(allocator) __declspec(restrict)
void* __cdecl calloc(
                            size_t _Count,
                            size_t _Size
    );


         int __cdecl _callnewh(
         size_t _Size
    );


         __declspec(allocator)
void* __cdecl _expand(
                            void* _Block,
                            size_t _Size
    );


void __cdecl _free_base(
                                   void* _Block
    );


void __cdecl free(
                                   void* _Block
    );


         __declspec(allocator) __declspec(restrict)
void* __cdecl _malloc_base(
         size_t _Size
    );


         __declspec(allocator) __declspec(restrict)
void* __cdecl malloc(
                            size_t _Size
    );



size_t __cdecl _msize(
                  void* _Block
    );


         __declspec(allocator) __declspec(restrict)
void* __cdecl _realloc_base(
                                    void* _Block,
                                    size_t _Size
    );


         __declspec(allocator) __declspec(restrict)
void* __cdecl realloc(
                                   void* _Block,
                                   size_t _Size
    );


         __declspec(allocator) __declspec(restrict)
void* __cdecl _recalloc(
                                   void* _Block,
                                   size_t _Count,
                                   size_t _Size
    );


void __cdecl _aligned_free(
                                   void* _Block
    );


         __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_malloc(
                            size_t _Size,
                            size_t _Alignment
    );


         __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_malloc(
                            size_t _Size,
                            size_t _Alignment,
                            size_t _Offset
    );



size_t __cdecl _aligned_msize(
                  void* _Block,
                  size_t _Alignment,
                  size_t _Offset
    );


         __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_realloc(
                                   void* _Block,
                                   size_t _Size,
                                   size_t _Alignment,
                                   size_t _Offset
    );


         __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_recalloc(
                                   void* _Block,
                                   size_t _Count,
                                   size_t _Size,
                                   size_t _Alignment,
                                   size_t _Offset
    );


         __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_realloc(
                                   void* _Block,
                                   size_t _Size,
                                   size_t _Alignment
    );


         __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_recalloc(
                                   void* _Block,
                                   size_t _Count,
                                   size_t _Size,
                                   size_t _Alignment
    );
# 214 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_malloc.h" 3
}
# 214 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_malloc.h" 3
#pragma pack(pop)
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdlib.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_search.h" 1 3
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_search.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stddef.h" 1 3
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stddef.h" 3
#pragma pack(push, 8)
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stddef.h" 3
 extern "C" {




    namespace std
    {
        typedef decltype(__nullptr) nullptr_t;
    }

    using ::std::nullptr_t;





         int* __cdecl _errno(void);


         errno_t __cdecl _set_errno( int _Value);
         errno_t __cdecl _get_errno( int* _Value);
# 46 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stddef.h" 3
         extern unsigned long __cdecl __threadid(void);

         extern uintptr_t __cdecl __threadhandle(void);



}
# 52 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stddef.h" 3
#pragma pack(pop)
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_search.h" 2 3


#pragma pack(push, 8)
# 16 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_search.h" 3
 extern "C" {






             void* __cdecl bsearch_s(
                                                           void const* _Key,
                                                           void const* _Base,
                                                           rsize_t _NumOfElements,
                                                           rsize_t _SizeOfElements,
             int (__cdecl* _PtFuncCompare)(void*, void const*, void const*),
                                                           void* _Context
        );

             void __cdecl qsort_s(
                                                                void* _Base,
                                                                rsize_t _NumOfElements,
                                                                rsize_t _SizeOfElements,
             int (__cdecl* _PtFuncCompare)(void*, void const*, void const*),
                                                                void* _Context
        );






         void* __cdecl bsearch(
                                                       void const* _Key,
                                                       void const* _Base,
                                                       size_t _NumOfElements,
                                                       size_t _SizeOfElements,
         int (__cdecl* _PtFuncCompare)(void const*, void const*)
    );

         void __cdecl qsort(
                                                            void* _Base,
                                                            size_t _NumOfElements,
                                                            size_t _SizeOfElements,
         int (__cdecl* _PtFuncCompare)(void const*, void const*)
    );


         void* __cdecl _lfind_s(
                                                          void const* _Key,
                                                          void const* _Base,
                                                          unsigned int* _NumOfElements,
                                                          size_t _SizeOfElements,
         int (__cdecl* _PtFuncCompare)(void*, void const*, void const*),
                                                          void* _Context
    );


         void* __cdecl _lfind(
                                                          void const* _Key,
                                                          void const* _Base,
                                                          unsigned int* _NumOfElements,
                                                          unsigned int _SizeOfElements,
         int (__cdecl* _PtFuncCompare)(void const*, void const*)
    );


         void* __cdecl _lsearch_s(
                                                                void const* _Key,
                                                                void* _Base,
                                                                unsigned int* _NumOfElements,
                                                                size_t _SizeOfElements,
         int (__cdecl* _PtFuncCompare)(void*, void const*, void const*),
                                                                void* _Context
    );


         void* __cdecl _lsearch(
                                                                void const* _Key,
                                                                void* _Base,
                                                                unsigned int* _NumOfElements,
                                                                unsigned int _SizeOfElements,
         int (__cdecl* _PtFuncCompare)(void const*, void const*)
    );
# 184 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_search.h" 3
                   __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_lfind" ". See online help for details."))
             void* __cdecl lfind(
                                                              void const* _Key,
                                                              void const* _Base,
                                                              unsigned int* _NumOfElements,
                                                              unsigned int _SizeOfElements,
             int (__cdecl* _PtFuncCompare)(void const*, void const*)
        );

                   __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_lsearch" ". See online help for details."))
             void* __cdecl lsearch(
                                                                   void const* _Key,
                                                                   void* _Base,
                                                                   unsigned int* _NumOfElements,
                                                                   unsigned int _SizeOfElements,
             int (__cdecl* _PtFuncCompare)(void const*, void const*)
        );





}
# 206 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_search.h" 3
#pragma pack(pop)
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdlib.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstdlib.h" 1 3
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstdlib.h" 3
#pragma pack(push, 8)
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstdlib.h" 3
 extern "C" {
# 48 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstdlib.h" 3
         errno_t __cdecl _itow_s(
                                 int _Value,
                                 wchar_t* _Buffer,
                                 size_t _BufferCount,
                                 int _Radix
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _itow_s(int _Value, wchar_t (&_Buffer)[_Size], int _Radix) throw() { return _itow_s(_Value, _Buffer, _Size, _Radix); } }






 wchar_t* __cdecl _itow(int _Value, wchar_t *_Buffer, int _Radix);
# 71 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstdlib.h" 3
         errno_t __cdecl _ltow_s(
                                 long _Value,
                                 wchar_t* _Buffer,
                                 size_t _BufferCount,
                                 int _Radix
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltow_s(long _Value, wchar_t (&_Buffer)[_Size], int _Radix) throw() { return _ltow_s(_Value, _Buffer, _Size, _Radix); } }






 wchar_t* __cdecl _ltow(long _Value, wchar_t *_Buffer, int _Radix);







         errno_t __cdecl _ultow_s(
                                 unsigned long _Value,
                                 wchar_t* _Buffer,
                                 size_t _BufferCount,
                                 int _Radix
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultow_s(unsigned long _Value, wchar_t (&_Buffer)[_Size], int _Radix) throw() { return _ultow_s(_Value, _Buffer, _Size, _Radix); } }






 wchar_t* __cdecl _ultow(unsigned long _Value, wchar_t *_Buffer, int _Radix);







         double __cdecl wcstod(
                             wchar_t const* _String,
                             wchar_t** _EndPtr
    );


         double __cdecl _wcstod_l(
                             wchar_t const* _String,
                             wchar_t** _EndPtr,
                             _locale_t _Locale
    );


         long __cdecl wcstol(
                             wchar_t const* _String,
                             wchar_t** _EndPtr,
                             int _Radix
    );


         long __cdecl _wcstol_l(
                             wchar_t const* _String,
                             wchar_t** _EndPtr,
                             int _Radix,
                             _locale_t _Locale
    );


         long long __cdecl wcstoll(
                             wchar_t const* _String,
                             wchar_t** _EndPtr,
                             int _Radix
    );


         long long __cdecl _wcstoll_l(
                             wchar_t const* _String,
                             wchar_t** _EndPtr,
                             int _Radix,
                             _locale_t _Locale
    );


         unsigned long __cdecl wcstoul(
                             wchar_t const* _String,
                             wchar_t** _EndPtr,
                             int _Radix
    );


         unsigned long __cdecl _wcstoul_l(
                             wchar_t const* _String,
                             wchar_t** _EndPtr,
                             int _Radix,
                             _locale_t _Locale
    );


         unsigned long long __cdecl wcstoull(
                             wchar_t const* _String,
                             wchar_t** _EndPtr,
                             int _Radix
    );


         unsigned long long __cdecl _wcstoull_l(
                             wchar_t const* _String,
                             wchar_t** _EndPtr,
                             int _Radix,
                             _locale_t _Locale
    );


         long double __cdecl wcstold(
                             wchar_t const* _String,
                             wchar_t** _EndPtr
    );


         long double __cdecl _wcstold_l(
                             wchar_t const* _String,
                             wchar_t** _EndPtr,
                             _locale_t _Locale
    );


         float __cdecl wcstof(
                             wchar_t const* _String,
                             wchar_t** _EndPtr
    );


         float __cdecl _wcstof_l(
                             wchar_t const* _String,
                             wchar_t** _EndPtr,
                             _locale_t _Locale
    );


         double __cdecl _wtof(
           wchar_t const* _String
    );


         double __cdecl _wtof_l(
             wchar_t const* _String,
             _locale_t _Locale
    );


         int __cdecl _wtoi(
           wchar_t const* _String
    );


         int __cdecl _wtoi_l(
             wchar_t const* _String,
             _locale_t _Locale
    );


         long __cdecl _wtol(
           wchar_t const* _String
    );


         long __cdecl _wtol_l(
             wchar_t const* _String,
             _locale_t _Locale
    );


         long long __cdecl _wtoll(
           wchar_t const* _String
    );


         long long __cdecl _wtoll_l(
             wchar_t const* _String,
             _locale_t _Locale
    );


         errno_t __cdecl _i64tow_s(
                                 __int64 _Value,
                                 wchar_t* _Buffer,
                                 size_t _BufferCount,
                                 int _Radix
    );


         wchar_t* __cdecl _i64tow(
                           __int64 _Value,
                           wchar_t* _Buffer,
                           int _Radix
    );


         errno_t __cdecl _ui64tow_s(
                                 unsigned __int64 _Value,
                                 wchar_t* _Buffer,
                                 size_t _BufferCount,
                                 int _Radix
    );


         wchar_t* __cdecl _ui64tow(
                           unsigned __int64 _Value,
                           wchar_t* _Buffer,
                           int _Radix
    );


         __int64 __cdecl _wtoi64(
           wchar_t const* _String
    );


         __int64 __cdecl _wtoi64_l(
             wchar_t const* _String,
             _locale_t _Locale
    );


         __int64 __cdecl _wcstoi64(
                             wchar_t const* _String,
                             wchar_t** _EndPtr,
                             int _Radix
    );


         __int64 __cdecl _wcstoi64_l(
                             wchar_t const* _String,
                             wchar_t** _EndPtr,
                             int _Radix,
                             _locale_t _Locale
    );


         unsigned __int64 __cdecl _wcstoui64(
                             wchar_t const* _String,
                             wchar_t** _EndPtr,
                             int _Radix
    );


         unsigned __int64 __cdecl _wcstoui64_l(
                             wchar_t const* _String,
                             wchar_t** _EndPtr,
                             int _Radix,
                             _locale_t _Locale
    );






         __declspec(allocator) wchar_t* __cdecl _wfullpath(
                                     wchar_t* _Buffer,
                                     wchar_t const* _Path,
                                     size_t _BufferCount
    );




         errno_t __cdecl _wmakepath_s(
                                 wchar_t* _Buffer,
                                 size_t _BufferCount,
                                 wchar_t const* _Drive,
                                 wchar_t const* _Dir,
                                 wchar_t const* _Filename,
                                 wchar_t const* _Ext
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmakepath_s(wchar_t (&_Buffer)[_Size], wchar_t const* _Drive, wchar_t const* _Dir, wchar_t const* _Filename, wchar_t const* _Ext) throw() { return _wmakepath_s(_Buffer, _Size, _Drive, _Dir, _Filename, _Ext); } }
# 360 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstdlib.h" 3
 void __cdecl _wmakepath( wchar_t *_Buffer, wchar_t const* _Drive, wchar_t const* _Dir, wchar_t const* _Filename, wchar_t const* _Ext);
# 369 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstdlib.h" 3
         void __cdecl _wperror(
               wchar_t const* _ErrMsg
    );


         void __cdecl _wsplitpath(
                             wchar_t const* _FullPath,
                             wchar_t* _Drive,
                             wchar_t* _Dir,
                             wchar_t* _Filename,
                             wchar_t* _Ext
    );

         errno_t __cdecl _wsplitpath_s(
                                       wchar_t const* _FullPath,
                                       wchar_t* _Drive,
                                       size_t _DriveCount,
                                       wchar_t* _Dir,
                                       size_t _DirCount,
                                       wchar_t* _Filename,
                                       size_t _FilenameCount,
                                       wchar_t* _Ext,
                                       size_t _ExtCount
    );

extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _wsplitpath_s( wchar_t const* _Path, wchar_t (&_Drive)[_DriveSize], wchar_t (&_Dir)[_DirSize], wchar_t (&_Name)[_NameSize], wchar_t (&_Ext)[_ExtSize] ) throw() { return _wsplitpath_s(_Path, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }
# 407 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstdlib.h" 3
             errno_t __cdecl _wdupenv_s(
                                                                                    wchar_t** _Buffer,
                                                                                    size_t* _BufferCount,
                                                                                    wchar_t const* _VarName
        );




             wchar_t* __cdecl _wgetenv(
               wchar_t const* _VarName
        );



             errno_t __cdecl _wgetenv_s(
                                         size_t* _RequiredCount,
                                         wchar_t* _Buffer,
                                         size_t _BufferCount,
                                         wchar_t const* _VarName
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _wgetenv_s(size_t* _RequiredCount, wchar_t (&_Buffer)[_Size], wchar_t const* _VarName) throw() { return _wgetenv_s(_RequiredCount, _Buffer, _Size, _VarName); } }
# 438 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstdlib.h" 3
             int __cdecl _wputenv(
               wchar_t const* _EnvString
        );


             errno_t __cdecl _wputenv_s(
               wchar_t const* _Name,
               wchar_t const* _Value
        );

             errno_t __cdecl _wsearchenv_s(
                                     wchar_t const* _Filename,
                                     wchar_t const* _VarName,
                                     wchar_t* _Buffer,
                                     size_t _BufferCount
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _wsearchenv_s(wchar_t const* _Filename, wchar_t const* _VarName, wchar_t (&_ResultPath)[_Size]) throw() { return _wsearchenv_s(_Filename, _VarName, _ResultPath, _Size); } }






    void __cdecl _wsearchenv(wchar_t const* _Filename, wchar_t const* _VarName, wchar_t *_ResultPath);






             int __cdecl _wsystem(
                   wchar_t const* _Command
        );





}
# 477 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstdlib.h" 3
#pragma pack(pop)
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdlib.h" 2 3

# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\limits.h" 1 3
# 11 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\limits.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime.h" 1 3
# 11 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\limits.h" 2 3


#pragma pack(push, 8)
# 13 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\limits.h" 3
 extern "C" {
# 88 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\limits.h" 3
}
# 88 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\limits.h" 3
#pragma pack(pop)
# 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdlib.h" 2 3


#pragma pack(push, 8)
# 17 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdlib.h" 3
 extern "C" {
# 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdlib.h" 3
         void __cdecl _swab(
                                                                     char* _Buf1,
                                                                     char* _Buf2,
                                                                     int _SizeInBytes
    );
# 50 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdlib.h" 3
         __declspec(noreturn) void __cdecl exit( int _Code);
         __declspec(noreturn) void __cdecl _exit( int _Code);
         __declspec(noreturn) void __cdecl _Exit( int _Code);
         __declspec(noreturn) void __cdecl quick_exit( int _Code);
         __declspec(noreturn) void __cdecl abort(void);





         unsigned int __cdecl _set_abort_behavior(
         unsigned int _Flags,
         unsigned int _Mask
    );




    typedef int (__cdecl* _onexit_t)(void);
# 139 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdlib.h" 3
    int __cdecl atexit(void (__cdecl*)(void));
    _onexit_t __cdecl _onexit( _onexit_t _Func);


int __cdecl at_quick_exit(void (__cdecl*)(void));
# 154 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdlib.h" 3
    typedef void (__cdecl* _purecall_handler)(void);


    typedef void (__cdecl* _invalid_parameter_handler)(
        wchar_t const*,
        wchar_t const*,
        wchar_t const*,
        unsigned int,
        uintptr_t
        );


             _purecall_handler __cdecl _set_purecall_handler(
                 _purecall_handler _Handler
        );

             _purecall_handler __cdecl _get_purecall_handler(void);


             _invalid_parameter_handler __cdecl _set_invalid_parameter_handler(
                 _invalid_parameter_handler _Handler
        );

             _invalid_parameter_handler __cdecl _get_invalid_parameter_handler(void);

             _invalid_parameter_handler __cdecl _set_thread_local_invalid_parameter_handler(
                 _invalid_parameter_handler _Handler
        );

             _invalid_parameter_handler __cdecl _get_thread_local_invalid_parameter_handler(void);
# 207 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdlib.h" 3
                            int __cdecl _set_error_mode( int _Mode);



         int* __cdecl _errno(void);


         errno_t __cdecl _set_errno( int _Value);
         errno_t __cdecl _get_errno( int* _Value);

         unsigned long* __cdecl __doserrno(void);


         errno_t __cdecl _set_doserrno( unsigned long _Value);
         errno_t __cdecl _get_doserrno( unsigned long * _Value);


                                           char** __cdecl __sys_errlist(void);


                                           int * __cdecl __sys_nerr(void);


         void __cdecl perror( char const* _ErrMsg);




                                                       char** __cdecl __p__pgmptr (void);
                                                       wchar_t** __cdecl __p__wpgmptr(void);
                                                       int* __cdecl __p__fmode (void);
# 250 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdlib.h" 3
         errno_t __cdecl _get_pgmptr ( char** _Value);


         errno_t __cdecl _get_wpgmptr( wchar_t** _Value);

         errno_t __cdecl _set_fmode ( int _Mode );

         errno_t __cdecl _get_fmode ( int* _PMode);
# 266 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdlib.h" 3
typedef struct _div_t
{
    int quot;
    int rem;
} div_t;

typedef struct _ldiv_t
{
    long quot;
    long rem;
} ldiv_t;

typedef struct _lldiv_t
{
    long long quot;
    long long rem;
} lldiv_t;

               int __cdecl abs ( int _Number);
               long __cdecl labs ( long _Number);
               long long __cdecl llabs ( long long _Number);
               __int64 __cdecl _abs64( __int64 _Number);

               unsigned short __cdecl _byteswap_ushort( unsigned short _Number);
               unsigned long __cdecl _byteswap_ulong ( unsigned long _Number);
               unsigned __int64 __cdecl _byteswap_uint64( unsigned __int64 _Number);

                        div_t __cdecl div ( int _Numerator, int _Denominator);
                        ldiv_t __cdecl ldiv ( long _Numerator, long _Denominator);
                        lldiv_t __cdecl lldiv( long long _Numerator, long long _Denominator);



#pragma warning(push)
#pragma warning(disable: 6540)

unsigned int __cdecl _rotl(
         unsigned int _Value,
         int _Shift
    );


unsigned long __cdecl _lrotl(
         unsigned long _Value,
         int _Shift
    );

unsigned __int64 __cdecl _rotl64(
         unsigned __int64 _Value,
         int _Shift
    );

unsigned int __cdecl _rotr(
         unsigned int _Value,
         int _Shift
    );


unsigned long __cdecl _lrotr(
         unsigned long _Value,
         int _Shift
    );

unsigned __int64 __cdecl _rotr64(
         unsigned __int64 _Value,
         int _Shift
    );

#pragma warning(pop)






 void __cdecl srand( unsigned int _Seed);

                        int __cdecl rand(void);
# 352 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdlib.h" 3
extern "C++"
{
    inline long abs(long const _X) throw()
    {
        return labs(_X);
    }

    inline long long abs(long long const _X) throw()
    {
        return llabs(_X);
    }

    inline ldiv_t div(long const _A1, long const _A2) throw()
    {
        return ldiv(_A1, _A2);
    }

    inline lldiv_t div(long long const _A1, long long const _A2) throw()
    {
        return lldiv(_A1, _A2);
    }
}
# 385 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdlib.h" 3
#pragma pack(push, 4)
 typedef struct
    {
        unsigned char ld[10];
    } _LDOUBLE;
#pragma pack(pop)
# 406 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdlib.h" 3
typedef struct
{
    double x;
} _CRT_DOUBLE;

typedef struct
{
    float f;
} _CRT_FLOAT;





typedef struct
{
    long double x;
} _LONGDOUBLE;



#pragma pack(push, 4)
typedef struct
{
    unsigned char ld12[12];
} _LDBL12;
#pragma pack(pop)








 double __cdecl atof ( char const* _String);
                                           int __cdecl atoi ( char const* _String);
                                           long __cdecl atol ( char const* _String);
                                           long long __cdecl atoll ( char const* _String);
                                           __int64 __cdecl _atoi64( char const* _String);

                        double __cdecl _atof_l ( char const* _String, _locale_t _Locale);
                        int __cdecl _atoi_l ( char const* _String, _locale_t _Locale);
                        long __cdecl _atol_l ( char const* _String, _locale_t _Locale);
                        long long __cdecl _atoll_l ( char const* _String, _locale_t _Locale);
                        __int64 __cdecl _atoi64_l( char const* _String, _locale_t _Locale);

                        int __cdecl _atoflt ( _CRT_FLOAT* _Result, char const* _String);
                        int __cdecl _atodbl ( _CRT_DOUBLE* _Result, char* _String);
                        int __cdecl _atoldbl( _LDOUBLE* _Result, char* _String);


         int __cdecl _atoflt_l(
             _CRT_FLOAT* _Result,
             char const* _String,
             _locale_t _Locale
    );


         int __cdecl _atodbl_l(
             _CRT_DOUBLE* _Result,
             char* _String,
             _locale_t _Locale
    );



         int __cdecl _atoldbl_l(
             _LDOUBLE* _Result,
             char* _String,
             _locale_t _Locale
    );


         float __cdecl strtof(
                             char const* _String,
                             char** _EndPtr
    );


         float __cdecl _strtof_l(
                             char const* _String,
                             char** _EndPtr,
                             _locale_t _Locale
    );


         double __cdecl strtod(
                             char const* _String,
                             char** _EndPtr
    );


         double __cdecl _strtod_l(
                             char const* _String,
                             char** _EndPtr,
                             _locale_t _Locale
    );


         long double __cdecl strtold(
                             char const* _String,
                             char** _EndPtr
    );


         long double __cdecl _strtold_l(
                             char const* _String,
                             char** _EndPtr,
                             _locale_t _Locale
    );


         long __cdecl strtol(
                             char const* _String,
                             char** _EndPtr,
                             int _Radix
    );


         long __cdecl _strtol_l(
                             char const* _String,
                             char** _EndPtr,
                             int _Radix,
                             _locale_t _Locale
    );


         long long __cdecl strtoll(
                             char const* _String,
                             char** _EndPtr,
                             int _Radix
    );


         long long __cdecl _strtoll_l(
                             char const* _String,
                             char** _EndPtr,
                             int _Radix,
                             _locale_t _Locale
    );


         unsigned long __cdecl strtoul(
                             char const* _String,
                             char** _EndPtr,
                             int _Radix
    );


         unsigned long __cdecl _strtoul_l(
                             char const* _String,
                             char** _EndPtr,
                             int _Radix,
                             _locale_t _Locale
    );


         unsigned long long __cdecl strtoull(
                             char const* _String,
                             char** _EndPtr,
                             int _Radix
    );


         unsigned long long __cdecl _strtoull_l(
                             char const* _String,
                             char** _EndPtr,
                             int _Radix,
                             _locale_t _Locale
    );


         __int64 __cdecl _strtoi64(
                             char const* _String,
                             char** _EndPtr,
                             int _Radix
    );


         __int64 __cdecl _strtoi64_l(
                             char const* _String,
                             char** _EndPtr,
                             int _Radix,
                             _locale_t _Locale
    );


         unsigned __int64 __cdecl _strtoui64(
                             char const* _String,
                             char** _EndPtr,
                             int _Radix
    );


         unsigned __int64 __cdecl _strtoui64_l(
                             char const* _String,
                             char** _EndPtr,
                             int _Radix,
                             _locale_t _Locale
    );
# 617 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdlib.h" 3
         errno_t __cdecl _itoa_s(
                                 int _Value,
                                 char* _Buffer,
                                 size_t _BufferCount,
                                 int _Radix
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _itoa_s(int _Value, char (&_Buffer)[_Size], int _Radix) throw() { return _itoa_s(_Value, _Buffer, _Size, _Radix); } }







 char* __cdecl _itoa(int _Value, char *_Buffer, int _Radix);
# 641 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdlib.h" 3
         errno_t __cdecl _ltoa_s(
                                 long _Value,
                                 char* _Buffer,
                                 size_t _BufferCount,
                                 int _Radix
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltoa_s(long _Value, char (&_Buffer)[_Size], int _Radix) throw() { return _ltoa_s(_Value, _Buffer, _Size, _Radix); } }






 char* __cdecl _ltoa(long _Value, char *_Buffer, int _Radix);
# 664 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdlib.h" 3
         errno_t __cdecl _ultoa_s(
                                 unsigned long _Value,
                                 char* _Buffer,
                                 size_t _BufferCount,
                                 int _Radix
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultoa_s(unsigned long _Value, char (&_Buffer)[_Size], int _Radix) throw() { return _ultoa_s(_Value, _Buffer, _Size, _Radix); } }






 char* __cdecl _ultoa(unsigned long _Value, char *_Buffer, int _Radix);
# 687 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdlib.h" 3
         errno_t __cdecl _i64toa_s(
                                 __int64 _Value,
                                 char* _Buffer,
                                 size_t _BufferCount,
                                 int _Radix
    );



         char* __cdecl _i64toa(
                           __int64 _Value,
                           char* _Buffer,
                           int _Radix
    );



         errno_t __cdecl _ui64toa_s(
                                 unsigned __int64 _Value,
                                 char* _Buffer,
                                 size_t _BufferCount,
                                 int _Radix
    );


         char* __cdecl _ui64toa(
                           unsigned __int64 _Value,
                           char* _Buffer,
                           int _Radix
    );
# 732 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdlib.h" 3
         errno_t __cdecl _ecvt_s(
                                 char* _Buffer,
          size_t _BufferCount,
          double _Value,
          int _DigitCount,
          int* _PtDec,
          int* _PtSign
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ecvt_s(char (&_Buffer)[_Size], double _Value, int _DigitCount, int* _PtDec, int* _PtSign) throw() { return _ecvt_s(_Buffer, _Size, _Value, _DigitCount, _PtDec, _PtSign); } }
# 751 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdlib.h" 3
         char* __cdecl _ecvt(
          double _Value,
          int _DigitCount,
          int* _PtDec,
          int* _PtSign
    );



         errno_t __cdecl _fcvt_s(
                                 char* _Buffer,
                                 size_t _BufferCount,
                                 double _Value,
                                 int _FractionalDigitCount,
                                 int* _PtDec,
                                 int* _PtSign
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _fcvt_s(char (&_Buffer)[_Size], double _Value, int _FractionalDigitCount, int* _PtDec, int* _PtSign) throw() { return _fcvt_s(_Buffer, _Size, _Value, _FractionalDigitCount, _PtDec, _PtSign); } }
# 781 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdlib.h" 3
         char* __cdecl _fcvt(
          double _Value,
          int _FractionalDigitCount,
          int* _PtDec,
          int* _PtSign
    );


         errno_t __cdecl _gcvt_s(
                                 char* _Buffer,
                                 size_t _BufferCount,
                                 double _Value,
                                 int _DigitCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _gcvt_s(char (&_Buffer)[_Size], double _Value, int _DigitCount) throw() { return _gcvt_s(_Buffer, _Size, _Value, _DigitCount); } }
# 805 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdlib.h" 3
         char* __cdecl _gcvt(
                           double _Value,
                           int _DigitCount,
                           char* _Buffer
    );
# 834 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdlib.h" 3
             int __cdecl ___mb_cur_max_func(void);


             int __cdecl ___mb_cur_max_l_func(_locale_t);





         int __cdecl mblen(
                                                char const* _Ch,
                                                size_t _MaxCount
    );


         int __cdecl _mblen_l(
                                                char const* _Ch,
                                                size_t _MaxCount,
                                                _locale_t _Locale
    );



         size_t __cdecl _mbstrlen(
           char const* _String
    );



         size_t __cdecl _mbstrlen_l(
             char const* _String,
             _locale_t _Locale
    );



         size_t __cdecl _mbstrnlen(
           char const* _String,
           size_t _MaxCount
    );



         size_t __cdecl _mbstrnlen_l(
             char const* _String,
             size_t _MaxCount,
             _locale_t _Locale
    );


         int __cdecl mbtowc(
                                         wchar_t* _DstCh,
                                         char const* _SrcCh,
                                         size_t _SrcSizeInBytes
    );


         int __cdecl _mbtowc_l(
                                         wchar_t* _DstCh,
                                         char const* _SrcCh,
                                         size_t _SrcSizeInBytes,
                                         _locale_t _Locale
    );


         errno_t __cdecl mbstowcs_s(
                                                              size_t* _PtNumOfCharConverted,
                                                              wchar_t* _DstBuf,
                                                              size_t _SizeInWords,
                                                              char const* _SrcBuf,
                                                              size_t _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl mbstowcs_s(size_t* _PtNumOfCharConverted, wchar_t (&_Dest)[_Size], char const* _Source, size_t _MaxCount) throw() { return mbstowcs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }







 size_t __cdecl mbstowcs( wchar_t *_Dest, char const* _Source, size_t _MaxCount);







         errno_t __cdecl _mbstowcs_s_l(
                                                              size_t* _PtNumOfCharConverted,
                                                              wchar_t* _DstBuf,
                                                              size_t _SizeInWords,
                                                              char const* _SrcBuf,
                                                              size_t _MaxCount,
                                                              _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _mbstowcs_s_l(size_t* _PtNumOfCharConverted, wchar_t (&_Dest)[_Size], char const* _Source, size_t _MaxCount, _locale_t _Locale) throw() { return _mbstowcs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }
# 941 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdlib.h" 3
 size_t __cdecl _mbstowcs_l( wchar_t *_Dest, char const* _Source, size_t _MaxCount, _locale_t _Locale);
# 954 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdlib.h" 3
         int __cdecl wctomb(
                                   char* _MbCh,
                                   wchar_t _WCh
    );


         int __cdecl _wctomb_l(
                             char* _MbCh,
                             wchar_t _WCh,
                             _locale_t _Locale
    );




             errno_t __cdecl wctomb_s(
                                                                 int* _SizeConverted,
                                                                 char* _MbCh,
                                                                 rsize_t _SizeInBytes,
                                                                 wchar_t _WCh
        );




         errno_t __cdecl _wctomb_s_l(
                                     int* _SizeConverted,
                                     char* _MbCh,
                                     size_t _SizeInBytes,
                                     wchar_t _WCh,
                                     _locale_t _Locale);


         errno_t __cdecl wcstombs_s(
                                                                       size_t* _PtNumOfCharConverted,
                                                                       char* _Dst,
                                                                       size_t _DstSizeInBytes,
                                                                       wchar_t const* _Src,
                                                                       size_t _MaxCountInBytes
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcstombs_s(size_t* _PtNumOfCharConverted, char (&_Dest)[_Size], wchar_t const* _Source, size_t _MaxCount) throw() { return wcstombs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }







 size_t __cdecl wcstombs( char *_Dest, wchar_t const* _Source, size_t _MaxCount);







         errno_t __cdecl _wcstombs_s_l(
                                                                       size_t* _PtNumOfCharConverted,
                                                                       char* _Dst,
                                                                       size_t _DstSizeInBytes,
                                                                       wchar_t const* _Src,
                                                                       size_t _MaxCountInBytes,
                                                                       _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcstombs_s_l(size_t* _PtNumOfCharConverted, char (&_Dest)[_Size], wchar_t const* _Source, size_t _MaxCount, _locale_t _Locale) throw() { return _wcstombs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }
# 1029 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdlib.h" 3
 size_t __cdecl _wcstombs_l( char *_Dest, wchar_t const* _Source, size_t _MaxCount, _locale_t _Locale);
# 1059 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdlib.h" 3
         __declspec(allocator) char* __cdecl _fullpath(
                                     char* _Buffer,
                                     char const* _Path,
                                     size_t _BufferCount
    );




         errno_t __cdecl _makepath_s(
                                 char* _Buffer,
                                 size_t _BufferCount,
                                 char const* _Drive,
                                 char const* _Dir,
                                 char const* _Filename,
                                 char const* _Ext
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _makepath_s(char (&_Buffer)[_Size], char const* _Drive, char const* _Dir, char const* _Filename, char const* _Ext) throw() { return _makepath_s(_Buffer, _Size, _Drive, _Dir, _Filename, _Ext); } }
# 1086 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdlib.h" 3
 void __cdecl _makepath( char *_Buffer, char const* _Drive, char const* _Dir, char const* _Filename, char const* _Ext);
# 1096 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdlib.h" 3
         void __cdecl _splitpath(
                             char const* _FullPath,
                             char* _Drive,
                             char* _Dir,
                             char* _Filename,
                             char* _Ext
    );


         errno_t __cdecl _splitpath_s(
                                       char const* _FullPath,
                                       char* _Drive,
                                       size_t _DriveCount,
                                       char* _Dir,
                                       size_t _DirCount,
                                       char* _Filename,
                                       size_t _FilenameCount,
                                       char* _Ext,
                                       size_t _ExtCount
    );

extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _splitpath_s( char const* _Dest, char (&_Drive)[_DriveSize], char (&_Dir)[_DirSize], char (&_Name)[_NameSize], char (&_Ext)[_ExtSize] ) throw() { return _splitpath_s(_Dest, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }
# 1132 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdlib.h" 3
             errno_t __cdecl getenv_s(
                                         size_t* _RequiredCount,
                                         char* _Buffer,
                                         rsize_t _BufferCount,
                                         char const* _VarName
        );






             int* __cdecl __p___argc (void);
             char*** __cdecl __p___argv (void);
             wchar_t*** __cdecl __p___wargv(void);
# 1158 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdlib.h" 3
             char*** __cdecl __p__environ (void);
             wchar_t*** __cdecl __p__wenviron(void);
# 1183 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdlib.h" 3
             char* __cdecl getenv(
               char const* _VarName
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl getenv_s(size_t* _RequiredCount, char (&_Buffer)[_Size], char const* _VarName) throw() { return getenv_s(_RequiredCount, _Buffer, _Size, _VarName); } }
# 1200 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdlib.h" 3
             errno_t __cdecl _dupenv_s(
                                                                                    char** _Buffer,
                                                                                    size_t* _BufferCount,
                                                                                    char const* _VarName
        );





             int __cdecl system(
                   char const* _Command
        );



#pragma warning(push)
#pragma warning(disable: 6540)


 int __cdecl _putenv(
               char const* _EnvString
        );


             errno_t __cdecl _putenv_s(
               char const* _Name,
               char const* _Value
        );

#pragma warning(pop)

 errno_t __cdecl _searchenv_s(
                                     char const* _Filename,
                                     char const* _VarName,
                                     char* _Buffer,
                                     size_t _BufferCount
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _searchenv_s(char const* _Filename, char const* _VarName, char (&_Buffer)[_Size]) throw() { return _searchenv_s(_Filename, _VarName, _Buffer, _Size); } }






    void __cdecl _searchenv(char const* _Filename, char const* _VarName, char *_Buffer);







    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "SetErrorMode" " " "instead. See online help for details."))
             void __cdecl _seterrormode(
             int _Mode
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "Beep" " " "instead. See online help for details."))
             void __cdecl _beep(
             unsigned _Frequency,
             unsigned _Duration
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "Sleep" " " "instead. See online help for details."))
             void __cdecl _sleep(
             unsigned long _Duration
        );
# 1289 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdlib.h" 3
#pragma warning(push)
#pragma warning(disable: 4141)

 __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ecvt" ". See online help for details."))
             char* __cdecl ecvt(
              double _Value,
              int _DigitCount,
              int* _PtDec,
              int* _PtSign
        );

                   __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fcvt" ". See online help for details."))
             char* __cdecl fcvt(
              double _Value,
              int _FractionalDigitCount,
              int* _PtDec,
              int* _PtSign
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_gcvt" ". See online help for details."))
             char* __cdecl gcvt(
                               double _Value,
                               int _DigitCount,
                               char* _DstBuf
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_itoa" ". See online help for details."))
             char* __cdecl itoa(
                               int _Value,
                               char* _Buffer,
                               int _Radix
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ltoa" ". See online help for details."))
             char* __cdecl ltoa(
                               long _Value,
                               char* _Buffer,
                               int _Radix
        );


    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_swab" ". See online help for details."))
             void __cdecl swab(
                                        char* _Buf1,
                                        char* _Buf2,
                                        int _SizeInBytes
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ultoa" ". See online help for details."))
             char* __cdecl ultoa(
                               unsigned long _Value,
                               char* _Buffer,
                               int _Radix
        );





                       __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_putenv" ". See online help for details."))
                 int __cdecl putenv(
                   char const* _EnvString
            );



#pragma warning(pop)

 _onexit_t __cdecl onexit( _onexit_t _Func);





}
# 1363 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdlib.h" 3
#pragma pack(pop)
# 13 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\cstdlib" 2 3




namespace std {
using :: size_t; using :: div_t; using :: ldiv_t;
using :: abort; using :: abs; using :: atexit;
using :: atof; using :: atoi; using :: atol;
using :: bsearch; using :: calloc; using :: div;
using :: exit; using :: free;
using :: labs; using :: ldiv; using :: malloc;
using :: mblen; using :: mbstowcs; using :: mbtowc;
using :: qsort; using :: rand; using :: realloc;
using :: srand; using :: strtod; using :: strtol;
using :: strtoul;
using :: wcstombs; using :: wctomb;

using :: lldiv_t;


using :: getenv;
using :: system;


using :: atoll; using :: llabs; using :: lldiv;
using :: strtof; using :: strtold;
using :: strtoll; using :: strtoull;

using :: _Exit; using :: at_quick_exit; using :: quick_exit;
}
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory0" 2 3

# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\limits" 1 3





# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\ymath.h" 1 3







#pragma pack(push,8)
#pragma warning(push, 3)






extern "C" {
# 33 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\ymath.h" 3
void __cdecl _Feraise(int);

typedef union
 {
 unsigned short _Word[8];
 float _Float;
 double _Double;
 long double _Long_double;
 } _Dconst;


              double __cdecl _Cosh(double, double);
              short __cdecl _Dtest(double *);
              double __cdecl _Sinh(double, double);

              short __cdecl _Exp(double *, double, short);
extern _Dconst _Denorm, _Hugeval, _Inf,
 _Nan, _Snan;


              float __cdecl _FCosh(float, float);
              short __cdecl _FDtest(float *);
              float __cdecl _FSinh(float, float);

              short __cdecl _FExp(float *, float, short);
extern _Dconst _FDenorm, _FInf, _FNan, _FSnan;


              long double __cdecl _LCosh(long double, long double);
              short __cdecl _LDtest(long double *);
              long double __cdecl _LSinh(long double, long double);

              short __cdecl _LExp(long double *, long double, short);
extern _Dconst _LDenorm, _LInf, _LNan, _LSnan;



}




#pragma warning(pop)
#pragma pack(pop)
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\limits" 2 3

# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\cfloat" 1 3






# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\float.h" 1 3
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\float.h" 3
#pragma pack(push, 8)
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\float.h" 3
 extern "C" {
# 226 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\float.h" 3
         unsigned int __cdecl _clearfp(void);

#pragma warning(push)
#pragma warning(disable: 4141)


 unsigned int __cdecl _controlfp(
         unsigned int _NewValue,
         unsigned int _Mask
    );

#pragma warning(pop)


 void __cdecl _set_controlfp(
         unsigned int _NewValue,
         unsigned int _Mask
    );


         errno_t __cdecl _controlfp_s(
              unsigned int* _CurrentState,
              unsigned int _NewValue,
              unsigned int _Mask
    );


         unsigned int __cdecl _statusfp(void);


         void __cdecl _fpreset(void);




             void __cdecl _statusfp2(
                  unsigned int* _X86Status,
                  unsigned int* _SSE2Status
        );







         unsigned int __cdecl _control87(
         unsigned int _NewValue,
         unsigned int _Mask
    );



             int __cdecl __control87_2(
                  unsigned int _NewValue,
                  unsigned int _Mask,
                  unsigned int* _X86ControlWord,
                  unsigned int* _Sse2ControlWord
        );




         int* __cdecl __fpecode(void);




         int __cdecl __fpe_flt_rounds(void);
# 307 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\float.h" 3
                        double __cdecl _copysign( double _Number, double _Sign);
                        double __cdecl _chgsign( double _X);
                        double __cdecl _scalb( double _X, long _Y);
                        double __cdecl _logb( double _X);
                        double __cdecl _nextafter( double _X, double _Y);
                        int __cdecl _finite( double _X);
                        int __cdecl _isnan( double _X);
                        int __cdecl _fpclass( double _X);
# 334 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\float.h" 3
             void __cdecl fpreset(void);
# 401 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\float.h" 3
}
# 401 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\float.h" 3
#pragma pack(pop)
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\cfloat" 2 3
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\limits" 2 3

# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\climits" 1 3
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\limits" 2 3

# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\cmath" 1 3
# 12 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\cmath" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\math.h" 1 3
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\math.h" 3
#pragma pack(push, 8)
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\math.h" 3
 extern "C" {



#pragma warning(push)
#pragma warning(disable: 4738)
#pragma warning(disable: 4820)






 struct _exception
    {
        int type;
        char* name;
        double arg1;
        double arg2;
        double retval;
    };






        struct _complex
        {
            double x, y;
        };
# 52 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\math.h" 3
typedef float float_t;
typedef double double_t;
# 68 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\math.h" 3
        extern double const _HUGE;
# 159 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\math.h" 3
void __cdecl _fperrraise( int _Except);

                        short __cdecl _dclass( double _X);
                        short __cdecl _ldclass( long double _X);
                        short __cdecl _fdclass( float _X);

                        int __cdecl _dsign( double _X);
                        int __cdecl _ldsign( long double _X);
                        int __cdecl _fdsign( float _X);

                        int __cdecl _dpcomp( double _X, double _Y);
                        int __cdecl _ldpcomp( long double _X, long double _Y);
                        int __cdecl _fdpcomp( float _X, float _Y);

                        short __cdecl _dtest( double* _Px);
                        short __cdecl _ldtest( long double* _Px);
                        short __cdecl _fdtest( float* _Px);

         short __cdecl _d_int( double* _Px, short _Xexp);
         short __cdecl _ld_int( long double* _Px, short _Xexp);
         short __cdecl _fd_int( float* _Px, short _Xexp);

         short __cdecl _dscale( double* _Px, long _Lexp);
         short __cdecl _ldscale( long double* _Px, long _Lexp);
         short __cdecl _fdscale( float* _Px, long _Lexp);

         short __cdecl _dunscale( short* _Pex, double* _Px);
         short __cdecl _ldunscale( short* _Pex, long double* _Px);
         short __cdecl _fdunscale( short* _Pex, float* _Px);

                        short __cdecl _dexp( double* _Px, double _Y, long _Eoff);
                        short __cdecl _ldexp( long double* _Px, long double _Y, long _Eoff);
                        short __cdecl _fdexp( float* _Px, float _Y, long _Eoff);

                        short __cdecl _dnorm( unsigned short* _Ps);
                        short __cdecl _fdnorm( unsigned short* _Ps);

                        double __cdecl _dpoly( double _X, double const* _Tab, int _N);
                        long double __cdecl _ldpoly( long double _X, long double const* _Tab, int _N);
                        float __cdecl _fdpoly( float _X, float const* _Tab, int _N);

                        double __cdecl _dlog( double _X, int _Baseflag);
                        long double __cdecl _ldlog( long double _X, int _Baseflag);
                        float __cdecl _fdlog( float _X, int _Baseflag);

                        double __cdecl _dsin( double _X, unsigned int _Qoff);
                        long double __cdecl _ldsin( long double _X, unsigned int _Qoff);
                        float __cdecl _fdsin( float _X, unsigned int _Qoff);


typedef union
{
    unsigned short _Sh[4];
    double _Val;
} _double_val;


typedef union
{
    unsigned short _Sh[2];
    float _Val;
} _float_val;


typedef union
{
    unsigned short _Sh[4];
    long double _Val;
} _ldouble_val;

typedef union
{
    unsigned short _Word[4];
    float _Float;
    double _Double;
    long double _Long_double;
} _float_const;

extern const _float_const _Denorm_C, _Inf_C, _Nan_C, _Snan_C, _Hugeval_C;
extern const _float_const _FDenorm_C, _FInf_C, _FNan_C, _FSnan_C;
extern const _float_const _LDenorm_C, _LInf_C, _LNan_C, _LSnan_C;

extern const _float_const _Eps_C, _Rteps_C;
extern const _float_const _FEps_C, _FRteps_C;
extern const _float_const _LEps_C, _LRteps_C;

extern const double _Zero_C, _Xbig_C;
extern const float _FZero_C, _FXbig_C;
extern const long double _LZero_C, _LXbig_C;
# 276 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\math.h" 3
extern "C++"
{
                   inline int fpclassify( float _X) throw()
    {
        return _fdtest(&_X);
    }

                   inline int fpclassify( double _X) throw()
    {
        return _dtest(&_X);
    }

                   inline int fpclassify( long double _X) throw()
    {
        return _ldtest(&_X);
    }

                   inline bool signbit( float _X) throw()
    {
        return _fdsign(_X) != 0;
    }

                   inline bool signbit( double _X) throw()
    {
        return _dsign(_X) != 0;
    }

                   inline bool signbit( long double _X) throw()
    {
        return _ldsign(_X) != 0;
    }

                   inline int _fpcomp( float _X, float _Y) throw()
    {
        return _fdpcomp(_X, _Y);
    }

                   inline int _fpcomp( double _X, double _Y) throw()
    {
        return _dpcomp(_X, _Y);
    }

                   inline int _fpcomp( long double _X, long double _Y) throw()
    {
        return _ldpcomp(_X, _Y);
    }

    template <class _Trc, class _Tre> struct _Combined_type
    {
        typedef float _Type;
    };

    template <> struct _Combined_type<float, double>
    {
        typedef double _Type;
    };

    template <> struct _Combined_type<float, long double>
    {
        typedef long double _Type;
    };

    template <class _Ty, class _T2> struct _Real_widened
    {
        typedef long double _Type;
    };

    template <> struct _Real_widened<float, float>
    {
        typedef float _Type;
    };

    template <> struct _Real_widened<float, double>
    {
        typedef double _Type;
    };

    template <> struct _Real_widened<double, float>
    {
        typedef double _Type;
    };

    template <> struct _Real_widened<double, double>
    {
        typedef double _Type;
    };

    template <class _Ty> struct _Real_type
    {
        typedef double _Type;
    };

    template <> struct _Real_type<float>
    {
        typedef float _Type;
    };

    template <> struct _Real_type<long double>
    {
        typedef long double _Type;
    };

    template <class _T1, class _T2>
                   inline int _fpcomp( _T1 _X, _T2 _Y) throw()
    {
        typedef typename _Combined_type<float,
            typename _Real_widened<
            typename _Real_type<_T1>::_Type,
            typename _Real_type<_T2>::_Type>::_Type>::_Type _Tw;
        return _fpcomp((_Tw)_X, (_Tw)_Y);
    }

    template <class _Ty>
                   inline bool isfinite( _Ty _X) throw()
    {
        return fpclassify(_X) <= 0;
    }

    template <class _Ty>
                   inline bool isinf( _Ty _X) throw()
    {
        return fpclassify(_X) == 1;
    }

    template <class _Ty>
                   inline bool isnan( _Ty _X) throw()
    {
        return fpclassify(_X) == 2;
    }

    template <class _Ty>
                   inline bool isnormal( _Ty _X) throw()
    {
        return fpclassify(_X) == (-1);
    }

    template <class _Ty1, class _Ty2>
                   inline bool isgreater( _Ty1 _X, _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & 4) != 0;
    }

    template <class _Ty1, class _Ty2>
                   inline bool isgreaterequal( _Ty1 _X, _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (2 | 4)) != 0;
    }

    template <class _Ty1, class _Ty2>
                   inline bool isless( _Ty1 _X, _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & 1) != 0;
    }

    template <class _Ty1, class _Ty2>
                   inline bool islessequal( _Ty1 _X, _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (1 | 2)) != 0;
    }

    template <class _Ty1, class _Ty2>
                   inline bool islessgreater( _Ty1 _X, _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (1 | 4)) != 0;
    }

    template <class _Ty1, class _Ty2>
                   inline bool isunordered( _Ty1 _X, _Ty2 _Y) throw()
    {
        return _fpcomp(_X, _Y) == 0;
    }
}






               int __cdecl abs( int _X);
               long __cdecl labs( long _X);
               long long __cdecl llabs( long long _X);

               double __cdecl acos( double _X);
               double __cdecl asin( double _X);
               double __cdecl atan( double _X);
               double __cdecl atan2( double _Y, double _X);

               double __cdecl cos( double _X);
               double __cdecl cosh( double _X);
               double __cdecl exp( double _X);
                                  double __cdecl fabs( double _X);
               double __cdecl fmod( double _X, double _Y);
               double __cdecl log( double _X);
               double __cdecl log10( double _X);
               double __cdecl pow( double _X, double _Y);
               double __cdecl sin( double _X);
               double __cdecl sinh( double _X);
                                  double __cdecl sqrt( double _X);
               double __cdecl tan( double _X);
               double __cdecl tanh( double _X);

                        double __cdecl acosh( double _X);
                        double __cdecl asinh( double _X);
                        double __cdecl atanh( double _X);
                         double __cdecl atof( char const* _String);
                         double __cdecl _atof_l( char const* _String, _locale_t _Locale);
                        double __cdecl _cabs( struct _complex _Complex_value);
                        double __cdecl cbrt( double _X);
                        double __cdecl ceil( double _X);
                        double __cdecl _chgsign( double _X);
                        double __cdecl copysign( double _Number, double _Sign);
                        double __cdecl _copysign( double _Number, double _Sign);
                        double __cdecl erf( double _X);
                        double __cdecl erfc( double _X);
                        double __cdecl exp2( double _X);
                        double __cdecl expm1( double _X);
                        double __cdecl fdim( double _X, double _Y);
                        double __cdecl floor( double _X);
                        double __cdecl fma( double _X, double _Y, double _Z);
                        double __cdecl fmax( double _X, double _Y);
                        double __cdecl fmin( double _X, double _Y);
                        double __cdecl frexp( double _X, int* _Y);
                        double __cdecl hypot( double _X, double _Y);
                        double __cdecl _hypot( double _X, double _Y);
                        int __cdecl ilogb( double _X);
                        double __cdecl ldexp( double _X, int _Y);
                        double __cdecl lgamma( double _X);
                        long long __cdecl llrint( double _X);
                        long long __cdecl llround( double _X);
                        double __cdecl log1p( double _X);
                        double __cdecl log2( double _X);
                        double __cdecl logb( double _X);
                        long __cdecl lrint( double _X);
                        long __cdecl lround( double _X);

int __cdecl _matherr( struct _exception* _Except);

                        double __cdecl modf( double _X, double* _Y);
                        double __cdecl nan( char const*);
                        double __cdecl nearbyint( double _X);
                        double __cdecl nextafter( double _X, double _Y);
                        double __cdecl nexttoward( double _X, long double _Y);
                        double __cdecl remainder( double _X, double _Y);
                        double __cdecl remquo( double _X, double _Y, int* _Z);
                        double __cdecl rint( double _X);
                        double __cdecl round( double _X);
                        double __cdecl scalbln( double _X, long _Y);
                        double __cdecl scalbn( double _X, int _Y);
                        double __cdecl tgamma( double _X);
                        double __cdecl trunc( double _X);
                        double __cdecl _j0( double _X );
                        double __cdecl _j1( double _X );
                        double __cdecl _jn(int _X, double _Y);
                        double __cdecl _y0( double _X);
                        double __cdecl _y1( double _X);
                        double __cdecl _yn( int _X, double _Y);

                        float __cdecl acoshf( float _X);
                        float __cdecl asinhf( float _X);
                        float __cdecl atanhf( float _X);
                        float __cdecl cbrtf( float _X);
                        float __cdecl _chgsignf( float _X);
                        float __cdecl copysignf( float _Number, float _Sign);
                        float __cdecl _copysignf( float _Number, float _Sign);
                        float __cdecl erff( float _X);
                        float __cdecl erfcf( float _X);
                        float __cdecl expm1f( float _X);
                        float __cdecl exp2f( float _X);
                        float __cdecl fdimf( float _X, float _Y);
                        float __cdecl fmaf( float _X, float _Y, float _Z);
                        float __cdecl fmaxf( float _X, float _Y);
                        float __cdecl fminf( float _X, float _Y);
                        float __cdecl _hypotf( float _X, float _Y);
                        int __cdecl ilogbf( float _X);
                        float __cdecl lgammaf( float _X);
                        long long __cdecl llrintf( float _X);
                        long long __cdecl llroundf( float _X);
                        float __cdecl log1pf( float _X);
                        float __cdecl log2f( float _X);
                        float __cdecl logbf( float _X);
                        long __cdecl lrintf( float _X);
                        long __cdecl lroundf( float _X);
                        float __cdecl nanf( char const*);
                        float __cdecl nearbyintf( float _X);
                        float __cdecl nextafterf( float _X, float _Y);
                        float __cdecl nexttowardf( float _X, long double _Y);
                        float __cdecl remainderf( float _X, float _Y);
                        float __cdecl remquof( float _X, float _Y, int* _Z);
                        float __cdecl rintf( float _X);
                        float __cdecl roundf( float _X);
                        float __cdecl scalblnf( float _X, long _Y);
                        float __cdecl scalbnf( float _X, int _Y);
                        float __cdecl tgammaf( float _X);
                        float __cdecl truncf( float _X);



                            int __cdecl _set_SSE2_enable( int _Flag);
# 608 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\math.h" 3
                   __inline float __cdecl acosf( float _X)
    {
        return (float)acos(_X);
    }

                   __inline float __cdecl asinf( float _X)
    {
        return (float)asin(_X);
    }

                   __inline float __cdecl atan2f( float _Y, float _X)
    {
        return (float)atan2(_Y, _X);
    }

                   __inline float __cdecl atanf( float _X)
    {
        return (float)atan(_X);
    }

                   __inline float __cdecl ceilf( float _X)
    {
        return (float)ceil(_X);
    }

                   __inline float __cdecl cosf( float _X)
    {
        return (float)cos(_X);
    }

                   __inline float __cdecl coshf( float _X)
    {
        return (float)cosh(_X);
    }

                   __inline float __cdecl expf( float _X)
    {
        return (float)exp(_X);
    }
# 656 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\math.h" 3
                   __inline float __cdecl fabsf( float _X)
    {
        return (float)fabs(_X);
    }
# 670 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\math.h" 3
                   __inline float __cdecl floorf( float _X)
    {
        return (float)floor(_X);
    }

                   __inline float __cdecl fmodf( float _X, float _Y)
    {
        return (float)fmod(_X, _Y);
    }



               __inline float __cdecl frexpf( float _X, int *_Y)
{
    return (float)frexp(_X, _Y);
}

               __inline float __cdecl hypotf( float _X, float _Y)
{
    return _hypotf(_X, _Y);
}

               __inline float __cdecl ldexpf( float _X, int _Y)
{
    return (float)ldexp(_X, _Y);
}
# 711 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\math.h" 3
                   __inline float __cdecl log10f( float _X)
    {
        return (float)log10(_X);
    }

                   __inline float __cdecl logf( float _X)
    {
        return (float)log(_X);
    }

                   __inline float __cdecl modff( float _X, float* _Y)
    {
        double _F, _I;
        _F = modf(_X, &_I);
        *_Y = (float)_I;
        return (float)_F;
    }

                   __inline float __cdecl powf( float _X, float _Y)
    {
        return (float)pow(_X, _Y);
    }

                   __inline float __cdecl sinf( float _X)
    {
        return (float)sin(_X);
    }

                   __inline float __cdecl sinhf( float _X)
    {
        return (float)sinh(_X);
    }

                   __inline float __cdecl sqrtf( float _X)
    {
        return (float)sqrt(_X);
    }

                   __inline float __cdecl tanf( float _X)
    {
        return (float)tan(_X);
    }

                   __inline float __cdecl tanhf( float _X)
    {
        return (float)tanh(_X);
    }



                        long double __cdecl acoshl( long double _X);

               __inline long double __cdecl acosl( long double _X)
{
    return acos((double)_X);
}

                        long double __cdecl asinhl( long double _X);

               __inline long double __cdecl asinl( long double _X)
{
    return asin((double)_X);
}

               __inline long double __cdecl atan2l( long double _Y, long double _X)
{
    return atan2((double)_Y, (double)_X);
}

                        long double __cdecl atanhl( long double _X);

               __inline long double __cdecl atanl( long double _X)
{
    return atan((double)_X);
}

                        long double __cdecl cbrtl( long double _X);

               __inline long double __cdecl ceill( long double _X)
{
    return ceil((double)_X);
}

               __inline long double __cdecl _chgsignl( long double _X)
{
    return _chgsign((double)_X);
}

                        long double __cdecl copysignl( long double _Number, long double _Sign);

               __inline long double __cdecl _copysignl( long double _Number, long double _Sign)
{
    return _copysign((double)_Number, (double)_Sign);
}

               __inline long double __cdecl coshl( long double _X)
{
    return cosh((double)_X);
}

               __inline long double __cdecl cosl( long double _X)
{
    return cos((double)_X);
}

                        long double __cdecl erfl( long double _X);
                        long double __cdecl erfcl( long double _X);

               __inline long double __cdecl expl( long double _X)
{
    return exp((double)_X);
}

                        long double __cdecl exp2l( long double _X);
                        long double __cdecl expm1l( long double _X);

               __inline long double __cdecl fabsl( long double _X)
{
    return fabs((double)_X);
}

                        long double __cdecl fdiml( long double _X, long double _Y);

               __inline long double __cdecl floorl( long double _X)
{
    return floor((double)_X);
}

                        long double __cdecl fmal( long double _X, long double _Y, long double _Z);
                        long double __cdecl fmaxl( long double _X, long double _Y);
                        long double __cdecl fminl( long double _X, long double _Y);

               __inline long double __cdecl fmodl( long double _X, long double _Y)
{
    return fmod((double)_X, (double)_Y);
}

               __inline long double __cdecl frexpl( long double _X, int *_Y)
{
    return frexp((double)_X, _Y);
}

                        int __cdecl ilogbl( long double _X);

               __inline long double __cdecl _hypotl( long double _X, long double _Y)
{
    return _hypot((double)_X, (double)_Y);
}

               __inline long double __cdecl hypotl( long double _X, long double _Y)
{
    return _hypot((double)_X, (double)_Y);
}

               __inline long double __cdecl ldexpl( long double _X, int _Y)
{
    return ldexp((double)_X, _Y);
}

                        long double __cdecl lgammal( long double _X);
                        long long __cdecl llrintl( long double _X);
                        long long __cdecl llroundl( long double _X);

               __inline long double __cdecl logl( long double _X)
{
    return log((double)_X);
}

               __inline long double __cdecl log10l( long double _X)
{
    return log10((double)_X);
}

                        long double __cdecl log1pl( long double _X);
                        long double __cdecl log2l( long double _X);
                        long double __cdecl logbl( long double _X);
                        long __cdecl lrintl( long double _X);
                        long __cdecl lroundl( long double _X);

               __inline long double __cdecl modfl( long double _X, long double* _Y)
{
    double _F, _I;
    _F = modf((double)_X, &_I);
    *_Y = _I;
    return _F;
}

                        long double __cdecl nanl( char const*);
                        long double __cdecl nearbyintl( long double _X);
                        long double __cdecl nextafterl( long double _X, long double _Y);
                        long double __cdecl nexttowardl( long double _X, long double _Y);

               __inline long double __cdecl powl( long double _X, long double _Y)
{
    return pow((double)_X, (double)_Y);
}

                        long double __cdecl remainderl( long double _X, long double _Y);
                        long double __cdecl remquol( long double _X, long double _Y, int* _Z);
                        long double __cdecl rintl( long double _X);
                        long double __cdecl roundl( long double _X);
                        long double __cdecl scalblnl( long double _X, long _Y);
                        long double __cdecl scalbnl( long double _X, int _Y);

               __inline long double __cdecl sinhl( long double _X)
{
    return sinh((double)_X);
}

               __inline long double __cdecl sinl( long double _X)
{
    return sin((double)_X);
}

               __inline long double __cdecl sqrtl( long double _X)
{
    return sqrt((double)_X);
}

               __inline long double __cdecl tanhl( long double _X)
{
    return tanh((double)_X);
}

               __inline long double __cdecl tanl( long double _X)
{
    return tan((double)_X);
}

                        long double __cdecl tgammal( long double _X);
                        long double __cdecl truncl( long double _X);
# 963 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\math.h" 3
            extern double HUGE;




        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_j0" ". See online help for details.")) double __cdecl j0( double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_j1" ". See online help for details.")) double __cdecl j1( double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_jn" ". See online help for details.")) double __cdecl jn( int _X, double _Y);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_y0" ". See online help for details.")) double __cdecl y0( double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_y1" ". See online help for details.")) double __cdecl y1( double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_yn" ". See online help for details.")) double __cdecl yn( int _X, double _Y);





#pragma warning(pop)



}
# 983 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\math.h" 3
#pragma pack(pop)
# 12 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\cmath" 2 3





               inline double abs( double _Xx) noexcept
 {
 return (:: fabs(_Xx));
 }

               inline double pow( double _Xx, int _Yx) noexcept
 {
 if (_Yx == 2)
  return (_Xx * _Xx);

 return (:: pow(_Xx, static_cast<double>(_Yx)));
 }

               inline float abs( float _Xx) noexcept
 {
 return (:: fabsf(_Xx));
 }

               inline float acos( float _Xx) noexcept
 {
 return (:: acosf(_Xx));
 }

               inline float acosh( float _Xx) noexcept
 {
 return (:: acoshf(_Xx));
 }

               inline float asin( float _Xx) noexcept
 {
 return (:: asinf(_Xx));
 }

               inline float asinh( float _Xx) noexcept
 {
 return (:: asinhf(_Xx));
 }

               inline float atan( float _Xx) noexcept
 {
 return (:: atanf(_Xx));
 }

               inline float atanh( float _Xx) noexcept
 {
 return (:: atanhf(_Xx));
 }

               inline float atan2( float _Yx, float _Xx) noexcept
 {
 return (:: atan2f(_Yx, _Xx));
 }

               inline float cbrt( float _Xx) noexcept
 {
 return (:: cbrtf(_Xx));
 }

               inline float ceil( float _Xx) noexcept
 {
 return (:: ceilf(_Xx));
 }

               inline float copysign( float _Number,
      float _Sign) noexcept
 {
 return (:: copysignf(_Number, _Sign));
 }

               inline float cos( float _Xx) noexcept
 {
 return (:: cosf(_Xx));
 }

               inline float cosh( float _Xx) noexcept
 {
 return (:: coshf(_Xx));
 }

               inline float erf( float _Xx) noexcept
 {
 return (:: erff(_Xx));
 }

               inline float erfc( float _Xx) noexcept
 {
 return (:: erfcf(_Xx));
 }

               inline float exp( float _Xx) noexcept
 {
 return (:: expf(_Xx));
 }

               inline float exp2( float _Xx) noexcept
 {
 return (:: exp2f(_Xx));
 }

               inline float expm1( float _Xx) noexcept
 {
 return (:: expm1f(_Xx));
 }

               inline float fabs( float _Xx) noexcept
 {
 return (:: fabsf(_Xx));
 }

               inline float fdim( float _Xx, float _Yx) noexcept
 {
 return (:: fdimf(_Xx, _Yx));
 }

               inline float floor( float _Xx) noexcept
 {
 return (:: floorf(_Xx));
 }

               inline float fma( float _Xx, float _Yx,
      float _Zx) noexcept
 {
 return (:: fmaf(_Xx, _Yx, _Zx));
 }

               inline float fmax( float _Xx, float _Yx) noexcept
 {
 return (:: fmaxf(_Xx, _Yx));
 }

               inline float fmin( float _Xx, float _Yx) noexcept
 {
 return (:: fminf(_Xx, _Yx));
 }

               inline float fmod( float _Xx, float _Yx) noexcept
 {
 return (:: fmodf(_Xx, _Yx));
 }

               inline float frexp( float _Xx, int* _Yx) noexcept
 {
 return (:: frexpf(_Xx, _Yx));
 }

               inline float hypot( float _Xx, float _Yx) noexcept
 {
 return (:: hypotf(_Xx, _Yx));
 }

               inline int ilogb( float _Xx) noexcept
 {
 return (:: ilogbf(_Xx));
 }

               inline float ldexp( float _Xx, int _Yx) noexcept
 {
 return (:: ldexpf(_Xx, _Yx));
 }

               inline float lgamma( float _Xx) noexcept
 {
 return (:: lgammaf(_Xx));
 }

               inline long long llrint( float _Xx) noexcept
 {
 return (:: llrintf(_Xx));
 }

               inline long long llround( float _Xx) noexcept
 {
 return (:: llroundf(_Xx));
 }

               inline float log( float _Xx) noexcept
 {
 return (:: logf(_Xx));
 }

               inline float log10( float _Xx) noexcept
 {
 return (:: log10f(_Xx));
 }

               inline float log1p( float _Xx) noexcept
 {
 return (:: log1pf(_Xx));
 }

               inline float log2( float _Xx) noexcept
 {
 return (:: log2f(_Xx));
 }

               inline float logb( float _Xx) noexcept
 {
 return (:: logbf(_Xx));
 }

               inline long lrint( float _Xx) noexcept
 {
 return (:: lrintf(_Xx));
 }

               inline long lround( float _Xx) noexcept
 {
 return (:: lroundf(_Xx));
 }

               inline float modf( float _Xx, float* _Yx) noexcept
 {
 return (:: modff(_Xx, _Yx));
 }

               inline float nearbyint( float _Xx) noexcept
 {
 return (:: nearbyintf(_Xx));
 }

               inline float nextafter( float _Xx, float _Yx) noexcept
 {
 return (:: nextafterf(_Xx, _Yx));
 }

               inline float nexttoward( float _Xx,
      long double _Yx) noexcept
 {
 return (:: nexttowardf(_Xx, _Yx));
 }

               inline float pow( float _Xx,
      float _Yx) noexcept
 {
 return (:: powf(_Xx, _Yx));
 }

               inline float pow( float _Xx, int _Yx) noexcept
 {
 if (_Yx == 2)
  return (_Xx * _Xx);

 return (:: powf(_Xx, static_cast<float>(_Yx)));
 }

               inline float remainder( float _Xx, float _Yx) noexcept
 {
 return (:: remainderf(_Xx, _Yx));
 }

               inline float remquo( float _Xx, float _Yx,
       int *_Zx) noexcept
 {
 return (:: remquof(_Xx, _Yx, _Zx));
 }

               inline float rint( float _Xx) noexcept
 {
 return (:: rintf(_Xx));
 }

               inline float round( float _Xx) noexcept
 {
 return (:: roundf(_Xx));
 }

               inline float scalbln( float _Xx, long _Yx) noexcept
 {
 return (:: scalblnf(_Xx, _Yx));
 }

               inline float scalbn( float _Xx, int _Yx) noexcept
 {
 return (:: scalbnf(_Xx, _Yx));
 }

               inline float sin( float _Xx) noexcept
 {
 return (:: sinf(_Xx));
 }

               inline float sinh( float _Xx) noexcept
 {
 return (:: sinhf(_Xx));
 }

               inline float sqrt( float _Xx) noexcept
 {
 return (:: sqrtf(_Xx));
 }

               inline float tan( float _Xx) noexcept
 {
 return (:: tanf(_Xx));
 }

               inline float tanh( float _Xx) noexcept
 {
 return (:: tanhf(_Xx));
 }

               inline float tgamma( float _Xx) noexcept
 {
 return (:: tgammaf(_Xx));
 }

               inline float trunc( float _Xx) noexcept
 {
 return (:: truncf(_Xx));
 }

               inline long double abs( long double _Xx) noexcept
 {
 return (:: fabsl(_Xx));
 }

               inline long double acos( long double _Xx) noexcept
 {
 return (:: acosl(_Xx));
 }

               inline long double acosh( long double _Xx) noexcept
 {
 return (:: acoshl(_Xx));
 }

               inline long double asin( long double _Xx) noexcept
 {
 return (:: asinl(_Xx));
 }

               inline long double asinh( long double _Xx) noexcept
 {
 return (:: asinhl(_Xx));
 }

               inline long double atan( long double _Xx) noexcept
 {
 return (:: atanl(_Xx));
 }

               inline long double atanh( long double _Xx) noexcept
 {
 return (:: atanhl(_Xx));
 }

               inline long double atan2( long double _Yx,
      long double _Xx) noexcept
 {
 return (:: atan2l(_Yx, _Xx));
 }

               inline long double cbrt( long double _Xx) noexcept
 {
 return (:: cbrtl(_Xx));
 }

               inline long double ceil( long double _Xx) noexcept
 {
 return (:: ceill(_Xx));
 }

               inline long double copysign( long double _Number,
      long double _Sign) noexcept
 {
 return (:: copysignl(_Number, _Sign));
 }

               inline long double cos( long double _Xx) noexcept
 {
 return (:: cosl(_Xx));
 }

               inline long double cosh( long double _Xx) noexcept
 {
 return (:: coshl(_Xx));
 }

               inline long double erf( long double _Xx) noexcept
 {
 return (:: erfl(_Xx));
 }

               inline long double erfc( long double _Xx) noexcept
 {
 return (:: erfcl(_Xx));
 }

               inline long double exp( long double _Xx) noexcept
 {
 return (:: expl(_Xx));
 }

               inline long double exp2( long double _Xx) noexcept
 {
 return (:: exp2l(_Xx));
 }

               inline long double expm1( long double _Xx) noexcept
 {
 return (:: expm1l(_Xx));
 }

               inline long double fabs( long double _Xx) noexcept
 {
 return (:: fabsl(_Xx));
 }

               inline long double fdim( long double _Xx,
      long double _Yx) noexcept
 {
 return (:: fdiml(_Xx, _Yx));
 }

               inline long double floor( long double _Xx) noexcept
 {
 return (:: floorl(_Xx));
 }

               inline long double fma( long double _Xx,
      long double _Yx, long double _Zx) noexcept
 {
 return (:: fmal(_Xx, _Yx, _Zx));
 }

               inline long double fmax( long double _Xx,
      long double _Yx) noexcept
 {
 return (:: fmaxl(_Xx, _Yx));
 }

               inline long double fmin( long double _Xx,
      long double _Yx) noexcept
 {
 return (:: fminl(_Xx, _Yx));
 }

               inline long double fmod( long double _Xx,
      long double _Yx) noexcept
 {
 return (:: fmodl(_Xx, _Yx));
 }

               inline long double frexp( long double _Xx,
       int* _Yx) noexcept
 {
 return (:: frexpl(_Xx, _Yx));
 }

               inline long double hypot( long double _Xx,
      long double _Yx) noexcept
 {
 return (:: hypotl(_Xx, _Yx));
 }

               inline int ilogb( long double _Xx) noexcept
 {
 return (:: ilogbl(_Xx));
 }

               inline long double ldexp( long double _Xx,
      int _Yx) noexcept
 {
 return (:: ldexpl(_Xx, _Yx));
 }

               inline long double lgamma( long double _Xx) noexcept
 {
 return (:: lgammal(_Xx));
 }

               inline long long llrint( long double _Xx) noexcept
 {
 return (:: llrintl(_Xx));
 }

               inline long long llround( long double _Xx) noexcept
 {
 return (:: llroundl(_Xx));
 }

               inline long double log( long double _Xx) noexcept
 {
 return (:: logl(_Xx));
 }

               inline long double log10( long double _Xx) noexcept
 {
 return (:: log10l(_Xx));
 }

               inline long double log1p( long double _Xx) noexcept
 {
 return (:: log1pl(_Xx));
 }

               inline long double log2( long double _Xx) noexcept
 {
 return (:: log2l(_Xx));
 }

               inline long double logb( long double _Xx) noexcept
 {
 return (:: logbl(_Xx));
 }

               inline long lrint( long double _Xx) noexcept
 {
 return (:: lrintl(_Xx));
 }

               inline long lround( long double _Xx) noexcept
 {
 return (:: lroundl(_Xx));
 }

               inline long double modf( long double _Xx,
       long double* _Yx) noexcept
 {
 return (:: modfl(_Xx, _Yx));
 }

               inline long double nearbyint( long double _Xx) noexcept
 {
 return (:: nearbyintl(_Xx));
 }

               inline long double nextafter( long double _Xx,
      long double _Yx) noexcept
 {
 return (:: nextafterl(_Xx, _Yx));
 }

               inline long double nexttoward( long double _Xx,
      long double _Yx) noexcept
 {
 return (:: nexttowardl(_Xx, _Yx));
 }

               inline long double pow( long double _Xx,
      long double _Yx) noexcept
 {
 return (:: powl(_Xx, _Yx));
 }

               inline long double pow( long double _Xx,
      int _Yx) noexcept
 {
 if (_Yx == 2)
  return (_Xx * _Xx);

 return (:: powl(_Xx, static_cast<long double>(_Yx)));
 }

               inline long double remainder( long double _Xx,
      long double _Yx) noexcept
 {
 return (:: remainderl(_Xx, _Yx));
 }

               inline long double remquo( long double _Xx,
      long double _Yx, int *_Zx) noexcept
 {
 return (:: remquol(_Xx, _Yx, _Zx));
 }

               inline long double rint( long double _Xx) noexcept
 {
 return (:: rintl(_Xx));
 }

               inline long double round( long double _Xx) noexcept
 {
 return (:: roundl(_Xx));
 }

               inline long double scalbln( long double _Xx,
      long _Yx) noexcept
 {
 return (:: scalblnl(_Xx, _Yx));
 }

               inline long double scalbn( long double _Xx,
      int _Yx) noexcept
 {
 return (:: scalbnl(_Xx, _Yx));
 }

               inline long double sin( long double _Xx) noexcept
 {
 return (:: sinl(_Xx));
 }

               inline long double sinh( long double _Xx) noexcept
 {
 return (:: sinhl(_Xx));
 }

               inline long double sqrt( long double _Xx) noexcept
 {
 return (:: sqrtl(_Xx));
 }

               inline long double tan( long double _Xx) noexcept
 {
 return (:: tanl(_Xx));
 }

               inline long double tanh( long double _Xx) noexcept
 {
 return (:: tanhl(_Xx));
 }

               inline long double tgamma( long double _Xx) noexcept
 {
 return (:: tgammal(_Xx));
 }

               inline long double trunc( long double _Xx) noexcept
 {
 return (:: truncl(_Xx));
 }
# 647 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\cmath" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xtgmath.h" 1 3







# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xtr1common" 1 3







#pragma pack(push,8)
#pragma warning(push, 3)



namespace std {

struct _Nil
 {
 };


template<class _Ty,
 _Ty _Val>
 struct integral_constant
 {
 static constexpr _Ty value = _Val;

 typedef _Ty value_type;
 typedef integral_constant<_Ty, _Val> type;

 constexpr operator value_type() const noexcept
  {
  return (value);
  }

 constexpr value_type operator()() const noexcept
  {
  return (value);
  }
 };

typedef integral_constant<bool, true> true_type;
typedef integral_constant<bool, false> false_type;


template<bool _Val>
 using bool_constant = integral_constant<bool, _Val>;


template<bool _Val>
 struct _Cat_base
  : integral_constant<bool, _Val>
 {
 };


template<bool _Test,
 class _Ty = void>
 struct enable_if
 {
 };

template<class _Ty>
 struct enable_if<true, _Ty>
 {
 typedef _Ty type;
 };


template<bool _Test,
 class _Ty1,
 class _Ty2>
 struct conditional
 {
 typedef _Ty2 type;
 };

template<class _Ty1,
 class _Ty2>
 struct conditional<true, _Ty1, _Ty2>
 {
 typedef _Ty1 type;
 };


template<class _Ty1,
 class _Ty2>
 struct is_same
  : false_type
 {
 };

template<class _Ty1>
 struct is_same<_Ty1, _Ty1>
  : true_type
 {
 };


template<class _Ty,
 class _Uty>
 constexpr bool is_same_v = is_same<_Ty, _Uty>::value;



template<class _Ty>
 struct remove_const
 {
 typedef _Ty type;
 };

template<class _Ty>
 struct remove_const<const _Ty>
 {
 typedef _Ty type;
 };


template<class _Ty>
 struct remove_volatile
 {
 typedef _Ty type;
 };

template<class _Ty>
 struct remove_volatile<volatile _Ty>
 {
 typedef _Ty type;
 };


template<class _Ty>
 struct remove_cv
 {
 typedef typename remove_const<typename remove_volatile<_Ty>::type>::type
  type;
 };


template<class _Ty>
 struct _Is_integral
  : false_type
 {
 };

template<>
 struct _Is_integral<bool>
  : true_type
 {
 };

template<>
 struct _Is_integral<char>
  : true_type
 {
 };

template<>
 struct _Is_integral<unsigned char>
  : true_type
 {
 };

template<>
 struct _Is_integral<signed char>
  : true_type
 {
 };


template<>
 struct _Is_integral<wchar_t>
  : true_type
 {
 };


template<>
 struct _Is_integral<unsigned short>
  : true_type
 {
 };

template<>
 struct _Is_integral<signed short>
  : true_type
 {
 };

template<>
 struct _Is_integral<unsigned int>
  : true_type
 {
 };

template<>
 struct _Is_integral<signed int>
  : true_type
 {
 };

template<>
 struct _Is_integral<unsigned long>
  : true_type
 {
 };

template<>
 struct _Is_integral<signed long>
  : true_type
 {
 };

template<>
 struct _Is_integral<char16_t>
  : true_type
 {
 };

template<>
 struct _Is_integral<char32_t>
  : true_type
 {
 };

template<>
 struct _Is_integral<long long>
  : true_type
 {
 };

template<>
 struct _Is_integral<unsigned long long>
  : true_type
 {
 };


template<class _Ty>
 struct is_integral
  : _Is_integral<typename remove_cv<_Ty>::type>
 {
 };


template<class _Ty>
 constexpr bool is_integral_v = is_integral<_Ty>::value;



template<class _Ty>
 struct _Is_floating_point
  : false_type
 {
 };

template<>
 struct _Is_floating_point<float>
  : true_type
 {
 };

template<>
 struct _Is_floating_point<double>
  : true_type
 {
 };

template<>
 struct _Is_floating_point<long double>
  : true_type
 {
 };


template<class _Ty>
 struct is_floating_point
  : _Is_floating_point<typename remove_cv<_Ty>::type>
 {
 };


template<class _Ty>
 constexpr bool is_floating_point_v = is_floating_point<_Ty>::value;



template<class _Ty>
 struct is_arithmetic
  : _Cat_base<is_integral<_Ty>::value
   || is_floating_point<_Ty>::value>
 {
 };


template<class _Ty>
 constexpr bool is_arithmetic_v = is_arithmetic<_Ty>::value;



template<class _Ty>
 struct remove_reference
 {
 typedef _Ty type;
 };

template<class _Ty>
 struct remove_reference<_Ty&>
 {
 typedef _Ty type;
 };

template<class _Ty>
 struct remove_reference<_Ty&&>
 {
 typedef _Ty type;
 };


struct _Wrap_int
 {
 _Wrap_int(int)
  {
  }
 };

template<class _Ty>
 struct _Identity
 {
 typedef _Ty type;
 };
# 344 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xtr1common" 3
}

#pragma warning(pop)
#pragma pack(pop)
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xtgmath.h" 2 3


#pragma pack(push,8)
#pragma warning(push, 3)



namespace std {
template<class _Ty>
 struct _Promote_to_float
 {
 typedef typename conditional<is_integral<_Ty>::value,
  double, _Ty>::type type;
 };

template<class _Ty1,
 class _Ty2>
 struct _Common_float_type
 {
 typedef typename _Promote_to_float<_Ty1>::type _Ty1f;
 typedef typename _Promote_to_float<_Ty2>::type _Ty2f;
 typedef typename conditional<is_same<_Ty1f, long double>::value
  || is_same<_Ty2f, long double>::value, long double,
  typename conditional<is_same<_Ty1f, double>::value
   || is_same<_Ty2f, double>::value, double,
   float>::type>::type type;
 };
}
# 76 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xtgmath.h" 3
template<class _Ty1,
 class _Ty2> inline
 typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value
  && ::std:: is_arithmetic<_Ty2>::value,
  typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type
 pow(const _Ty1 _Left, const _Ty2 _Right)
 {
 typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type;
 return (:: pow(type(_Left), type(_Right)));
 }


extern "C" double __cdecl acos( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type acos(_Ty _Left) { return (:: acos((double)_Left)); }
extern "C" double __cdecl asin( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type asin(_Ty _Left) { return (:: asin((double)_Left)); }
extern "C" double __cdecl atan( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type atan(_Ty _Left) { return (:: atan((double)_Left)); }
extern "C" double __cdecl atan2( double, double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type atan2(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: atan2((type)_Left, (type)_Right)); }
extern "C" double __cdecl ceil( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type ceil(_Ty _Left) { return (:: ceil((double)_Left)); }
extern "C" double __cdecl cos( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type cos(_Ty _Left) { return (:: cos((double)_Left)); }
extern "C" double __cdecl cosh( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type cosh(_Ty _Left) { return (:: cosh((double)_Left)); }
extern "C" double __cdecl exp( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type exp(_Ty _Left) { return (:: exp((double)_Left)); }

extern "C" double __cdecl fabs( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type fabs(_Ty _Left) { return (:: fabs((double)_Left)); }

extern "C" double __cdecl floor( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type floor(_Ty _Left) { return (:: floor((double)_Left)); }
extern "C" double __cdecl fmod( double, double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fmod(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fmod((type)_Left, (type)_Right)); }
extern "C" double __cdecl frexp( double, int *); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type frexp(_Ty _Left, int * _Arg2) { return (:: frexp((double)_Left, _Arg2)); }
extern "C" double __cdecl ldexp( double, int); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type ldexp(_Ty _Left, int _Arg2) { return (:: ldexp((double)_Left, _Arg2)); }
extern "C" double __cdecl log( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log(_Ty _Left) { return (:: log((double)_Left)); }
extern "C" double __cdecl log10( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log10(_Ty _Left) { return (:: log10((double)_Left)); }


extern "C" double __cdecl sin( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type sin(_Ty _Left) { return (:: sin((double)_Left)); }
extern "C" double __cdecl sinh( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type sinh(_Ty _Left) { return (:: sinh((double)_Left)); }
extern "C" double __cdecl sqrt( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type sqrt(_Ty _Left) { return (:: sqrt((double)_Left)); }
extern "C" double __cdecl tan( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type tan(_Ty _Left) { return (:: tan((double)_Left)); }
extern "C" double __cdecl tanh( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type tanh(_Ty _Left) { return (:: tanh((double)_Left)); }
# 125 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xtgmath.h" 3
inline float _Fma(float _Left, float _Middle, float _Right)
 {
 return (:: fmaf(_Left, _Middle, _Right));
 }

inline double _Fma(double _Left, double _Middle, double _Right)
 {
 return (:: fma(_Left, _Middle, _Right));
 }

inline long double _Fma(long double _Left, long double _Middle,
 long double _Right)
 {
 return (:: fmal(_Left, _Middle, _Right));
 }

template<class _Ty1,
 class _Ty2,
 class _Ty3> inline
 typename ::std:: _Common_float_type<_Ty1,
  typename ::std:: _Common_float_type<_Ty2, _Ty3>::type>::type
 fma(_Ty1 _Left, _Ty2 _Middle, _Ty3 _Right)
 {
 typedef typename ::std:: _Common_float_type<_Ty1,
  typename ::std:: _Common_float_type<_Ty2, _Ty3>::type>::type type;
 return (_Fma((type)_Left, (type)_Middle, (type)_Right));
 }



inline float _Remquo(float _Left, float _Right, int *_Pquo)
 {
 return (:: remquof(_Left, _Right, _Pquo));
 }

inline double _Remquo(double _Left, double _Right, int *_Pquo)
 {
 return (:: remquo(_Left, _Right, _Pquo));
 }

inline long double _Remquo(long double _Left, long double _Right, int *_Pquo)
 {
 return (:: remquol(_Left, _Right, _Pquo));
 }

template<class _Ty1,
 class _Ty2> inline
 typename ::std:: _Common_float_type<_Ty1, _Ty2>::type
 remquo(_Ty1 _Left, _Ty2 _Right, int *_Pquo)
 {
 typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type;
 return (_Remquo((type)_Left, (type)_Right, _Pquo));
 }

extern "C" double __cdecl acosh( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type acosh(_Ty _Left) { return (:: acosh((double)_Left)); }
extern "C" double __cdecl asinh( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type asinh(_Ty _Left) { return (:: asinh((double)_Left)); }
extern "C" double __cdecl atanh( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type atanh(_Ty _Left) { return (:: atanh((double)_Left)); }
extern "C" double __cdecl cbrt( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type cbrt(_Ty _Left) { return (:: cbrt((double)_Left)); }
extern "C" double __cdecl copysign( double, double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type copysign(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: copysign((type)_Left, (type)_Right)); }
extern "C" double __cdecl erf( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type erf(_Ty _Left) { return (:: erf((double)_Left)); }
extern "C" double __cdecl erfc( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type erfc(_Ty _Left) { return (:: erfc((double)_Left)); }
extern "C" double __cdecl expm1( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type expm1(_Ty _Left) { return (:: expm1((double)_Left)); }
extern "C" double __cdecl exp2( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type exp2(_Ty _Left) { return (:: exp2((double)_Left)); }
extern "C" double __cdecl fdim( double, double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fdim(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fdim((type)_Left, (type)_Right)); }

extern "C" double __cdecl fmax( double, double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fmax(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fmax((type)_Left, (type)_Right)); }
extern "C" double __cdecl fmin( double, double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fmin(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fmin((type)_Left, (type)_Right)); }
extern "C" double __cdecl hypot( double, double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type hypot(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: hypot((type)_Left, (type)_Right)); }
extern "C" int __cdecl ilogb( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, int>::type ilogb(_Ty _Left) { return (:: ilogb((double)_Left)); }
extern "C" double __cdecl lgamma( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type lgamma(_Ty _Left) { return (:: lgamma((double)_Left)); }
extern "C" long long __cdecl llrint( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long long>::type llrint(_Ty _Left) { return (:: llrint((double)_Left)); }
extern "C" long long __cdecl llround( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long long>::type llround(_Ty _Left) { return (:: llround((double)_Left)); }
extern "C" double __cdecl log1p( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log1p(_Ty _Left) { return (:: log1p((double)_Left)); }
extern "C" double __cdecl log2( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log2(_Ty _Left) { return (:: log2((double)_Left)); }
extern "C" double __cdecl logb( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type logb(_Ty _Left) { return (:: logb((double)_Left)); }
extern "C" long __cdecl lrint( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long>::type lrint(_Ty _Left) { return (:: lrint((double)_Left)); }
extern "C" long __cdecl lround( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long>::type lround(_Ty _Left) { return (:: lround((double)_Left)); }
extern "C" double __cdecl nearbyint( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type nearbyint(_Ty _Left) { return (:: nearbyint((double)_Left)); }
extern "C" double __cdecl nextafter( double, double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type nextafter(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: nextafter((type)_Left, (type)_Right)); }
extern "C" double __cdecl nexttoward( double, long double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type nexttoward(_Ty _Left, long double _Arg2) { return (:: nexttoward((double)_Left, _Arg2)); }
extern "C" double __cdecl remainder( double, double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type remainder(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: remainder((type)_Left, (type)_Right)); }

extern "C" double __cdecl rint( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type rint(_Ty _Left) { return (:: rint((double)_Left)); }
extern "C" double __cdecl round( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type round(_Ty _Left) { return (:: round((double)_Left)); }
extern "C" double __cdecl scalbln( double, long); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type scalbln(_Ty _Left, long _Arg2) { return (:: scalbln((double)_Left, _Arg2)); }
extern "C" double __cdecl scalbn( double, int); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type scalbn(_Ty _Left, int _Arg2) { return (:: scalbn((double)_Left, _Arg2)); }
extern "C" double __cdecl tgamma( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type tgamma(_Ty _Left) { return (:: tgamma((double)_Left)); }
extern "C" double __cdecl trunc( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type trunc(_Ty _Left) { return (:: trunc((double)_Left)); }


#pragma warning(pop)
#pragma pack(pop)
# 647 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\cmath" 2 3




namespace std {
using :: abs; using :: acos; using :: asin;
using :: atan; using :: atan2; using :: ceil;
using :: cos; using :: cosh; using :: exp;
using :: fabs; using :: floor; using :: fmod;
using :: frexp; using :: ldexp; using :: log;
using :: log10; using :: modf; using :: pow;
using :: sin; using :: sinh; using :: sqrt;
using :: tan; using :: tanh;

using :: acosf; using :: asinf;
using :: atanf; using :: atan2f; using :: ceilf;
using :: cosf; using :: coshf; using :: expf;
using :: fabsf; using :: floorf; using :: fmodf;
using :: frexpf; using :: ldexpf; using :: logf;
using :: log10f; using :: modff; using :: powf;
using :: sinf; using :: sinhf; using :: sqrtf;
using :: tanf; using :: tanhf;

using :: acosl; using :: asinl;
using :: atanl; using :: atan2l; using :: ceill;
using :: cosl; using :: coshl; using :: expl;
using :: fabsl; using :: floorl; using :: fmodl;
using :: frexpl; using :: ldexpl; using :: logl;
using :: log10l; using :: modfl; using :: powl;
using :: sinl; using :: sinhl; using :: sqrtl;
using :: tanl; using :: tanhl;

using :: float_t; using :: double_t;

using :: acosh; using :: asinh; using :: atanh;
using :: cbrt; using :: erf; using :: erfc;
using :: expm1; using :: exp2;
using :: hypot; using :: ilogb; using :: lgamma;
using :: log1p; using :: log2; using :: logb;
using :: llrint; using :: lrint; using :: nearbyint;
using :: rint; using :: llround; using :: lround;
using :: fdim; using :: fma; using :: fmax; using :: fmin;
using :: round; using :: trunc;
using :: remainder; using :: remquo;
using :: copysign; using :: nan; using :: nextafter;
using :: scalbn; using :: scalbln;
using :: nexttoward; using :: tgamma;

using :: acoshf; using :: asinhf; using :: atanhf;
using :: cbrtf; using :: erff; using :: erfcf;
using :: expm1f; using :: exp2f;
using :: hypotf; using :: ilogbf; using :: lgammaf;
using :: log1pf; using :: log2f; using :: logbf;
using :: llrintf; using :: lrintf; using :: nearbyintf;
using :: rintf; using :: llroundf; using :: lroundf;
using :: fdimf; using :: fmaf; using :: fmaxf; using :: fminf;
using :: roundf; using :: truncf;
using :: remainderf; using :: remquof;
using :: copysignf; using :: nanf;
using :: nextafterf; using :: scalbnf; using :: scalblnf;
using :: nexttowardf; using :: tgammaf;

using :: acoshl; using :: asinhl; using :: atanhl;
using :: cbrtl; using :: erfl; using :: erfcl;
using :: expm1l; using :: exp2l;
using :: hypotl; using :: ilogbl; using :: lgammal;
using :: log1pl; using :: log2l; using :: logbl;
using :: llrintl; using :: lrintl; using :: nearbyintl;
using :: rintl; using :: llroundl; using :: lroundl;
using :: fdiml; using :: fmal; using :: fmaxl; using :: fminl;
using :: roundl; using :: truncl;
using :: remainderl; using :: remquol;
using :: copysignl; using :: nanl;
using :: nextafterl; using :: scalbnl; using :: scalblnl;
using :: nexttowardl; using :: tgammal;

using :: fpclassify; using :: signbit;
using :: isfinite; using :: isinf;
using :: isnan; using :: isnormal;
using :: isgreater; using :: isgreaterequal;
using :: isless; using :: islessequal;
using :: islessgreater; using :: isunordered;
}
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\limits" 2 3

# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\cwchar" 1 3
# 13 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\cwchar" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\wchar.h" 1 3
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\wchar.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_memcpy_s.h" 1 3
# 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_memcpy_s.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\errno.h" 1 3
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\errno.h" 3
#pragma pack(push, 8)
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\errno.h" 3
 extern "C" {



         extern int* __cdecl _errno(void);


         errno_t __cdecl _set_errno( int _Value);
         errno_t __cdecl _get_errno( int* _Value);



         unsigned long* __cdecl __doserrno(void);


         errno_t __cdecl _set_doserrno( unsigned long _Value);
         errno_t __cdecl _get_doserrno( unsigned long * _Value);
# 129 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\errno.h" 3
}
# 129 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\errno.h" 3
#pragma pack(pop)
# 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_memcpy_s.h" 2 3

# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime_string.h" 1 3
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime_string.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime.h" 1 3
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime_string.h" 2 3




#pragma pack(push, 8)
# 14 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime_string.h" 3
 extern "C" {




         void const* __cdecl memchr(
                                    void const* _Buf,
                                    int _Val,
                                    size_t _MaxCount
    );


int __cdecl memcmp(
                            void const* _Buf1,
                            void const* _Buf2,
                            size_t _Size
    );
# 40 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime_string.h" 3
void* __cdecl memcpy(
                                  void* _Dst,
                                  void const* _Src,
                                  size_t _Size
    );


         void* __cdecl memmove(
                                      void* _Dst,
                                      void const* _Src,
                                      size_t _Size
    );
# 60 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime_string.h" 3
void* __cdecl memset(
                                  void* _Dst,
                                  int _Val,
                                  size_t _Size
    );


         char const* __cdecl strchr(
           char const* _Str,
           int _Val
    );


         char const* __cdecl strrchr(
           char const* _Str,
           int _Ch
    );


         char const* __cdecl strstr(
           char const* _Str,
           char const* _SubStr
    );



         wchar_t const* __cdecl wcschr(
           wchar_t const* _Str,
           wchar_t _Ch
    );


         wchar_t const* __cdecl wcsrchr(
           wchar_t const* _Str,
           wchar_t _Ch
    );



         wchar_t const* __cdecl wcsstr(
           wchar_t const* _Str,
           wchar_t const* _SubStr
    );



}
# 106 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime_string.h" 3
#pragma pack(pop)
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_memcpy_s.h" 2 3


#pragma pack(push, 8)
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_memcpy_s.h" 3
 extern "C" {
# 35 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_memcpy_s.h" 3
    static __inline errno_t __cdecl memcpy_s(
                                                                 void* const _Destination,
                                                                 rsize_t const _DestinationSize,
                                                                 void const* const _Source,
                                                                 rsize_t const _SourceSize
        )
    {
        if (_SourceSize == 0)
        {
            return 0;
        }

        { int _Expr_val=!!(_Destination != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        if (_Source == 0 || _DestinationSize < _SourceSize)
        {
            memset(_Destination, 0, _DestinationSize);

            { int _Expr_val=!!(_Source != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
            { int _Expr_val=!!(_DestinationSize >= _SourceSize); if (!(_Expr_val)) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; } };


            return 22;
        }

        memcpy(_Destination, _Source, _SourceSize);
        return 0;
    }


    static __inline errno_t __cdecl memmove_s(
                                                                 void* const _Destination,
                                                                 rsize_t const _DestinationSize,
                                                                 void const* const _Source,
                                                                 rsize_t const _SourceSize
        )
    {
        if (_SourceSize == 0)
        {
            return 0;
        }

        { int _Expr_val=!!(_Destination != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        { int _Expr_val=!!(_Source != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        { int _Expr_val=!!(_DestinationSize >= _SourceSize); if (!(_Expr_val)) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; } };

        memmove(_Destination, _Source, _SourceSize);
        return 0;
    }





}
# 88 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_memcpy_s.h" 3
#pragma pack(pop)
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\wchar.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wconio.h" 1 3
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wconio.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_stdio_config.h" 1 3
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_stdio_config.h" 3
#pragma pack(push, 8)
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_stdio_config.h" 3
 extern "C" {
# 65 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_stdio_config.h" 3
#pragma detect_mismatch("_CRT_STDIO_ISO_WIDE_SPECIFIERS", "0")






__declspec(noinline) __inline unsigned __int64* __cdecl __local_stdio_printf_options(void)
{
    static unsigned __int64 _OptionsStorage;
    return &_OptionsStorage;
}




__declspec(noinline) __inline unsigned __int64* __cdecl __local_stdio_scanf_options(void)
{
    static unsigned __int64 _OptionsStorage;
    return &_OptionsStorage;
}
# 105 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_stdio_config.h" 3
}
# 105 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_stdio_config.h" 3
#pragma pack(pop)
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wconio.h" 2 3


#pragma pack(push, 8)
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wconio.h" 3
 extern "C" {
# 26 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wconio.h" 3
             errno_t __cdecl _cgetws_s(
                                                  wchar_t* _Buffer,
                                                  size_t _BufferCount,
                                                  size_t* _SizeRead
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _cgetws_s(wchar_t (&_Buffer)[_Size], size_t* _SizeRead) throw() { return _cgetws_s(_Buffer, _Size, _SizeRead); } }







             int __cdecl _cputws(
               wchar_t const* _Buffer
        );

                                wint_t __cdecl _getwch (void);
                                wint_t __cdecl _getwche (void);
                                wint_t __cdecl _putwch ( wchar_t _Character);
                                wint_t __cdecl _ungetwch( wint_t _Character);

                                wint_t __cdecl _getwch_nolock (void);
                                wint_t __cdecl _getwche_nolock (void);
                                wint_t __cdecl _putwch_nolock ( wchar_t _Character);
                                wint_t __cdecl _ungetwch_nolock( wint_t _Character);
# 62 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wconio.h" 3
             int __cdecl __conio_common_vcwprintf(
                                                unsigned __int64 _Options,
                                                wchar_t const* _Format,
                                                _locale_t _Locale,
                                                va_list _ArgList
        );


             int __cdecl __conio_common_vcwprintf_s(
                                                unsigned __int64 _Options,
                                                wchar_t const* _Format,
                                                _locale_t _Locale,
                                                va_list _ArgList
        );


             int __cdecl __conio_common_vcwprintf_p(
                                                unsigned __int64 _Options,
                                                wchar_t const* _Format,
                                                _locale_t _Locale,
                                                va_list _ArgList
        );


    __inline int __cdecl _vcwprintf_l(
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        return __conio_common_vcwprintf((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }



    __inline int __cdecl _vcwprintf(
                                      wchar_t const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vcwprintf_l(_Format, 0, _ArgList);
    }



    __inline int __cdecl _vcwprintf_s_l(
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        return __conio_common_vcwprintf_s((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }



    __inline int __cdecl _vcwprintf_s(
                                      wchar_t const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vcwprintf_s_l(_Format, 0, _ArgList);
    }



    __inline int __cdecl _vcwprintf_p_l(
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        return __conio_common_vcwprintf_p((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }



    __inline int __cdecl _vcwprintf_p(
                                      const wchar_t* const _Format,
                                      va_list _ArgList
        )



    {
        return _vcwprintf_p_l(_Format, 0, _ArgList);
    }



    __inline int __cdecl _cwprintf_l(
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vcwprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }



    __inline int __cdecl _cwprintf(
                                      wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vcwprintf_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }



    __inline int __cdecl _cwprintf_s_l(
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vcwprintf_s_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }



    __inline int __cdecl _cwprintf_s(
                                      wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vcwprintf_s_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }



    __inline int __cdecl _cwprintf_p_l(
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vcwprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }



    __inline int __cdecl _cwprintf_p(
                                      wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vcwprintf_p_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
# 279 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wconio.h" 3
             int __cdecl __conio_common_vcwscanf(
                                               unsigned __int64 _Options,
                                               wchar_t const* _Format,
                                               _locale_t _Locale,
                                               va_list _ArgList
        );


    __inline int __cdecl _vcwscanf_l(
                                               wchar_t const* const _Format,
                                               _locale_t const _Locale,
                                               va_list _ArgList
        )



    {
        return __conio_common_vcwscanf(
            (*__local_stdio_scanf_options ()),
            _Format, _Locale, _ArgList);
    }



    __inline int __cdecl _vcwscanf(
                                               wchar_t const* const _Format,
                                               va_list _ArgList
        )



    {
#pragma warning(push)
#pragma warning(disable: 4996)
 return _vcwscanf_l(_Format, 0, _ArgList);
#pragma warning(pop)
 }



    __inline int __cdecl _vcwscanf_s_l(
                                               wchar_t const* const _Format,
                                               _locale_t const _Locale,
                                               va_list _ArgList
        )



    {
        return __conio_common_vcwscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Format, _Locale, _ArgList);
    }



    __inline int __cdecl _vcwscanf_s(
                                               wchar_t const* const _Format,
                                               va_list _ArgList
        )



    {
        return _vcwscanf_s_l(_Format, 0, _ArgList);
    }



    __inline int __cdecl _cwscanf_l(
                                               wchar_t const* const _Format,
                                               _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

#pragma warning(push)
#pragma warning(disable: 4996)
 _Result = _vcwscanf_l(_Format, _Locale, _ArgList);
#pragma warning(pop)

 ((void)(_ArgList = (va_list)0));
        return _Result;
    }



    __inline int __cdecl _cwscanf(
                                     wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

#pragma warning(push)
#pragma warning(disable: 4996)
 _Result = _vcwscanf_l(_Format, 0, _ArgList);
#pragma warning(pop)

 ((void)(_ArgList = (va_list)0));
        return _Result;
    }



    __inline int __cdecl _cwscanf_s_l(
                                               wchar_t const* const _Format,
                                               _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vcwscanf_s_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }



    __inline int __cdecl _cwscanf_s(
                                     wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vcwscanf_s_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }






}
# 431 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wconio.h" 3
#pragma pack(pop)
# 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\wchar.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wctype.h" 1 3
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wctype.h" 3
#pragma pack(push, 8)
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wctype.h" 3
 extern "C" {
# 31 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wctype.h" 3
             const unsigned short* __cdecl __pctype_func(void);
             const wctype_t* __cdecl __pwctype_func(void);
# 63 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wctype.h" 3
                        int __cdecl iswalnum ( wint_t _C);
                        int __cdecl iswalpha ( wint_t _C);
                        int __cdecl iswascii ( wint_t _C);
                        int __cdecl iswblank ( wint_t _C);
                        int __cdecl iswcntrl ( wint_t _C);


                        int __cdecl iswdigit ( wint_t _C);

                        int __cdecl iswgraph ( wint_t _C);
                        int __cdecl iswlower ( wint_t _C);
                        int __cdecl iswprint ( wint_t _C);
                        int __cdecl iswpunct ( wint_t _C);
                        int __cdecl iswspace ( wint_t _C);
                        int __cdecl iswupper ( wint_t _C);
                        int __cdecl iswxdigit ( wint_t _C);
                        int __cdecl __iswcsymf( wint_t _C);
                        int __cdecl __iswcsym ( wint_t _C);

                        int __cdecl _iswalnum_l ( wint_t _C, _locale_t _Locale);
                        int __cdecl _iswalpha_l ( wint_t _C, _locale_t _Locale);
                        int __cdecl _iswblank_l ( wint_t _C, _locale_t _Locale);
                        int __cdecl _iswcntrl_l ( wint_t _C, _locale_t _Locale);
                        int __cdecl _iswdigit_l ( wint_t _C, _locale_t _Locale);
                        int __cdecl _iswgraph_l ( wint_t _C, _locale_t _Locale);
                        int __cdecl _iswlower_l ( wint_t _C, _locale_t _Locale);
                        int __cdecl _iswprint_l ( wint_t _C, _locale_t _Locale);
                        int __cdecl _iswpunct_l ( wint_t _C, _locale_t _Locale);
                        int __cdecl _iswspace_l ( wint_t _C, _locale_t _Locale);
                        int __cdecl _iswupper_l ( wint_t _C, _locale_t _Locale);
                        int __cdecl _iswxdigit_l( wint_t _C, _locale_t _Locale);
                        int __cdecl _iswcsymf_l ( wint_t _C, _locale_t _Locale);
                        int __cdecl _iswcsym_l ( wint_t _C, _locale_t _Locale);


                        wint_t __cdecl towupper( wint_t _C);
                        wint_t __cdecl towlower( wint_t _C);
                        int __cdecl iswctype( wint_t _C, wctype_t _Type);

                        wint_t __cdecl _towupper_l( wint_t _C, _locale_t _Locale);
                        wint_t __cdecl _towlower_l( wint_t _C, _locale_t _Locale);
                        int __cdecl _iswctype_l( wint_t _C, wctype_t _Type, _locale_t _Locale);



                            int __cdecl isleadbyte( int _C);
                            int __cdecl _isleadbyte_l( int _C, _locale_t _Locale);

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "iswctype" " " "instead. See online help for details.")) int __cdecl is_wctype( wint_t _C, wctype_t _Type);
# 199 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wctype.h" 3
}
# 199 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wctype.h" 3
#pragma pack(pop)
# 16 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\wchar.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wdirect.h" 1 3
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wdirect.h" 3
#pragma pack(push, 8)
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wdirect.h" 3
 extern "C" {
# 22 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wdirect.h" 3
         __declspec(allocator) wchar_t* __cdecl _wgetcwd(
                                     wchar_t* _DstBuf,
                                     int _SizeInWords
    );



         __declspec(allocator) wchar_t* __cdecl _wgetdcwd(
                                     int _Drive,
                                     wchar_t* _DstBuf,
                                     int _SizeInWords
    );







         int __cdecl _wchdir(
           wchar_t const* _Path
    );


         int __cdecl _wmkdir(
           wchar_t const* _Path
    );


         int __cdecl _wrmdir(
           wchar_t const* _Path
    );



}
# 57 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wdirect.h" 3
#pragma pack(pop)
# 17 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\wchar.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wio.h" 1 3
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wio.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_share.h" 1 3
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wio.h" 2 3


#pragma pack(push, 8)
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wio.h" 3
 extern "C" {



#pragma warning(push)
#pragma warning(disable: 4820)
# 36 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wio.h" 3
typedef unsigned long _fsize_t;

struct _wfinddata32_t
{
    unsigned attrib;
    __time32_t time_create;
    __time32_t time_access;
    __time32_t time_write;
    _fsize_t size;
    wchar_t name[260];
};

struct _wfinddata32i64_t
{
    unsigned attrib;
    __time32_t time_create;
    __time32_t time_access;
    __time32_t time_write;
    __int64 size;
    wchar_t name[260];
};

struct _wfinddata64i32_t
{
    unsigned attrib;
    __time64_t time_create;
    __time64_t time_access;
    __time64_t time_write;
    _fsize_t size;
    wchar_t name[260];
};

struct _wfinddata64_t
{
    unsigned attrib;
    __time64_t time_create;
    __time64_t time_access;
    __time64_t time_write;
    __int64 size;
    wchar_t name[260];
};
# 98 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wio.h" 3
         int __cdecl _waccess(
           wchar_t const* _FileName,
           int _AccessMode
    );


         errno_t __cdecl _waccess_s(
           wchar_t const* _FileName,
           int _AccessMode
    );


         int __cdecl _wchmod(
           wchar_t const* _FileName,
           int _Mode
    );


         int __cdecl _wcreat(
           wchar_t const* _FileName,
           int _PermissionMode
    );



         intptr_t __cdecl _wfindfirst32(
           wchar_t const* _FileName,
           struct _wfinddata32_t* _FindData
    );



         int __cdecl _wfindnext32(
          intptr_t _FindHandle,
          struct _wfinddata32_t* _FindData
    );

         int __cdecl _wunlink(
           wchar_t const* _FileName
    );


         int __cdecl _wrename(
           wchar_t const* _OldFileName,
           wchar_t const* _NewFileName
    );

         errno_t __cdecl _wmktemp_s(
                                    wchar_t* _TemplateName,
                                    size_t _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmktemp_s(wchar_t (&_TemplateName)[_Size]) throw() { return _wmktemp_s(_TemplateName, _Size); } }





 wchar_t* __cdecl _wmktemp( wchar_t *_TemplateName);






         intptr_t __cdecl _wfindfirst32i64(
           wchar_t const* _FileName,
           struct _wfinddata32i64_t* _FindData
    );



         intptr_t __cdecl _wfindfirst64i32(
           wchar_t const* _FileName,
           struct _wfinddata64i32_t* _FindData
    );



         intptr_t __cdecl _wfindfirst64(
           wchar_t const* _FileName,
           struct _wfinddata64_t* _FindData
    );



         int __cdecl _wfindnext32i64(
          intptr_t _FindHandle,
          struct _wfinddata32i64_t* _FindData
    );



         int __cdecl _wfindnext64i32(
          intptr_t _FindHandle,
          struct _wfinddata64i32_t* _FindData
    );



         int __cdecl _wfindnext64(
          intptr_t _FindHandle,
          struct _wfinddata64_t* _FindData
    );


         errno_t __cdecl _wsopen_s(
           int* _FileHandle,
           wchar_t const* _FileName,
           int _OpenFlag,
           int _ShareFlag,
           int _PermissionFlag
    );

         errno_t __cdecl _wsopen_dispatch(
           wchar_t const* _FileName,
           int _OFlag,
           int _ShFlag,
           int _PMode,
           int* _PFileHandle,
           int _BSecure
    );






    extern "C++"
    inline int __cdecl _wopen(
               wchar_t const* _FileName,
               int _OFlag,
               int _PMode = 0
        )
    {
        int _FileHandle;

        errno_t const _Result = _wsopen_dispatch(_FileName, _OFlag, 0x40, _PMode, &_FileHandle, 0);
        return _Result ? -1 : _FileHandle;
    }

    extern "C++"
    inline int __cdecl _wsopen(
               wchar_t const* _FileName,
               int _OFlag,
               int _ShFlag,
               int _PMode = 0
        )
    {
        int _FileHandle;

        errno_t const _Result = _wsopen_dispatch(_FileName, _OFlag, _ShFlag, _PMode, &_FileHandle, 0);
        return _Result ? -1 : _FileHandle;
    }
# 273 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wio.h" 3
#pragma warning(pop)



}
# 277 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wio.h" 3
#pragma pack(pop)
# 18 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\wchar.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wprocess.h" 1 3
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wprocess.h" 3
#pragma pack(push, 8)
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wprocess.h" 3
 extern "C" {





             intptr_t __cdecl _wexecl(
               wchar_t const* _FileName,
               wchar_t const* _ArgList,
        ...);

             intptr_t __cdecl _wexecle(
               wchar_t const* _FileName,
               wchar_t const* _ArgList,
        ...);

             intptr_t __cdecl _wexeclp(
               wchar_t const* _FileName,
               wchar_t const* _ArgList,
        ...);

             intptr_t __cdecl _wexeclpe(
               wchar_t const* _FileName,
               wchar_t const* _ArgList,
        ...);

             intptr_t __cdecl _wexecv(
               wchar_t const* _FileName,
               wchar_t const* const* _ArgList
        );

             intptr_t __cdecl _wexecve(
                   wchar_t const* _FileName,
                   wchar_t const* const* _ArgList,
                   wchar_t const* const* _Env
        );

             intptr_t __cdecl _wexecvp(
               wchar_t const* _FileName,
               wchar_t const* const* _ArgList
        );

             intptr_t __cdecl _wexecvpe(
                   wchar_t const* _FileName,
                   wchar_t const* const* _ArgList,
                   wchar_t const* const* _Env
        );

             intptr_t __cdecl _wspawnl(
               int _Mode,
               wchar_t const* _FileName,
               wchar_t const* _ArgList,
        ...);

             intptr_t __cdecl _wspawnle(
               int _Mode,
               wchar_t const* _FileName,
               wchar_t const* _ArgList,
        ...);

             intptr_t __cdecl _wspawnlp(
               int _Mode,
               wchar_t const* _FileName,
               wchar_t const* _ArgList,
        ...);

             intptr_t __cdecl _wspawnlpe(
               int _Mode,
               wchar_t const* _FileName,
               wchar_t const* _ArgList,
        ...);

             intptr_t __cdecl _wspawnv(
               int _Mode,
               wchar_t const* _FileName,
               wchar_t const* const* _ArgList
        );

             intptr_t __cdecl _wspawnve(
                   int _Mode,
                   wchar_t const* _FileName,
                   wchar_t const* const* _ArgList,
                   wchar_t const* const* _Env
        );

             intptr_t __cdecl _wspawnvp(
               int _Mode,
               wchar_t const* _FileName,
               wchar_t const* const* _ArgList
        );

             intptr_t __cdecl _wspawnvpe(
                   int _Mode,
                   wchar_t const* _FileName,
                   wchar_t const* const* _ArgList,
                   wchar_t const* const* _Env
        );

             int __cdecl _wsystem(
                   wchar_t const* _Command
        );





}
# 119 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wprocess.h" 3
#pragma pack(pop)
# 19 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\wchar.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h" 1 3
# 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h" 3
#pragma pack(push, 8)
# 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h" 3
 extern "C" {
# 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h" 3
    typedef struct _iobuf
    {
        void* _Placeholder;
    } FILE;


             FILE* __cdecl __acrt_iob_func(unsigned);
# 47 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h" 3
         wint_t __cdecl fgetwc(
            FILE* _Stream
    );


         wint_t __cdecl _fgetwchar(void);


         wint_t __cdecl fputwc(
            wchar_t _Character,
            FILE* _Stream);


         wint_t __cdecl _fputwchar(
         wchar_t _Character
    );


         wint_t __cdecl getwc(
            FILE* _Stream
    );


         wint_t __cdecl getwchar(void);




         wchar_t* __cdecl fgetws(
                                 wchar_t* _Buffer,
                                 int _BufferCount,
                                 FILE* _Stream
    );


         int __cdecl fputws(
            wchar_t const* _Buffer,
            FILE* _Stream
    );



         wchar_t* __cdecl _getws_s(
                                 wchar_t* _Buffer,
                                 size_t _BufferCount
    );

extern "C++" { template <size_t _Size> inline wchar_t* __cdecl _getws_s(wchar_t (&_Buffer)[_Size]) throw() { return _getws_s(_Buffer, _Size); } }






         wint_t __cdecl putwc(
            wchar_t _Character,
            FILE* _Stream
    );


         wint_t __cdecl putwchar(
         wchar_t _Character
    );


         int __cdecl _putws(
           wchar_t const* _Buffer
    );


         wint_t __cdecl ungetwc(
            wint_t _Character,
            FILE* _Stream
    );


         FILE * __cdecl _wfdopen(
           int _FileHandle,
           wchar_t const* _Mode
    );


         FILE* __cdecl _wfopen(
           wchar_t const* _FileName,
           wchar_t const* _Mode
    );


         errno_t __cdecl _wfopen_s(
                              FILE** _Stream,
                              wchar_t const* _FileName,
                              wchar_t const* _Mode
    );



         FILE* __cdecl _wfreopen(
            wchar_t const* _FileName,
            wchar_t const* _Mode,
            FILE* _OldStream
    );


         errno_t __cdecl _wfreopen_s(
                              FILE** _Stream,
                              wchar_t const* _FileName,
                              wchar_t const* _Mode,
                              FILE* _OldStream
    );


         FILE* __cdecl _wfsopen(
           wchar_t const* _FileName,
           wchar_t const* _Mode,
           int _ShFlag
    );

         void __cdecl _wperror(
               wchar_t const* _ErrorMessage
    );




             FILE* __cdecl _wpopen(
               wchar_t const* _Command,
               wchar_t const* _Mode
        );



         int __cdecl _wremove(
           wchar_t const* _FileName
    );





         __declspec(allocator) wchar_t* __cdecl _wtempnam(
               wchar_t const* _Directory,
               wchar_t const* _FilePrefix
    );





         errno_t __cdecl _wtmpnam_s(
                                 wchar_t* _Buffer,
                                 size_t _BufferCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wtmpnam_s(wchar_t (&_Buffer)[_Size]) throw() { return _wtmpnam_s(_Buffer, _Size); } }




 wchar_t* __cdecl _wtmpnam( wchar_t *_Buffer);
# 219 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h" 3
         wint_t __cdecl _fgetwc_nolock(
            FILE* _Stream
    );


         wint_t __cdecl _fputwc_nolock(
            wchar_t _Character,
            FILE* _Stream
    );


         wint_t __cdecl _getwc_nolock(
            FILE* _Stream
    );


         wint_t __cdecl _putwc_nolock(
            wchar_t _Character,
            FILE* _Stream
    );


         wint_t __cdecl _ungetwc_nolock(
            wint_t _Character,
            FILE* _Stream
    );
# 267 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h" 3
         int __cdecl __stdio_common_vfwprintf(
                                            unsigned __int64 _Options,
                                            FILE* _Stream,
                                            wchar_t const* _Format,
                                            _locale_t _Locale,
                                            va_list _ArgList
    );


         int __cdecl __stdio_common_vfwprintf_s(
                                            unsigned __int64 _Options,
                                            FILE* _Stream,
                                            wchar_t const* _Format,
                                            _locale_t _Locale,
                                            va_list _ArgList
    );


         int __cdecl __stdio_common_vfwprintf_p(
                                            unsigned __int64 _Options,
                                            FILE* _Stream,
                                            wchar_t const* _Format,
                                            _locale_t _Locale,
                                            va_list _ArgList
    );


__inline int __cdecl _vfwprintf_l(
                                            FILE* const _Stream,
                                            wchar_t const* const _Format,
                                            _locale_t const _Locale,
                                            va_list _ArgList
    )



{
    return __stdio_common_vfwprintf((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
}



__inline int __cdecl vfwprintf(
                                  FILE* const _Stream,
                                  wchar_t const* const _Format,
                                  va_list _ArgList
    )



{
    return _vfwprintf_l(_Stream, _Format, 0, _ArgList);
}



__inline int __cdecl _vfwprintf_s_l(
                                            FILE* const _Stream,
                                            wchar_t const* const _Format,
                                            _locale_t const _Locale,
                                            va_list _ArgList
    )



{
    return __stdio_common_vfwprintf_s((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
}





    __inline int __cdecl vfwprintf_s(
                                      FILE* const _Stream,
                                      wchar_t const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vfwprintf_s_l(_Stream, _Format, 0, _ArgList);
    }





__inline int __cdecl _vfwprintf_p_l(
                                            FILE* const _Stream,
                                            wchar_t const* const _Format,
                                            _locale_t const _Locale,
                                            va_list _ArgList
    )



{
    return __stdio_common_vfwprintf_p((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
}



__inline int __cdecl _vfwprintf_p(
                                  FILE* const _Stream,
                                  wchar_t const* const _Format,
                                  va_list _ArgList
    )



{
    return _vfwprintf_p_l(_Stream, _Format, 0, _ArgList);
}



__inline int __cdecl _vwprintf_l(
                                            wchar_t const* const _Format,
                                            _locale_t const _Locale,
                                            va_list _ArgList
    )



{
    return _vfwprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
}



__inline int __cdecl vwprintf(
                                  wchar_t const* const _Format,
                                  va_list _ArgList
    )



{
    return _vfwprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
}



__inline int __cdecl _vwprintf_s_l(
                                            wchar_t const* const _Format,
                                            _locale_t const _Locale,
                                            va_list _ArgList
    )



{
    return _vfwprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
}





    __inline int __cdecl vwprintf_s(
                                      wchar_t const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vfwprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }





__inline int __cdecl _vwprintf_p_l(
                                            wchar_t const* const _Format,
                                            _locale_t const _Locale,
                                            va_list _ArgList
    )



{
    return _vfwprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
}



__inline int __cdecl _vwprintf_p(
                                  wchar_t const* const _Format,
                                  va_list _ArgList
    )



{
    return _vfwprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
}



__inline int __cdecl _fwprintf_l(
                                            FILE* const _Stream,
                                            wchar_t const* const _Format,
                                            _locale_t const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwprintf_l(_Stream, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}



__inline int __cdecl fwprintf(
                                  FILE* const _Stream,
                                  wchar_t const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwprintf_l(_Stream, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}



__inline int __cdecl _fwprintf_s_l(
                                            FILE* const _Stream,
                                            wchar_t const* const _Format,
                                            _locale_t const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwprintf_s_l(_Stream, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}





    __inline int __cdecl fwprintf_s(
                                      FILE* const _Stream,
                                      wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfwprintf_s_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }





__inline int __cdecl _fwprintf_p_l(
                                            FILE* const _Stream,
                                            wchar_t const* const _Format,
                                            _locale_t const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwprintf_p_l(_Stream, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}



__inline int __cdecl _fwprintf_p(
                                  FILE* const _Stream,
                                  wchar_t const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwprintf_p_l(_Stream, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}



__inline int __cdecl _wprintf_l(
                                            wchar_t const* const _Format,
                                            _locale_t const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}



__inline int __cdecl wprintf(
                                  wchar_t const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}



__inline int __cdecl _wprintf_s_l(
                                            wchar_t const* const _Format,
                                            _locale_t const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}





    __inline int __cdecl wprintf_s(
                                      wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfwprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }





__inline int __cdecl _wprintf_p_l(
                                            wchar_t const* const _Format,
                                            _locale_t const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}



__inline int __cdecl _wprintf_p(
                                  wchar_t const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
# 700 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h" 3
         int __cdecl __stdio_common_vfwscanf(
                                           unsigned __int64 _Options,
                                           FILE* _Stream,
                                           wchar_t const* _Format,
                                           _locale_t _Locale,
                                           va_list _ArgList
    );


__inline int __cdecl _vfwscanf_l(
            FILE* const _Stream,
                                  wchar_t const* const _Format,
                                  _locale_t const _Locale,
                                  va_list _ArgList
    )



{
    return __stdio_common_vfwscanf(
        (*__local_stdio_scanf_options ()),
        _Stream, _Format, _Locale, _ArgList);
}



__inline int __cdecl vfwscanf(
            FILE* const _Stream,
                                  wchar_t const* const _Format,
                                  va_list _ArgList
    )



{
    return _vfwscanf_l(_Stream, _Format, 0, _ArgList);
}



__inline int __cdecl _vfwscanf_s_l(
                                  FILE* const _Stream,
                                  wchar_t const* const _Format,
                                  _locale_t const _Locale,
                                  va_list _ArgList
    )



{
    return __stdio_common_vfwscanf(
        (*__local_stdio_scanf_options ()) | (1ULL << 0),
        _Stream, _Format, _Locale, _ArgList);
}





    __inline int __cdecl vfwscanf_s(
                                      FILE* const _Stream,
                                      wchar_t const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vfwscanf_s_l(_Stream, _Format, 0, _ArgList);
    }




__inline int __cdecl _vwscanf_l(
                                  wchar_t const* const _Format,
                                  _locale_t const _Locale,
                                  va_list _ArgList
    )



{
    return _vfwscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
}



__inline int __cdecl vwscanf(
                                  wchar_t const* const _Format,
                                  va_list _ArgList
    )



{
    return _vfwscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
}



__inline int __cdecl _vwscanf_s_l(
                                  wchar_t const* const _Format,
                                  _locale_t const _Locale,
                                  va_list _ArgList
    )



{
    return _vfwscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
}





    __inline int __cdecl vwscanf_s(
                                      wchar_t const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vfwscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    }





__inline int __cdecl _fwscanf_l(
                                           FILE* const _Stream,
                                           wchar_t const* const _Format,
                                           _locale_t const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwscanf_l(_Stream, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}



__inline int __cdecl fwscanf(
                                 FILE* const _Stream,
                                 wchar_t const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwscanf_l(_Stream, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}



__inline int __cdecl _fwscanf_s_l(
                                             FILE* const _Stream,
                                             wchar_t const* const _Format,
                                             _locale_t const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwscanf_s_l(_Stream, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}





    __inline int __cdecl fwscanf_s(
                                       FILE* const _Stream,
                                       wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfwscanf_s_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }





__inline int __cdecl _wscanf_l(
                                           wchar_t const* const _Format,
                                           _locale_t const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}



__inline int __cdecl wscanf(
                                 wchar_t const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}



__inline int __cdecl _wscanf_s_l(
                                             wchar_t const* const _Format,
                                             _locale_t const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}





    __inline int __cdecl wscanf_s(
                                       wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfwscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
# 1001 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h" 3
         int __cdecl __stdio_common_vswprintf(
                                            unsigned __int64 _Options,
                                            wchar_t* _Buffer,
                                            size_t _BufferCount,
                                            wchar_t const* _Format,
                                            _locale_t _Locale,
                                            va_list _ArgList
    );



         int __cdecl __stdio_common_vswprintf_s(
                                            unsigned __int64 _Options,
                                            wchar_t* _Buffer,
                                            size_t _BufferCount,
                                            wchar_t const* _Format,
                                            _locale_t _Locale,
                                            va_list _ArgList
    );



         int __cdecl __stdio_common_vsnwprintf_s(
                                            unsigned __int64 _Options,
                                            wchar_t* _Buffer,
                                            size_t _BufferCount,
                                            size_t _MaxCount,
                                            wchar_t const* _Format,
                                            _locale_t _Locale,
                                            va_list _ArgList
    );



         int __cdecl __stdio_common_vswprintf_p(
                                            unsigned __int64 _Options,
                                            wchar_t* _Buffer,
                                            size_t _BufferCount,
                                            wchar_t const* _Format,
                                            _locale_t _Locale,
                                            va_list _ArgList
    );



__inline int __cdecl _vsnwprintf_l(
                                                wchar_t* const _Buffer,
                                                size_t const _BufferCount,
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
                                                va_list _ArgList
    )



{
    int const _Result = __stdio_common_vswprintf(
        (*__local_stdio_printf_options()) | (1ULL << 0),
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}


#pragma warning(push)
#pragma warning(disable: 4793)



__inline int __cdecl _vsnwprintf_s_l(
                                            wchar_t* const _Buffer,
                                            size_t const _BufferCount,
                                            size_t const _MaxCount,
                                            wchar_t const* const _Format,
                                            _locale_t const _Locale,
                                            va_list _ArgList
    )



{
    int const _Result = __stdio_common_vsnwprintf_s(
        (*__local_stdio_printf_options()),
        _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}




__inline int __cdecl _vsnwprintf_s(
                                  wchar_t* const _Buffer,
                                  size_t const _BufferCount,
                                  size_t const _MaxCount,
                                  wchar_t const* const _Format,
                                  va_list _ArgList
    )



{
    return _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
}


 __inline int __cdecl _snwprintf( wchar_t *_Buffer, size_t _BufferCount, wchar_t const* _Format, ...); __inline int __cdecl _vsnwprintf( wchar_t *_Buffer, size_t _BufferCount, wchar_t const* _Format, va_list _Args);








#pragma warning(pop)



__inline int __cdecl _vsnwprintf(
                                             wchar_t* _Buffer,
                                             size_t _BufferCount,
                                             wchar_t const* _Format,
                                             va_list _ArgList
    )



{
#pragma warning(push)
#pragma warning(disable: 4996)
 return _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
#pragma warning(pop)
}


extern "C++" { template <size_t _Size> inline int __cdecl _vsnwprintf_s(wchar_t (&_Buffer)[_Size], size_t _BufferCount, wchar_t const* _Format, va_list _ArgList) throw() { return _vsnwprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
# 1148 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h" 3
__inline int __cdecl _vswprintf_c_l(
                                            wchar_t* const _Buffer,
                                            size_t const _BufferCount,
                                            wchar_t const* const _Format,
                                            _locale_t const _Locale,
                                            va_list _ArgList
    )



{
    int const _Result = __stdio_common_vswprintf(
        (*__local_stdio_printf_options()),
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}




__inline int __cdecl _vswprintf_c(
                                  wchar_t* const _Buffer,
                                  size_t const _BufferCount,
                                  wchar_t const* const _Format,
                                  va_list _ArgList
    )



{
    return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
}




__inline int __cdecl _vswprintf_l(
                                            wchar_t* const _Buffer,
                                            size_t const _BufferCount,
                                            wchar_t const* const _Format,
                                            _locale_t const _Locale,
                                            va_list _ArgList
    )



{
#pragma warning(push)
#pragma warning(disable: 4996)
 return _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
#pragma warning(pop)
}




__inline int __cdecl __vswprintf_l(
                                            wchar_t* const _Buffer,
                                            wchar_t const* const _Format,
                                            _locale_t const _Locale,
                                            va_list _ArgList
    )



{
    return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
}




__inline int __cdecl _vswprintf(
                                  wchar_t* const _Buffer,
                                  wchar_t const* const _Format,
                                  va_list _ArgList
    )



{
    return _vswprintf_l(_Buffer, (size_t)-1, _Format, 0, _ArgList);
}




__inline int __cdecl vswprintf(
                                            wchar_t* const _Buffer,
                                            size_t const _BufferCount,
                                            wchar_t const* const _Format,
                                            va_list _ArgList
    )



{
    return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
}




__inline int __cdecl _vswprintf_s_l(
                                            wchar_t* const _Buffer,
                                            size_t const _BufferCount,
                                            wchar_t const* const _Format,
                                            _locale_t const _Locale,
                                            va_list _ArgList
    )



{
    int const _Result = __stdio_common_vswprintf_s(
        (*__local_stdio_printf_options()),
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}





    __inline int __cdecl vswprintf_s(
                                      wchar_t* const _Buffer,
                                      size_t const _BufferCount,
                                      wchar_t const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }




extern "C++" { template <size_t _Size> inline int __cdecl vswprintf_s(wchar_t (&_Buffer)[_Size], wchar_t const* _Format, va_list _ArgList) throw() { return vswprintf_s(_Buffer, _Size, _Format, _ArgList); } }
# 1300 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h" 3
__inline int __cdecl _vswprintf_p_l(
                                            wchar_t* const _Buffer,
                                            size_t const _BufferCount,
                                            wchar_t const* const _Format,
                                            _locale_t const _Locale,
                                            va_list _ArgList
    )



{
    int const _Result = __stdio_common_vswprintf_p(
        (*__local_stdio_printf_options()),
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}




__inline int __cdecl _vswprintf_p(
                                  wchar_t* const _Buffer,
                                  size_t const _BufferCount,
                                  wchar_t const* const _Format,
                                  va_list _ArgList
    )



{
    return _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
}




__inline int __cdecl _vscwprintf_l(
                                            wchar_t const* const _Format,
                                            _locale_t const _Locale,
                                            va_list _ArgList
    )



{
    int const _Result = __stdio_common_vswprintf(
        (*__local_stdio_printf_options()) | (1ULL << 1),
        0, 0, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}




__inline int __cdecl _vscwprintf(
                                  wchar_t const* const _Format,
                                  va_list _ArgList
    )



{
    return _vscwprintf_l(_Format, 0, _ArgList);
}




__inline int __cdecl _vscwprintf_p_l(
                                            wchar_t const* const _Format,
                                            _locale_t const _Locale,
                                            va_list _ArgList
    )



{
    int const _Result = __stdio_common_vswprintf_p(
        (*__local_stdio_printf_options()) | (1ULL << 1),
        0, 0, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}




__inline int __cdecl _vscwprintf_p(
                                  wchar_t const* const _Format,
                                  va_list _ArgList
    )



{
    return _vscwprintf_p_l(_Format, 0, _ArgList);
}




__inline int __cdecl __swprintf_l(
                                            wchar_t* const _Buffer,
                                            wchar_t const* const _Format,
                                            _locale_t const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = __vswprintf_l(_Buffer, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}




__inline int __cdecl _swprintf_l(
                                            wchar_t* const _Buffer,
                                            size_t const _BufferCount,
                                            wchar_t const* const _Format,
                                            _locale_t const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}




__inline int __cdecl _swprintf(
                                  wchar_t* const _Buffer,
                                  wchar_t const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = __vswprintf_l(_Buffer, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}




__inline int __cdecl swprintf(
                                  wchar_t* const _Buffer,
                                  size_t const _BufferCount,
                                  wchar_t const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}


#pragma warning(push)


#pragma warning(disable: 4793 4996)

 __inline int __cdecl __swprintf_l( wchar_t *_Buffer, wchar_t const* _Format, _locale_t _Locale, ...); __inline int __cdecl __vswprintf_l( wchar_t *_Buffer, wchar_t const* _Format, _locale_t _Locale, va_list _Args);
# 1495 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h" 3
 __inline int __cdecl _swprintf( wchar_t *_Buffer, wchar_t const* _Format, ...); __inline int __cdecl _vswprintf( wchar_t *_Buffer, wchar_t const* _Format, va_list _Args);






#pragma warning(pop)



__inline int __cdecl _swprintf_s_l(
                                            wchar_t* const _Buffer,
                                            size_t const _BufferCount,
                                            wchar_t const* const _Format,
                                            _locale_t const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}





    __inline int __cdecl swprintf_s(
                                      wchar_t* const _Buffer,
                                      size_t const _BufferCount,
                                      wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }




extern "C++" {
# 1548 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h" 3
#pragma warning(push)
# 1548 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h" 3
;
# 1548 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h" 3
#pragma warning(disable: 4793)
# 1548 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h" 3
; template <size_t _Size> inline int __cdecl swprintf_s(wchar_t (&_Buffer)[_Size], wchar_t const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1)))))); return vswprintf_s(_Buffer, _Size, _Format, _ArgList); }
# 1548 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h" 3
#pragma warning(pop)
# 1548 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h" 3
; }
# 1557 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h" 3
__inline int __cdecl _swprintf_p_l(
                                            wchar_t* const _Buffer,
                                            size_t const _BufferCount,
                                            wchar_t const* const _Format,
                                            _locale_t const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}




__inline int __cdecl _swprintf_p(
                                  wchar_t* const _Buffer,
                                  size_t const _BufferCount,
                                  wchar_t const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}




__inline int __cdecl _swprintf_c_l(
                                            wchar_t* const _Buffer,
                                            size_t const _BufferCount,
                                            wchar_t const* const _Format,
                                            _locale_t const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}




__inline int __cdecl _swprintf_c(
                                  wchar_t* const _Buffer,
                                  size_t const _BufferCount,
                                  wchar_t const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}




__inline int __cdecl _snwprintf_l(
                                             wchar_t* const _Buffer,
                                             size_t const _BufferCount,
                                             wchar_t const* const _Format,
                                             _locale_t const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

#pragma warning(push)
#pragma warning(disable: 4996)
 _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
#pragma warning(pop)

 ((void)(_ArgList = (va_list)0));
    return _Result;
}




__inline int __cdecl _snwprintf(
                                             wchar_t* _Buffer,
                                             size_t _BufferCount,
                                             wchar_t const* _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

#pragma warning(push)
#pragma warning(disable: 4996)
 _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
#pragma warning(pop)

 ((void)(_ArgList = (va_list)0));
    return _Result;
}




__inline int __cdecl _snwprintf_s_l(
                                            wchar_t* const _Buffer,
                                            size_t const _BufferCount,
                                            size_t const _MaxCount,
                                            wchar_t const* const _Format,
                                            _locale_t const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}




__inline int __cdecl _snwprintf_s(
                                  wchar_t* const _Buffer,
                                  size_t const _BufferCount,
                                  size_t const _MaxCount,
                                  wchar_t const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}


extern "C++" {
# 1731 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h" 3
#pragma warning(push)
# 1731 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h" 3
;
# 1731 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h" 3
#pragma warning(disable: 4793)
# 1731 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h" 3
; template <size_t _Size> inline int __cdecl _snwprintf_s(wchar_t (&_Buffer)[_Size], size_t _BufferCount, wchar_t const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1)))))); return _vsnwprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); }
# 1731 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h" 3
#pragma warning(pop)
# 1731 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h" 3
; }
# 1740 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h" 3
__inline int __cdecl _scwprintf_l(
                                            wchar_t const* const _Format,
                                            _locale_t const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vscwprintf_l(_Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}




__inline int __cdecl _scwprintf(
                                  wchar_t const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vscwprintf_l(_Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}




__inline int __cdecl _scwprintf_p_l(
                                            wchar_t const* const _Format,
                                            _locale_t const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vscwprintf_p_l(_Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}




__inline int __cdecl _scwprintf_p(
                                  wchar_t const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vscwprintf_p_l(_Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}




#pragma warning(push)
#pragma warning(disable: 4141 4412 4793 4996 6054)



 extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS."))
        inline int swprintf(
                                          wchar_t* const _Buffer,
                                          wchar_t const* const _Format,
            ...) throw()
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
#pragma warning(suppress: 28719)
 _Result = vswprintf(_Buffer, 2147483647, _Format, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }

        extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS."))
        inline int __cdecl vswprintf(
                                          wchar_t* const _Buffer,
                                          wchar_t const* const _Format,
                                          va_list _ArgList
            ) throw()
        {
#pragma warning(suppress: 28719)
 return vswprintf(_Buffer, 2147483647, _Format, _ArgList);
        }

        extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS."))
        inline int _swprintf_l(
                                                    wchar_t* const _Buffer,
                                                    wchar_t const* const _Format,
                                                    _locale_t const _Locale,
            ...) throw()
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
            _Result = _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }

        extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS."))
        inline int __cdecl _vswprintf_l(
                                                    wchar_t* const _Buffer,
                                                    wchar_t const* const _Format,
                                                    _locale_t const _Locale,
                                                    va_list _ArgList
            ) throw()
        {
            return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
        }



#pragma warning(pop)
# 1890 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h" 3
 int __cdecl __stdio_common_vswscanf(
                                           unsigned __int64 _Options,
                                           wchar_t const* _Buffer,
                                           size_t _BufferCount,
                                           wchar_t const* _Format,
                                           _locale_t _Locale,
                                           va_list _ArgList
    );



__inline int __cdecl _vswscanf_l(
                                  wchar_t const* const _Buffer,
                                  wchar_t const* const _Format,
                                  _locale_t const _Locale,
                                  va_list _ArgList
    )



{
    return __stdio_common_vswscanf(
        (*__local_stdio_scanf_options ()),
        _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
}




__inline int __cdecl vswscanf(
                                  wchar_t const* _Buffer,
                                  wchar_t const* _Format,
                                  va_list _ArgList
    )



{
    return _vswscanf_l(_Buffer, _Format, 0, _ArgList);
}




__inline int __cdecl _vswscanf_s_l(
                                  wchar_t const* const _Buffer,
                                  wchar_t const* const _Format,
                                  _locale_t const _Locale,
                                  va_list _ArgList
    )



{
    return __stdio_common_vswscanf(
        (*__local_stdio_scanf_options ()) | (1ULL << 0),
        _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
}






    __inline int __cdecl vswscanf_s(
                                      wchar_t const* const _Buffer,
                                      wchar_t const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vswscanf_s_l(_Buffer, _Format, 0, _ArgList);
    }




extern "C++" { template <size_t _Size> inline int __cdecl vswscanf_s(wchar_t (&_Buffer)[_Size], wchar_t const* _Format, va_list _Args) throw() { return vswscanf_s(_Buffer, _Size, _Format, _Args); } }
# 1979 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h" 3
__inline int __cdecl _vsnwscanf_l(
                                           wchar_t const* const _Buffer,
                                           size_t const _BufferCount,
                                           wchar_t const* const _Format,
                                           _locale_t const _Locale,
                                           va_list _ArgList
    )



{
    return __stdio_common_vswscanf(
        (*__local_stdio_scanf_options ()),
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);
}




__inline int __cdecl _vsnwscanf_s_l(
                                             wchar_t const* const _Buffer,
                                             size_t const _BufferCount,
                                             wchar_t const* const _Format,
                                             _locale_t const _Locale,
                                             va_list _ArgList
    )



{
    return __stdio_common_vswscanf(
        (*__local_stdio_scanf_options ()) | (1ULL << 0),
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);
}




__inline int __cdecl _swscanf_l(
                                           wchar_t const* const _Buffer,
                                           wchar_t const* const _Format,
                                           _locale_t _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vswscanf_l(_Buffer, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}




__inline int __cdecl swscanf(
                                 wchar_t const* const _Buffer,
                                 wchar_t const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vswscanf_l(_Buffer, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}




__inline int __cdecl _swscanf_s_l(
                                             wchar_t const* const _Buffer,
                                             wchar_t const* const _Format,
                                             _locale_t const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vswscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}






    __inline int __cdecl swscanf_s(
                                       wchar_t const* const _Buffer,
                                       wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vswscanf_s_l(_Buffer, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }






__inline int __cdecl _snwscanf_l(
                                           wchar_t const* const _Buffer,
                                           size_t const _BufferCount,
                                           wchar_t const* const _Format,
                                           _locale_t const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

#pragma warning(push)
#pragma warning(disable: 4996)
 _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
#pragma warning(pop)

 ((void)(_ArgList = (va_list)0));
    return _Result;
}




__inline int __cdecl _snwscanf(
                                     wchar_t const* const _Buffer,
                                     size_t const _BufferCount,
                                     wchar_t const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

#pragma warning(push)
#pragma warning(disable: 4996)
 _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
#pragma warning(pop)

 ((void)(_ArgList = (va_list)0));
    return _Result;
}




__inline int __cdecl _snwscanf_s_l(
                                             wchar_t const* const _Buffer,
                                             size_t const _BufferCount,
                                             wchar_t const* const _Format,
                                             _locale_t const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}




__inline int __cdecl _snwscanf_s(
                                      wchar_t const* const _Buffer,
                                      size_t const _BufferCount,
                                      wchar_t const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
# 2195 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h" 3
}
# 2195 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h" 3
#pragma pack(pop)
# 20 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\wchar.h" 2 3


# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstring.h" 1 3
# 16 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstring.h" 3
#pragma pack(push, 8)
# 16 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstring.h" 3
 extern "C" {
# 28 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstring.h" 3
             errno_t __cdecl wcscat_s(
                                        wchar_t* _Destination,
             rsize_t _SizeInWords,
               wchar_t const* _Source
        );


             errno_t __cdecl wcscpy_s(
                                     wchar_t* _Destination,
             rsize_t _SizeInWords,
               wchar_t const* _Source
        );


             errno_t __cdecl wcsncat_s(
                                        wchar_t* _Destination,
                                        rsize_t _SizeInWords,
                                        wchar_t const* _Source,
                                        rsize_t _MaxCount
        );


             errno_t __cdecl wcsncpy_s(
                                     wchar_t* _Destination,
                                     rsize_t _SizeInWords,
                                     wchar_t const* _Source,
                                     rsize_t _MaxCount
        );


             wchar_t* __cdecl wcstok_s(
                                      wchar_t* _String,
                                      wchar_t const* _Delimiter,
                                      wchar_t** _Context
        );
# 79 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstring.h" 3
         __declspec(allocator) wchar_t* __cdecl _wcsdup(
           wchar_t const* _String
    );







extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscat_s(wchar_t (&_Destination)[_Size], wchar_t const* _Source) throw() { return wcscat_s(_Destination, _Size, _Source); } }







    wchar_t* __cdecl wcscat( wchar_t *_Destination, wchar_t const* _Source);
# 106 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstring.h" 3
         int __cdecl wcscmp(
           wchar_t const* _String1,
           wchar_t const* _String2
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscpy_s(wchar_t (&_Destination)[_Size], wchar_t const* _Source) throw() { return wcscpy_s(_Destination, _Size, _Source); } }





 wchar_t* __cdecl wcscpy( wchar_t *_Destination, wchar_t const* _Source);






         size_t __cdecl wcscspn(
           wchar_t const* _String,
           wchar_t const* _Control
    );


         size_t __cdecl wcslen(
           wchar_t const* _String
    );
# 143 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstring.h" 3
         size_t __cdecl wcsnlen(
                               wchar_t const* _Source,
                               size_t _MaxCount
    );
# 159 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstring.h" 3
    static __inline size_t __cdecl wcsnlen_s(
                                   wchar_t const* _Source,
                                   size_t _MaxCount
        )
    {
        return (_Source == 0) ? 0 : wcsnlen(_Source, _MaxCount);
    }



extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncat_s(wchar_t (&_Destination)[_Size], wchar_t const* _Source, size_t _Count) throw() { return wcsncat_s(_Destination, _Size, _Source, _Count); } }






 wchar_t* __cdecl wcsncat( wchar_t *_Destination, wchar_t const* _Source, size_t _Count);
# 185 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstring.h" 3
         int __cdecl wcsncmp(
                               wchar_t const* _String1,
                               wchar_t const* _String2,
                               size_t _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncpy_s(wchar_t (&_Destination)[_Size], wchar_t const* _Source, size_t _Count) throw() { return wcsncpy_s(_Destination, _Size, _Source, _Count); } }






 wchar_t* __cdecl wcsncpy( wchar_t *_Destination, wchar_t const* _Source, size_t _Count);
# 207 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstring.h" 3
         wchar_t const* __cdecl wcspbrk(
           wchar_t const* _String,
           wchar_t const* _Control
    );


         size_t __cdecl wcsspn(
           wchar_t const* _String,
           wchar_t const* _Control
    );


         wchar_t* __cdecl wcstok(
                                      wchar_t* _String,
                                      wchar_t const* _Delimiter,
                                      wchar_t** _Context
    );
# 236 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstring.h" 3
#pragma warning(push)
#pragma warning(disable: 4141 4996)


 static __inline wchar_t* __cdecl _wcstok(
                      wchar_t* const _String,
                      wchar_t const* const _Delimiter
        )
    {
        return wcstok(_String, _Delimiter, 0);
    }






        extern "C++" __declspec(deprecated("wcstok has been changed to conform with the ISO C standard, " "adding an extra context parameter. To use the legacy Microsoft " "wcstok, define _CRT_NON_CONFORMING_WCSTOK."))
        inline wchar_t* __cdecl wcstok(
                          wchar_t* _String,
                          wchar_t const* _Delimiter
            ) throw()
        {
            return wcstok(_String, _Delimiter, 0);
        }


#pragma warning(pop)







 wchar_t* __cdecl _wcserror(
         int _ErrorNumber
    );


         errno_t __cdecl _wcserror_s(
                                     wchar_t* _Buffer,
                                     size_t _SizeInWords,
                                     int _ErrorNumber
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcserror_s(wchar_t (&_Buffer)[_Size], int _Error) throw() { return _wcserror_s(_Buffer, _Size, _Error); } }
# 291 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstring.h" 3
         wchar_t* __cdecl __wcserror(
               wchar_t const* _String
    );

                            errno_t __cdecl __wcserror_s(
                                     wchar_t* _Buffer,
                                     size_t _SizeInWords,
                                     wchar_t const* _ErrorMessage
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl __wcserror_s(wchar_t (&_Buffer)[_Size], wchar_t const* _ErrorMessage) throw() { return __wcserror_s(_Buffer, _Size, _ErrorMessage); } }





                        int __cdecl _wcsicmp(
           wchar_t const* _String1,
           wchar_t const* _String2
    );

                        int __cdecl _wcsicmp_l(
             wchar_t const* _String1,
             wchar_t const* _String2,
             _locale_t _Locale
    );

                        int __cdecl _wcsnicmp(
                               wchar_t const* _String1,
                               wchar_t const* _String2,
                               size_t _MaxCount
    );

                        int __cdecl _wcsnicmp_l(
                               wchar_t const* _String1,
                               wchar_t const* _String2,
                               size_t _MaxCount,
                               _locale_t _Locale
    );

                            errno_t __cdecl _wcsnset_s(
                                    wchar_t* _Destination,
                                    size_t _SizeInWords,
                                    wchar_t _Value,
                                    size_t _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsnset_s(wchar_t (&_Destination)[_Size], wchar_t _Value, size_t _MaxCount) throw() { return _wcsnset_s(_Destination, _Size, _Value, _MaxCount); } }






 wchar_t* __cdecl _wcsnset( wchar_t *_String, wchar_t _Value, size_t _MaxCount);







         wchar_t* __cdecl _wcsrev(
              wchar_t* _String
    );

                            errno_t __cdecl _wcsset_s(
                                    wchar_t* _Destination,
                                    size_t _SizeInWords,
                                    wchar_t _Value
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsset_s(wchar_t (&_String)[_Size], wchar_t _Value) throw() { return _wcsset_s(_String, _Size, _Value); } }





 wchar_t* __cdecl _wcsset( wchar_t *_String, wchar_t _Value);






                            errno_t __cdecl _wcslwr_s(
                                    wchar_t* _String,
                                    size_t _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s(wchar_t (&_String)[_Size]) throw() { return _wcslwr_s(_String, _Size); } }




 wchar_t* __cdecl _wcslwr( wchar_t *_String);





         errno_t __cdecl _wcslwr_s_l(
                                    wchar_t* _String,
                                    size_t _SizeInWords,
                                    _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s_l(wchar_t (&_String)[_Size], _locale_t _Locale) throw() { return _wcslwr_s_l(_String, _Size, _Locale); } }





 wchar_t* __cdecl _wcslwr_l( wchar_t *_String, _locale_t _Locale);







         errno_t __cdecl _wcsupr_s(
                             wchar_t* _String,
                             size_t _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s(wchar_t (&_String)[_Size]) throw() { return _wcsupr_s(_String, _Size); } }




 wchar_t* __cdecl _wcsupr( wchar_t *_String);





         errno_t __cdecl _wcsupr_s_l(
                             wchar_t* _String,
                             size_t _Size,
                             _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s_l(wchar_t (&_String)[_Size], _locale_t _Locale) throw() { return _wcsupr_s_l(_String, _Size, _Locale); } }





 wchar_t* __cdecl _wcsupr_l( wchar_t *_String, _locale_t _Locale);
# 449 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstring.h" 3
         size_t __cdecl wcsxfrm(
                                              wchar_t* _Destination,
                                              wchar_t const* _Source,
                                              size_t _MaxCount
    );



         size_t __cdecl _wcsxfrm_l(
                                              wchar_t* _Destination,
                                              wchar_t const* _Source,
                                              size_t _MaxCount,
                                              _locale_t _Locale
    );


         int __cdecl wcscoll(
           wchar_t const* _String1,
           wchar_t const* _String2
    );


         int __cdecl _wcscoll_l(
             wchar_t const* _String1,
             wchar_t const* _String2,
             _locale_t _Locale
    );


         int __cdecl _wcsicoll(
           wchar_t const* _String1,
           wchar_t const* _String2
    );


         int __cdecl _wcsicoll_l(
             wchar_t const* _String1,
             wchar_t const* _String2,
             _locale_t _Locale
    );


         int __cdecl _wcsncoll(
                               wchar_t const* _String1,
                               wchar_t const* _String2,
                               size_t _MaxCount
    );


         int __cdecl _wcsncoll_l(
                               wchar_t const* _String1,
                               wchar_t const* _String2,
                               size_t _MaxCount,
                               _locale_t _Locale
    );


         int __cdecl _wcsnicoll(
                               wchar_t const* _String1,
                               wchar_t const* _String2,
                               size_t _MaxCount
    );


         int __cdecl _wcsnicoll_l(
                               wchar_t const* _String1,
                               wchar_t const* _String2,
                               size_t _MaxCount,
                               _locale_t _Locale
    );
# 528 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstring.h" 3
extern "C++" {



    inline wchar_t* __cdecl wcschr( wchar_t* _String, wchar_t _C)
    {
        return const_cast<wchar_t*>(wcschr(static_cast<wchar_t const*>(_String), _C));
    }


    inline wchar_t* __cdecl wcspbrk( wchar_t* _String, wchar_t const* _Control)
    {
        return const_cast<wchar_t*>(wcspbrk(static_cast<wchar_t const*>(_String), _Control));
    }


    inline wchar_t* __cdecl wcsrchr( wchar_t* _String, wchar_t _C)
    {
        return const_cast<wchar_t*>(wcsrchr(static_cast<wchar_t const*>(_String), _C));
    }



    inline wchar_t* __cdecl wcsstr( wchar_t* _String, wchar_t const*_SubStr)
    {
        return const_cast<wchar_t*>(wcsstr(static_cast<wchar_t const*>(_String), _SubStr));
    }

}
# 572 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstring.h" 3
                   __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsdup" ". See online help for details."))
             wchar_t* __cdecl wcsdup(
               wchar_t const* _String
        );
# 584 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstring.h" 3
                   __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsicmp" ". See online help for details."))
             int __cdecl wcsicmp(
               wchar_t const* _String1,
               wchar_t const* _String2
        );

                   __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsnicmp" ". See online help for details."))
             int __cdecl wcsnicmp(
                                   wchar_t const* _String1,
                                   wchar_t const* _String2,
                                   size_t _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsnset" ". See online help for details."))

             wchar_t* __cdecl wcsnset(
                                     wchar_t* _String,
                                     wchar_t _Value,
                                     size_t _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsrev" ". See online help for details."))

             wchar_t* __cdecl wcsrev(
                  wchar_t* _String
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsset" ". See online help for details."))

             wchar_t* __cdecl wcsset(
                  wchar_t* _String,
                  wchar_t _Value
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcslwr" ". See online help for details."))

             wchar_t* __cdecl wcslwr(
                  wchar_t* _String
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsupr" ". See online help for details."))

             wchar_t* __cdecl wcsupr(
                  wchar_t* _String
        );

                   __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsicoll" ". See online help for details."))
             int __cdecl wcsicoll(
               wchar_t const* _String1,
               wchar_t const* _String2
        );





}
# 640 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wstring.h" 3
#pragma pack(pop)
# 22 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\wchar.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wtime.h" 1 3
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wtime.h" 3
#pragma pack(push, 8)
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wtime.h" 3
 extern "C" {
# 22 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wtime.h" 3
struct tm
{
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;
    int tm_yday;
    int tm_isdst;
};
# 44 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wtime.h" 3
         wchar_t* __cdecl _wasctime(
         struct tm const* _Tm
    );



         errno_t __cdecl _wasctime_s(
                                                          wchar_t* _Buffer,
                                                          size_t _SizeInWords,
                                                          struct tm const* _Tm
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wasctime_s(wchar_t (&_Buffer)[_Size], struct tm const* _Time) throw() { return _wasctime_s(_Buffer, _Size, _Time); } }
# 65 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wtime.h" 3
         size_t __cdecl wcsftime(
                                  wchar_t* _Buffer,
                                  size_t _SizeInWords,
                                  wchar_t const* _Format,
                                  struct tm const* _Tm
    );



         size_t __cdecl _wcsftime_l(
                                  wchar_t* _Buffer,
                                  size_t _SizeInWords,
                                  wchar_t const* _Format,
                                  struct tm const* _Tm,
                                  _locale_t _Locale
    );



         wchar_t* __cdecl _wctime32(
         __time32_t const* _Time
    );


         errno_t __cdecl _wctime32_s(
                                                          wchar_t* _Buffer,
                                                          size_t _SizeInWords,
                                                          __time32_t const* _Time
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime32_s(wchar_t (&_Buffer)[_Size], __time32_t const* _Time) throw() { return _wctime32_s(_Buffer, _Size, _Time); } }
# 104 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wtime.h" 3
         wchar_t* __cdecl _wctime64(
         __time64_t const* _Time
    );


         errno_t __cdecl _wctime64_s(
                                                          wchar_t* _Buffer,
                                                          size_t _SizeInWords,
                                                          __time64_t const* _Time);

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime64_s(wchar_t (&_Buffer)[_Size], __time64_t const* _Time) throw() { return _wctime64_s(_Buffer, _Size, _Time); } }






         errno_t __cdecl _wstrdate_s(
                                                         wchar_t* _Buffer,
                                                         size_t _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrdate_s(wchar_t (&_Buffer)[_Size]) throw() { return _wstrdate_s(_Buffer, _Size); } }




 wchar_t* __cdecl _wstrdate( wchar_t *_Buffer);





         errno_t __cdecl _wstrtime_s(
                                                         wchar_t* _Buffer,
                                                         size_t _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrtime_s(wchar_t (&_Buffer)[_Size]) throw() { return _wstrtime_s(_Buffer, _Size); } }




 wchar_t* __cdecl _wstrtime( wchar_t *_Buffer);
# 160 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wtime.h" 3
#pragma warning(push)
#pragma warning(disable: 4996)
# 185 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wtime.h" 3
 static __inline wchar_t * __cdecl _wctime(
                 time_t const* const _Time)
        {
            return _wctime64(_Time);
        }


        static __inline errno_t __cdecl _wctime_s(
                                                                wchar_t* const _Buffer,
                                                                size_t const _SizeInWords,
                                                                time_t const* const _Time
            )
        {
            return _wctime64_s(_Buffer, _SizeInWords, _Time);
        }



#pragma warning(pop)




}
# 208 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_wtime.h" 3
#pragma pack(pop)
# 23 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\wchar.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\sys/stat.h" 1 3
# 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\sys/stat.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\sys/types.h" 1 3
# 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\sys/types.h" 3
    typedef unsigned short _ino_t;


        typedef _ino_t ino_t;
# 27 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\sys/types.h" 3
    typedef unsigned int _dev_t;


        typedef _dev_t dev_t;
# 39 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\sys/types.h" 3
    typedef long _off_t;


        typedef _off_t off_t;
# 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\sys/stat.h" 2 3


#pragma pack(push, 8)
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\sys/stat.h" 3
 extern "C" {



#pragma warning(push)
#pragma warning(disable: 4820)








struct _stat32
{
    _dev_t st_dev;
    _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    _off_t st_size;
    __time32_t st_atime;
    __time32_t st_mtime;
    __time32_t st_ctime;
};

struct _stat32i64
{
    _dev_t st_dev;
    _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    __int64 st_size;
    __time32_t st_atime;
    __time32_t st_mtime;
    __time32_t st_ctime;
};

struct _stat64i32
{
    _dev_t st_dev;
    _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    _off_t st_size;
    __time64_t st_atime;
    __time64_t st_mtime;
    __time64_t st_ctime;
};

struct _stat64
{
    _dev_t st_dev;
    _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    __int64 st_size;
    __time64_t st_atime;
    __time64_t st_mtime;
    __time64_t st_ctime;
};




    struct stat
    {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
    };
# 157 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\sys/stat.h" 3
         int __cdecl _fstat32(
          int _FileHandle,
          struct _stat32* _Stat
    );

         int __cdecl _fstat32i64(
          int _FileHandle,
          struct _stat32i64* _Stat
    );

         int __cdecl _fstat64i32(
          int _FileHandle,
          struct _stat64i32* _Stat
    );

         int __cdecl _fstat64(
          int _FileHandle,
          struct _stat64* _Stat
    );

         int __cdecl _stat32(
           char const* _FileName,
           struct _stat32* _Stat
    );

         int __cdecl _stat32i64(
           char const* _FileName,
           struct _stat32i64* _Stat
    );

         int __cdecl _stat64i32(
           char const* _FileName,
           struct _stat64i32* _Stat
    );

         int __cdecl _stat64(
           char const* _FileName,
           struct _stat64* _Stat
    );

         int __cdecl _wstat32(
           wchar_t const* _FileName,
           struct _stat32* _Stat
    );

         int __cdecl _wstat32i64(
           wchar_t const* _FileName,
           struct _stat32i64* _Stat
    );

         int __cdecl _wstat64i32(
           wchar_t const* _FileName,
           struct _stat64i32* _Stat
    );

         int __cdecl _wstat64(
           wchar_t const* _FileName,
           struct _stat64* _Stat
    );
# 236 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\sys/stat.h" 3
        static __inline int __cdecl fstat(int const _FileHandle, struct stat* const _Stat)
        {
            typedef char __static_assert_t[(sizeof(struct stat) == sizeof(struct _stat64i32)) != 0];
            return _fstat64i32(_FileHandle, (struct _stat64i32*)_Stat);
        }
        static __inline int __cdecl stat(char const* const _FileName, struct stat* const _Stat)
        {
            typedef char __static_assert_t[(sizeof(struct stat) == sizeof(struct _stat64i32)) != 0];
            return _stat64i32(_FileName, (struct _stat64i32*)_Stat);
        }






#pragma warning(pop)



}
# 256 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\sys/stat.h" 3
#pragma pack(pop)
# 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\wchar.h" 2 3




#pragma pack(push, 8)
# 28 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\wchar.h" 3
 extern "C" {
# 37 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\wchar.h" 3
typedef wchar_t _Wint_t;




         wchar_t* __cdecl _wsetlocale(
               int _Category,
               wchar_t const* _Locale
    );


         _locale_t __cdecl _wcreate_locale(
           int _Category,
           wchar_t const* _Locale
    );



         wint_t __cdecl btowc(
         int _Ch
    );

         size_t __cdecl mbrlen(
                                                   char const* _Ch,
                                                   size_t _SizeInBytes,
                                                   mbstate_t* _State
    );

         size_t __cdecl mbrtowc(
                                                   wchar_t* _DstCh,
                                                   char const* _SrcCh,
                                                   size_t _SizeInBytes,
                                                   mbstate_t* _State
    );


         errno_t __cdecl mbsrtowcs_s(
                                      size_t* _Retval,
                                      wchar_t* _Dst,
                                      size_t _Size,
                                      char const** _PSrc,
                                      size_t _N,
                                      mbstate_t* _State
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl mbsrtowcs_s(size_t* _Retval, wchar_t (&_Dest)[_Size], char const** _PSource, size_t _Count, mbstate_t* _State) throw() { return mbsrtowcs_s(_Retval, _Dest, _Size, _PSource, _Count, _State); } }
# 92 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\wchar.h" 3
 size_t __cdecl mbsrtowcs( wchar_t *_Dest, char const** _PSrc, size_t _Count, mbstate_t* _State);
# 101 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\wchar.h" 3
         errno_t __cdecl wcrtomb_s(
                                     size_t* _Retval,
                                     char* _Dst,
                                     size_t _SizeInBytes,
                                     wchar_t _Ch,
                                     mbstate_t* _State
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcrtomb_s(size_t* _Retval, char (&_Dest)[_Size], wchar_t _Source, mbstate_t* _State) throw() { return wcrtomb_s(_Retval, _Dest, _Size, _Source, _State); } }
# 118 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\wchar.h" 3
 size_t __cdecl wcrtomb( char *_Dest, wchar_t _Source, mbstate_t* _State);







         errno_t __cdecl wcsrtombs_s(
                                                      size_t* _Retval,
                                                      char* _Dst,
                                                      size_t _SizeInBytes,
                                                      wchar_t const** _Src,
                                                      size_t _Size,
                                                      mbstate_t* _State
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsrtombs_s(size_t* _Retval, char (&_Dest)[_Size], wchar_t const** _PSrc, size_t _Count, mbstate_t* _State) throw() { return wcsrtombs_s(_Retval, _Dest, _Size, _PSrc, _Count, _State); } }
# 145 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\wchar.h" 3
 size_t __cdecl wcsrtombs( char *_Dest, wchar_t const** _PSource, size_t _Count, mbstate_t* _State);







         int __cdecl wctob(
         wint_t _WCh
    );
# 164 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\wchar.h" 3
        errno_t __cdecl wmemcpy_s(
                                         wchar_t* _S1,
                                         rsize_t _N1,
                                         wchar_t const* _S2,
                                         rsize_t _N
            );


        errno_t __cdecl wmemmove_s(
                                         wchar_t* _S1,
                                         rsize_t _N1,
                                         wchar_t const* _S2,
                                         rsize_t _N
            );



    __inline int __cdecl fwide(
                 FILE* _F,
                 int _M
        )
    {
        (void)_F;
        return (_M);
    }

    __inline int __cdecl mbsinit(
                 mbstate_t const* _P
        )
    {
        return _P == 0 || _P->_Wchar == 0;
    }

    __inline wchar_t const* __cdecl wmemchr(
                       wchar_t const* _S,
                       wchar_t _C,
                       size_t _N
        )
    {
        for (; 0 < _N; ++_S, --_N)
            if (*_S == _C)
                return (wchar_t const*)_S;

        return 0;
    }

    __inline int __cdecl wmemcmp(
                       wchar_t const* _S1,
                       wchar_t const* _S2,
                       size_t _N
        )
    {
        for (; 0 < _N; ++_S1, ++_S2, --_N)
            if (*_S1 != *_S2)
                return *_S1 < *_S2 ? -1 : 1;

        return 0;
    }



    __inline
    wchar_t* __cdecl wmemcpy(
                             wchar_t* _S1,
                             wchar_t const* _S2,
                             size_t _N
        )
    {
#pragma warning(push)
#pragma warning(disable: 4995 4996 6386)
 return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));
#pragma warning(pop)
 }

    __inline
    wchar_t* __cdecl wmemmove(
                                 wchar_t* _S1,
                                 wchar_t const* _S2,
                                 size_t _N
        )
    {
#pragma warning(push)
#pragma warning(disable: 4996 6386)
 return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));
#pragma warning(pop)
 }



    __inline wchar_t* __cdecl wmemset(
                             wchar_t* _S,
                             wchar_t _C,
                             size_t _N
        )
    {
        wchar_t *_Su = _S;
        for (; 0 < _N; ++_Su, --_N)
        {
            *_Su = _C;
        }
        return _S;
    }



        extern "C++" inline wchar_t* __cdecl wmemchr(
                           wchar_t* _S,
                           wchar_t _C,
                           size_t _N
            )
        {
            wchar_t const* const _SC = _S;
            return const_cast<wchar_t*>(wmemchr(_SC, _C, _N));
        }







}
# 285 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\wchar.h" 3
#pragma pack(pop)
# 13 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\cwchar" 2 3



typedef mbstate_t _Mbstatet;


namespace std {
using :: _Mbstatet;

using :: mbstate_t; using :: size_t; using :: tm; using :: wint_t;

using :: btowc; using :: fgetwc; using :: fgetws; using :: fputwc;
using :: fputws; using :: fwide; using :: fwprintf;
using :: fwscanf; using :: getwc; using :: getwchar;
using :: mbrlen; using :: mbrtowc; using :: mbsrtowcs;
using :: mbsinit; using :: putwc; using :: putwchar;
using :: swprintf; using :: swscanf; using :: ungetwc;
using :: vfwprintf; using :: vswprintf; using :: vwprintf;
using :: wcrtomb; using :: wprintf; using :: wscanf;
using :: wcsrtombs; using :: wcstol; using :: wcscat;
using :: wcschr; using :: wcscmp; using :: wcscoll;
using :: wcscpy; using :: wcscspn; using :: wcslen;
using :: wcsncat; using :: wcsncmp; using :: wcsncpy;
using :: wcspbrk; using :: wcsrchr; using :: wcsspn;
using :: wcstod; using :: wcstoul; using :: wcsstr;
using :: wcstok; using :: wcsxfrm; using :: wctob;
using :: wmemchr; using :: wmemcmp; using :: wmemcpy;
using :: wmemmove; using :: wmemset; using :: wcsftime;

using :: vfwscanf; using :: vswscanf; using :: vwscanf;
using :: wcstof; using :: wcstold;
using :: wcstoll; using :: wcstoull;
}
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\limits" 2 3

# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xstddef" 1 3





# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\cstddef" 1 3
# 17 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\cstddef" 3
namespace std {
using :: ptrdiff_t; using :: size_t;
}



namespace std {
typedef double max_align_t;
}

using ::std:: max_align_t;
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xstddef" 2 3



# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\initializer_list" 1 3







#pragma pack(push,8)
#pragma warning(push, 3)



namespace std {

template<class _Elem>
 class initializer_list
 {
public:
 typedef _Elem value_type;
 typedef const _Elem& reference;
 typedef const _Elem& const_reference;
 typedef size_t size_type;

 typedef const _Elem* iterator;
 typedef const _Elem* const_iterator;

 constexpr initializer_list() noexcept
  : _First(0), _Last(0)
  {
  }

 constexpr initializer_list(const _Elem *_First_arg,
  const _Elem *_Last_arg) noexcept
  : _First(_First_arg), _Last(_Last_arg)
  {
  }

 constexpr const _Elem *begin() const noexcept
  {
  return (_First);
  }

 constexpr const _Elem *end() const noexcept
  {
  return (_Last);
  }

 constexpr size_t size() const noexcept
  {
  return ((size_t)(_Last - _First));
  }

private:
 const _Elem *_First;
 const _Elem *_Last;
 };


template<class _Elem> inline
 constexpr const _Elem *begin(initializer_list<_Elem> _Ilist) noexcept
 {
 return (_Ilist.begin());
 }


template<class _Elem> inline
 constexpr const _Elem *end(initializer_list<_Elem> _Ilist) noexcept
 {
 return (_Ilist.end());
 }
}

#pragma warning(pop)
#pragma pack(pop)
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xstddef" 2 3




#pragma pack(push,8)
#pragma warning(push, 3)
# 24 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xstddef" 3
namespace std {
# 128 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xstddef" 3
template<bool,
 class _Ty1,
 class _Ty2>
 struct _If
 {
 typedef _Ty2 type;
 };

template<class _Ty1,
 class _Ty2>
 struct _If<true, _Ty1, _Ty2>
 {
 typedef _Ty1 type;
 };

template<class _Ty>
 struct _Always_false
 {
 static constexpr bool value = false;
 };





template<class _Arg,
 class _Result>
 struct unary_function
 {
 typedef _Arg argument_type;
 typedef _Result result_type;
 };


template<class _Arg1,
 class _Arg2,
 class _Result>
 struct binary_function
 {
 typedef _Arg1 first_argument_type;
 typedef _Arg2 second_argument_type;
 typedef _Result result_type;
 };



template<class _Ty = void>
 struct plus
 {
 typedef _Ty first_argument_type;
 typedef _Ty second_argument_type;
 typedef _Ty result_type;

 constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left + _Right);
  }
 };


template<class _Ty = void>
 struct minus
 {
 typedef _Ty first_argument_type;
 typedef _Ty second_argument_type;
 typedef _Ty result_type;

 constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left - _Right);
  }
 };


template<class _Ty = void>
 struct multiplies
 {
 typedef _Ty first_argument_type;
 typedef _Ty second_argument_type;
 typedef _Ty result_type;

 constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left * _Right);
  }
 };


template<class _Ty = void>
 struct equal_to
 {
 typedef _Ty first_argument_type;
 typedef _Ty second_argument_type;
 typedef bool result_type;

 constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left == _Right);
  }
 };


template<class _Ty = void>
 struct less
 {
 typedef _Ty first_argument_type;
 typedef _Ty second_argument_type;
 typedef bool result_type;

 constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left < _Right);
  }
 };


template<>
 struct plus<void>
 {
 typedef int is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(static_cast<_Ty1&&>(_Left)
   + static_cast<_Ty2&&>(_Right))
  {
  return (static_cast<_Ty1&&>(_Left)
   + static_cast<_Ty2&&>(_Right));
  }
 };


template<>
 struct minus<void>
 {
 typedef int is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(static_cast<_Ty1&&>(_Left)
   - static_cast<_Ty2&&>(_Right))
  {
  return (static_cast<_Ty1&&>(_Left)
   - static_cast<_Ty2&&>(_Right));
  }
 };


template<>
 struct multiplies<void>
 {
 typedef int is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(static_cast<_Ty1&&>(_Left)
   * static_cast<_Ty2&&>(_Right))
  {
  return (static_cast<_Ty1&&>(_Left)
   * static_cast<_Ty2&&>(_Right));
  }
 };


template<>
 struct equal_to<void>
 {
 typedef int is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(static_cast<_Ty1&&>(_Left)
   == static_cast<_Ty2&&>(_Right))
  {
  return (static_cast<_Ty1&&>(_Left)
   == static_cast<_Ty2&&>(_Right));
  }
 };


template<>
 struct less<void>
 {
 typedef int is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(static_cast<_Ty1&&>(_Left)
   < static_cast<_Ty2&&>(_Right))
  {
  return (static_cast<_Ty1&&>(_Left)
   < static_cast<_Ty2&&>(_Right));
  }
 };


}



namespace std {

inline size_t _Hash_seq(const unsigned char *_First, size_t _Count)
 {






 static_assert(sizeof(size_t) == 4, "This code is for 32-bit size_t.");
 const size_t _FNV_offset_basis = 2166136261U;
 const size_t _FNV_prime = 16777619U;


 size_t _Val = _FNV_offset_basis;
 for (size_t _Next = 0; _Next < _Count; ++_Next)
  {
  _Val ^= (size_t)_First[_Next];
  _Val *= _FNV_prime;
  }
 return (_Val);
 }


template<class _Kty>
 struct _Bitwise_hash
 {
 typedef _Kty argument_type;
 typedef size_t result_type;

 size_t operator()(const _Kty& _Keyval) const
  {
  return (_Hash_seq((const unsigned char *)&_Keyval, sizeof (_Kty)));
  }
 };


template<class _Kty>
 struct hash
  : public _Bitwise_hash<_Kty>
 {
 static constexpr bool _Value = __is_enum(_Kty);
 static_assert(_Value,
  "The C++ Standard doesn't provide a hash for this type.");
 };
template<>
 struct hash<bool>
  : public _Bitwise_hash<bool>
 {
 };

template<>
 struct hash<char>
  : public _Bitwise_hash<char>
 {
 };

template<>
 struct hash<signed char>
  : public _Bitwise_hash<signed char>
 {
 };

template<>
 struct hash<unsigned char>
  : public _Bitwise_hash<unsigned char>
 {
 };

template<>
 struct hash<char16_t>
  : public _Bitwise_hash<char16_t>
 {
 };

template<>
 struct hash<char32_t>
  : public _Bitwise_hash<char32_t>
 {
 };


template<>
 struct hash<wchar_t>
  : public _Bitwise_hash<wchar_t>
 {
 };


template<>
 struct hash<short>
  : public _Bitwise_hash<short>
 {
 };

template<>
 struct hash<unsigned short>
  : public _Bitwise_hash<unsigned short>
 {
 };

template<>
 struct hash<int>
  : public _Bitwise_hash<int>
 {
 };

template<>
 struct hash<unsigned int>
  : public _Bitwise_hash<unsigned int>
 {
 };

template<>
 struct hash<long>
  : public _Bitwise_hash<long>
 {
 };

template<>
 struct hash<unsigned long>
  : public _Bitwise_hash<unsigned long>
 {
 };

template<>
 struct hash<long long>
  : public _Bitwise_hash<long long>
 {
 };

template<>
 struct hash<unsigned long long>
  : public _Bitwise_hash<unsigned long long>
 {
 };

template<>
 struct hash<float>
  : public _Bitwise_hash<float>
 {
 typedef float _Kty;
 typedef _Bitwise_hash<_Kty> _Mybase;

 size_t operator()(const _Kty& _Keyval) const
  {
  return (_Mybase::operator()(
   _Keyval == 0 ? 0 : _Keyval));
  }
 };

template<>
 struct hash<double>
  : public _Bitwise_hash<double>
 {
 typedef double _Kty;
 typedef _Bitwise_hash<_Kty> _Mybase;

 size_t operator()(const _Kty& _Keyval) const
  {
  return (_Mybase::operator()(
   _Keyval == 0 ? 0 : _Keyval));
  }
 };

template<>
 struct hash<long double>
  : public _Bitwise_hash<long double>
 {
 typedef long double _Kty;
 typedef _Bitwise_hash<_Kty> _Mybase;

 size_t operator()(const _Kty& _Keyval) const
  {
  return (_Mybase::operator()(
   _Keyval == 0 ? 0 : _Keyval));
  }
 };

template<class _Ty>
 struct hash<_Ty *>
  : public _Bitwise_hash<_Ty *>
 {
 };
}



namespace std {
namespace tr1 {
using ::std:: hash;
}
}
# 633 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xstddef" 3
namespace std {

template<class... _Types>
 struct _Arg_types
 {
 };

template<class _Ty1>
 struct _Arg_types<_Ty1>
 {
 typedef _Ty1 argument_type;
 };

template<class _Ty1,
 class _Ty2>
 struct _Arg_types<_Ty1, _Ty2>
 {
 typedef _Ty1 first_argument_type;
 typedef _Ty2 second_argument_type;
 };


template<class _Ty>
 struct _Is_function
 {
 typedef false_type _Bool_type;
 static constexpr bool _Weird = false;
 };
# 673 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xstddef" 3
template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = false; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __fastcall (_Types...) > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = false; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __stdcall (_Types...) > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = false; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = false; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) const> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __fastcall (_Types...) const> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __stdcall (_Types...) const> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) const> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) volatile> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __fastcall (_Types...) volatile> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __stdcall (_Types...) volatile> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) volatile> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) const volatile> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __fastcall (_Types...) const volatile> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __stdcall (_Types...) const volatile> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) const volatile> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __fastcall (_Types...) &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __stdcall (_Types...) &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) const &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __fastcall (_Types...) const &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __stdcall (_Types...) const &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) const &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) volatile &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __fastcall (_Types...) volatile &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __stdcall (_Types...) volatile &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) volatile &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) const volatile &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __fastcall (_Types...) const volatile &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __stdcall (_Types...) const volatile &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) const volatile &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __fastcall (_Types...) &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __stdcall (_Types...) &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) const &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __fastcall (_Types...) const &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __stdcall (_Types...) const &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) const &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) volatile &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __fastcall (_Types...) volatile &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __stdcall (_Types...) volatile &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) volatile &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) const volatile &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __fastcall (_Types...) const volatile &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __stdcall (_Types...) const volatile &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) const volatile &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; };
# 686 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xstddef" 3
template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) > { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = false; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) volatile> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const volatile> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) &> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const &> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) volatile &> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const volatile &> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) &&> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const &&> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) volatile &&> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const volatile &&> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; };


template<class _Ty>
 struct is_function
  : _Is_function<_Ty>::_Bool_type
 {
 };


template<class _Ty>
 constexpr bool is_function_v = is_function<_Ty>::value;
# 722 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xstddef" 3
template<class _Ty> inline
 constexpr _Ty *addressof(_Ty& _Val) noexcept
 {
 return (__builtin_addressof(_Val));
 }




template<class _Ptrty> inline
 auto _Unfancy(_Ptrty _Ptr)
 {
 return (::std:: addressof(*_Ptr));
 }

template<class _Ty> inline
 _Ty * _Unfancy(_Ty * _Ptr)
 {
 return (_Ptr);
 }

}

#pragma warning(pop)
#pragma pack(pop)
# 11 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\limits" 2 3


#pragma pack(push,8)
#pragma warning(push, 3)



namespace std {
# 52 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\limits" 3
typedef enum
 {
 denorm_indeterminate = -1,
 denorm_absent = 0,
 denorm_present = 1}
  float_denorm_style;


typedef enum
 {
 round_indeterminate = -1,
 round_toward_zero = 0,
 round_to_nearest = 1,
 round_toward_infinity = 2,
 round_toward_neg_infinity = 3}
  float_round_style;


struct _Num_base
 {
 static constexpr float_denorm_style has_denorm = (float_denorm_style)(denorm_absent);
 static constexpr bool has_denorm_loss = (bool)(false);
 static constexpr bool has_infinity = (bool)(false);
 static constexpr bool has_quiet_NaN = (bool)(false);
 static constexpr bool has_signaling_NaN = (bool)(false);
 static constexpr bool is_bounded = (bool)(false);
 static constexpr bool is_exact = (bool)(false);
 static constexpr bool is_iec559 = (bool)(false);
 static constexpr bool is_integer = (bool)(false);
 static constexpr bool is_modulo = (bool)(false);
 static constexpr bool is_signed = (bool)(false);
 static constexpr bool is_specialized = (bool)(false);
 static constexpr bool tinyness_before = (bool)(false);
 static constexpr bool traps = (bool)(false);
 static constexpr float_round_style round_style = (float_round_style)(round_toward_zero);
 static constexpr int digits = (int)(0);
 static constexpr int digits10 = (int)(0);

 static constexpr int max_digits10 = (int)(0);

 static constexpr int max_exponent = (int)(0);
 static constexpr int max_exponent10 = (int)(0);
 static constexpr int min_exponent = (int)(0);
 static constexpr int min_exponent10 = (int)(0);
 static constexpr int radix = (int)(0);
 };


template<class _Ty>
 class numeric_limits
  : public _Num_base
 {
public:
 static constexpr _Ty (min)() noexcept
  {
  return (_Ty());
  }

 static constexpr _Ty (max)() noexcept
  {
  return (_Ty());
  }

 static constexpr _Ty lowest() noexcept
  {
  return (_Ty());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (_Ty());
  }

 static constexpr _Ty round_error() noexcept
  {
  return (_Ty());
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (_Ty());
  }

 static constexpr _Ty infinity() noexcept
  {
  return (_Ty());
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (_Ty());
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (_Ty());
  }
 };

template<class _Ty>
 class numeric_limits<const _Ty>
  : public numeric_limits<_Ty>
 {
 };

template<class _Ty>
 class numeric_limits<volatile _Ty>
  : public numeric_limits<_Ty>
 {
 };

template<class _Ty>
 class numeric_limits<const volatile _Ty>
  : public numeric_limits<_Ty>
 {
 };


struct _Num_int_base
 : public _Num_base
 {
 static constexpr bool is_bounded = (bool)(true);
 static constexpr bool is_exact = (bool)(true);
 static constexpr bool is_integer = (bool)(true);
 static constexpr bool is_modulo = (bool)(true);
 static constexpr bool is_specialized = (bool)(true);
 static constexpr int radix = (int)(2);
 };


struct _Num_float_base
 : public _Num_base
 {
 static constexpr float_denorm_style has_denorm = (float_denorm_style)(denorm_present);
 static constexpr bool has_denorm_loss = (bool)(true);
 static constexpr bool has_infinity = (bool)(true);
 static constexpr bool has_quiet_NaN = (bool)(true);
 static constexpr bool has_signaling_NaN = (bool)(true);
 static constexpr bool is_bounded = (bool)(true);
 static constexpr bool is_exact = (bool)(false);
 static constexpr bool is_iec559 = (bool)(true);
 static constexpr bool is_integer = (bool)(false);
 static constexpr bool is_modulo = (bool)(false);
 static constexpr bool is_signed = (bool)(true);
 static constexpr bool is_specialized = (bool)(true);
 static constexpr bool tinyness_before = (bool)(true);
 static constexpr bool traps = (bool)(false);
 static constexpr float_round_style round_style = (float_round_style)(round_to_nearest);
 static constexpr int radix = (int)(2);
 };


template<> class numeric_limits<char>
 : public _Num_int_base
 {
public:
 typedef char _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return ((-128));
  }

 static constexpr _Ty (max)() noexcept
  {
  return (127);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)((-128) != 0);
 static constexpr int digits = (int)(8 - ((-128) != 0 ? 1 : 0));
 static constexpr int digits10 = (int)((8 - ((-128) != 0 ? 1 : 0)) * 301L / 1000);

 };


template<> class numeric_limits<wchar_t>
 : public _Num_int_base
 {
public:
 typedef wchar_t _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return ((_Ty)0x0000);
  }

 static constexpr _Ty (max)() noexcept
  {
  return ((_Ty)0xffff);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(0x0000 != 0);
 static constexpr int digits = (int)(8 * sizeof (wchar_t) - (0x0000 != 0 ? 1 : 0));

 static constexpr int digits10 = (int)((8 * sizeof (wchar_t) - (0x0000 != 0 ? 1 : 0)) * 301L / 1000);

 };


template<> class numeric_limits<bool>
 : public _Num_int_base
 {
public:
 typedef bool _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (false);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (true);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_modulo = (bool)(false);
 static constexpr bool is_signed = (bool)(false);
 static constexpr int digits = (int)(1);
 static constexpr int digits10 = (int)(0);
 };


template<> class numeric_limits<signed char>
 : public _Num_int_base
 {
public:
 typedef signed char _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return ((-128));
  }

 static constexpr _Ty (max)() noexcept
  {
  return (127);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(true);
 static constexpr int digits = (int)(8 - 1);
 static constexpr int digits10 = (int)((8 - 1) * 301L / 1000);
 };


template<> class numeric_limits<unsigned char>
 : public _Num_int_base
 {
public:
 typedef unsigned char _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (0);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0xff);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(false);
 static constexpr int digits = (int)(8);
 static constexpr int digits10 = (int)(8 * 301L / 1000);
 };


template<> class numeric_limits<short>
 : public _Num_int_base
 {
public:
 typedef short _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return ((-32768));
  }

 static constexpr _Ty (max)() noexcept
  {
  return (32767);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(true);
 static constexpr int digits = (int)(8 * sizeof (short) - 1);
 static constexpr int digits10 = (int)((8 * sizeof (short) - 1) * 301L / 1000);

 };



template<> class numeric_limits<unsigned short>
 : public _Num_int_base
 {
public:
 typedef unsigned short _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (0);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0xffff);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(false);
 static constexpr int digits = (int)(8 * sizeof (unsigned short));
 static constexpr int digits10 = (int)(8 * sizeof (unsigned short) * 301L / 1000);

 };



template<> class numeric_limits<char16_t>
 : public _Num_int_base
 {
public:
 typedef char16_t _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (0);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0xffff);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(false);
 static constexpr int digits = (int)(8 * sizeof (char16_t));
 static constexpr int digits10 = (int)(8 * sizeof (char16_t) * 301L / 1000);

 };


template<> class numeric_limits<int>
 : public _Num_int_base
 {
public:
 typedef int _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return ((-2147483647 - 1));
  }

 static constexpr _Ty (max)() noexcept
  {
  return (2147483647);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(true);
 static constexpr int digits = (int)(8 * sizeof (int) - 1);
 static constexpr int digits10 = (int)((8 * sizeof (int) - 1) * 301L / 1000);

 };


template<> class numeric_limits<unsigned int>
 : public _Num_int_base
 {
public:
 typedef unsigned int _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (0);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0xffffffff);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(false);
 static constexpr int digits = (int)(8 * sizeof (unsigned int));
 static constexpr int digits10 = (int)(8 * sizeof (unsigned int) * 301L / 1000);

 };


template<> class numeric_limits<long>
 : public _Num_int_base
 {
public:
 typedef long _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return ((-2147483647L - 1));
  }

 static constexpr _Ty (max)() noexcept
  {
  return (2147483647L);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(true);
 static constexpr int digits = (int)(8 * sizeof (long) - 1);
 static constexpr int digits10 = (int)((8 * sizeof (long) - 1) * 301L / 1000);

 };


template<> class numeric_limits<unsigned long>
 : public _Num_int_base
 {
public:
 typedef unsigned long _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (0);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0xffffffffUL);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(false);
 static constexpr int digits = (int)(8 * sizeof (unsigned long));
 static constexpr int digits10 = (int)(8 * sizeof (unsigned long) * 301L / 1000);

 };


template<> class numeric_limits<char32_t>
 : public _Num_int_base
 {
public:
 typedef char32_t _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (0);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0xffffffff);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(false);
 static constexpr int digits = (int)(8 * sizeof (char32_t));
 static constexpr int digits10 = (int)(8 * sizeof (char32_t) * 301L / 1000);

 };


template<> class numeric_limits<long long>
 : public _Num_int_base
 {
public:
 typedef long long _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (-0x7fffffffffffffff - 1);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0x7fffffffffffffff);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(true);
 static constexpr int digits = (int)(8 * sizeof (long long) - 1);
 static constexpr int digits10 = (int)((8 * sizeof (long long) - 1) * 301L / 1000);

 };


template<> class numeric_limits<unsigned long long>
 : public _Num_int_base
 {
public:
 typedef unsigned long long _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (0);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0xffffffffffffffff);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(false);
 static constexpr int digits = (int)(8 * sizeof (unsigned long long));
 static constexpr int digits10 = (int)(8 * sizeof (unsigned long long) * 301L / 1000);

 };


template<> class numeric_limits<float>
 : public _Num_float_base
 {
public:
 typedef float _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (1.175494351e-38F);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (3.402823466e+38F);
  }

 static constexpr _Ty lowest() noexcept
  {
  return (-(max)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (1.192092896e-07F);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0.5F);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (1.401298464e-45F);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (__builtin_huge_valf());
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (__builtin_nanf("0"));
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (__builtin_nansf("1"));
  }

 static constexpr int digits = (int)(24);
 static constexpr int digits10 = (int)(6);

 static constexpr int max_digits10 = (int)(2 + 24 * 301L / 1000);

 static constexpr int max_exponent = (int)((int)128);
 static constexpr int max_exponent10 = (int)((int)38);
 static constexpr int min_exponent = (int)((int)(-125));
 static constexpr int min_exponent10 = (int)((int)(-37));
 };


template<> class numeric_limits<double>
 : public _Num_float_base
 {
public:
 typedef double _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (2.2250738585072014e-308);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (1.7976931348623158e+308);
  }

 static constexpr _Ty lowest() noexcept
  {
  return (-(max)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (2.2204460492503131e-016);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0.5);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (4.9406564584124654e-324);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (__builtin_huge_val());
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (__builtin_nan("0"));
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (__builtin_nans("1"));
  }

 static constexpr int digits = (int)(53);
 static constexpr int digits10 = (int)(15);

 static constexpr int max_digits10 = (int)(2 + 53 * 301L / 1000);

 static constexpr int max_exponent = (int)((int)1024);
 static constexpr int max_exponent10 = (int)((int)308);
 static constexpr int min_exponent = (int)((int)(-1021));
 static constexpr int min_exponent10 = (int)((int)(-307));
 };


template<> class numeric_limits<long double>
 : public _Num_float_base
 {
public:
 typedef long double _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (2.2250738585072014e-308);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (1.7976931348623158e+308);
  }

 static constexpr _Ty lowest() noexcept
  {
  return (-(max)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (2.2204460492503131e-016);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0.5L);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (4.9406564584124654e-324);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (__builtin_huge_val());
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (__builtin_nan("0"));
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (__builtin_nans("1"));
  }

 static constexpr int digits = (int)(53);
 static constexpr int digits10 = (int)(15);

 static constexpr int max_digits10 = (int)(2 + 53 * 301L / 1000);

 static constexpr int max_exponent = (int)((int)1024);
 static constexpr int max_exponent10 = (int)((int)308);
 static constexpr int min_exponent = (int)((int)(-1021));
 static constexpr int min_exponent10 = (int)((int)(-307));
 };
# 1481 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\limits" 3
}

#pragma warning(pop)
#pragma pack(pop)
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory0" 2 3

# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\new" 1 3





# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\exception" 1 3






# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\type_traits" 1 3







#pragma pack(push,8)
#pragma warning(push, 3)


#pragma warning(disable: 4180 4296)

namespace std {
template<class _Ty>
 struct _Is_memfunptr
 {
 typedef false_type _Bool_type;
 };
# 33 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\type_traits" 3
template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) > : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) > : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) > : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) > : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) > : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const > : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) const > : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) const > : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) const > : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const > : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile > : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) volatile > : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) volatile > : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) volatile > : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile > : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile > : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) const volatile > : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) const volatile > : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) const volatile > : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile > : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) &> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) &> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) &> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) &> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) &> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const &> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) const &> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) const &> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) const &> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const &> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile &> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) volatile &> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) volatile &> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) volatile &> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile &> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile &> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) const volatile &> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) const volatile &> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) const volatile &> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile &> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) &&> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) &&> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) &&> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) &&> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) &&> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const &&> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) const &&> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) const &&> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) const &&> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const &&> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile &&> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) volatile &&> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) volatile &&> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) volatile &&> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile &&> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile &&> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) const volatile &&> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) const volatile &&> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) const volatile &&> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile &&> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };
# 47 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\type_traits" 3
template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) &> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const &> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile &> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile &> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) &&> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const &&> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile &&> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile &&> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };



template<class _Ty>
 struct is_void
  : false_type
 {
 };
# 64 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\type_traits" 3
template<> struct is_void< void> : true_type { }; template<> struct is_void<const void> : true_type { }; template<> struct is_void<volatile void> : true_type { }; template<> struct is_void<const volatile void> : true_type { };




template<class _Ty>
 struct add_const
 {
 typedef const _Ty type;
 };


template<class _Ty>
 struct add_volatile
 {
 typedef volatile _Ty type;
 };


template<class _Ty>
 struct add_cv
 {
 typedef const volatile _Ty type;
 };


template<class _Ty,
 bool = _Is_function<_Ty>::_Weird || is_void<_Ty>::value>
 struct _Add_reference
 {
 typedef _Ty _Lvalue;
 typedef _Ty _Rvalue;
 };

template<class _Ty>
 struct _Add_reference<_Ty, false>
 {
 typedef _Ty& _Lvalue;
 typedef _Ty&& _Rvalue;
 };


template<class _Ty>
 struct add_lvalue_reference
 {
 typedef typename _Add_reference<_Ty>::_Lvalue type;
 };


template<class _Ty>
 struct add_rvalue_reference
 {
 typedef typename _Add_reference<_Ty>::_Rvalue type;
 };


template<class _Ty>
 typename add_rvalue_reference<_Ty>::type
  declval() noexcept;


template<class _Ty>
 struct remove_extent
 {
 typedef _Ty type;
 };

template<class _Ty, size_t _Ix>
 struct remove_extent<_Ty[_Ix]>
 {
 typedef _Ty type;
 };

template<class _Ty>
 struct remove_extent<_Ty[]>
 {
 typedef _Ty type;
 };


template<class _Ty>
 struct remove_all_extents
 {
 typedef _Ty type;
 };

template<class _Ty, size_t _Ix>
 struct remove_all_extents<_Ty[_Ix]>
 {
 typedef typename remove_all_extents<_Ty>::type type;
 };

template<class _Ty>
 struct remove_all_extents<_Ty[]>
 {
 typedef typename remove_all_extents<_Ty>::type type;
 };


template<class _Ty>
 struct remove_pointer
 {
 typedef _Ty type;
 };
# 176 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\type_traits" 3
template<class _Ty> struct remove_pointer<_Ty *> { typedef _Ty type; }; template<class _Ty> struct remove_pointer<_Ty *const> { typedef _Ty type; }; template<class _Ty> struct remove_pointer<_Ty *volatile> { typedef _Ty type; }; template<class _Ty> struct remove_pointer<_Ty *const volatile> { typedef _Ty type; };



template<class _Ty,
 bool = _Is_function<_Ty>::_Weird>
 struct _Add_pointer
 {
 typedef _Ty type;
 };

template<class _Ty>
 struct _Add_pointer<_Ty, false>
 {
 typedef typename remove_reference<_Ty>::type *type;
 };

template<class _Ty>
 struct add_pointer
 {
 typedef typename _Add_pointer<_Ty>::type type;
 };



template<class _Ty>
 struct is_array
  : false_type
 {
 };

template<class _Ty, size_t _Nx>
 struct is_array<_Ty[_Nx]>
  : true_type
 {
 };

template<class _Ty>
 struct is_array<_Ty[]>
  : true_type
 {
 };


template<class _Ty>
 struct is_lvalue_reference
  : false_type
 {
 };

template<class _Ty>
 struct is_lvalue_reference<_Ty&>
  : true_type
 {
 };


template<class _Ty>
 struct is_rvalue_reference
  : false_type
 {
 };

template<class _Ty>
 struct is_rvalue_reference<_Ty&&>
  : true_type
 {
 };


template<class _Ty>
 struct is_reference
  : _Cat_base<is_lvalue_reference<_Ty>::value
  || is_rvalue_reference<_Ty>::value>
 {
 };



template<class _Ty,
 bool _Pmf = _Is_memfunptr<_Ty>::_Bool_type::value>
 struct _Is_member_object_pointer
  : false_type
 {
 };

template<class _Ty1,
 class _Ty2>
 struct _Is_member_object_pointer<_Ty1 _Ty2::*, false>
  : true_type
 {
 typedef _Ty2 _Class_type;
 };

template<class _Ty>
 struct is_member_object_pointer
  : _Is_member_object_pointer<typename remove_cv<_Ty>::type>::type
 {
 };


template<class _Ty>
 struct is_member_function_pointer
  : _Is_memfunptr<typename remove_cv<_Ty>::type>::_Bool_type
 {
 };


template<class _Ty>
 struct _Is_pointer
  : false_type
 {
 };

template<class _Ty>
 struct _Is_pointer<_Ty *>
  : _Cat_base<!is_member_object_pointer<_Ty *>::value
  && !is_member_function_pointer<_Ty *>::value>
 {
 };

template<class _Ty>
 struct is_pointer
  : _Is_pointer<typename remove_cv<_Ty>::type>
 {
 };



template<class _Ty>
 struct is_null_pointer
  : _Cat_base<is_same<typename remove_cv<_Ty>::type, nullptr_t>::value>
 {
 };


template<class _Ty>
 struct is_union
  : _Cat_base<__is_union(_Ty)>
 {
 };


template<class _Ty>
 struct is_class
  : _Cat_base<__is_class(_Ty)>
 {
 };


template<class _Ty>
 struct is_fundamental
  : _Cat_base<is_arithmetic<_Ty>::value
  || is_void<_Ty>::value
  || is_null_pointer<_Ty>::value>
 {
 };


template<class _Ty>
 struct is_object
  : _Cat_base<!is_function<_Ty>::value
  && !is_reference<_Ty>::value
  && !is_void<_Ty>::value>
 {
 };



template<class _From,
 class _To>
 struct is_convertible
  : _Cat_base<__is_convertible_to(_From, _To)>
 {
 };


template<class _Ty>
 struct is_enum
  : _Cat_base<__is_enum(_Ty)>
 {
 };


template<class _Ty>
 struct is_compound
  : _Cat_base<!is_fundamental<_Ty>::value>
 {
 };


template<class _Ty>
 struct is_member_pointer
  : _Cat_base<is_member_object_pointer<_Ty>::value
  || is_member_function_pointer<_Ty>::value>
 {
 };


template<class _Ty>
 struct is_scalar
  : _Cat_base<is_arithmetic<_Ty>::value
  || is_enum<_Ty>::value
  || is_pointer<_Ty>::value
  || is_member_pointer<_Ty>::value
  || is_null_pointer<_Ty>::value>
 {
 };


template<class _Ty>
 struct is_const
  : false_type
 {
 };

template<class _Ty>
 struct is_const<const _Ty>
  : true_type
 {
 };


template<class _Ty>
 struct is_volatile
  : false_type
 {
 };

template<class _Ty>
 struct is_volatile<volatile _Ty>
  : true_type
 {
 };


template<class _Ty>
 struct is_pod
  : _Cat_base<__is_pod(_Ty)>
 {
 };


template<class _Ty>
 struct is_empty
  : _Cat_base<__is_empty(_Ty)>
 {
 };


template<class _Ty>
 struct is_polymorphic
  : _Cat_base<__is_polymorphic(_Ty)>
 {
 };


template<class _Ty>
 struct is_abstract
  : _Cat_base<__is_abstract(_Ty)>
 {
 };


template<class _Ty>
 struct is_final
  : _Cat_base<__is_final(_Ty)>
 {
 };


template<class _Ty>
 struct is_standard_layout
  : _Cat_base<__is_standard_layout(_Ty)>
 {
 };


template<class _Ty>
 struct is_literal_type
  : _Cat_base<__is_literal_type(_Ty)>
 {
 };


template<class _Ty>
 struct is_trivial
  : _Cat_base<__is_trivial(_Ty)>
 {
 };


template<class _Ty>
 struct is_trivially_copyable
  : _Cat_base<__is_trivially_copyable(_Ty)>
 {
 };


template<class _Ty>
 struct has_virtual_destructor
  : _Cat_base<__has_virtual_destructor(_Ty)>
 {
 };




template<class _Ty,
 class... _Args>
 struct is_constructible
  : _Cat_base<__is_constructible(_Ty, _Args...)>
 {
 };


template<class _Ty>
 struct is_copy_constructible
  : is_constructible<
   _Ty,
   typename add_lvalue_reference<
    typename add_const<_Ty>::type
   >::type
  >::type
 {
 };


template<class _Ty>
 struct is_default_constructible
  : is_constructible<_Ty>::type
 {
 };


template<class _Ty>
 struct is_move_constructible
  : is_constructible<
   _Ty,
   typename add_rvalue_reference<_Ty>::type
  >::type
 {
 };


template<class _To,
 class _From>
 struct is_assignable
  : integral_constant<bool, __is_assignable(_To, _From)>
 {
 };


template<class _Ty>
 struct is_copy_assignable
  : is_assignable<
   typename add_lvalue_reference<_Ty>::type,
   typename add_lvalue_reference<
    typename add_const<_Ty>::type
   >::type
  >::type
 {
 };


template<class _Ty>
 struct is_move_assignable
  : is_assignable<
   typename add_lvalue_reference<_Ty>::type,
   typename add_rvalue_reference<_Ty>::type
  >::type
 {
 };


template<class _Ty>
 struct is_destructible
  : _Cat_base<__is_destructible(_Ty)>
 {
 };




template<class _Ty,
 class... _Args>
 struct is_trivially_constructible
  : _Cat_base<__is_trivially_constructible(_Ty, _Args...)>
 {
 };


template<class _Ty>
 struct is_trivially_copy_constructible
  : is_trivially_constructible<
   _Ty,
   typename add_lvalue_reference<
    typename add_const<_Ty>::type
   >::type
  >::type
 {
 };


template<class _Ty>
 struct is_trivially_default_constructible
  : is_trivially_constructible<_Ty>::type
 {
 };


template<class _Ty>
 struct is_trivially_move_constructible
  : is_trivially_constructible<
   _Ty,
   typename add_rvalue_reference<_Ty>::type
  >::type
 {
 };


template<class _To,
 class _From>
 struct is_trivially_assignable
  : _Cat_base<__is_trivially_assignable(_To, _From)>
 {
 };


template<class _Ty>
 struct is_trivially_copy_assignable
  : is_trivially_assignable<
   typename add_lvalue_reference<_Ty>::type,
   typename add_lvalue_reference<
    typename add_const<_Ty>::type
   >::type
  >::type
 {
 };


template<class _Ty>
 struct is_trivially_move_assignable
  : is_trivially_assignable<
   typename add_lvalue_reference<_Ty>::type,
   typename add_rvalue_reference<_Ty>::type
  >::type
 {
 };


template<class _Ty>
 struct is_trivially_destructible
  : _Cat_base<__has_trivial_destructor(_Ty)>
 {
 };




template<class _Ty,
 class... _Args>
 struct is_nothrow_constructible
  : _Cat_base<__is_nothrow_constructible(_Ty, _Args...)>
 {
 };


template<class _Ty>
 struct is_nothrow_copy_constructible
  : is_nothrow_constructible<
   _Ty,
   typename add_lvalue_reference<
    typename add_const<_Ty>::type
   >::type
  >::type
 {
 };


template<class _Ty>
 struct is_nothrow_default_constructible
  : is_nothrow_constructible<_Ty>::type
 {
 };


template<class _Ty>
 struct is_nothrow_move_constructible
  : is_nothrow_constructible<
   _Ty,
   typename add_rvalue_reference<_Ty>::type
  >::type
 {
 };


template<class _To,
 class _From>
 struct is_nothrow_assignable
  : _Cat_base<__is_nothrow_assignable(_To, _From)>
 {
 };


template<class _Ty>
 struct is_nothrow_copy_assignable
  : is_nothrow_assignable<
   typename add_lvalue_reference<_Ty>::type,
   typename add_lvalue_reference<
    typename add_const<_Ty>::type
   >::type
  >::type
 {
 };


template<class _Ty>
 struct is_nothrow_move_assignable
  : is_nothrow_assignable<
   typename add_lvalue_reference<_Ty>::type,
   typename add_rvalue_reference<_Ty>::type
  >::type
 {
 };


template<class _Ty>
 struct is_nothrow_destructible
  : _Cat_base<__is_nothrow_destructible(_Ty)>
 {
 };


template<class _Ty,
 bool = is_integral<_Ty>::value>
 struct _Sign_base
 {
 typedef typename remove_cv<_Ty>::type _Uty;
 typedef _Cat_base<_Uty(-1) < _Uty(0)> _Signed;
 typedef _Cat_base<_Uty(0) < _Uty(-1)> _Unsigned;
 };

template<class _Ty>
 struct _Sign_base<_Ty, false>
 {

 typedef is_floating_point<_Ty> _Signed;
 typedef false_type _Unsigned;
 };

template<class _Ty>
 struct is_signed
  : _Sign_base<_Ty>::_Signed
 {
 };


template<class _Ty>
 struct is_unsigned
  : _Sign_base<_Ty>::_Unsigned
 {
 };


template<class _Ty>
 struct _Change_sign
 {
 static_assert(
  ((is_integral<_Ty>::value || is_enum<_Ty>::value)
   && !is_same<_Ty, bool>::value),
  "make_signed<T>/make_unsigned<T> require that T shall be a (possibly "
  "cv-qualified) integral type or enumeration but not a bool type.");

 typedef
  typename _If<is_same<_Ty, signed char>::value
   || is_same<_Ty, unsigned char >::value, signed char,
  typename _If<is_same<_Ty, short >::value
   || is_same<_Ty, unsigned short >::value, short,
  typename _If<is_same<_Ty, int >::value
   || is_same<_Ty, unsigned int >::value, int,
  typename _If<is_same<_Ty, long >::value
   || is_same<_Ty, unsigned long >::value, long,
  typename _If<is_same<_Ty, long long >::value
   || is_same<_Ty, unsigned long long>::value, long long,
  typename _If<sizeof (_Ty) == sizeof (signed char), signed char,
  typename _If<sizeof (_Ty) == sizeof (short ), short,
  typename _If<sizeof (_Ty) == sizeof (int ), int,
  typename _If<sizeof (_Ty) == sizeof (long ), long,
   long long
  >::type>::type>::type>::type>::type>::type>::type>::type>::type
   _Signed;

 typedef
  typename _If<is_same<_Signed, signed char>::value, unsigned char,
  typename _If<is_same<_Signed, short >::value, unsigned short,
  typename _If<is_same<_Signed, int >::value, unsigned int,
  typename _If<is_same<_Signed, long >::value, unsigned long,
   unsigned long long
  >::type>::type>::type>::type
   _Unsigned;
 };

template<class _Ty>
 struct _Change_sign<const _Ty>
 {
 typedef const typename _Change_sign<_Ty>::_Signed _Signed;
 typedef const typename _Change_sign<_Ty>::_Unsigned _Unsigned;
 };

template<class _Ty>
 struct _Change_sign<volatile _Ty>
 {
 typedef volatile typename _Change_sign<_Ty>::_Signed _Signed;
 typedef volatile typename _Change_sign<_Ty>::_Unsigned _Unsigned;
 };

template<class _Ty>
 struct _Change_sign<const volatile _Ty>
 {
 typedef const volatile typename _Change_sign<_Ty>::_Signed _Signed;
 typedef const volatile typename _Change_sign<_Ty>::_Unsigned _Unsigned;
 };


template<class _Ty>
 struct make_signed
 {
 typedef typename _Change_sign<_Ty>::_Signed type;
 };


template<class _Ty>
 struct make_unsigned
 {
 typedef typename _Change_sign<_Ty>::_Unsigned type;
 };



template<class _Ty>
 struct alignment_of
  : integral_constant<size_t, alignof(_Ty)>
 {
 };






template<class _Ty,
 size_t _Len>
 union _Align_type
 {
 _Ty _Val;
 char _Pad[_Len];
 };

template<size_t _Len,
 size_t _Align,
 class _Ty,
 bool _Ok>
 struct _Aligned;

template<size_t _Len,
 size_t _Align,
 class _Ty>
 struct _Aligned<_Len, _Align, _Ty, true>
 {
 typedef _Align_type<_Ty, _Len> type;
 };

template<size_t _Len,
 size_t _Align>
 struct _Aligned<_Len, _Align, double, false>
 {
 typedef _Align_type<max_align_t, _Len> type;
 };

template<size_t _Len,
 size_t _Align>
 struct _Aligned<_Len, _Align, int, false>
 {
 typedef typename _Aligned<_Len, _Align, double, _Align <= alignment_of<double>::value>::type type;
 };

template<size_t _Len,
 size_t _Align>
 struct _Aligned<_Len, _Align, short, false>
 {
 typedef typename _Aligned<_Len, _Align, int, _Align <= alignment_of<int>::value>::type type;
 };

template<size_t _Len,
 size_t _Align>
 struct _Aligned<_Len, _Align, char, false>
 {
 typedef typename _Aligned<_Len, _Align, short, _Align <= alignment_of<short>::value>::type type;
 };

template<size_t _Len,
 size_t _Align = alignment_of<max_align_t>::value>
 struct aligned_storage
 {
 typedef typename _Aligned<_Len, _Align, char, _Align <= alignment_of<char>::value>::type type;
 };





template<size_t... _Vals>
 struct _Maximum;

template<>
 struct _Maximum<>
 {
 static constexpr size_t value = 0;
 };

template<size_t _Val>
 struct _Maximum<_Val>
 {
 static constexpr size_t value = _Val;
 };

template<size_t _First,
 size_t _Second,
 size_t... _Rest>
 struct _Maximum<_First, _Second, _Rest...>
  : _Maximum<(_First < _Second ? _Second : _First), _Rest...>
 {
 };

template<size_t _Len,
 class... _Types>
 struct aligned_union
 {
 static constexpr size_t _Max_len = _Maximum<
  _Len, sizeof(_Types)...>::value;
 static constexpr size_t alignment_value = _Maximum<
  alignment_of<_Types>::value...>::value;
 typedef typename aligned_storage<_Max_len, alignment_value>::type type;
 };


template<class _Ty>
 struct underlying_type
 {
 typedef __underlying_type(_Ty) type;
 };


template<class _Ty>
 struct rank
  : integral_constant<size_t, 0>
 {
 };

template<class _Ty, size_t _Ix>
 struct rank<_Ty[_Ix]>
  : integral_constant<size_t, rank<_Ty>::value + 1>
 {
 };

template<class _Ty>
 struct rank<_Ty[]>
  : integral_constant<size_t, rank<_Ty>::value + 1>
 {
 };


template<class _Ty, unsigned int _Nx>
 struct _Extent
  : integral_constant<size_t, 0>
 {
 };

template<class _Ty, size_t _Ix>
 struct _Extent<_Ty[_Ix], 0>
  : integral_constant<size_t, _Ix>
 {
 };

template<class _Ty, unsigned int _Nx, size_t _Ix>
 struct _Extent<_Ty[_Ix], _Nx>
  : _Extent<_Ty, _Nx - 1>
 {
 };

template<class _Ty, unsigned int _Nx>
 struct _Extent<_Ty[], _Nx>
  : _Extent<_Ty, _Nx - 1>
 {
 };

template<class _Ty, unsigned int _Nx = 0>
 struct extent
  : _Extent<_Ty, _Nx>
 {
 };


template<class _Base,
 class _Der>
 struct is_base_of
  : _Cat_base<__is_base_of(_Base, _Der)>
 {
 };


template<class _Ty>
 struct decay
 {
 typedef typename remove_reference<_Ty>::type _Ty1;

 typedef typename _If<is_array<_Ty1>::value,
  typename remove_extent<_Ty1>::type *,
  typename _If<is_function<_Ty1>::value,
   typename add_pointer<_Ty1>::type,
   typename remove_cv<_Ty1>::type>::type>::type type;
 };


template<class...>
 struct _Conjunction;

template<bool,
 class _Lhs,
 class... _Traits>
 struct _Choose_conjunction
 {
 typedef _Lhs type;
 };

template<class _Lhs,
 class... _Traits>
 struct _Choose_conjunction<true, _Lhs, _Traits...>
 {
 typedef typename _Conjunction<_Traits...>::type type;
 };

template<>
 struct _Conjunction<>
 {
 typedef true_type type;
 };

template<class _Trait>
 struct _Conjunction<_Trait>
 {
 typedef _Trait type;
 };

template<class _Lhs,
 class... _Traits>
 struct _Conjunction<_Lhs, _Traits...>
 {
 typedef typename _Choose_conjunction<_Lhs::value, _Lhs, _Traits...>::type type;
 };

template<class... _Traits>
 struct conjunction
  : _Conjunction<_Traits...>::type
 {


 };


template<class...>
 struct _Disjunction;

template<bool,
 class _Lhs,
 class... _Traits>
 struct _Choose_disjunction
 {
 typedef _Lhs type;
 };

template<class _Lhs,
 class... _Traits>
 struct _Choose_disjunction<false, _Lhs, _Traits...>
 {
 typedef typename _Disjunction<_Traits...>::type type;
 };

template<>
 struct _Disjunction<>
 {
 typedef false_type type;
 };

template<class _Trait>
 struct _Disjunction<_Trait>
 {
 typedef _Trait type;
 };

template<class _Lhs,
 class... _Traits>
 struct _Disjunction<_Lhs, _Traits...>
 {
 typedef typename _Choose_disjunction<_Lhs::value, _Lhs, _Traits...>::type type;
 };

template<class... _Traits>
 struct disjunction
  : _Disjunction<_Traits...>::type
 {


 };


template<class _Trait>
 struct negation
  : bool_constant<!_Trait::value>
 {
 };


namespace tr1 {
using ::std:: add_const;
using ::std:: add_cv;
using ::std:: add_pointer;
using ::std:: add_volatile;
using ::std:: aligned_storage;
using ::std:: alignment_of;
using ::std:: conditional;
using ::std:: decay;
using ::std:: enable_if;
using ::std:: extent;
using ::std:: false_type;
using ::std:: has_virtual_destructor;
using ::std:: integral_constant;
using ::std:: is_abstract;
using ::std:: is_arithmetic;
using ::std:: is_array;
using ::std:: is_base_of;
using ::std:: is_class;
using ::std:: is_compound;
using ::std:: is_const;
using ::std:: is_convertible;
using ::std:: is_empty;
using ::std:: is_enum;
using ::std:: is_floating_point;
using ::std:: is_function;
using ::std:: is_fundamental;
using ::std:: is_integral;
using ::std:: is_member_function_pointer;
using ::std:: is_member_object_pointer;
using ::std:: is_member_pointer;
using ::std:: is_object;
using ::std:: is_pod;
using ::std:: is_pointer;
using ::std:: is_polymorphic;
using ::std:: is_reference;
using ::std:: is_same;
using ::std:: is_scalar;
using ::std:: is_signed;
using ::std:: is_union;
using ::std:: is_unsigned;
using ::std:: is_void;
using ::std:: is_volatile;
using ::std:: make_signed;
using ::std:: make_unsigned;
using ::std:: rank;
using ::std:: remove_all_extents;
using ::std:: remove_const;
using ::std:: remove_cv;
using ::std:: remove_extent;
using ::std:: remove_pointer;
using ::std:: remove_reference;
using ::std:: remove_volatile;
using ::std:: true_type;
 }



template<class... _Ty>
 struct common_type;

template<class _Ty>
 struct common_type<_Ty>
 {
 typedef typename decay<_Ty>::type type;
 };

template<class _Ty0,
 class _Ty1>
 struct common_type<_Ty0, _Ty1>
 {
 typedef typename decay<
  decltype(_Always_false<_Ty0>::value
   ? ::std:: declval<_Ty0>()
   : ::std:: declval<_Ty1>())
 >::type type;
 };

template<class _Ty0,
 class _Ty1,
 class... _Ty>
 struct common_type<_Ty0, _Ty1, _Ty...>
 {
 typedef typename common_type<
  typename common_type<_Ty0, _Ty1>::type, _Ty...
 >::type type;
 };


template<class _Ty,
 _Ty... _Vals>
 struct integer_sequence
 {
 static_assert(is_integral<_Ty>::value,
  "integer_sequence<T, I...> requires T to be an integral type.");

 typedef integer_sequence<_Ty, _Vals...> type;
 typedef _Ty value_type;

 static constexpr size_t size() noexcept
  {
  return (sizeof...(_Vals));
  }
 };
# 1243 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\type_traits" 3
template<class _Ty,
 _Ty _Size>
 using make_integer_sequence = __make_integer_seq<integer_sequence, _Ty, _Size>;


template<size_t... _Vals>
 using index_sequence = integer_sequence<size_t, _Vals...>;

template<size_t _Size>
 using make_index_sequence = make_integer_sequence<size_t, _Size>;

template<class... _Types>
 using index_sequence_for = make_index_sequence<sizeof...(_Types)>;



template<class _Ty>
 struct identity
 {
 typedef _Ty type;

 const _Ty& operator()(const _Ty& _Left) const
  {
  return (_Left);
  }
 };



template<class _Ty> inline
 constexpr _Ty&& forward(
  typename remove_reference<_Ty>::type& _Arg) noexcept
 {
 return (static_cast<_Ty&&>(_Arg));
 }

template<class _Ty> inline
 constexpr _Ty&& forward(
  typename remove_reference<_Ty>::type&& _Arg) noexcept
 {
 static_assert(!is_lvalue_reference<_Ty>::value, "bad forward call");
 return (static_cast<_Ty&&>(_Arg));
 }


template<class _Ty> inline
 constexpr typename remove_reference<_Ty>::type&&
  move(_Ty&& _Arg) noexcept
 {
 return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));
 }


template<class _Ty> inline
 constexpr typename _If<!is_nothrow_move_constructible<_Ty>::value
  && is_copy_constructible<_Ty>::value,
   const _Ty&, _Ty&&>::type
 move_if_noexcept(_Ty& _Arg) noexcept
 {
 return (::std:: move(_Arg));
 }


template<class...>
 struct _Param_tester
 {
 typedef void type;
 };


template<class... _Types>
 using void_t = typename _Param_tester<_Types...>::type;


struct _Invoker_pmf_object
 {
 template<class _Decayed,
  class _Ty1,
  class... _Types2>
  static auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2)
  -> decltype((::std:: forward<_Ty1>(_Arg1).*_Pmf)(
   ::std:: forward<_Types2>(_Args2)...))
  {
  return ((::std:: forward<_Ty1>(_Arg1).*_Pmf)(
   ::std:: forward<_Types2>(_Args2)...));
  }
 };

struct _Invoker_pmf_pointer
 {
 template<class _Decayed,
  class _Ty1,
  class... _Types2>
  static auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2)
  -> decltype(((*::std:: forward<_Ty1>(_Arg1)).*_Pmf)(
   ::std:: forward<_Types2>(_Args2)...))
  {
  return (((*::std:: forward<_Ty1>(_Arg1)).*_Pmf)(
   ::std:: forward<_Types2>(_Args2)...));
  }
 };

struct _Invoker_pmd_object
 {
 template<class _Decayed,
  class _Ty1>
  static auto _Call(_Decayed _Pmd, _Ty1&& _Arg1)
  -> decltype(::std:: forward<_Ty1>(_Arg1).*_Pmd)
  {
  return (::std:: forward<_Ty1>(_Arg1).*_Pmd);
  }
 };

struct _Invoker_pmd_pointer
 {
 template<class _Decayed,
  class _Ty1>
  static auto _Call(_Decayed _Pmd, _Ty1&& _Arg1)
  -> decltype((*::std:: forward<_Ty1>(_Arg1)).*_Pmd)
  {
  return ((*::std:: forward<_Ty1>(_Arg1)).*_Pmd);
  }
 };

struct _Invoker_functor
 {
 template<class _Callable,
  class... _Types>
  static auto _Call(_Callable&& _Obj, _Types&&... _Args)
  -> decltype(::std:: forward<_Callable>(_Obj)(
   ::std:: forward<_Types>(_Args)...))
  {
  return (::std:: forward<_Callable>(_Obj)(
   ::std:: forward<_Types>(_Args)...));
  }
 };

template<class _Callable,
 class _Ty1,
 class _Decayed = typename decay<_Callable>::type,
 bool _Is_pmf = is_member_function_pointer<_Decayed>::value,
 bool _Is_pmd = is_member_object_pointer<_Decayed>::value>
 struct _Invoker1;

template<class _Callable,
 class _Ty1,
 class _Decayed>
 struct _Invoker1<_Callable, _Ty1, _Decayed, true, false>
  : _If<is_base_of<
   typename _Is_memfunptr<_Decayed>::_Class_type,
   typename decay<_Ty1>::type>::value,
  _Invoker_pmf_object,
  _Invoker_pmf_pointer>::type
 {
 };

template<class _Callable,
 class _Ty1,
 class _Decayed>
 struct _Invoker1<_Callable, _Ty1, _Decayed, false, true>
  : _If<is_base_of<
   typename _Is_member_object_pointer<_Decayed>::_Class_type,
   typename decay<_Ty1>::type>::value,
  _Invoker_pmd_object,
  _Invoker_pmd_pointer>::type
 {
 };

template<class _Callable,
 class _Ty1,
 class _Decayed>
 struct _Invoker1<_Callable, _Ty1, _Decayed, false, false>
  : _Invoker_functor
 {
 };

template<class _Callable,
 class... _Types>
 struct _Invoker;

template<class _Callable>
 struct _Invoker<_Callable>
  : _Invoker_functor
 {
 };

template<class _Callable,
 class _Ty1,
 class... _Types2>
 struct _Invoker<_Callable, _Ty1, _Types2...>
  : _Invoker1<_Callable, _Ty1>
 {
 };

template<class _Callable,
 class... _Types> inline
 auto invoke(_Callable&& _Obj, _Types&&... _Args)
 -> decltype(_Invoker<_Callable, _Types...>::_Call(
  ::std:: forward<_Callable>(_Obj), ::std:: forward<_Types>(_Args)...))
 {
 return (_Invoker<_Callable, _Types...>::_Call(
  ::std:: forward<_Callable>(_Obj), ::std:: forward<_Types>(_Args)...));
 }

template<class _Rx,
 bool = is_void<_Rx>::value>
 struct _Forced
 {
 };

struct _Unforced
 {
 };

template<class _Cv_void,
 class... _Valtys> inline
 void _Invoke_ret(_Forced<_Cv_void, true>, _Valtys&&... _Vals)
 {
 ::std:: invoke(::std:: forward<_Valtys>(_Vals)...);
 }

template<class _Rx,
 class... _Valtys> inline
 _Rx _Invoke_ret(_Forced<_Rx, false>, _Valtys&&... _Vals)
 {
 return (::std:: invoke(::std:: forward<_Valtys>(_Vals)...));
 }

template<class... _Valtys> inline
 auto _Invoke_ret(_Forced<_Unforced, false>, _Valtys&&... _Vals)
 -> decltype(::std:: invoke(::std:: forward<_Valtys>(_Vals)...))
 {
 return (::std:: invoke(::std:: forward<_Valtys>(_Vals)...));
 }


struct _Unique_tag_result_of
 {
 };

template<class _Void,
 class... _Types>
 struct _Result_of
 {
 };

template<class... _Types>
 struct _Result_of<
  void_t<
   _Unique_tag_result_of,
   decltype(::std:: invoke(::std:: declval<_Types>()...))>,
  _Types...>
 {
 typedef decltype(::std:: invoke(::std:: declval<_Types>()...)) type;
 };

template<class _Fty>
 struct result_of
 {
 static_assert(_Always_false<_Fty>::value,
  "result_of<CallableType> is invalid; use "
  "result_of<CallableType(zero or more argument types)> instead.");
 };
# 1515 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\type_traits" 3
template<class _Fty, class... _Args> struct result_of<_Fty __cdecl (_Args...)> : _Result_of<void, _Fty, _Args...> { }; template<class _Fty, class... _Args> struct result_of<_Fty __fastcall (_Args...)> : _Result_of<void, _Fty, _Args...> { }; template<class _Fty, class... _Args> struct result_of<_Fty __stdcall (_Args...)> : _Result_of<void, _Fty, _Args...> { }; template<class _Fty, class... _Args> struct result_of<_Fty __vectorcall (_Args...)> : _Result_of<void, _Fty, _Args...> { };



template<class _Ty,
 class = void>
 struct _Weak_result_type
 {
 };

template<class _Ty>
 struct _Weak_result_type<_Ty, void_t<
  typename _Ty::result_type> >
 {
 typedef typename _Ty::result_type result_type;
 };

template<class _Ty,
 class = void>
 struct _Weak_argument_type
  : _Weak_result_type<_Ty>
 {
 };

template<class _Ty>
 struct _Weak_argument_type<_Ty, void_t<
  typename _Ty::argument_type> >
  : _Weak_result_type<_Ty>
 {
 typedef typename _Ty::argument_type argument_type;
 };

template<class _Ty,
 class = void>
 struct _Weak_binary_args
  : _Weak_argument_type<_Ty>
 {
 };

template<class _Ty>
 struct _Weak_binary_args<_Ty, void_t<
  typename _Ty::first_argument_type,
  typename _Ty::second_argument_type> >
  : _Weak_argument_type<_Ty>
 {
 typedef typename _Ty::first_argument_type first_argument_type;
 typedef typename _Ty::second_argument_type second_argument_type;
 };

template<class _Ty>
 struct _Weak_types
 {
 typedef _Is_function<typename remove_pointer<_Ty>::type> _Is_f_or_pf;
 typedef _Is_memfunptr<typename remove_cv<_Ty>::type> _Is_pmf;
 typedef typename _If<_Is_f_or_pf::_Bool_type::value, _Is_f_or_pf,
  typename _If<_Is_pmf::_Bool_type::value, _Is_pmf,
  _Weak_binary_args<_Ty> >::type>::type type;
 };


template<class _Ty>
 class reference_wrapper
  : public _Weak_types<_Ty>::type
 {
public:
 static_assert(is_object<_Ty>::value || is_function<_Ty>::value,
  "reference_wrapper<T> requires T to be an object type "
  "or a function type.");

 typedef _Ty type;

 reference_wrapper(_Ty& _Val) noexcept
  : _Ptr(::std:: addressof(_Val))
  {
  }

 operator _Ty&() const noexcept
  {
  return (*_Ptr);
  }

 _Ty& get() const noexcept
  {
  return (*_Ptr);
  }

 template<class... _Types>
  auto operator()(_Types&&... _Args) const
  -> decltype(::std:: invoke(get(), ::std:: forward<_Types>(_Args)...))
  {
  return (::std:: invoke(get(), ::std:: forward<_Types>(_Args)...));
  }

 reference_wrapper(_Ty&&) = delete;

private:
 _Ty *_Ptr;
 };


template<class _Ty> inline
 reference_wrapper<_Ty>
  ref(_Ty& _Val) noexcept
 {
 return (reference_wrapper<_Ty>(_Val));
 }

template<class _Ty>
 void ref(const _Ty&&) = delete;

template<class _Ty> inline
 reference_wrapper<_Ty>
  ref(reference_wrapper<_Ty> _Val) noexcept
 {
 return (::std:: ref(_Val.get()));
 }

template<class _Ty> inline
 reference_wrapper<const _Ty>
  cref(const _Ty& _Val) noexcept
 {
 return (reference_wrapper<const _Ty>(_Val));
 }

template<class _Ty>
 void cref(const _Ty&&) = delete;

template<class _Ty> inline
 reference_wrapper<const _Ty>
  cref(reference_wrapper<_Ty> _Val) noexcept
 {
 return (::std:: cref(_Val.get()));
 }


template<class _Ty>
 struct _Unrefwrap_helper
 {
 typedef _Ty type;
 static constexpr bool _Is_refwrap = false;
 };

template<class _Ty>
 struct _Unrefwrap_helper<reference_wrapper<_Ty> >
 {
 typedef _Ty& type;
 static constexpr bool _Is_refwrap = true;
 };

template<class _Ty>
 struct _Unrefwrap
 {
 typedef typename decay<_Ty>::type _Ty1;
 typedef typename _Unrefwrap_helper<_Ty1>::type type;
 static constexpr bool _Is_refwrap = _Unrefwrap_helper<_Ty1>::_Is_refwrap;
 };


namespace tr1 {
using ::std:: cref;
using ::std:: ref;
using ::std:: reference_wrapper;
using ::std:: result_of;
 }



template<class _Ty>
 struct _Is_swappable;


template<class _Ty>
 struct _Is_nothrow_swappable;







template<class _Ty,
 class = void> inline

 void swap(_Ty&, _Ty&)
  noexcept(is_nothrow_move_constructible<_Ty>::value && is_nothrow_move_assignable<_Ty>::value);


template<class _Ty,
 size_t _Size,
 class = typename enable_if<_Is_swappable<_Ty>::value>::type> inline
 void swap(_Ty (&)[_Size], _Ty (&)[_Size])
  noexcept(_Is_nothrow_swappable<_Ty>::value);


template<class _Ty1,
 class _Ty2,
 class = void>
 struct _Swappable_with_helper
  : false_type
 {
 };

struct _Swappable_with_helper_unique_type {};
template<class _Ty1,
 class _Ty2>
 struct _Swappable_with_helper<_Ty1, _Ty2, void_t<
  _Swappable_with_helper_unique_type,
  decltype(swap(::std:: declval<_Ty1>(), ::std:: declval<_Ty2>()))>>
  : true_type
 {
 };


template<class _Ty1,
 class _Ty2>
 struct _Is_swappable_with
  : conjunction<
   _Swappable_with_helper<_Ty1, _Ty2>,
   _Swappable_with_helper<_Ty2, _Ty1>>::type
 {

 };


template<class _Ty>
 struct _Is_swappable
  : _Is_swappable_with<
   typename add_lvalue_reference<_Ty>::type,
   typename add_lvalue_reference<_Ty>::type>::type
 {
 };


template<class _Ty1,
 class _Ty2>
 struct _Swap_cannot_throw
 {



 static constexpr bool value =
  noexcept(swap(::std:: declval<_Ty1>(), ::std:: declval<_Ty2>()))
  && noexcept(swap(::std:: declval<_Ty2>(), ::std:: declval<_Ty1>()));



 using type = bool_constant<value>;
 };


template<class _Ty1,
 class _Ty2>
 struct _Is_nothrow_swappable_with
  : conjunction<
   _Is_swappable_with<_Ty1, _Ty2>,
   _Swap_cannot_throw<_Ty1, _Ty2>>::type
 {

 };


template<class _Ty>
 struct _Is_nothrow_swappable
  : _Is_nothrow_swappable_with<
   typename add_lvalue_reference<_Ty>::type,
   typename add_lvalue_reference<_Ty>::type>::type
 {
 };
# 1819 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\type_traits" 3
template<class _Ty>
 using remove_const_t = typename remove_const<_Ty>::type;

template<class _Ty>
 using remove_volatile_t = typename remove_volatile<_Ty>::type;

template<class _Ty>
 using remove_cv_t = typename remove_cv<_Ty>::type;

template<class _Ty>
 using add_const_t = typename add_const<_Ty>::type;

template<class _Ty>
 using add_volatile_t = typename add_volatile<_Ty>::type;

template<class _Ty>
 using add_cv_t = typename add_cv<_Ty>::type;

template<class _Ty>
 using remove_reference_t = typename remove_reference<_Ty>::type;

template<class _Ty>
 using add_lvalue_reference_t = typename add_lvalue_reference<_Ty>::type;

template<class _Ty>
 using add_rvalue_reference_t = typename add_rvalue_reference<_Ty>::type;

template<class _Ty>
 using make_signed_t = typename make_signed<_Ty>::type;

template<class _Ty>
 using make_unsigned_t = typename make_unsigned<_Ty>::type;

template<class _Ty>
 using remove_extent_t = typename remove_extent<_Ty>::type;

template<class _Ty>
 using remove_all_extents_t = typename remove_all_extents<_Ty>::type;

template<class _Ty>
 using remove_pointer_t = typename remove_pointer<_Ty>::type;

template<class _Ty>
 using add_pointer_t = typename add_pointer<_Ty>::type;

template<size_t _Len,
 size_t _Align = alignment_of<max_align_t>::value>
 using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;

template<size_t _Len,
 class... _Types>
 using aligned_union_t = typename aligned_union<_Len, _Types...>::type;

template<class _Ty>
 using decay_t = typename decay<_Ty>::type;

template<bool _Test,
 class _Ty = void>
 using enable_if_t = typename enable_if<_Test, _Ty>::type;

template<bool _Test,
 class _Ty1,
 class _Ty2>
 using conditional_t = typename conditional<_Test, _Ty1, _Ty2>::type;

template<class... _Ty>
 using common_type_t = typename common_type<_Ty...>::type;

template<class _Ty>
 using underlying_type_t = typename underlying_type<_Ty>::type;

template<class _Ty>
 using result_of_t = typename result_of<_Ty>::type;



template<class _Ty>
 constexpr bool is_void_v = is_void<_Ty>::value;
template<class _Ty>
 constexpr bool is_null_pointer_v = is_null_pointer<_Ty>::value;
template<class _Ty>
 constexpr bool is_array_v = is_array<_Ty>::value;
template<class _Ty>
 constexpr bool is_pointer_v = is_pointer<_Ty>::value;
template<class _Ty>
 constexpr bool is_lvalue_reference_v = is_lvalue_reference<_Ty>::value;
template<class _Ty>
 constexpr bool is_rvalue_reference_v = is_rvalue_reference<_Ty>::value;
template<class _Ty>
 constexpr bool is_member_object_pointer_v = is_member_object_pointer<_Ty>::value;
template<class _Ty>
 constexpr bool is_member_function_pointer_v = is_member_function_pointer<_Ty>::value;
template<class _Ty>
 constexpr bool is_enum_v = is_enum<_Ty>::value;
template<class _Ty>
 constexpr bool is_union_v = is_union<_Ty>::value;
template<class _Ty>
 constexpr bool is_class_v = is_class<_Ty>::value;
template<class _Ty>
 constexpr bool is_reference_v = is_reference<_Ty>::value;
template<class _Ty>
 constexpr bool is_fundamental_v = is_fundamental<_Ty>::value;
template<class _Ty>
 constexpr bool is_object_v = is_object<_Ty>::value;
template<class _Ty>
 constexpr bool is_scalar_v = is_scalar<_Ty>::value;
template<class _Ty>
 constexpr bool is_compound_v = is_compound<_Ty>::value;
template<class _Ty>
 constexpr bool is_member_pointer_v = is_member_pointer<_Ty>::value;
template<class _Ty>
 constexpr bool is_const_v = is_const<_Ty>::value;
template<class _Ty>
 constexpr bool is_volatile_v = is_volatile<_Ty>::value;
template<class _Ty>
 constexpr bool is_trivial_v = is_trivial<_Ty>::value;
template<class _Ty>
 constexpr bool is_trivially_copyable_v = is_trivially_copyable<_Ty>::value;
template<class _Ty>
 constexpr bool is_standard_layout_v = is_standard_layout<_Ty>::value;
template<class _Ty>
 constexpr bool is_pod_v = is_pod<_Ty>::value;
template<class _Ty>
 constexpr bool is_literal_type_v = is_literal_type<_Ty>::value;
template<class _Ty>
 constexpr bool is_empty_v = is_empty<_Ty>::value;
template<class _Ty>
 constexpr bool is_polymorphic_v = is_polymorphic<_Ty>::value;
template<class _Ty>
 constexpr bool is_abstract_v = is_abstract<_Ty>::value;
template<class _Ty>
 constexpr bool is_final_v = is_final<_Ty>::value;
template<class _Ty>
 constexpr bool is_signed_v = is_signed<_Ty>::value;
template<class _Ty>
 constexpr bool is_unsigned_v = is_unsigned<_Ty>::value;
template<class _Ty,
 class... _Args>
 constexpr bool is_constructible_v = is_constructible<_Ty, _Args...>::value;
template<class _Ty>
 constexpr bool is_default_constructible_v = is_default_constructible<_Ty>::value;
template<class _Ty>
 constexpr bool is_copy_constructible_v = is_copy_constructible<_Ty>::value;
template<class _Ty>
 constexpr bool is_move_constructible_v = is_move_constructible<_Ty>::value;
template<class _Ty,
 class _Uty>
 constexpr bool is_assignable_v = is_assignable<_Ty, _Uty>::value;
template<class _Ty>
 constexpr bool is_copy_assignable_v = is_copy_assignable<_Ty>::value;
template<class _Ty>
 constexpr bool is_move_assignable_v = is_move_assignable<_Ty>::value;







template<class _Ty>
 constexpr bool is_destructible_v = is_destructible<_Ty>::value;
template<class _Ty,
 class... _Args>
 constexpr bool is_trivially_constructible_v = is_trivially_constructible<_Ty, _Args...>::value;
template<class _Ty>
 constexpr bool is_trivially_default_constructible_v = is_trivially_default_constructible<_Ty>::value;
template<class _Ty>
 constexpr bool is_trivially_copy_constructible_v = is_trivially_copy_constructible<_Ty>::value;
template<class _Ty>
 constexpr bool is_trivially_move_constructible_v = is_trivially_move_constructible<_Ty>::value;
template<class _Ty,
 class _Uty>
 constexpr bool is_trivially_assignable_v = is_trivially_assignable<_Ty, _Uty>::value;
template<class _Ty>
 constexpr bool is_trivially_copy_assignable_v = is_trivially_copy_assignable<_Ty>::value;
template<class _Ty>
 constexpr bool is_trivially_move_assignable_v = is_trivially_move_assignable<_Ty>::value;
template<class _Ty>
 constexpr bool is_trivially_destructible_v = is_trivially_destructible<_Ty>::value;
template<class _Ty,
 class... _Args>
 constexpr bool is_nothrow_constructible_v = is_nothrow_constructible<_Ty, _Args...>::value;
template<class _Ty>
 constexpr bool is_nothrow_default_constructible_v = is_nothrow_default_constructible<_Ty>::value;
template<class _Ty>
 constexpr bool is_nothrow_copy_constructible_v = is_nothrow_copy_constructible<_Ty>::value;
template<class _Ty>
 constexpr bool is_nothrow_move_constructible_v = is_nothrow_move_constructible<_Ty>::value;
template<class _Ty,
 class _Uty>
 constexpr bool is_nothrow_assignable_v = is_nothrow_assignable<_Ty, _Uty>::value;
template<class _Ty>
 constexpr bool is_nothrow_copy_assignable_v = is_nothrow_copy_assignable<_Ty>::value;
template<class _Ty>
 constexpr bool is_nothrow_move_assignable_v = is_nothrow_move_assignable<_Ty>::value;







template<class _Ty>
 constexpr bool is_nothrow_destructible_v = is_nothrow_destructible<_Ty>::value;
template<class _Ty>
 constexpr bool has_virtual_destructor_v = has_virtual_destructor<_Ty>::value;
template<class _Ty>
 constexpr size_t alignment_of_v = alignment_of<_Ty>::value;
template<class _Ty>
 constexpr size_t rank_v = rank<_Ty>::value;
template<class _Ty,
 unsigned int _Ix = 0>
 constexpr size_t extent_v = extent<_Ty, _Ix>::value;
template<class _Base,
 class _Derived>
 constexpr bool is_base_of_v = is_base_of<_Base, _Derived>::value;
template<class _From,
 class _To>
 constexpr bool is_convertible_v = is_convertible<_From, _To>::value;
template<class... _Traits>
 constexpr bool conjunction_v = conjunction<_Traits...>::value;
template<class... _Traits>
 constexpr bool disjunction_v = disjunction<_Traits...>::value;
template<class _Trait>
 constexpr bool negation_v = negation<_Trait>::value;


}


#pragma warning(pop)
#pragma pack(pop)
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\exception" 2 3


#pragma pack(push,8)
#pragma warning(push, 3)



namespace std {
# 33 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\exception" 3
              bool __cdecl uncaught_exception() noexcept;
              int __cdecl uncaught_exceptions() noexcept;

}




# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\malloc.h" 1 3
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\malloc.h" 3
#pragma pack(push, 8)
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\malloc.h" 3
 extern "C" {
# 39 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\malloc.h" 3
typedef struct _heapinfo
{
    int* _pentry;
    size_t _size;
    int _useflag;
} _HEAPINFO;
# 54 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\malloc.h" 3
void* __cdecl _alloca( size_t _Size);





             intptr_t __cdecl _get_heap_handle(void);


             int __cdecl _heapmin(void);


                 int __cdecl _heapwalk( _HEAPINFO* _EntryInfo);



                                int __cdecl _heapchk(void);
                 int __cdecl _resetstkoflw(void);
# 84 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\malloc.h" 3
    typedef char __static_assert_t[(sizeof(unsigned int) <= 8) != 0];


#pragma warning(push)
#pragma warning(disable: 6540)

 __inline void* _MarkAllocaS( void* _Ptr, unsigned int _Marker)
    {
        if (_Ptr)
        {
            *((unsigned int*)_Ptr) = _Marker;
            _Ptr = (char*)_Ptr + 8;
        }
        return _Ptr;
    }

    __inline size_t _MallocaComputeSize(size_t _Size)
    {
        size_t _MarkedSize = _Size + 8;
        return _MarkedSize > _Size ? _MarkedSize : 0;
    }

#pragma warning(pop)
# 144 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\malloc.h" 3
#pragma warning(push)
#pragma warning(disable: 6014)
 __inline void __cdecl _freea( void* _Memory)
    {
        unsigned int _Marker;
        if (_Memory)
        {
            _Memory = (char*)_Memory - 8;
            _Marker = *(unsigned int*)_Memory;
            if (_Marker == 0xDDDD)
            {
                free(_Memory);
            }






        }
    }
#pragma warning(pop)
# 177 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\malloc.h" 3
}
# 177 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\malloc.h" 3
#pragma pack(pop)
# 40 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\exception" 2 3

# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime_exception.h" 1 3
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime_exception.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\eh.h" 1 3
# 11 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\eh.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_terminate.h" 1 3
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_terminate.h" 3
#pragma pack(push, 8)
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_terminate.h" 3
 extern "C" {



typedef void (__cdecl* terminate_handler )();
typedef void (__cdecl* terminate_function)();
# 28 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_terminate.h" 3
             __declspec(noreturn) void __cdecl abort();
             __declspec(noreturn) void __cdecl terminate() throw();



                 terminate_handler __cdecl set_terminate(
                     terminate_handler _NewTerminateHandler
            ) throw();

                 terminate_handler __cdecl _get_terminate();





}
# 43 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_terminate.h" 3
#pragma pack(pop)
# 11 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\eh.h" 2 3




#pragma pack(push, 8)
# 15 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\eh.h" 3
 extern "C" {



typedef void (__cdecl* unexpected_handler )();
typedef void (__cdecl* unexpected_function)();






struct _EXCEPTION_POINTERS;



             __declspec(noreturn) void __cdecl unexpected() throw(...);



                 unexpected_handler __cdecl set_unexpected(
                     unexpected_handler _NewUnexpectedHandler
            ) throw();

                 unexpected_handler __cdecl _get_unexpected();

        typedef void (__cdecl* _se_translator_function)(unsigned int, struct _EXCEPTION_POINTERS*);

                 _se_translator_function __cdecl _set_se_translator(
                     _se_translator_function _NewSETranslator
            );



    class type_info;

             int __cdecl _is_exception_typeof(
             type_info const& _Type,
             _EXCEPTION_POINTERS* _ExceptionPtr
        );

             bool __cdecl __uncaught_exception();
             int __cdecl __uncaught_exceptions();



}
# 61 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\eh.h" 3
#pragma pack(pop)
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime_exception.h" 2 3






#pragma pack(push, 8)


#pragma pack(push, 8)
# 19 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime_exception.h" 3
 extern "C" {

struct __std_exception_data
{
    char const* _What;
    bool _DoFree;
};

         void __cdecl __std_exception_copy(
          __std_exception_data const* _From,
          __std_exception_data* _To
    );

         void __cdecl __std_exception_destroy(
            __std_exception_data* _Data
    );

}
# 36 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime_exception.h" 3
#pragma pack(pop)



namespace std {

class exception
{
public:

    exception() throw()
        : _Data()
    {
    }

    explicit exception(char const* const _Message) throw()
        : _Data()
    {
        __std_exception_data _InitData = { _Message, true };
        __std_exception_copy(&_InitData, &_Data);
    }

    exception(char const* const _Message, int) throw()
        : _Data()
    {
        _Data._What = _Message;
    }

    exception(exception const& _Other) throw()
        : _Data()
    {
        __std_exception_copy(&_Other._Data, &_Data);
    }

    exception& operator=(exception const& _Other) throw()
    {
        if (this == &_Other)
        {
            return *this;
        }

        __std_exception_destroy(&_Data);
        __std_exception_copy(&_Other._Data, &_Data);
        return *this;
    }

    virtual ~exception() throw()
    {
        __std_exception_destroy(&_Data);
    }

    virtual char const* what() const
    {
        return _Data._What ? _Data._What : "Unknown exception";
    }

private:

    __std_exception_data _Data;
};

class bad_exception
    : public exception
{
public:

    bad_exception() throw()
        : exception("bad exception", 1)
    {
    }
};

class bad_alloc
    : public exception
{
public:

    bad_alloc() throw()
        : exception("bad allocation", 1)
    {
    }

private:

    friend class bad_array_new_length;

    bad_alloc(char const* const _Message) throw()
        : exception(_Message, 1)
    {
    }
};

class bad_array_new_length
    : public bad_alloc
{
public:

    bad_array_new_length() throw()
        : bad_alloc("bad array new length")
    {
    }
};

}


#pragma pack(pop)
# 41 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\exception" 2 3


namespace std {

using ::set_terminate; using ::terminate_handler; using ::terminate; using ::set_unexpected; using ::unexpected_handler; using ::unexpected;

typedef void (__cdecl *_Prhand)(const exception&);


inline terminate_handler __cdecl get_terminate() noexcept
 {
 return (_get_terminate());
 }

inline unexpected_handler __cdecl get_unexpected() noexcept
 {
 return (_get_unexpected());
 }


}
# 240 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\exception" 3
              void __cdecl __ExceptionPtrCreate( void*);
              void __cdecl __ExceptionPtrDestroy( void*);
              void __cdecl __ExceptionPtrCopy( void*, const void*);
              void __cdecl __ExceptionPtrAssign( void*, const void*);
              bool __cdecl __ExceptionPtrCompare( const void*, const void*);
              bool __cdecl __ExceptionPtrToBool( const void*);
              void __cdecl __ExceptionPtrSwap( void*, void*);
              void __cdecl __ExceptionPtrCurrentException( void*);
[[noreturn]] void __cdecl __ExceptionPtrRethrow( const void*);
              void __cdecl __ExceptionPtrCopyException(
         void*, const void*, const void*);

namespace std {

class exception_ptr
 {
public:
 exception_ptr() throw ()
  {
  __ExceptionPtrCreate(this);
  }

 exception_ptr(nullptr_t) throw ()
  {
  __ExceptionPtrCreate(this);
  }

 ~exception_ptr() throw ()
  {
  __ExceptionPtrDestroy(this);
  }

 exception_ptr(const exception_ptr& _Rhs) throw ()
  {
  __ExceptionPtrCopy(this, &_Rhs);
  }

 exception_ptr& operator=(const exception_ptr& _Rhs) throw ()
  {
  __ExceptionPtrAssign(this, &_Rhs);
  return *this;
  }

 exception_ptr& operator=(nullptr_t) throw ()
  {
  exception_ptr _Ptr;
  __ExceptionPtrAssign(this, &_Ptr);
  return *this;
  }

 explicit operator bool() const throw ()
  {
  return __ExceptionPtrToBool(this);
  }

 [[noreturn]] void _RethrowException() const
  {
  __ExceptionPtrRethrow(this);
  }

 static exception_ptr _Current_exception() throw ()
  {
  exception_ptr _Retval;
  __ExceptionPtrCurrentException(&_Retval);
  return _Retval;
  }

 static exception_ptr _Copy_exception( void* _Except, const void* _Ptr)
  {
  exception_ptr _Retval = 0;
  if (!_Ptr)
   {

   return _Retval;
   }
  __ExceptionPtrCopyException(&_Retval, _Except, _Ptr);
  return _Retval;
  }

private:
 void* _Data1;
 void* _Data2;
 };

inline void swap(exception_ptr& _Lhs, exception_ptr& _Rhs) throw ()
 {
 __ExceptionPtrSwap(&_Lhs, &_Rhs);
 }

inline bool operator==(const exception_ptr& _Lhs, const exception_ptr& _Rhs) throw ()
 {
 return __ExceptionPtrCompare(&_Lhs, &_Rhs);
 }

inline bool operator==(nullptr_t, const exception_ptr& _Rhs) throw ()
 {
 return !_Rhs;
 }

inline bool operator==(const exception_ptr& _Lhs, nullptr_t) throw ()
 {
 return !_Lhs;
 }

inline bool operator!=(const exception_ptr& _Lhs, const exception_ptr& _Rhs) throw ()
 {
 return !(_Lhs == _Rhs);
 }

inline bool operator!=(nullptr_t _Lhs, const exception_ptr& _Rhs) throw ()
 {
 return !(_Lhs == _Rhs);
 }

inline bool operator!=(const exception_ptr& _Lhs, nullptr_t _Rhs) throw ()
 {
 return !(_Lhs == _Rhs);
 }

inline exception_ptr current_exception() noexcept
 {
 return exception_ptr::_Current_exception();
 }

[[noreturn]] inline void rethrow_exception( exception_ptr _Ptr)
 {
 _Ptr._RethrowException();
 }

template<class _Ex> void *__GetExceptionInfo(_Ex);

template<class _Ex> exception_ptr make_exception_ptr(_Ex _Except) noexcept
 {
 return exception_ptr::_Copy_exception(::std:: addressof(_Except), __GetExceptionInfo(_Except));
 }


class nested_exception
 {
public:
 nested_exception() noexcept
  : _Exc(::std:: current_exception())
  {
  }

 nested_exception(const nested_exception&) noexcept = default;
 nested_exception& operator=(const nested_exception&) noexcept = default;
 virtual ~nested_exception() noexcept = default;

 [[noreturn]] void rethrow_nested() const
  {
  if (_Exc)
   ::std:: rethrow_exception(_Exc);
  else
   ::std:: terminate();
  }

 ::std:: exception_ptr nested_ptr() const noexcept
  {
  return (_Exc);
  }

private:
 ::std:: exception_ptr _Exc;
 };


template<class _Ty,
 class _Uty>
 struct _With_nested
  : _Uty, nested_exception
 {
 explicit _With_nested(_Ty&& _Arg)
  : _Uty(::std:: forward<_Ty>(_Arg)), nested_exception()
  {
  }
 };

template<class _Ty>
 [[noreturn]] inline void _Throw_with_nested(_Ty&& _Arg, true_type)
 {
 typedef typename remove_reference<_Ty>::type _Uty;
 typedef _With_nested<_Ty, _Uty> _Glued;

 throw _Glued(::std:: forward<_Ty>(_Arg));
 }

template<class _Ty>
 [[noreturn]] inline void _Throw_with_nested(_Ty&& _Arg, false_type)
 {
 typedef typename decay<_Ty>::type _Decayed;

 throw _Decayed(::std:: forward<_Ty>(_Arg));
 }

template<class _Ty>
 [[noreturn]] inline void throw_with_nested(_Ty&& _Arg)
 {
 typedef typename remove_reference<_Ty>::type _Uty;

 integral_constant<bool,
  is_class<_Uty>::value
  && !is_base_of<nested_exception, _Uty>::value
  && !is_final<_Uty>::value> _Tag;

 _Throw_with_nested(::std:: forward<_Ty>(_Arg), _Tag);
 }


template<class _Ty> inline
 void _Rethrow_if_nested(const _Ty *_Ptr, true_type)
 {
 const auto _Nested = dynamic_cast<const nested_exception *>(_Ptr);

 if (_Nested)
  _Nested->rethrow_nested();
 }

template<class _Ty> inline
 void _Rethrow_if_nested(const _Ty *, false_type)
 {
 }

template<class _Ty> inline
 void rethrow_if_nested(const _Ty& _Arg)
 {
 integral_constant<bool,
  is_polymorphic<_Ty>::value
  && (!is_base_of<nested_exception, _Ty>::value
   || is_convertible<_Ty *, nested_exception *>::value)> _Tag;

 _Rethrow_if_nested(::std:: addressof(_Arg), _Tag);
 }
}


#pragma warning(pop)
#pragma pack(pop)
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\new" 2 3

# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime_new.h" 1 3
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime_new.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime.h" 1 3
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime_new.h" 2 3



extern "C++" {

#pragma pack(push, 8)

#pragma warning(push)
#pragma warning(disable: 4985)






 namespace std
    {
        struct nothrow_t { };

        extern nothrow_t const nothrow;
    }



__declspec(allocator) void* __cdecl operator new(
    size_t _Size
    );


__declspec(allocator) void* __cdecl operator new(
    size_t _Size,
    std::nothrow_t const&
    ) throw();


__declspec(allocator) void* __cdecl operator new[](
    size_t _Size
    );


__declspec(allocator) void* __cdecl operator new[](
    size_t _Size,
    std::nothrow_t const&
    ) throw();

void __cdecl operator delete(
    void* _Block
    ) throw();

void __cdecl operator delete(
    void* _Block,
    std::nothrow_t const&
    ) throw();

void __cdecl operator delete[](
    void* _Block
    ) throw();

void __cdecl operator delete[](
    void* _Block,
    std::nothrow_t const&
    ) throw();

void __cdecl operator delete(
    void* _Block,
    size_t _Size
    ) throw();

void __cdecl operator delete[](
    void* _Block,
    size_t _Size
    ) throw();




    inline void* __cdecl operator new(size_t _Size, void* _Where) throw()
    {
        (void)_Size;
        return _Where;
    }

    inline void __cdecl operator delete(void*, void*) throw()
    {
        return;
    }





    inline void* __cdecl operator new[](size_t _Size, void* _Where) throw()
    {
        (void)_Size;
        return _Where;
    }

    inline void __cdecl operator delete[](void*, void*) throw()
    {
    }




#pragma warning(pop)
#pragma pack(pop)

}
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\new" 2 3


#pragma pack(push,8)
#pragma warning(push, 3)






namespace std {




typedef void (__cdecl * new_handler) ();



         new_handler __cdecl set_new_handler( new_handler)
 noexcept;

         new_handler __cdecl get_new_handler()
 noexcept;
}


#pragma warning(pop)
#pragma pack(pop)
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory0" 2 3

# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility" 1 3







# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\utility" 1 3






# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\iosfwd" 1 3





# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\cstdio" 1 3
# 13 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\cstdio" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdio.h" 1 3
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdio.h" 3
#pragma pack(push, 8)
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdio.h" 3
 extern "C" {
# 68 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdio.h" 3
typedef __int64 fpos_t;




         errno_t __cdecl _get_stream_buffer_pointers(
              FILE* _Stream,
              char*** _Base,
              char*** _Pointer,
              int** _Count
    );
# 89 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdio.h" 3
             errno_t __cdecl clearerr_s(
                FILE* _Stream
        );


             errno_t __cdecl fopen_s(
                                  FILE** _Stream,
                                  char const* _FileName,
                                  char const* _Mode
        );



             size_t __cdecl fread_s(
                                                                           void* _Buffer,
                                                                           size_t _BufferSize,
                                                                           size_t _ElementSize,
                                                                           size_t _ElementCount,
                                                                           FILE* _Stream
        );


             errno_t __cdecl freopen_s(
                                  FILE** _Stream,
                                  char const* _FileName,
                                  char const* _Mode,
                                  FILE* _OldStream
        );


             char* __cdecl gets_s(
                              char* _Buffer,
                              rsize_t _Size
        );


             errno_t __cdecl tmpfile_s(
                                     FILE** _Stream
        );



             errno_t __cdecl tmpnam_s(
                              char* _Buffer,
                              rsize_t _Size
        );



         void __cdecl clearerr(
            FILE* _Stream
    );



         int __cdecl fclose(
            FILE* _Stream
    );


         int __cdecl _fcloseall(void);


         FILE* __cdecl _fdopen(
           int _FileHandle,
           char const* _Mode
    );


         int __cdecl feof(
         FILE* _Stream
    );


         int __cdecl ferror(
         FILE* _Stream
    );


         int __cdecl fflush(
                FILE* _Stream
    );



         int __cdecl fgetc(
            FILE* _Stream
    );


         int __cdecl _fgetchar(void);



         int __cdecl fgetpos(
            FILE* _Stream,
            fpos_t* _Position
    );



         char* __cdecl fgets(
                              char* _Buffer,
                              int _MaxCount,
                              FILE* _Stream
    );


         int __cdecl _fileno(
         FILE* _Stream
    );


         int __cdecl _flushall(void);


         FILE* __cdecl fopen(
           char const* _FileName,
           char const* _Mode
    );




         int __cdecl fputc(
            int _Character,
            FILE* _Stream
    );


         int __cdecl _fputchar(
         int _Character
    );



         int __cdecl fputs(
            char const* _Buffer,
            FILE* _Stream
    );


         size_t __cdecl fread(
                                                     void* _Buffer,
                                                     size_t _ElementSize,
                                                     size_t _ElementCount,
                                                     FILE* _Stream
    );



         FILE* __cdecl freopen(
            char const* _FileName,
            char const* _Mode,
            FILE* _Stream
    );


         FILE* __cdecl _fsopen(
           char const* _FileName,
           char const* _Mode,
           int _ShFlag
    );



         int __cdecl fsetpos(
            FILE* _Stream,
            fpos_t const* _Position
    );



         int __cdecl fseek(
            FILE* _Stream,
            long _Offset,
            int _Origin
    );



         int __cdecl _fseeki64(
            FILE* _Stream,
            __int64 _Offset,
            int _Origin
    );



         long __cdecl ftell(
            FILE* _Stream
    );



         __int64 __cdecl _ftelli64(
            FILE* _Stream
    );


         size_t __cdecl fwrite(
                                                   void const* _Buffer,
                                                   size_t _ElementSize,
                                                   size_t _ElementCount,
                                                   FILE* _Stream
    );



         int __cdecl getc(
            FILE* _Stream
    );


         int __cdecl getchar(void);


         int __cdecl _getmaxstdio(void);

extern "C++" { template <size_t _Size> inline char* __cdecl gets_s(char (&_Buffer)[_Size]) throw() { return gets_s(_Buffer, _Size); } }




         int __cdecl _getw(
            FILE* _Stream
    );

         void __cdecl perror(
               char const* _ErrorMessage
    );





             int __cdecl _pclose(
                FILE* _Stream
        );


             FILE* __cdecl _popen(
               char const* _Command,
               char const* _Mode
        );





         int __cdecl putc(
            int _Character,
            FILE* _Stream
    );


         int __cdecl putchar(
         int _Character
    );


         int __cdecl puts(
           char const* _Buffer
    );



         int __cdecl _putw(
            int _Word,
            FILE* _Stream
    );



         int __cdecl remove(
           char const* _FileName
    );


         int __cdecl rename(
           char const* _OldFileName,
           char const* _NewFileName
    );

         int __cdecl _unlink(
           char const* _FileName
    );



    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_unlink" ". See online help for details."))
             int __cdecl unlink(
               char const* _FileName
        );





         void __cdecl rewind(
            FILE* _Stream
    );


         int __cdecl _rmtmp(void);


         void __cdecl setbuf(
                                                        FILE* _Stream,
                                                        char* _Buffer
    );


         int __cdecl _setmaxstdio(
         int _Maximum
    );



         int __cdecl setvbuf(
                                 FILE* _Stream,
                                 char* _Buffer,
                                 int _Mode,
                                 size_t _Size
    );







         __declspec(allocator) char* __cdecl _tempnam(
               char const* _DirectoryName,
               char const* _FilePrefix
    );






         FILE* __cdecl tmpfile(void);

extern "C++" { template <size_t _Size> inline errno_t __cdecl tmpnam_s(char (&_Buffer)[_Size]) throw() { return tmpnam_s(_Buffer, _Size); } }




 char* __cdecl tmpnam( char *_Buffer);







         int __cdecl ungetc(
            int _Character,
            FILE* _Stream
    );
# 458 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdio.h" 3
         void __cdecl _lock_file(
            FILE* _Stream
    );

         void __cdecl _unlock_file(
            FILE* _Stream
    );



         int __cdecl _fclose_nolock(
            FILE* _Stream
    );



         int __cdecl _fflush_nolock(
                FILE* _Stream
    );



         int __cdecl _fgetc_nolock(
            FILE* _Stream
    );



         int __cdecl _fputc_nolock(
            int _Character,
            FILE* _Stream
    );


         size_t __cdecl _fread_nolock(
                                                     void* _Buffer,
                                                     size_t _ElementSize,
                                                     size_t _ElementCount,
                                                     FILE* _Stream
    );



         size_t __cdecl _fread_nolock_s(
                                                                     void* _Buffer,
                                                                     size_t _BufferSize,
                                                                     size_t _ElementSize,
                                                                     size_t _ElementCount,
                                                                     FILE* _Stream
    );


         int __cdecl _fseek_nolock(
            FILE* _Stream,
            long _Offset,
            int _Origin
    );


         int __cdecl _fseeki64_nolock(
            FILE* _Stream,
            __int64 _Offset,
            int _Origin
    );


         long __cdecl _ftell_nolock(
            FILE* _Stream
    );


         __int64 __cdecl _ftelli64_nolock(
            FILE* _Stream
    );


         size_t __cdecl _fwrite_nolock(
                                                   void const* _Buffer,
                                                   size_t _ElementSize,
                                                   size_t _ElementCount,
                                                   FILE* _Stream
    );


         int __cdecl _getc_nolock(
            FILE* _Stream
    );


         int __cdecl _putc_nolock(
            int _Character,
            FILE* _Stream
    );


         int __cdecl _ungetc_nolock(
            int _Character,
            FILE* _Stream
    );
# 583 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdio.h" 3
         int* __cdecl __p__commode(void);
# 603 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdio.h" 3
         int __cdecl __stdio_common_vfprintf(
                                            unsigned __int64 _Options,
                                            FILE* _Stream,
                                            char const* _Format,
                                            _locale_t _Locale,
                                            va_list _ArgList
    );

         int __cdecl __stdio_common_vfprintf_s(
                                            unsigned __int64 _Options,
                                            FILE* _Stream,
                                            char const* _Format,
                                            _locale_t _Locale,
                                            va_list _ArgList
    );


         int __cdecl __stdio_common_vfprintf_p(
                                            unsigned __int64 _Options,
                                            FILE* _Stream,
                                            char const* _Format,
                                            _locale_t _Locale,
                                            va_list _ArgList
    );


__inline int __cdecl _vfprintf_l(
             FILE* const _Stream,
             char const* const _Format,
             _locale_t const _Locale,
             va_list _ArgList
    )



{
    return __stdio_common_vfprintf((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
}



__inline int __cdecl vfprintf(
                                  FILE* const _Stream,
                                  char const* const _Format,
                                  va_list _ArgList
    )



{
    return _vfprintf_l(_Stream, _Format, 0, _ArgList);
}



__inline int __cdecl _vfprintf_s_l(
             FILE* const _Stream,
             char const* const _Format,
             _locale_t const _Locale,
             va_list _ArgList
    )



{
    return __stdio_common_vfprintf_s((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
}





    __inline int __cdecl vfprintf_s(
                                      FILE* const _Stream,
                                      char const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vfprintf_s_l(_Stream, _Format, 0, _ArgList);
    }





__inline int __cdecl _vfprintf_p_l(
             FILE* const _Stream,
             char const* const _Format,
             _locale_t const _Locale,
             va_list _ArgList
    )



{
    return __stdio_common_vfprintf_p((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
}



__inline int __cdecl _vfprintf_p(
                                  FILE* const _Stream,
                                  char const* const _Format,
                                  va_list _ArgList
    )



{
    return _vfprintf_p_l(_Stream, _Format, 0, _ArgList);
}



__inline int __cdecl _vprintf_l(
                                            char const* const _Format,
                                            _locale_t const _Locale,
                                            va_list _ArgList
    )



{
    return _vfprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
}



__inline int __cdecl vprintf(
                                  char const* const _Format,
                                  va_list _ArgList
    )



{
    return _vfprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
}



__inline int __cdecl _vprintf_s_l(
                                            char const* const _Format,
                                            _locale_t const _Locale,
                                            va_list _ArgList
    )



{
    return _vfprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
}





    __inline int __cdecl vprintf_s(
                                      char const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vfprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }





__inline int __cdecl _vprintf_p_l(
                                            char const* const _Format,
                                            _locale_t const _Locale,
                                            va_list _ArgList
    )



{
    return _vfprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
}



__inline int __cdecl _vprintf_p(
                                  char const* const _Format,
                                  va_list _ArgList
    )



{
    return _vfprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
}



__inline int __cdecl _fprintf_l(
                                            FILE* const _Stream,
                                            char const* const _Format,
                                            _locale_t const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfprintf_l(_Stream, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}



__inline int __cdecl fprintf(
                                  FILE* const _Stream,
                                  char const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfprintf_l(_Stream, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}


         int __cdecl _set_printf_count_output(
         int _Value
    );

         int __cdecl _get_printf_count_output(void);


__inline int __cdecl _fprintf_s_l(
                                            FILE* const _Stream,
                                            char const* const _Format,
                                            _locale_t const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfprintf_s_l(_Stream, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}





    __inline int __cdecl fprintf_s(
                                      FILE* const _Stream,
                                      char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfprintf_s_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }





__inline int __cdecl _fprintf_p_l(
                                            FILE* const _Stream,
                                            char const* const _Format,
                                            _locale_t const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfprintf_p_l(_Stream, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}



__inline int __cdecl _fprintf_p(
                                  FILE* const _Stream,
                                  char const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfprintf_p_l(_Stream, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}



__inline int __cdecl _printf_l(
                                            char const* const _Format,
                                            _locale_t const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}



__inline int __cdecl printf(
                                  char const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}



__inline int __cdecl _printf_s_l(
                                            char const* const _Format,
                                            _locale_t const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}





    __inline int __cdecl printf_s(
                                      char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }





__inline int __cdecl _printf_p_l(
                                            char const* const _Format,
                                            _locale_t const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}



__inline int __cdecl _printf_p(
                                  char const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
# 1040 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdio.h" 3
         int __cdecl __stdio_common_vfscanf(
                                           unsigned __int64 _Options,
                                           FILE* _Stream,
                                           char const* _Format,
                                           _locale_t _Locale,
                                           va_list _Arglist
    );


__inline int __cdecl _vfscanf_l(
                                  FILE* const _Stream,
                                  char const* const _Format,
                                  _locale_t const _Locale,
                                  va_list _ArgList
    )



{
    return __stdio_common_vfscanf(
        (*__local_stdio_scanf_options ()),
        _Stream, _Format, _Locale, _ArgList);
}



__inline int __cdecl vfscanf(
                                  FILE* const _Stream,
                                  char const* const _Format,
                                  va_list _ArgList
    )



{
    return _vfscanf_l(_Stream, _Format, 0, _ArgList);
}



__inline int __cdecl _vfscanf_s_l(
                                  FILE* const _Stream,
                                  char const* const _Format,
                                  _locale_t const _Locale,
                                  va_list _ArgList
    )



{
    return __stdio_common_vfscanf(
        (*__local_stdio_scanf_options ()) | (1ULL << 0),
        _Stream, _Format, _Locale, _ArgList);
}






    __inline int __cdecl vfscanf_s(
                                      FILE* const _Stream,
                                      char const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vfscanf_s_l(_Stream, _Format, 0, _ArgList);
    }





__inline int __cdecl _vscanf_l(
                                  char const* const _Format,
                                  _locale_t const _Locale,
                                  va_list _ArgList
    )



{
    return _vfscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
}



__inline int __cdecl vscanf(
                                  char const* const _Format,
                                  va_list _ArgList
    )



{
    return _vfscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
}



__inline int __cdecl _vscanf_s_l(
                                  char const* const _Format,
                                  _locale_t const _Locale,
                                  va_list _ArgList
    )



{
    return _vfscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
}





    __inline int __cdecl vscanf_s(
                                      char const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vfscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    }





__inline int __cdecl _fscanf_l(
                                           FILE* const _Stream,
                                           char const* const _Format,
                                           _locale_t const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfscanf_l(_Stream, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}



__inline int __cdecl fscanf(
                                 FILE* const _Stream,
                                 char const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfscanf_l(_Stream, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}



__inline int __cdecl _fscanf_s_l(
                                             FILE* const _Stream,
                                             char const* const _Format,
                                             _locale_t const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfscanf_s_l(_Stream, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}





    __inline int __cdecl fscanf_s(
                                       FILE* const _Stream,
                                       char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfscanf_s_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }





__inline int __cdecl _scanf_l(
                                           char const* const _Format,
                                           _locale_t const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}



__inline int __cdecl scanf(
                                 char const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}



__inline int __cdecl _scanf_s_l(
                                             char const* const _Format,
                                             _locale_t const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}





    __inline int __cdecl scanf_s(
                                       char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
# 1333 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdio.h" 3
         int __cdecl __stdio_common_vsprintf(
                                            unsigned __int64 _Options,
                                            char* _Buffer,
                                            size_t _BufferCount,
                                            char const* _Format,
                                            _locale_t _Locale,
                                            va_list _ArgList
    );


         int __cdecl __stdio_common_vsprintf_s(
                                            unsigned __int64 _Options,
                                            char* _Buffer,
                                            size_t _BufferCount,
                                            char const* _Format,
                                            _locale_t _Locale,
                                            va_list _ArgList
    );


         int __cdecl __stdio_common_vsnprintf_s(
                                            unsigned __int64 _Options,
                                            char* _Buffer,
                                            size_t _BufferCount,
                                            size_t _MaxCount,
                                            char const* _Format,
                                            _locale_t _Locale,
                                            va_list _ArgList
    );


         int __cdecl __stdio_common_vsprintf_p(
                                            unsigned __int64 _Options,
                                            char* _Buffer,
                                            size_t _BufferCount,
                                            char const* _Format,
                                            _locale_t _Locale,
                                            va_list _ArgList
    );



__inline int __cdecl _vsnprintf_l(
                                            char* const _Buffer,
                                            size_t const _BufferCount,
                                            char const* const _Format,
                                            _locale_t const _Locale,
                                            va_list _ArgList
    )



{
    int const _Result = __stdio_common_vsprintf(
        (*__local_stdio_printf_options()) | (1ULL << 0),
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}




__inline int __cdecl _vsnprintf(
                                             char* const _Buffer,
                                             size_t const _BufferCount,
                                             char const* const _Format,
                                             va_list _ArgList
    )



{
#pragma warning(push)
#pragma warning(disable: 4996)
 return _vsnprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
#pragma warning(pop)
}
# 1426 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdio.h" 3
__inline int __cdecl vsnprintf(
                                  char* const _Buffer,
                                  size_t const _BufferCount,
                                  char const* const _Format,
                                  va_list _ArgList
    )



{
    int const _Result = __stdio_common_vsprintf(
        (*__local_stdio_printf_options()) | (1ULL << 1),
        _Buffer, _BufferCount, _Format, 0, _ArgList);

    return _Result < 0 ? -1 : _Result;
}




__inline int __cdecl _vsprintf_l(
                           char* const _Buffer,
                           char const* const _Format,
                           _locale_t const _Locale,
                           va_list _ArgList
    )



{
#pragma warning(push)
#pragma warning(disable: 4996)
 return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
#pragma warning(pop)
}




__inline int __cdecl vsprintf(
                                  char* const _Buffer,
                                  char const* const _Format,
                                  va_list _ArgList
    )



{
#pragma warning(push)
#pragma warning(disable: 4996)
 return _vsnprintf_l(_Buffer, (size_t)-1, _Format, 0, _ArgList);
#pragma warning(pop)
}




__inline int __cdecl _vsprintf_s_l(
                                            char* const _Buffer,
                                            size_t const _BufferCount,
                                            char const* const _Format,
                                            _locale_t const _Locale,
                                            va_list _ArgList
    )



{
    int const _Result = __stdio_common_vsprintf_s(
        (*__local_stdio_printf_options()),
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}






    __inline int __cdecl vsprintf_s(
                                      char* const _Buffer,
                                      size_t const _BufferCount,
                                      char const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }


    extern "C++" { template <size_t _Size> inline int __cdecl vsprintf_s(char (&_Buffer)[_Size], char const* _Format, va_list _ArgList) throw() { return vsprintf_s(_Buffer, _Size, _Format, _ArgList); } }
# 1532 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdio.h" 3
__inline int __cdecl _vsprintf_p_l(
                                            char* const _Buffer,
                                            size_t const _BufferCount,
                                            char const* const _Format,
                                            _locale_t const _Locale,
                                            va_list _ArgList
    )



{
    int const _Result = __stdio_common_vsprintf_p(
        (*__local_stdio_printf_options()),
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}




__inline int __cdecl _vsprintf_p(
                                  char* const _Buffer,
                                  size_t const _BufferCount,
                                  char const* const _Format,
                                  va_list _ArgList
    )



{
    return _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
}




__inline int __cdecl _vsnprintf_s_l(
                                            char* const _Buffer,
                                            size_t const _BufferCount,
                                            size_t const _MaxCount,
                                            char const* const _Format,
                                            _locale_t const _Locale,
                                            va_list _ArgList
    )



{
    int const _Result = __stdio_common_vsnprintf_s(
        (*__local_stdio_printf_options()),
        _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}




__inline int __cdecl _vsnprintf_s(
                                  char* const _Buffer,
                                  size_t const _BufferCount,
                                  size_t const _MaxCount,
                                  char const* const _Format,
                                  va_list _ArgList
    )



{
    return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
}


extern "C++" { template <size_t _Size> inline int __cdecl _vsnprintf_s(char (&_Buffer)[_Size], size_t _BufferCount, char const* _Format, va_list _ArgList) throw() { return _vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
# 1619 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdio.h" 3
    __inline int __cdecl vsnprintf_s(
                                      char* const _Buffer,
                                      size_t const _BufferCount,
                                      size_t const _MaxCount,
                                      char const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
    }


    extern "C++" { template <size_t _Size> inline int __cdecl vsnprintf_s(char (&_Buffer)[_Size], size_t _BufferCount, char const* _Format, va_list _ArgList) throw() { return vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
# 1646 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdio.h" 3
__inline int __cdecl _vscprintf_l(
                                            char const* const _Format,
                                            _locale_t const _Locale,
                                            va_list _ArgList
    )



{
    int const _Result = __stdio_common_vsprintf(
        (*__local_stdio_printf_options()) | (1ULL << 1),
        0, 0, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}



__inline int __cdecl _vscprintf(
                                  char const* const _Format,
                                  va_list _ArgList
    )



{
    return _vscprintf_l(_Format, 0, _ArgList);
}



__inline int __cdecl _vscprintf_p_l(
                                            char const* const _Format,
                                            _locale_t const _Locale,
                                            va_list _ArgList
    )



{
    int const _Result = __stdio_common_vsprintf_p(
        (*__local_stdio_printf_options()) | (1ULL << 1),
        0, 0, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}



__inline int __cdecl _vscprintf_p(
                                  char const* const _Format,
                                  va_list _ArgList
    )



{
    return _vscprintf_p_l(_Format, 0, _ArgList);
}



__inline int __cdecl _vsnprintf_c_l(
                                            char* const _Buffer,
                                            size_t const _BufferCount,
                                            char const* const _Format,
                                            _locale_t const _Locale,
                                            va_list _ArgList
    )



{
    int const _Result = __stdio_common_vsprintf(
        (*__local_stdio_printf_options()),
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}




__inline int __cdecl _vsnprintf_c(
                                  char* const _Buffer,
                                  size_t const _BufferCount,
                                  char const* const _Format,
                                  va_list _ArgList
    )



{
    return _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
}



__inline int __cdecl _sprintf_l(
                                            char* const _Buffer,
                                            char const* const _Format,
                                            _locale_t const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

#pragma warning(push)
#pragma warning(disable: 4996)
 _Result = _vsprintf_l(_Buffer, _Format, _Locale, _ArgList);
#pragma warning(pop)

 ((void)(_ArgList = (va_list)0));
    return _Result;
}




__inline int __cdecl sprintf(
                                  char* const _Buffer,
                                  char const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

#pragma warning(push)
#pragma warning(disable: 4996)
 _Result = _vsprintf_l(_Buffer, _Format, 0, _ArgList);
#pragma warning(pop)

 ((void)(_ArgList = (va_list)0));
    return _Result;
}


#pragma warning(push)
#pragma warning(disable: 4996)
 int __cdecl sprintf( char *_Buffer, char const* _Format, ...); int __cdecl vsprintf( char *_Buffer, char const* _Format, va_list _Args);





#pragma warning(pop)



__inline int __cdecl _sprintf_s_l(
                                            char* const _Buffer,
                                            size_t const _BufferCount,
                                            char const* const _Format,
                                            _locale_t const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}






    __inline int __cdecl sprintf_s(
                                      char* const _Buffer,
                                      size_t const _BufferCount,
                                      char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }




extern "C++" {
# 1846 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdio.h" 3
#pragma warning(push)
# 1846 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdio.h" 3
;
# 1846 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdio.h" 3
#pragma warning(disable: 4793)
# 1846 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdio.h" 3
; template <size_t _Size> inline int __cdecl sprintf_s(char (&_Buffer)[_Size], char const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1)))))); return vsprintf_s(_Buffer, _Size, _Format, _ArgList); }
# 1846 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdio.h" 3
#pragma warning(pop)
# 1846 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdio.h" 3
; }







__inline int __cdecl _sprintf_p_l(
                                            char* const _Buffer,
                                            size_t const _BufferCount,
                                            char const* const _Format,
                                            _locale_t const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}




__inline int __cdecl _sprintf_p(
                                  char* const _Buffer,
                                  size_t const _BufferCount,
                                  char const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}




__inline int __cdecl _snprintf_l(
                                            char* const _Buffer,
                                            size_t const _BufferCount,
                                            char const* const _Format,
                                            _locale_t const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

#pragma warning(push)
#pragma warning(disable: 4996)
 _Result = _vsnprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
#pragma warning(pop)

 ((void)(_ArgList = (va_list)0));
    return _Result;
}
# 1932 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdio.h" 3
__inline int __cdecl snprintf(
                                  char* const _Buffer,
                                  size_t const _BufferCount,
                                  char const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
#pragma warning(suppress: 28719)
 _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}



__inline int __cdecl _snprintf(
                                             char* const _Buffer,
                                             size_t const _BufferCount,
                                             char const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
#pragma warning(suppress: 28719)
 _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}


 int __cdecl _snprintf( char *_Buffer, size_t _BufferCount, char const* _Format, ...); int __cdecl _vsnprintf( char *_Buffer, size_t _BufferCount, char const* _Format, va_list _Args);
# 1982 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdio.h" 3
__inline int __cdecl _snprintf_c_l(
                                            char* const _Buffer,
                                            size_t const _BufferCount,
                                            char const* const _Format,
                                            _locale_t const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}




__inline int __cdecl _snprintf_c(
                                  char* const _Buffer,
                                  size_t const _BufferCount,
                                  char const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}




__inline int __cdecl _snprintf_s_l(
                                            char* const _Buffer,
                                            size_t const _BufferCount,
                                            size_t const _MaxCount,
                                            char const* const _Format,
                                            _locale_t const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}




__inline int __cdecl _snprintf_s(
                                  char* const _Buffer,
                                  size_t const _BufferCount,
                                  size_t const _MaxCount,
                                  char const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}


extern "C++" {
# 2064 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdio.h" 3
#pragma warning(push)
# 2064 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdio.h" 3
;
# 2064 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdio.h" 3
#pragma warning(disable: 4793)
# 2064 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdio.h" 3
; template <size_t _Size> inline int __cdecl _snprintf_s(char (&_Buffer)[_Size], size_t _BufferCount, char const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1)))))); return _vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); }
# 2064 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdio.h" 3
#pragma warning(pop)
# 2064 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdio.h" 3
; }
# 2073 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdio.h" 3
__inline int __cdecl _scprintf_l(
                                            char const* const _Format,
                                            _locale_t const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vscprintf_l(_Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}



__inline int __cdecl _scprintf(
                                  char const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vscprintf_l(_Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}



__inline int __cdecl _scprintf_p_l(
                                            char const* const _Format,
                                            _locale_t const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vscprintf_p_l(_Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}



__inline int __cdecl _scprintf_p(
                                  char const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vscprintf_p(_Format, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}







         int __cdecl __stdio_common_vsscanf(
                                           unsigned __int64 _Options,
                                           char const* _Buffer,
                                           size_t _BufferCount,
                                           char const* _Format,
                                           _locale_t _Locale,
                                           va_list _ArgList
    );


__inline int __cdecl _vsscanf_l(
                                  char const* const _Buffer,
                                  char const* const _Format,
                                  _locale_t const _Locale,
                                  va_list _ArgList
    )



{
    return __stdio_common_vsscanf(
        (*__local_stdio_scanf_options ()),
        _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
}



__inline int __cdecl vsscanf(
                                  char const* const _Buffer,
                                  char const* const _Format,
                                  va_list _ArgList
    )



{
    return _vsscanf_l(_Buffer, _Format, 0, _ArgList);
}



__inline int __cdecl _vsscanf_s_l(
                                  char const* const _Buffer,
                                  char const* const _Format,
                                  _locale_t const _Locale,
                                  va_list _ArgList
    )



{
    return __stdio_common_vsscanf(
        (*__local_stdio_scanf_options ()) | (1ULL << 0),
        _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
}




#pragma warning(push)
#pragma warning(disable: 6530)


 __inline int __cdecl vsscanf_s(
                                      char const* const _Buffer,
                                      char const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vsscanf_s_l(_Buffer, _Format, 0, _ArgList);
    }


    extern "C++" { template <size_t _Size> inline int __cdecl vsscanf_s(char const (&_Buffer)[_Size], char const* _Format, va_list _ArgList) throw() { return vsscanf_s(_Buffer, _Size, _Format, _ArgList); } }






#pragma warning(pop)




__inline int __cdecl _sscanf_l(
                                           char const* const _Buffer,
                                           char const* const _Format,
                                           _locale_t const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vsscanf_l(_Buffer, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}



__inline int __cdecl sscanf(
                                 char const* const _Buffer,
                                 char const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vsscanf_l(_Buffer, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}



__inline int __cdecl _sscanf_s_l(
                                             char const* const _Buffer,
                                             char const* const _Format,
                                             _locale_t const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vsscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}





    __inline int __cdecl sscanf_s(
                                       char const* const _Buffer,
                                       char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

#pragma warning(push)
#pragma warning(disable: 4996)
 _Result = vsscanf_s(_Buffer, _Format, _ArgList);
#pragma warning(pop)

 ((void)(_ArgList = (va_list)0));
        return _Result;
    }




#pragma warning(push)
#pragma warning(disable: 6530)


__inline int __cdecl _snscanf_l(
                                           char const* const _Buffer,
                                           size_t const _BufferCount,
                                           char const* const _Format,
                                           _locale_t const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

    _Result = __stdio_common_vsscanf(
        (*__local_stdio_scanf_options ()),
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);

    ((void)(_ArgList = (va_list)0));
    return _Result;
}



__inline int __cdecl _snscanf(
                                           char const* const _Buffer,
                                           size_t const _BufferCount,
                                           char const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

    _Result = __stdio_common_vsscanf(
        (*__local_stdio_scanf_options ()),
        _Buffer, _BufferCount, _Format, 0, _ArgList);

    ((void)(_ArgList = (va_list)0));
    return _Result;
}




__inline int __cdecl _snscanf_s_l(
                                             char const* const _Buffer,
                                             size_t const _BufferCount,
                                             char const* const _Format,
                                             _locale_t const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

    _Result = __stdio_common_vsscanf(
        (*__local_stdio_scanf_options ()) | (1ULL << 0),
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);

    ((void)(_ArgList = (va_list)0));
    return _Result;
}



__inline int __cdecl _snscanf_s(
                                           char const* const _Buffer,
                                           size_t const _BufferCount,
                                           char const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

    _Result = __stdio_common_vsscanf(
        (*__local_stdio_scanf_options ()) | (1ULL << 0),
        _Buffer, _BufferCount, _Format, 0, _ArgList);

    ((void)(_ArgList = (va_list)0));
    return _Result;
}


#pragma warning(pop)
# 2437 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdio.h" 3
 __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_tempnam" ". See online help for details."))
             char* __cdecl tempnam(
                   char const* _Directory,
                   char const* _FilePrefix
        );





                       __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fcloseall" ". See online help for details.")) int __cdecl fcloseall(void);
                       __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fdopen" ". See online help for details.")) FILE* __cdecl fdopen( int _FileHandle, char const* _Format);
                       __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fgetchar" ". See online help for details.")) int __cdecl fgetchar(void);
                       __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fileno" ". See online help for details.")) int __cdecl fileno( FILE* _Stream);
                       __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_flushall" ". See online help for details.")) int __cdecl flushall(void);
                       __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fputchar" ". See online help for details.")) int __cdecl fputchar( int _Ch);
                       __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_getw" ". See online help for details.")) int __cdecl getw( FILE* _Stream);
                       __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_putw" ". See online help for details.")) int __cdecl putw( int _Ch, FILE* _Stream);
                       __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_rmtmp" ". See online help for details.")) int __cdecl rmtmp(void);





}
# 2461 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\stdio.h" 3
#pragma pack(pop)
# 13 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\cstdio" 2 3
# 32 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\cstdio" 3
typedef FILE FILE;


namespace std {
using :: FILE; using :: _Mbstatet;

using :: size_t; using :: fpos_t; using :: FILE;
using :: clearerr; using :: fclose; using :: feof;
using :: ferror; using :: fflush; using :: fgetc;
using :: fgetpos; using :: fgets; using :: fopen;
using :: fprintf; using :: fputc; using :: fputs;
using :: fread; using :: freopen; using :: fscanf;
using :: fseek; using :: fsetpos; using :: ftell;
using :: fwrite; using :: getc; using :: getchar;
using :: perror;
using :: putc; using :: putchar;
using :: printf; using :: puts; using :: remove;
using :: rename; using :: rewind; using :: scanf;
using :: setbuf; using :: setvbuf; using :: sprintf;
using :: sscanf; using :: tmpfile; using :: tmpnam;
using :: ungetc; using :: vfprintf; using :: vprintf;
using :: vsprintf;

using :: snprintf; using :: vsnprintf;
using :: vfscanf; using :: vscanf; using :: vsscanf;
}
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\iosfwd" 2 3

# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\cstring" 1 3
# 13 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\cstring" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\string.h" 1 3
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\string.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_memory.h" 1 3
# 19 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_memory.h" 3
#pragma pack(push, 8)
# 19 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_memory.h" 3
 extern "C" {




         int __cdecl _memicmp(
                                void const* _Buf1,
                                void const* _Buf2,
                                size_t _Size
    );


         int __cdecl _memicmp_l(
                                void const* _Buf1,
                                void const* _Buf2,
                                size_t _Size,
                                _locale_t _Locale
    );
# 77 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_memory.h" 3
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_memccpy" ". See online help for details."))
             void* __cdecl memccpy(
                                      void* _Dst,
                                      void const* _Src,
                                      int _Val,
                                      size_t _Size
        );

                   __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_memicmp" ". See online help for details."))
             int __cdecl memicmp(
                                    void const* _Buf1,
                                    void const* _Buf2,
                                    size_t _Size
        );





    extern "C++"
    inline void* __cdecl memchr(
                                 void* _Pv,
                                 int _C,
                                 size_t _N
        )
    {
        void const* const _Pvc = _Pv;
        return const_cast<void*>(memchr(_Pvc, _C, _N));
    }




}
# 110 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\corecrt_memory.h" 3
#pragma pack(pop)
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\string.h" 2 3






#pragma pack(push, 8)
# 18 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\string.h" 3
 extern "C" {
# 27 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\string.h" 3
             errno_t __cdecl strcpy_s(
                                     char* _Destination,
                                     rsize_t _SizeInBytes,
                                     char const* _Source
        );


             errno_t __cdecl strcat_s(
                                        char* _Destination,
                                        rsize_t _SizeInBytes,
                                        char const* _Source
        );


             errno_t __cdecl strerror_s(
                                     char* _Buffer,
                                     size_t _SizeInBytes,
                                     int _ErrorNumber);


             errno_t __cdecl strncat_s(
                                        char* _Destination,
                                        rsize_t _SizeInBytes,
                                        char const* _Source,
                                        rsize_t _MaxCount
        );


             errno_t __cdecl strncpy_s(
                                     char* _Destination,
                                     rsize_t _SizeInBytes,
                                     char const* _Source,
                                     rsize_t _MaxCount
        );


             char* __cdecl strtok_s(
                                      char* _String,
                                      char const* _Delimiter,
                                      char** _Context
        );



         void* __cdecl _memccpy(
                                      void* _Dst,
                                      void const* _Src,
                                      int _Val,
                                      size_t _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strcat_s(char (&_Destination)[_Size], char const* _Source) throw() { return strcat_s(_Destination, _Size, _Source); } }







    char* __cdecl strcat( char *_Destination, char const* _Source);
# 95 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\string.h" 3
int __cdecl strcmp(
           char const* _Str1,
           char const* _Str2
    );


         int __cdecl _strcmpi(
           char const* _String1,
           char const* _String2
    );


         int __cdecl strcoll(
           char const* _String1,
           char const* _String2
    );


         int __cdecl _strcoll_l(
             char const* _String1,
             char const* _String2,
             _locale_t _Locale
    );

char* __cdecl strcpy(
                                                 char* _Dest,
                                                 char const* _Source
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strcpy_s(char (&_Destination)[_Size], char const* _Source) throw() { return strcpy_s(_Destination, _Size, _Source); } }





 char* __cdecl strcpy( char *_Destination, char const* _Source);






         size_t __cdecl strcspn(
           char const* _Str,
           char const* _Control
    );







         __declspec(allocator) char* __cdecl _strdup(
               char const* _Source
    );
# 159 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\string.h" 3
         char* __cdecl _strerror(
               char const* _ErrorMessage
    );


         errno_t __cdecl _strerror_s(
                                 char* _Buffer,
                                 size_t _SizeInBytes,
                                 char const* _ErrorMessage
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strerror_s(char (&_Buffer)[_Size], char const* _ErrorMessage) throw() { return _strerror_s(_Buffer, _Size, _ErrorMessage); } }







         char* __cdecl strerror(
         int _ErrorMessage
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strerror_s(char (&_Buffer)[_Size], int _ErrorMessage) throw() { return strerror_s(_Buffer, _Size, _ErrorMessage); } }






         int __cdecl _stricmp(
           char const* _String1,
           char const* _String2
    );


         int __cdecl _stricoll(
           char const* _String1,
           char const* _String2
    );


         int __cdecl _stricoll_l(
             char const* _String1,
             char const* _String2,
             _locale_t _Locale
    );


         int __cdecl _stricmp_l(
             char const* _String1,
             char const* _String2,
             _locale_t _Locale
    );


size_t __cdecl strlen(
           char const* _Str
    );


         errno_t __cdecl _strlwr_s(
                             char* _String,
                             size_t _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s(char (&_String)[_Size]) throw() { return _strlwr_s(_String, _Size); } }




 char* __cdecl _strlwr( char *_String);





         errno_t __cdecl _strlwr_s_l(
                             char* _String,
                             size_t _Size,
                             _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s_l(char (&_String)[_Size], _locale_t _Locale) throw() { return _strlwr_s_l(_String, _Size, _Locale); } }





 char* __cdecl _strlwr_l( char *_String, _locale_t _Locale);






         char* __cdecl strncat(
                              char* _Dest,
                              char const* _Source,
                              size_t _Count
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strncat_s(char (&_Destination)[_Size], char const* _Source, size_t _Count) throw() { return strncat_s(_Destination, _Size, _Source, _Count); } }






 char* __cdecl strncat( char *_Destination, char const* _Source, size_t _Count);
# 277 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\string.h" 3
         int __cdecl strncmp(
                               char const* _Str1,
                               char const* _Str2,
                               size_t _MaxCount
    );


         int __cdecl _strnicmp(
                               char const* _String1,
                               char const* _String2,
                               size_t _MaxCount
    );


         int __cdecl _strnicmp_l(
                               char const* _String1,
                               char const* _String2,
                               size_t _MaxCount,
                               _locale_t _Locale
    );


         int __cdecl _strnicoll(
                               char const* _String1,
                               char const* _String2,
                               size_t _MaxCount
    );


         int __cdecl _strnicoll_l(
                               char const* _String1,
                               char const* _String2,
                               size_t _MaxCount,
                               _locale_t _Locale
    );


         int __cdecl _strncoll(
                               char const* _String1,
                               char const* _String2,
                               size_t _MaxCount
    );


         int __cdecl _strncoll_l(
                               char const* _String1,
                               char const* _String2,
                               size_t _MaxCount,
                               _locale_t _Locale
    );

         size_t __cdecl __strncnt(
                            char const* _String,
                            size_t _Count
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strncpy_s(char (&_Destination)[_Size], char const* _Source, size_t _Count) throw() { return strncpy_s(_Destination, _Size, _Source, _Count); } }






 char* __cdecl strncpy( char *_Destination, char const* _Source, size_t _Count);
# 357 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\string.h" 3
         size_t __cdecl strnlen(
                               char const* _String,
                               size_t _MaxCount
    );
# 373 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\string.h" 3
    static __inline size_t __cdecl strnlen_s(
                                   char const* _String,
                                   size_t _MaxCount
        )
    {
        return _String == 0 ? 0 : strnlen(_String, _MaxCount);
    }



         char* __cdecl _strnset(
                              char* _Dest,
                              int _Val,
                              size_t _Count
    );


         errno_t __cdecl _strnset_s(
                                    char* _String,
                                    size_t _SizeInBytes,
                                    int _Value,
                                    size_t _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strnset_s(char (&_Destination)[_Size], int _Value, size_t _Count) throw() { return _strnset_s(_Destination, _Size, _Value, _Count); } }






 char* __cdecl _strnset( char *_Destination, int _Value, size_t _Count);
# 413 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\string.h" 3
         char const* __cdecl strpbrk(
           char const* _Str,
           char const* _Control
    );

         char* __cdecl _strrev(
              char* _Str
    );


         errno_t __cdecl _strset_s(
                                        char* _Destination,
                                        size_t _DestinationSize,
                                        int _Value
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strset_s(char (&_Destination)[_Size], int _Value) throw() { return _strset_s(_Destination, _Size, _Value); } }





 char* __cdecl _strset( char *_Destination, int _Value);





char* __cdecl _strset(
              char* _Dest,
              int _Value
    );


         size_t __cdecl strspn(
           char const* _Str,
           char const* _Control
    );


         char* __cdecl strtok(
                  char* _String,
                  char const* _Delimiter
    );


         errno_t __cdecl _strupr_s(
                             char* _String,
                             size_t _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s(char (&_String)[_Size]) throw() { return _strupr_s(_String, _Size); } }




 char* __cdecl _strupr( char *_String);





         errno_t __cdecl _strupr_s_l(
                             char* _String,
                             size_t _Size,
                             _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s_l(char (&_String)[_Size], _locale_t _Locale) throw() { return _strupr_s_l(_String, _Size, _Locale); } }





 char* __cdecl _strupr_l( char *_String, _locale_t _Locale);
# 496 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\string.h" 3
         size_t __cdecl strxfrm(
                                              char* _Destination,
                                              char const* _Source,
                                              size_t _MaxCount
    );



         size_t __cdecl _strxfrm_l(
                                              char* _Destination,
                                              char const* _Source,
                                              size_t _MaxCount,
                                              _locale_t _Locale
    );




extern "C++"
{

    inline char* __cdecl strchr( char* const _String, int const _Ch)
    {
        return const_cast<char*>(strchr(static_cast<char const*>(_String), _Ch));
    }


    inline char* __cdecl strpbrk( char* const _String, char const* const _Control)
    {
        return const_cast<char*>(strpbrk(static_cast<char const*>(_String), _Control));
    }


    inline char* __cdecl strrchr( char* const _String, int const _Ch)
    {
        return const_cast<char*>(strrchr(static_cast<char const*>(_String), _Ch));
    }


    inline char* __cdecl strstr( char* const _String, char const* const _SubString)
    {
        return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));
    }
}
# 551 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\string.h" 3
                   __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strdup" ". See online help for details."))
             char* __cdecl strdup(
                   char const* _String
        );






                   __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strcmpi" ". See online help for details."))
             int __cdecl strcmpi(
               char const* _String1,
               char const* _String2
        );

                   __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_stricmp" ". See online help for details."))
             int __cdecl stricmp(
               char const* _String1,
               char const* _String2
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strlwr" ". See online help for details."))
             char* __cdecl strlwr(
                  char* _String
        );

                   __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strnicmp" ". See online help for details."))
             int __cdecl strnicmp(
                                   char const* _String1,
                                   char const* _String2,
                                   size_t _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strnset" ". See online help for details."))
             char* __cdecl strnset(
                                     char* _String,
                                     int _Value,
                                     size_t _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strrev" ". See online help for details."))
             char* __cdecl strrev(
                  char* _String
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strset" ". See online help for details."))
    char* __cdecl strset(
                  char* _String,
                  int _Value);

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strupr" ". See online help for details."))
             char* __cdecl strupr(
                  char* _String
        );





}
# 611 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\string.h" 3
#pragma pack(pop)
# 13 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\cstring" 2 3




namespace std {
using :: size_t; using :: memchr; using :: memcmp;
using :: memcpy; using :: memmove; using :: memset;
using :: strcat; using :: strchr; using :: strcmp;
using :: strcoll; using :: strcpy; using :: strcspn;
using :: strerror; using :: strlen; using :: strncat;
using :: strncmp; using :: strncpy; using :: strpbrk;
using :: strrchr; using :: strspn; using :: strstr;
using :: strtok; using :: strxfrm;
}
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\iosfwd" 2 3




# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\crtdbg.h" 1 3
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\crtdbg.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime_new_debug.h" 1 3
# 13 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime_new_debug.h" 3
extern "C++" {

#pragma pack(push, 8)







 __declspec(allocator) void* __cdecl operator new(
               size_t _Size,
               int _BlockUse,
               char const* _FileName,
               int _LineNumber
        );


    __declspec(allocator) void* __cdecl operator new[](
               size_t _Size,
               int _BlockUse,
               char const* _FileName,
               int _LineNumber
        );

    void __cdecl operator delete(
        void* _Block,
        int _BlockUse,
        char const* _FileName,
        int _LineNumber
        ) throw();

    void __cdecl operator delete[](
        void* _Block,
        int _BlockUse,
        char const* _FileName,
        int _LineNumber
        ) throw();





#pragma pack(pop)

}
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\crtdbg.h" 2 3


#pragma pack(push, 8)
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\crtdbg.h" 3
 extern "C" {



typedef void* _HFILE;
# 44 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\crtdbg.h" 3
typedef int (__cdecl* _CRT_REPORT_HOOK )(int, char*, int*);
typedef int (__cdecl* _CRT_REPORT_HOOKW)(int, wchar_t*, int*);





typedef int (__cdecl* _CRT_ALLOC_HOOK)(int, void*, size_t, int, long, unsigned char const*, int);
# 107 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\crtdbg.h" 3
typedef void (__cdecl* _CRT_DUMP_CLIENT)(void*, size_t);





struct _CrtMemBlockHeader;

typedef struct _CrtMemState
{
    struct _CrtMemBlockHeader* pBlockHeader;
    size_t lCounts[5];
    size_t lSizes[5];
    size_t lHighWaterCount;
    size_t lTotalCount;
} _CrtMemState;
# 808 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\crtdbg.h" 3
}
# 808 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\crtdbg.h" 3
#pragma pack(pop)
# 11 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\iosfwd" 2 3


#pragma pack(push,8)
#pragma warning(push, 3)



namespace std {


typedef _Longlong streamoff;
typedef _Longlong streamsize;
# 31 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\iosfwd" 3
extern const streamoff _BADOFF;



template<class _Statetype>
 class fpos
 {
 typedef fpos<_Statetype> _Myt;

public:
                    fpos(streamoff _Off = 0)
  : _Myoff(_Off), _Fpos(0), _Mystate()
  {
  }

                    fpos(_Statetype _State, fpos_t _Fileposition)
  : _Myoff(0), _Fpos(_Fileposition), _Mystate(_State)
  {
  }

 _Statetype state() const
  {
  return (_Mystate);
  }

 void state(_Statetype _State)
  {
  _Mystate = _State;
  }

 fpos_t seekpos() const
  {
  return (_Fpos);
  }

                    operator streamoff() const
  {
  return ((streamoff)(_Myoff + ((long long)(_Fpos))));
  }

 streamoff operator-(const _Myt& _Right) const
  {
  return ((streamoff)*this - (streamoff)_Right);
  }

 _Myt& operator+=(streamoff _Off)
  {
  _Myoff += _Off;
  return (*this);
  }

 _Myt& operator-=(streamoff _Off)
  {
  _Myoff -= _Off;
  return (*this);
  }

 _Myt operator+(streamoff _Off) const
  {
  _Myt _Tmp = *this;
  return (_Tmp += _Off);
  }

 _Myt operator-(streamoff _Off) const
  {
  _Myt _Tmp = *this;
  return (_Tmp -= _Off);
  }

 bool operator==(const _Myt& _Right) const
  {
  return ((streamoff)*this == (streamoff)_Right);
  }

 bool operator==(streamoff _Right) const
  {
  return ((streamoff)*this == _Right);
  }

 bool operator!=(const _Myt& _Right) const
  {
  return (!(*this == _Right));
  }

private:
 streamoff _Myoff;
 fpos_t _Fpos;
 _Statetype _Mystate;
 };






typedef fpos<_Mbstatet> streampos;

typedef streampos wstreampos;


template<class _Elem,
 class _Int_type>
 struct _Char_traits
 {
 typedef _Elem char_type;
 typedef _Int_type int_type;
 typedef streampos pos_type;
 typedef streamoff off_type;
 typedef _Mbstatet state_type;

 static int __cdecl compare(
                     const _Elem *_First1,
                     const _Elem *_First2, size_t _Count)
  {
  for (; 0 < _Count; --_Count, ++_First1, ++_First2)
   if (!eq(*_First1, *_First2))
    return (lt(*_First1, *_First2) ? -1 : +1);
  return (0);
  }

 static size_t __cdecl length( const _Elem *_First)
  {
  size_t _Count;
  for (_Count = 0; !eq(*_First, _Elem()); ++_First)
   ++_Count;
  return (_Count);
  }

 static _Elem *__cdecl copy(
                       _Elem *_First1,
                     const _Elem *_First2, size_t _Count)
  {
  _Elem *_Next = _First1;
  for (; 0 < _Count; --_Count, ++_Next, ++_First2)
   assign(*_Next, *_First2);
  return (_First1);
  }

 static _Elem *__cdecl _Copy_s(
                           _Elem *_First1, size_t _Dest_size,
                     const _Elem *_First2, size_t _Count)
  {
  { if (!(_Count <= _Dest_size)) { ((void)0); ::_invalid_parameter_noinfo_noreturn(); return (0); } };
  return (copy(_First1, _First2, _Count));
  }

 static const _Elem *__cdecl find(
                     const _Elem *_First,
  size_t _Count, const _Elem& _Ch)
  {
  for (; 0 < _Count; --_Count, ++_First)
   if (eq(*_First, _Ch))
    return (_First);
  return (0);
  }

 static _Elem *__cdecl move(
                       _Elem *_First1,
                     const _Elem *_First2, size_t _Count)
  {
  _Elem *_Next = _First1;
  if (_First2 < _Next && _Next < _First2 + _Count)
   for (_Next += _Count, _First2 += _Count; 0 < _Count; --_Count)
    assign(*--_Next, *--_First2);
  else
   for (; 0 < _Count; --_Count, ++_Next, ++_First2)
    assign(*_Next, *_First2);
  return (_First1);
  }

 static _Elem *__cdecl assign(
                       _Elem *_First,
  size_t _Count, _Elem _Ch)
  {
  _Elem *_Next = _First;
  for (; 0 < _Count; --_Count, ++_Next)
   assign(*_Next, _Ch);
  return (_First);
  }

 static void __cdecl assign(_Elem& _Left, const _Elem& _Right) noexcept
  {
  _Left = _Right;
  }

 static constexpr bool __cdecl eq(const _Elem& _Left,
  const _Elem& _Right) noexcept
  {
  return (_Left == _Right);
  }

 static constexpr bool __cdecl lt(const _Elem& _Left,
  const _Elem& _Right) noexcept
  {
  return (_Left < _Right);
  }

 static constexpr _Elem __cdecl to_char_type(
  const int_type& _Meta) noexcept
  {
  return ((_Elem)_Meta);
  }

 static constexpr int_type __cdecl to_int_type(
  const _Elem& _Ch) noexcept
  {
  return ((int_type)_Ch);
  }

 static constexpr bool __cdecl eq_int_type(const int_type& _Left,
  const int_type& _Right) noexcept
  {
  return (_Left == _Right);
  }

 static constexpr int_type __cdecl not_eof(
  const int_type& _Meta) noexcept
  {
  return (_Meta != eof() ? (int_type)_Meta : (int_type)!eof());
  }

 static constexpr int_type __cdecl eof() noexcept
  {
  return ((int_type)(-1));
  }
 };


template<class _Elem>
 struct char_traits
  : public _Char_traits<_Elem, long>
 {
 };


template<>
 struct char_traits<char16_t>
 : public _Char_traits<char16_t, unsigned short>
 {
 };

typedef streampos u16streampos;


template<>
 struct char_traits<char32_t>
 : public _Char_traits<char32_t, unsigned int>
 {
 };

typedef streampos u32streampos;


template<>
 struct char_traits<wchar_t>
 {
 typedef wchar_t _Elem;
 typedef _Elem char_type;
 typedef wint_t int_type;
 typedef streampos pos_type;
 typedef streamoff off_type;
 typedef _Mbstatet state_type;

 static int __cdecl compare(const _Elem *_First1, const _Elem *_First2,
  size_t _Count)
  {
  return (_Count == 0 ? 0
   : :: wmemcmp(_First1, _First2, _Count));
  }

 static size_t __cdecl length(const _Elem *_First)
  {
  return (*_First == 0 ? 0
   : :: wcslen(_First));
  }

 static _Elem *__cdecl copy(_Elem *_First1, const _Elem *_First2,
  size_t _Count)
  {
  return (_Count == 0 ? _First1
   : (_Elem *):: wmemcpy(_First1, _First2, _Count));
  }

 static _Elem *__cdecl _Copy_s(
                               _Elem *_First1, size_t _Size_in_words,
                     const _Elem *_First2, size_t _Count)
  {
  if (0 < _Count)
   ::wmemcpy_s((_First1), (_Size_in_words), (_First2), (_Count));
  return (_First1);
  }

 static const _Elem *__cdecl find(const _Elem *_First, size_t _Count,
  const _Elem& _Ch)
  {
  return (_Count == 0 ? (const _Elem *)0
   : (const _Elem *):: wmemchr(_First, _Ch, _Count));
  }

 static _Elem *__cdecl move(_Elem *_First1, const _Elem *_First2,
  size_t _Count)
  {
  return (_Count == 0 ? _First1
   : (_Elem *):: wmemmove(_First1, _First2, _Count));
  }

 static _Elem *__cdecl assign(_Elem *_First, size_t _Count,
  _Elem _Ch)
  {
  return ((_Elem *):: wmemset(_First, _Ch, _Count));
  }

 static void __cdecl assign(_Elem& _Left, const _Elem& _Right) noexcept
  {
  _Left = _Right;
  }

 static constexpr bool __cdecl eq(const _Elem& _Left,
  const _Elem& _Right) noexcept
  {
  return (_Left == _Right);
  }

 static constexpr bool __cdecl lt(const _Elem& _Left,
  const _Elem& _Right) noexcept
  {
  return (_Left < _Right);
  }

 static constexpr _Elem __cdecl to_char_type(
  const int_type& _Meta) noexcept
  {
  return (_Meta);
  }

 static constexpr int_type __cdecl to_int_type(
  const _Elem& _Ch) noexcept
  {
  return (_Ch);
  }

 static constexpr bool __cdecl eq_int_type(const int_type& _Left,
  const int_type& _Right) noexcept
  {
  return (_Left == _Right);
  }

 static constexpr int_type __cdecl not_eof(
  const int_type& _Meta) noexcept
  {
  return (_Meta != eof() ? _Meta : !eof());
  }

 static constexpr int_type __cdecl eof() noexcept
  {
  return (((wint_t)(0xFFFF)));
  }
 };



template<>
 struct char_traits<unsigned short>
 {
 typedef unsigned short _Elem;
 typedef _Elem char_type;
 typedef wint_t int_type;
 typedef streampos pos_type;
 typedef streamoff off_type;
 typedef _Mbstatet state_type;

 static int __cdecl compare(const _Elem *_First1, const _Elem *_First2,
  size_t _Count)
  {
  return (_Count == 0 ? 0
   : :: wmemcmp((const wchar_t *)_First1,
    (const wchar_t *)_First2, _Count));
  }

 static size_t __cdecl length(const _Elem *_First)
  {
  return (*_First == 0 ? 0
   : :: wcslen((const wchar_t *)_First));
  }

 static _Elem *__cdecl copy(_Elem *_First1, const _Elem *_First2,
  size_t _Count)
  {
  return (_Count == 0 ? _First1
   : (_Elem *):: wmemcpy((wchar_t *)_First1,
    (const wchar_t *)_First2, _Count));
  }

 static _Elem *__cdecl _Copy_s(
                               _Elem *_First1, size_t _Size_in_words,
                     const _Elem *_First2, size_t _Count)
  {
  if (0 < _Count)
   ::wmemcpy_s(((wchar_t *)_First1), (_Size_in_words), ((const wchar_t *)_First2), (_Count));

  return (_First1);
  }

 static const _Elem *__cdecl find(const _Elem *_First, size_t _Count,
  const _Elem& _Ch)
  {
  return (_Count == 0 ? (const _Elem *)0
   : (const _Elem *):: wmemchr((const wchar_t *)_First,
    _Ch, _Count));
  }

 static _Elem *__cdecl move(_Elem *_First1, const _Elem *_First2,
  size_t _Count)
  {
  return (_Count == 0 ? _First1
   : (_Elem *):: wmemmove((wchar_t *)_First1,
    (const wchar_t *)_First2, _Count));
  }

 static _Elem *__cdecl assign(_Elem *_First, size_t _Count,
  _Elem _Ch)
  {
  return ((_Elem *):: wmemset((wchar_t *)_First, _Ch, _Count));
  }

 static void __cdecl assign(_Elem& _Left, const _Elem& _Right) noexcept
  {
  _Left = _Right;
  }

 static constexpr bool __cdecl eq(const _Elem& _Left,
  const _Elem& _Right) noexcept
  {
  return (_Left == _Right);
  }

 static constexpr bool __cdecl lt(const _Elem& _Left,
  const _Elem& _Right) noexcept
  {
  return (_Left < _Right);
  }

 static constexpr _Elem __cdecl to_char_type(const int_type& _Meta)
  noexcept
  {
  return (_Meta);
  }

 static constexpr int_type __cdecl to_int_type(const _Elem& _Ch)
  noexcept
  {
  return (_Ch);
  }

 static constexpr bool __cdecl eq_int_type(const int_type& _Left,
  const int_type& _Right) noexcept
  {
  return (_Left == _Right);
  }

 static constexpr int_type __cdecl not_eof(const int_type& _Meta)
  noexcept
  {
  return (_Meta != eof() ? _Meta : !eof());
  }

 static constexpr int_type __cdecl eof() noexcept
  {
  return (((wint_t)(0xFFFF)));
  }
 };



template<> struct char_traits<char>
 {
 typedef char _Elem;
 typedef _Elem char_type;
 typedef int int_type;
 typedef streampos pos_type;
 typedef streamoff off_type;
 typedef _Mbstatet state_type;

 static int __cdecl compare(const _Elem *_First1, const _Elem *_First2,
  size_t _Count)
  {
  return (_Count == 0 ? 0
   : :: memcmp(_First1, _First2, _Count));
  }

 static size_t __cdecl length(const _Elem *_First)
  {
  return (*_First == 0 ? 0
   : :: strlen(_First));
  }

 static _Elem *__cdecl copy(_Elem *_First1, const _Elem *_First2,
  size_t _Count)
  {
  return (_Count == 0 ? _First1
   : (_Elem *):: memcpy(_First1, _First2, _Count));
  }

 static _Elem *__cdecl _Copy_s(
                               _Elem *_First1, size_t _Size_in_bytes,
                     const _Elem *_First2, size_t _Count)
  {
  if (0 < _Count)
   ::memcpy_s((_First1), (_Size_in_bytes), (_First2), (_Count));
  return (_First1);
  }

 static const _Elem *__cdecl find(const _Elem *_First, size_t _Count,
  const _Elem& _Ch)
  {
  return (_Count == 0 ? (const _Elem *)0
   : (const _Elem *):: memchr(_First, _Ch, _Count));
  }

 static _Elem *__cdecl move(_Elem *_First1, const _Elem *_First2,
  size_t _Count)
  {
  return (_Count == 0 ? _First1
   : (_Elem *):: memmove(_First1, _First2, _Count));
  }

 static _Elem *__cdecl assign(_Elem *_First, size_t _Count,
  _Elem _Ch)
  {
  return ((_Elem *):: memset(_First, _Ch, _Count));
  }

 static void __cdecl assign(_Elem& _Left, const _Elem& _Right) noexcept
  {
  _Left = _Right;
  }

 static constexpr bool __cdecl eq(const _Elem& _Left,
  const _Elem& _Right) noexcept
  {
  return (_Left == _Right);
  }

 static constexpr bool __cdecl lt(const _Elem& _Left,
  const _Elem& _Right) noexcept
  {
  return ((unsigned char)_Left < (unsigned char)_Right);
  }

 static constexpr _Elem __cdecl to_char_type(
  const int_type& _Meta) noexcept
  {
  return ((_Elem)_Meta);
  }

 static constexpr int_type __cdecl to_int_type(
  const _Elem& _Ch) noexcept
  {
  return ((unsigned char)_Ch);
  }

 static constexpr bool __cdecl eq_int_type(const int_type& _Left,
  const int_type& _Right) noexcept
  {
  return (_Left == _Right);
  }

 static constexpr int_type __cdecl not_eof(
  const int_type& _Meta) noexcept
  {
  return (_Meta != eof() ? _Meta : !eof());
  }

 static constexpr int_type __cdecl eof() noexcept
  {
  return ((-1));
  }
 };


template<class _Ty>
 class allocator;
class ios_base;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_ios;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class istreambuf_iterator;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class ostreambuf_iterator;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_streambuf;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_istream;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_ostream;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_iostream;
template<class _Elem,
 class _Traits = char_traits<_Elem>,
 class _Alloc = allocator<_Elem> >
 class basic_stringbuf;
template<class _Elem,
 class _Traits = char_traits<_Elem>,
 class _Alloc = allocator<_Elem> >
 class basic_istringstream;
template<class _Elem,
 class _Traits = char_traits<_Elem>,
 class _Alloc = allocator<_Elem> >
 class basic_ostringstream;
template<class _Elem,
 class _Traits = char_traits<_Elem>,
 class _Alloc = allocator<_Elem> >
 class basic_stringstream;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_filebuf;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_ifstream;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_ofstream;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_fstream;
# 676 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\iosfwd" 3
typedef basic_ios<char, char_traits<char> > ios;
typedef basic_streambuf<char, char_traits<char> > streambuf;
typedef basic_istream<char, char_traits<char> > istream;
typedef basic_ostream<char, char_traits<char> > ostream;
typedef basic_iostream<char, char_traits<char> > iostream;
typedef basic_stringbuf<char, char_traits<char>,
 allocator<char> > stringbuf;
typedef basic_istringstream<char, char_traits<char>,
 allocator<char> > istringstream;
typedef basic_ostringstream<char, char_traits<char>,
 allocator<char> > ostringstream;
typedef basic_stringstream<char, char_traits<char>,
 allocator<char> > stringstream;
typedef basic_filebuf<char, char_traits<char> > filebuf;
typedef basic_ifstream<char, char_traits<char> > ifstream;
typedef basic_ofstream<char, char_traits<char> > ofstream;
typedef basic_fstream<char, char_traits<char> > fstream;


typedef basic_ios<wchar_t, char_traits<wchar_t> > wios;
typedef basic_streambuf<wchar_t, char_traits<wchar_t> >
 wstreambuf;
typedef basic_istream<wchar_t, char_traits<wchar_t> > wistream;
typedef basic_ostream<wchar_t, char_traits<wchar_t> > wostream;
typedef basic_iostream<wchar_t, char_traits<wchar_t> > wiostream;
typedef basic_stringbuf<wchar_t, char_traits<wchar_t>,
 allocator<wchar_t> > wstringbuf;
typedef basic_istringstream<wchar_t, char_traits<wchar_t>,
 allocator<wchar_t> > wistringstream;
typedef basic_ostringstream<wchar_t, char_traits<wchar_t>,
 allocator<wchar_t> > wostringstream;
typedef basic_stringstream<wchar_t, char_traits<wchar_t>,
 allocator<wchar_t> > wstringstream;
typedef basic_filebuf<wchar_t, char_traits<wchar_t> > wfilebuf;
typedef basic_ifstream<wchar_t, char_traits<wchar_t> > wifstream;
typedef basic_ofstream<wchar_t, char_traits<wchar_t> > wofstream;
typedef basic_fstream<wchar_t, char_traits<wchar_t> > wfstream;
# 748 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\iosfwd" 3
}


#pragma warning(pop)
#pragma pack(pop)
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\utility" 2 3



#pragma pack(push,8)
#pragma warning(push, 3)



#pragma warning(disable: 4180 4512)

namespace std {

template<class _FwdIt1,
 class _FwdIt2> inline
 void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right)
 {
 swap(*_Left, *_Right);
 }


template<class _Ty,
 size_t _Size,
 class> inline
 void swap(_Ty (&_Left)[_Size], _Ty (&_Right)[_Size])
  noexcept(_Is_nothrow_swappable<_Ty>::value)
 {
 if (&_Left != &_Right)
  {
  _Ty *_First1 = _Left;
  _Ty *_Last1 = _First1 + _Size;
  _Ty *_First2 = _Right;
  for (; _First1 != _Last1; ++_First1, ++_First2)
   ::std:: iter_swap(_First1, _First2);
  }
 }

template<class _Ty,
 class> inline
 void swap(_Ty& _Left, _Ty& _Right)
  noexcept(is_nothrow_move_constructible<_Ty>::value && is_nothrow_move_assignable<_Ty>::value)

 {
 _Ty _Tmp = ::std:: move(_Left);
 _Left = ::std:: move(_Right);
 _Right = ::std:: move(_Tmp);
 }


template<class _Ty> inline
 void _Swap_adl(_Ty& _Left, _Ty& _Right)
  noexcept(_Is_nothrow_swappable<_Ty>::value)
 {
 swap(_Left, _Right);
 }


struct piecewise_construct_t
 {
 };

constexpr piecewise_construct_t piecewise_construct{};


template<class...>
 class tuple;

template<class _Ty1,
 class _Ty2>
 struct pair
 {
 typedef pair<_Ty1, _Ty2> _Myt;
 typedef _Ty1 first_type;
 typedef _Ty2 second_type;

 template<class _Uty1 = _Ty1,
  class _Uty2 = _Ty2,
  class = enable_if_t<is_default_constructible<_Uty1>::value
      && is_default_constructible<_Uty2>::value> >
  constexpr pair()
  : first(), second()
  {
  }

 template<class _Uty1 = _Ty1,
  class _Uty2 = _Ty2,
  class = enable_if_t<is_copy_constructible<_Uty1>::value
      && is_copy_constructible<_Uty2>::value>,
  enable_if_t<is_convertible<const _Uty1&, _Uty1>::value
    && is_convertible<const _Uty2&, _Uty2>::value, int> = 0>
  constexpr pair(const _Ty1& _Val1, const _Ty2& _Val2)
  : first(_Val1), second(_Val2)
  {
  }

 template<class _Uty1 = _Ty1,
  class _Uty2 = _Ty2,
  class = enable_if_t<is_copy_constructible<_Uty1>::value
      && is_copy_constructible<_Uty2>::value>,
  enable_if_t<!is_convertible<const _Uty1&, _Uty1>::value
    || !is_convertible<const _Uty2&, _Uty2>::value, int> = 0>
  constexpr explicit pair(const _Ty1& _Val1, const _Ty2& _Val2)
  : first(_Val1), second(_Val2)
  {
  }

 pair(const pair&) = default;
 pair(pair&&) = default;

 template<class _Other1,
  class _Other2,
  class = enable_if_t<is_constructible<_Ty1, const _Other1&>::value
      && is_constructible<_Ty2, const _Other2&>::value>,
  enable_if_t<is_convertible<const _Other1&, _Ty1>::value
    && is_convertible<const _Other2&, _Ty2>::value, int> = 0>
  constexpr pair(const pair<_Other1, _Other2>& _Right)
  : first(_Right.first), second(_Right.second)
  {
  }

 template<class _Other1,
  class _Other2,
  class = enable_if_t<is_constructible<_Ty1, const _Other1&>::value
      && is_constructible<_Ty2, const _Other2&>::value>,
  enable_if_t<!is_convertible<const _Other1&, _Ty1>::value
    || !is_convertible<const _Other2&, _Ty2>::value, int> = 0>
  constexpr explicit pair(const pair<_Other1, _Other2>& _Right)
  : first(_Right.first), second(_Right.second)
  {
  }

 template<class _Other1,
  class _Other2>
  _Myt& operator=(const pair<_Other1, _Other2>& _Right)
  {
  first = _Right.first;
  second = _Right.second;
  return (*this);
  }

 template<class _Tuple1,
  class _Tuple2,
  size_t... _Indexes1,
  size_t... _Indexes2> inline
  pair(_Tuple1& _Val1,
   _Tuple2& _Val2,
   integer_sequence<size_t, _Indexes1...>,
   integer_sequence<size_t, _Indexes2...>);

 template<class... _Types1,
  class... _Types2> inline
  pair(piecewise_construct_t,
   tuple<_Types1...> _Val1,
   tuple<_Types2...> _Val2);

 template<class _Other1,
  class _Other2,
  class = enable_if_t<is_constructible<_Ty1, _Other1>::value
      && is_constructible<_Ty2, _Other2>::value>,
  enable_if_t<is_convertible<_Other1, _Ty1>::value
    && is_convertible<_Other2, _Ty2>::value, int> = 0>
  constexpr pair(_Other1&& _Val1, _Other2&& _Val2)
   noexcept((is_nothrow_constructible<_Ty1, _Other1>::value && is_nothrow_constructible<_Ty2, _Other2>::value))

  : first(::std:: forward<_Other1>(_Val1)),
    second(::std:: forward<_Other2>(_Val2))
  {
  }

 template<class _Other1,
  class _Other2,
  class = enable_if_t<is_constructible<_Ty1, _Other1>::value
      && is_constructible<_Ty2, _Other2>::value>,
  enable_if_t<!is_convertible<_Other1, _Ty1>::value
    || !is_convertible<_Other2, _Ty2>::value, int> = 0>
  constexpr explicit pair(_Other1&& _Val1, _Other2&& _Val2)
   noexcept((is_nothrow_constructible<_Ty1, _Other1>::value && is_nothrow_constructible<_Ty2, _Other2>::value))

  : first(::std:: forward<_Other1>(_Val1)),
    second(::std:: forward<_Other2>(_Val2))
  {
  }

 template<class _Other1,
  class _Other2,
  class = enable_if_t<is_constructible<_Ty1, _Other1>::value
      && is_constructible<_Ty2, _Other2>::value>,
  enable_if_t<is_convertible<_Other1, _Ty1>::value
    && is_convertible<_Other2, _Ty2>::value, int> = 0>
  constexpr pair(pair<_Other1, _Other2>&& _Right)
   noexcept((is_nothrow_constructible<_Ty1, _Other1>::value && is_nothrow_constructible<_Ty2, _Other2>::value))

  : first(::std:: forward<_Other1>(_Right.first)),
   second(::std:: forward<_Other2>(_Right.second))
  {
  }

 template<class _Other1,
  class _Other2,
  class = enable_if_t<is_constructible<_Ty1, _Other1>::value
      && is_constructible<_Ty2, _Other2>::value>,
  enable_if_t<!is_convertible<_Other1, _Ty1>::value
    || !is_convertible<_Other2, _Ty2>::value, int> = 0>
  constexpr explicit pair(pair<_Other1, _Other2>&& _Right)
   noexcept((is_nothrow_constructible<_Ty1, _Other1>::value && is_nothrow_constructible<_Ty2, _Other2>::value))

  : first(::std:: forward<_Other1>(_Right.first)),
   second(::std:: forward<_Other2>(_Right.second))
  {
  }

 template<class _Other1,
  class _Other2>
  _Myt& operator=(pair<_Other1, _Other2>&& _Right)
  {
  first = ::std:: forward<_Other1>(_Right.first);
  second = ::std:: forward<_Other2>(_Right.second);
  return (*this);
  }

 _Myt& operator=(_Myt&& _Right)
  noexcept((is_nothrow_move_assignable<_Ty1>::value && is_nothrow_move_assignable<_Ty2>::value))

  {
  first = ::std:: forward<_Ty1>(_Right.first);
  second = ::std:: forward<_Ty2>(_Right.second);
  return (*this);
  }

 _Myt& operator=(const _Myt& _Right)
  {
  first = _Right.first;
  second = _Right.second;
  return (*this);
  }

 _Ty1 first;
 _Ty2 second;

 void swap(_Myt& _Right)
  noexcept(_Is_nothrow_swappable<_Ty1>::value && _Is_nothrow_swappable<_Ty2>::value)

  {
  if (this != &_Right)
   {
   _Swap_adl(first, _Right.first);
   _Swap_adl(second, _Right.second);
   }
  }
 };



template<class _Ty1,
 class _Ty2,
 class = enable_if_t<_Is_swappable<_Ty1>::value && _Is_swappable<_Ty2>::value>> inline
 void swap(pair<_Ty1, _Ty2>& _Left, pair<_Ty1, _Ty2>& _Right)
  noexcept(noexcept(_Left.swap(_Right)))
 {
 _Left.swap(_Right);
 }

template<class _Ty1,
 class _Ty2> inline
 constexpr bool operator==(const pair<_Ty1, _Ty2>& _Left,
  const pair<_Ty1, _Ty2>& _Right)
 {
 return (_Left.first == _Right.first && _Left.second == _Right.second);
 }

template<class _Ty1,
 class _Ty2> inline
 constexpr bool operator!=(const pair<_Ty1, _Ty2>& _Left,
  const pair<_Ty1, _Ty2>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _Ty1,
 class _Ty2> inline
 constexpr bool operator<(const pair<_Ty1, _Ty2>& _Left,
  const pair<_Ty1, _Ty2>& _Right)
 {
 return (_Left.first < _Right.first ||
  (!(_Right.first < _Left.first) && _Left.second < _Right.second));
 }

template<class _Ty1,
 class _Ty2> inline
 constexpr bool operator>(const pair<_Ty1, _Ty2>& _Left,
  const pair<_Ty1, _Ty2>& _Right)
 {
 return (_Right < _Left);
 }

template<class _Ty1,
 class _Ty2> inline
 constexpr bool operator<=(const pair<_Ty1, _Ty2>& _Left,
  const pair<_Ty1, _Ty2>& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _Ty1,
 class _Ty2> inline
 constexpr bool operator>=(const pair<_Ty1, _Ty2>& _Left,
  const pair<_Ty1, _Ty2>& _Right)
 {
 return (!(_Left < _Right));
 }



template<class _Ty1,
 class _Ty2> inline
 constexpr pair<typename _Unrefwrap<_Ty1>::type,
  typename _Unrefwrap<_Ty2>::type>
  make_pair(_Ty1&& _Val1, _Ty2&& _Val2)
 {
 typedef pair<typename _Unrefwrap<_Ty1>::type,
  typename _Unrefwrap<_Ty2>::type> _Mypair;
 return (_Mypair(::std:: forward<_Ty1>(_Val1),
  ::std:: forward<_Ty2>(_Val2)));
 }


 namespace rel_ops
  {
template<class _Ty> inline
 bool operator!=(const _Ty& _Left, const _Ty& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _Ty> inline
 bool operator>(const _Ty& _Left, const _Ty& _Right)
 {
 return (_Right < _Left);
 }

template<class _Ty> inline
 bool operator<=(const _Ty& _Left, const _Ty& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _Ty> inline
 bool operator>=(const _Ty& _Left, const _Ty& _Right)
 {
 return (!(_Left < _Right));
 }
  }
}

namespace std {
template<class _Ty,
 size_t _Size>
 class array;


template<class _Tuple>
 struct tuple_size;

template<class _Ty,
 size_t _Size>
 struct tuple_size<array<_Ty, _Size> >
  : integral_constant<size_t, _Size>
 {
 };

template<class _Ty1,
 class _Ty2>
 struct tuple_size<pair<_Ty1, _Ty2> >
 : integral_constant<size_t, 2>
 {
 };

template<class... _Types>
 struct tuple_size<tuple<_Types...> >
 : integral_constant<size_t, sizeof...(_Types)>
 {
 };


template<class _Tuple>
 struct tuple_size<const _Tuple>
 : tuple_size<_Tuple>
 {
 };

template<class _Tuple>
 struct tuple_size<volatile _Tuple>
 : tuple_size<_Tuple>
 {
 };

template<class _Tuple>
 struct tuple_size<const volatile _Tuple>
 : tuple_size<_Tuple>
 {
 };


template<class _Ty>
 constexpr size_t tuple_size_v = tuple_size<_Ty>::value;



template<size_t _Index,
 class _Tuple>
 struct tuple_element;

template<size_t _Idx,
 class _Ty,
 size_t _Size>
 struct tuple_element<_Idx, array<_Ty, _Size> >
 {
 static_assert(_Idx < _Size, "array index out of bounds");

 typedef _Ty type;
 };

template<class _Ty1,
 class _Ty2>
 struct tuple_element<0, pair<_Ty1, _Ty2> >
 {
 typedef _Ty1 type;
 };

template<class _Ty1,
 class _Ty2>
 struct tuple_element<1, pair<_Ty1, _Ty2> >
 {
 typedef _Ty2 type;
 };

template<size_t _Index>
 struct tuple_element<_Index, tuple<> >
 {
 static_assert(_Always_false<integral_constant<size_t, _Index> >::value,
  "tuple index out of bounds");
 };

template<class _This,
 class... _Rest>
 struct tuple_element<0, tuple<_This, _Rest...> >
 {
 typedef _This type;
 typedef tuple<_This, _Rest...> _Ttype;
 };

template<size_t _Index,
 class _This,
 class... _Rest>
 struct tuple_element<_Index, tuple<_This, _Rest...> >
  : public tuple_element<_Index - 1, tuple<_Rest...> >
 {
 };


template<size_t _Index,
 class _Tuple>
 struct tuple_element<_Index, const _Tuple>
  : public tuple_element<_Index, _Tuple>
 {
 typedef tuple_element<_Index, _Tuple> _Mybase;
 typedef typename add_const<typename _Mybase::type>::type type;
 };

template<size_t _Index,
 class _Tuple>
 struct tuple_element<_Index, volatile _Tuple>
  : public tuple_element<_Index, _Tuple>
 {
 typedef tuple_element<_Index, _Tuple> _Mybase;
 typedef typename add_volatile<typename _Mybase::type>::type type;
 };

template<size_t _Index,
 class _Tuple>
 struct tuple_element<_Index, const volatile _Tuple>
  : public tuple_element<_Index, _Tuple>
 {
 typedef tuple_element<_Index, _Tuple> _Mybase;
 typedef typename add_cv<typename _Mybase::type>::type type;
 };

template<size_t _Index,
 class _Tuple>
 using tuple_element_t = typename tuple_element<_Index, _Tuple>::type;


template<class _Ret,
 class _Pair> inline
 constexpr _Ret _Pair_get(_Pair& _Pr,
  integral_constant<size_t, 0>) noexcept
 {
 return (_Pr.first);
 }

template<class _Ret,
 class _Pair> inline
 constexpr _Ret _Pair_get(_Pair& _Pr,
  integral_constant<size_t, 1>) noexcept
 {
 return (_Pr.second);
 }

template<size_t _Idx,
 class _Ty1,
 class _Ty2> inline
 constexpr typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&
  get(pair<_Ty1, _Ty2>& _Pr) noexcept
 {
 typedef typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type& _Rtype;
 return (_Pair_get<_Rtype>(_Pr, integral_constant<size_t, _Idx>()));
 }

template<class _Ty1,
 class _Ty2> inline
 constexpr _Ty1& get(pair<_Ty1, _Ty2>& _Pr) noexcept
 {
 return (::std:: get<0>(_Pr));
 }

template<class _Ty2,
 class _Ty1> inline
 constexpr _Ty2& get(pair<_Ty1, _Ty2>& _Pr) noexcept
 {
 return (::std:: get<1>(_Pr));
 }

template<size_t _Idx,
 class _Ty1,
 class _Ty2> inline
 constexpr const typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&
  get(const pair<_Ty1, _Ty2>& _Pr) noexcept
 {
 typedef const typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&
  _Ctype;
 return (_Pair_get<_Ctype>(_Pr, integral_constant<size_t, _Idx>()));
 }

template<class _Ty1,
 class _Ty2> inline
 constexpr const _Ty1& get(const pair<_Ty1, _Ty2>& _Pr) noexcept
 {
 return (::std:: get<0>(_Pr));
 }

template<class _Ty2,
 class _Ty1> inline
 constexpr const _Ty2& get(const pair<_Ty1, _Ty2>& _Pr) noexcept
 {
 return (::std:: get<1>(_Pr));
 }

template<size_t _Idx,
 class _Ty1,
 class _Ty2> inline
 constexpr typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&&
  get(pair<_Ty1, _Ty2>&& _Pr) noexcept
 {
 typedef typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&& _RRtype;
 return (::std:: forward<_RRtype>(::std:: get<_Idx>(_Pr)));
 }

template<class _Ty1,
 class _Ty2> inline
 constexpr _Ty1&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept
 {
 return (::std:: get<0>(::std:: move(_Pr)));
 }

template<class _Ty2,
 class _Ty1> inline
 constexpr _Ty2&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept
 {
 return (::std:: get<1>(::std:: move(_Pr)));
 }


template<class _Ty,
 class _Other = _Ty> inline
 _Ty exchange(_Ty& _Val, _Other&& _New_val)
 {
 _Ty _Old_val = ::std:: move(_Val);
 _Val = ::std:: forward<_Other>(_New_val);
 return (_Old_val);
 }


template<class _Ty> inline
 constexpr add_const_t<_Ty>& as_const(_Ty& _Val) noexcept
 {
 return (_Val);
 }

template<class _Ty>
 void as_const(const _Ty&&) = delete;
}


namespace std {
namespace tr1 {
using ::std:: get;
using ::std:: tuple_element;
using ::std:: tuple_size;
}
}



#pragma warning(pop)
#pragma pack(pop)
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility" 2 3


#pragma pack(push,8)
#pragma warning(push, 3)



namespace std {
# 36 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility" 3
struct _Container_proxy;
struct _Container_base12;
struct _Iterator_base12;

struct _Container_base0
 {
 void _Orphan_all()
  {
  }

 void _Swap_all(_Container_base0&)
  {
  }
 };

struct _Iterator_base0
 {
 void _Adopt(const void *)
  {
  }

 const _Container_base0 *_Getcont() const
  {
  return (0);
  }
 };


struct _Container_proxy
 {
 _Container_proxy()
  : _Mycont(0), _Myfirstiter(0)
  {
  }

 const _Container_base12 *_Mycont;
 _Iterator_base12 *_Myfirstiter;
 };

struct _Container_base12
 {
public:
 _Container_base12()
  : _Myproxy(0)
  {
  }

 _Container_base12(const _Container_base12&)
  : _Myproxy(0)
  {
  }

 _Container_base12& operator=(const _Container_base12&)
  {
  return (*this);
  }

 ~_Container_base12() noexcept
  {
  _Orphan_all();
  }

 _Iterator_base12 **_Getpfirst() const
  {
  return (_Myproxy == 0 ? 0 : &_Myproxy->_Myfirstiter);
  }

 void _Orphan_all();
 void _Swap_all(_Container_base12&);

 _Container_proxy *_Myproxy;
 };

struct _Iterator_base12
 {
public:
 _Iterator_base12()
  : _Myproxy(0), _Mynextiter(0)
  {
  }

 _Iterator_base12(const _Iterator_base12& _Right)
  : _Myproxy(0), _Mynextiter(0)
  {
  *this = _Right;
  }

 _Iterator_base12& operator=(const _Iterator_base12& _Right)
  {
  if (_Myproxy == _Right._Myproxy)
   ;
  else if (_Right._Myproxy != 0)
   _Adopt(_Right._Myproxy->_Mycont);
  else
   {




   }

  return (*this);
  }

 ~_Iterator_base12() noexcept
  {




  }

 void _Adopt(const _Container_base12 *_Parent)
  {
  if (_Parent == 0)
   {




   }
  else
   {
   _Container_proxy *_Parent_proxy = _Parent->_Myproxy;
# 172 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility" 3
   _Myproxy = _Parent_proxy;

   }
  }

 void _Clrcont()
  {
  _Myproxy = 0;
  }

 const _Container_base12 *_Getcont() const
  {
  return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);
  }

 _Iterator_base12 **_Getpnext()
  {
  return (&_Mynextiter);
  }

 void _Orphan_me()
  {
# 207 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility" 3
  }

 _Container_proxy *_Myproxy;
 _Iterator_base12 *_Mynextiter;
 };


inline void _Container_base12::_Orphan_all()
 {
# 227 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility" 3
 }

inline void _Container_base12::_Swap_all(_Container_base12& _Right)
 {




 _Container_proxy *_Temp = _Myproxy;
 _Myproxy = _Right._Myproxy;
 _Right._Myproxy = _Temp;

 if (_Myproxy != 0)
  _Myproxy->_Mycont = (_Container_base12 *)this;
 if (_Right._Myproxy != 0)
  _Right._Myproxy->_Mycont = (_Container_base12 *)&_Right;
 }


typedef _Container_base0 _Container_base;
typedef _Iterator_base0 _Iterator_base;







struct _Zero_then_variadic_args_t
 {
 };

struct _One_then_variadic_args_t
 {
 };

template<class _Ty1,
 class _Ty2,
 bool = is_empty<_Ty1>::value && !is_final<_Ty1>::value>
 class _Compressed_pair final
  : private _Ty1

 {
private:
 _Ty2 _Myval2;

 typedef _Ty1 _Mybase;

public:
 template<class... _Other2>
  constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t,
   _Other2&&... _Val2)
  : _Ty1(), _Myval2(::std:: forward<_Other2>(_Val2)...)
  {
  }

 template<class _Other1,
  class... _Other2>
  _Compressed_pair(_One_then_variadic_args_t,
   _Other1&& _Val1, _Other2&&... _Val2)
  : _Ty1(::std:: forward<_Other1>(_Val1)),
   _Myval2(::std:: forward<_Other2>(_Val2)...)
  {
  }


 _Ty1& _Get_first() noexcept
  {
  return (*this);
  }

 const _Ty1& _Get_first() const noexcept
  {
  return (*this);
  }

 volatile _Ty1& _Get_first() volatile noexcept
  {
  return (*this);
  }

 const volatile _Ty1& _Get_first() const volatile noexcept
  {
  return (*this);
  }

 _Ty2& _Get_second() noexcept
  {
  return (_Myval2);
  }

 const _Ty2& _Get_second() const noexcept
  {
  return (_Myval2);
  }

 volatile _Ty2& _Get_second() volatile noexcept
  {
  return (_Myval2);
  }

 const volatile _Ty2& _Get_second() const volatile noexcept
  {
  return (_Myval2);
  }
 };

template<class _Ty1,
 class _Ty2>
 class _Compressed_pair<_Ty1, _Ty2, false> final

 {
private:
 _Ty1 _Myval1;
 _Ty2 _Myval2;

public:
 template<class... _Other2>
  constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t,
   _Other2&&... _Val2)
  : _Myval1(), _Myval2(::std:: forward<_Other2>(_Val2)...)
  {
  }

 template<class _Other1,
  class... _Other2>
  _Compressed_pair(_One_then_variadic_args_t,
   _Other1&& _Val1, _Other2&&... _Val2)
  : _Myval1(::std:: forward<_Other1>(_Val1)),
   _Myval2(::std:: forward<_Other2>(_Val2)...)
  {
  }


 _Ty1& _Get_first() noexcept
  {
  return (_Myval1);
  }

 const _Ty1& _Get_first() const noexcept
  {
  return (_Myval1);
  }

 volatile _Ty1& _Get_first() volatile noexcept
  {
  return (_Myval1);
  }

 const volatile _Ty1& _Get_first() const volatile noexcept
  {
  return (_Myval1);
  }

 _Ty2& _Get_second() noexcept
  {
  return (_Myval2);
  }

 const _Ty2& _Get_second() const noexcept
  {
  return (_Myval2);
  }

 volatile _Ty2& _Get_second() volatile noexcept
  {
  return (_Myval2);
  }

 const volatile _Ty2& _Get_second() const volatile noexcept
  {
  return (_Myval2);
  }
 };


template<class _Ty,
 class = void>
 struct _Is_checked_helper
  : false_type
 {
 };

template<class _Ty>
 struct _Is_checked_helper<_Ty, void_t<
  typename _Ty::_Unchecked_type> >
  : true_type
 {
 };


template<class _Iter> inline
 typename _Is_checked_helper<_Iter>::type _Is_checked(_Iter)
 {
 return {};
 }


template<class _Iter> inline
 _Iter _Unchecked(_Iter _Src)
 {
 return (_Src);
 }







template<class _Iter> inline
 decltype(_Unchecked(::std:: declval<_Iter>())) _Unchecked_idl0(_Iter _Src)
 {
 return (_Unchecked(_Src));
 }
# 454 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility" 3
template<class _Iter,
 class _UIter> inline
 _Iter& _Rechecked(_Iter& _Dest, _UIter _Src)
 {
 _Dest = _Src;
 return (_Dest);
 }
# 506 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility" 3
struct input_iterator_tag
 {
 };

struct _Mutable_iterator_tag
 {
 };

struct output_iterator_tag
 : _Mutable_iterator_tag
 {
 };

struct forward_iterator_tag
 : input_iterator_tag, _Mutable_iterator_tag
 {
 };

struct bidirectional_iterator_tag
 : forward_iterator_tag
 {
 };

struct random_access_iterator_tag
 : bidirectional_iterator_tag
 {
 };


struct _General_ptr_iterator_tag
 {
 };

struct _Trivially_copyable_ptr_iterator_tag
 : _General_ptr_iterator_tag
 {
 };

struct _Really_trivial_ptr_iterator_tag
 : _Trivially_copyable_ptr_iterator_tag
 {
 };


struct _Any_tag
 {
 constexpr _Any_tag() noexcept = default;
 template<class _Ty>
  constexpr _Any_tag(_Ty&&) noexcept {}
 };


template<class _Category,
 class _Ty,
 class _Diff = ptrdiff_t,
 class _Pointer = _Ty *,
 class _Reference = _Ty&>
 struct iterator
 {
 typedef _Category iterator_category;
 typedef _Ty value_type;
 typedef _Diff difference_type;

 typedef _Pointer pointer;
 typedef _Reference reference;
 };

template<class _Category,
 class _Ty,
 class _Diff,
 class _Pointer,
 class _Reference,
 class _Base>
 struct _Iterator012
  : public _Base
 {
 typedef _Category iterator_category;
 typedef _Ty value_type;
 typedef _Diff difference_type;

 typedef _Pointer pointer;
 typedef _Reference reference;
 };


typedef iterator<output_iterator_tag, void, void, void, void> _Outit;


template<class,
 class = void>
 struct _Iterator_traits_base
 {
 };

template<class _Iter>
 struct _Iterator_traits_base<_Iter, void_t<
  typename _Iter::iterator_category,
  typename _Iter::value_type,
  typename _Iter::difference_type,
  typename _Iter::pointer,
  typename _Iter::reference
  > >
 {
 typedef typename _Iter::iterator_category iterator_category;
 typedef typename _Iter::value_type value_type;
 typedef typename _Iter::difference_type difference_type;

 typedef typename _Iter::pointer pointer;
 typedef typename _Iter::reference reference;
 };

template<class _Iter>
 struct iterator_traits
  : _Iterator_traits_base<_Iter>
 {
 };

template<class _Ty>
 struct iterator_traits<_Ty *>
 {
 typedef random_access_iterator_tag iterator_category;
 typedef _Ty value_type;
 typedef ptrdiff_t difference_type;

 typedef _Ty *pointer;
 typedef _Ty& reference;
 };

template<class _Ty>
 struct iterator_traits<const _Ty *>
 {
 typedef random_access_iterator_tag iterator_category;
 typedef _Ty value_type;
 typedef ptrdiff_t difference_type;

 typedef const _Ty *pointer;
 typedef const _Ty& reference;
 };


template<class _Iter>
 using _Iter_value_t = typename iterator_traits<_Iter>::value_type;


template<class _Iter>
 using _Iter_diff_t = typename iterator_traits<_Iter>::difference_type;


template<class _Iter>
 using _Iter_cat_t = typename iterator_traits<_Iter>::iterator_category;


template<class _Ty,
 class = void>
 struct _Is_iterator
  : false_type
 {
 };

template<class _Ty>
 struct _Is_iterator<_Ty, void_t<
  typename iterator_traits<_Ty>::iterator_category
  > >
  : true_type
 {
 };




template<class _Iter,
 class _Diff> inline
 auto _Unchecked_n(_Iter _Src, _Diff)
 {
 return (_Unchecked(_Src));
 }
# 712 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility" 3
template<class _Ty1,
 class _Ty2>
 struct _Is_same_size
  : bool_constant<sizeof(_Ty1) == sizeof(_Ty2)>
 {
 };


template<class _Elem,
 bool _Is_enum = is_enum<_Elem>::value>
 struct _Unwrap_enum
 {
 typedef underlying_type_t<_Elem> type;
 };

template<class _Elem>
 struct _Unwrap_enum<_Elem, false>
 {
 typedef _Elem type;
 };


template<class _Ty1,
 class _Ty2>
 struct _Both_or_neither_bool
  : bool_constant<is_same<bool, _Ty1>::value == is_same<bool, _Ty2>::value>
 {
 };


template<class _Source,
 class _Dest>
 struct _Ptr_cat_helper
 {
 typedef typename _Unwrap_enum<_Source>::type _USource;
 typedef typename _Unwrap_enum<_Dest>::type _UDest;
 typedef conditional_t<
  conjunction<
   _Is_same_size<_USource, _UDest>,
   is_integral<_USource>,
   is_integral<_UDest>,
   _Both_or_neither_bool<_USource, _UDest>,

   negation<is_volatile<_Source>>,
   negation<is_volatile<_Dest>>
  >::value,
  _Really_trivial_ptr_iterator_tag,
  _General_ptr_iterator_tag> type;
 };

template<class _Elem>
 struct _Ptr_cat_helper<_Elem, _Elem>
 {
 typedef conditional_t<
  is_trivially_copyable<_Elem>::value,
  conditional_t<is_trivial<_Elem>::value,
   _Really_trivial_ptr_iterator_tag,
   _Trivially_copyable_ptr_iterator_tag>,
  _General_ptr_iterator_tag> type;
 };

template<class _Anything>
 struct _Ptr_cat_helper<_Anything *, const _Anything *>
 {
 typedef _Really_trivial_ptr_iterator_tag type;
 };

template<class _Source,
 class _Dest> inline
 _General_ptr_iterator_tag _Ptr_copy_cat(const _Source&, const _Dest&)
 {
 return {};
 }

template<class _Source,
 class _Dest> inline
 conditional_t<is_trivially_assignable<_Dest&, _Source&>::value,
  typename _Ptr_cat_helper<remove_const_t<_Source>, _Dest>::type,
  _General_ptr_iterator_tag>
  _Ptr_copy_cat(_Source * const&, _Dest * const&)
 {
 return {};
 }

template<class _Source,
 class _Dest> inline
 _General_ptr_iterator_tag _Ptr_move_cat(const _Source&, const _Dest&)
 {
 return {};
 }

template<class _Source,
 class _Dest> inline
 conditional_t<is_trivially_assignable<_Dest&, _Source>::value,
  typename _Ptr_cat_helper<remove_const_t<_Source>, _Dest>::type,
  _General_ptr_iterator_tag>
  _Ptr_move_cat(_Source * const&, _Dest * const&)
 {
 return {};
 }
# 1057 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility" 3
template<class _InIt,
 class _Diff> inline
 void _Advance1(_InIt& _Where, _Diff _Off, input_iterator_tag)
 {





 for (; 0 < _Off; --_Off)
  ++_Where;
 }

template<class _BidIt,
 class _Diff> inline
 void _Advance1(_BidIt& _Where, _Diff _Off, bidirectional_iterator_tag)
 {
 for (; 0 < _Off; --_Off)
  ++_Where;
 for (; _Off < 0; ++_Off)
  --_Where;
 }

template<class _RanIt,
 class _Diff> inline
 void _Advance1(_RanIt& _Where, _Diff _Off, random_access_iterator_tag)
 {
 _Where += _Off;
 }

template<class _InIt,
 class _Diff> inline
 void advance(_InIt& _Where, _Diff _Off)
 {

 _Advance1(_Where, _Off, _Iter_cat_t<remove_const_t<_InIt>>());
 }


template<class _InIt> inline
 _Iter_diff_t<_InIt>
  _Distance1(_InIt _First, _InIt _Last, input_iterator_tag)
 {
 _Iter_diff_t<_InIt> _Off = 0;
 for (; _First != _Last; ++_First)
  ++_Off;

 return (_Off);
 }

template<class _RanIt> inline
 _Iter_diff_t<_RanIt>
  _Distance1(_RanIt _First, _RanIt _Last, random_access_iterator_tag)
 {
# 1119 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility" 3
 return (_Last - _First);
 }

template<class _InIt> inline
 _Iter_diff_t<_InIt>
  distance(_InIt _First, _InIt _Last)
 {
 return (_Distance1(_First, _Last, _Iter_cat_t<_InIt>()));
 }


template<class _InIt> inline
 _InIt next(_InIt _First, _Iter_diff_t<_InIt> _Off = 1)
 {
 static_assert(is_base_of<input_iterator_tag,
  typename iterator_traits<_InIt>::iterator_category>::value,
  "next requires input iterator");

 ::std:: advance(_First, _Off);
 return (_First);
 }


template<class _BidIt> inline
 _BidIt prev(_BidIt _First, _Iter_diff_t<_BidIt> _Off = 1)
 {
 static_assert(is_base_of<bidirectional_iterator_tag,
  typename iterator_traits<_BidIt>::iterator_category>::value,
  "prev requires bidirectional iterator");

 ::std:: advance(_First, -_Off);
 return (_First);
 }


template<class _Ty>
 struct pointer_traits;

template<class _RanIt>
 class reverse_iterator
  : public iterator<
   typename iterator_traits<_RanIt>::iterator_category,
   typename iterator_traits<_RanIt>::value_type,
   typename iterator_traits<_RanIt>::difference_type,
   typename iterator_traits<_RanIt>::pointer,
   typename iterator_traits<_RanIt>::reference>
 {
 typedef reverse_iterator<_RanIt> _Myt;

public:
 typedef typename iterator_traits<_RanIt>::difference_type difference_type;
 typedef typename iterator_traits<_RanIt>::pointer pointer;
 typedef typename iterator_traits<_RanIt>::reference reference;
 typedef _RanIt iterator_type;

 reverse_iterator()
  : current()
  {
  }

 explicit reverse_iterator(_RanIt _Right)
  : current(_Right)
  {
  }

 template<class _Other>
  reverse_iterator(const reverse_iterator<_Other>& _Right)
  : current(_Right.base())
  {
  }

 template<class _Other>
  _Myt& operator=(const reverse_iterator<_Other>& _Right)
  {
  current = _Right.base();
  return (*this);
  }

 _RanIt base() const
  {
  return (current);
  }

 reference operator*() const
  {
  _RanIt _Tmp = current;
  return (*--_Tmp);
  }

 pointer operator->() const
  {
  return (pointer_traits<pointer>::pointer_to(**this));
  }

 _Myt& operator++()
  {
  --current;
  return (*this);
  }

 _Myt operator++(int)
  {
  _Myt _Tmp = *this;
  --current;
  return (_Tmp);
  }

 _Myt& operator--()
  {
  ++current;
  return (*this);
  }

 _Myt operator--(int)
  {
  _Myt _Tmp = *this;
  ++current;
  return (_Tmp);
  }



 _Myt& operator+=(difference_type _Off)
  {
  current -= _Off;
  return (*this);
  }

 _Myt operator+(difference_type _Off) const
  {
  return (_Myt(current - _Off));
  }

 _Myt& operator-=(difference_type _Off)
  {
  current += _Off;
  return (*this);
  }

 _Myt operator-(difference_type _Off) const
  {
  return (_Myt(current + _Off));
  }

 reference operator[](difference_type _Off) const
  {
  return (*(*this + _Off));
  }

protected:
 _RanIt current;
 };

template<class _RanIt>
 struct _Is_checked_helper<reverse_iterator<_RanIt> >
  : public _Is_checked_helper<_RanIt>
 {
 };


template<class _RanIt> inline
 reverse_iterator<_RanIt> operator+(
  typename reverse_iterator<_RanIt>::difference_type _Off,
  const reverse_iterator<_RanIt>& _Right)
 {
 return (_Right + _Off);
 }

template<class _RanIt1,
 class _RanIt2>
 auto inline operator-(const reverse_iterator<_RanIt1>& _Left,
  const reverse_iterator<_RanIt2>& _Right)
   -> decltype(_Right.base() - _Left.base())
 {
 return (_Right.base() - _Left.base());
 }

template<class _RanIt1,
 class _RanIt2> inline
 bool operator==(const reverse_iterator<_RanIt1>& _Left,
  const reverse_iterator<_RanIt2>& _Right)
 {
 return (_Left.base() == _Right.base());
 }

template<class _RanIt1,
 class _RanIt2> inline
 bool operator!=(const reverse_iterator<_RanIt1>& _Left,
  const reverse_iterator<_RanIt2>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _RanIt1,
 class _RanIt2> inline
 bool operator<(const reverse_iterator<_RanIt1>& _Left,
  const reverse_iterator<_RanIt2>& _Right)
 {
 return (_Right.base() < _Left.base());
 }

template<class _RanIt1,
 class _RanIt2> inline
 bool operator>(const reverse_iterator<_RanIt1>& _Left,
  const reverse_iterator<_RanIt2>& _Right)
 {
 return (_Right < _Left);
 }

template<class _RanIt1,
 class _RanIt2> inline
 bool operator<=(const reverse_iterator<_RanIt1>& _Left,
  const reverse_iterator<_RanIt2>& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _RanIt1,
 class _RanIt2> inline
 bool operator>=(const reverse_iterator<_RanIt1>& _Left,
  const reverse_iterator<_RanIt2>& _Right)
 {
 return (!(_Left < _Right));
 }


template<class _RanIt> inline
 reverse_iterator<_RanIt> make_reverse_iterator(_RanIt _Iter)
 {
 return (reverse_iterator<_RanIt>(_Iter));
 }



template<class _Container>
 auto inline begin(_Container& _Cont) -> decltype(_Cont.begin())
 {
 return (_Cont.begin());
 }

template<class _Container>
 auto inline begin(const _Container& _Cont) -> decltype(_Cont.begin())
 {
 return (_Cont.begin());
 }

template<class _Container>
 auto inline end(_Container& _Cont) -> decltype(_Cont.end())
 {
 return (_Cont.end());
 }

template<class _Container>
 auto inline end(const _Container& _Cont) -> decltype(_Cont.end())
 {
 return (_Cont.end());
 }

template<class _Ty,
 size_t _Size> inline
 constexpr _Ty *begin(_Ty (&_Array)[_Size]) noexcept
 {
 return (_Array);
 }

template<class _Ty,
 size_t _Size> inline
 constexpr _Ty *end(_Ty (&_Array)[_Size]) noexcept
 {
 return (_Array + _Size);
 }


template<class _Container>
 constexpr auto inline cbegin(const _Container& _Cont)
  noexcept(noexcept(::std:: begin(_Cont)))
  -> decltype(::std:: begin(_Cont))
 {
 return (::std:: begin(_Cont));
 }

template<class _Container>
 constexpr auto inline cend(const _Container& _Cont)
  noexcept(noexcept(::std:: end(_Cont)))
  -> decltype(::std:: end(_Cont))
 {
 return (::std:: end(_Cont));
 }


template<class _Container>
 auto inline rbegin(_Container& _Cont) -> decltype(_Cont.rbegin())
 {
 return (_Cont.rbegin());
 }

template<class _Container>
 auto inline rbegin(const _Container& _Cont) -> decltype(_Cont.rbegin())
 {
 return (_Cont.rbegin());
 }

template<class _Container>
 auto inline rend(_Container& _Cont) -> decltype(_Cont.rend())
 {
 return (_Cont.rend());
 }

template<class _Container>
 auto inline rend(const _Container& _Cont) -> decltype(_Cont.rend())
 {
 return (_Cont.rend());
 }

template<class _Ty,
 size_t _Size> inline
 reverse_iterator<_Ty *> rbegin(_Ty (&_Array)[_Size])
 {
 return (reverse_iterator<_Ty *>(_Array + _Size));
 }

template<class _Ty,
 size_t _Size> inline
 reverse_iterator<_Ty *> rend(_Ty (&_Array)[_Size])
 {
 return (reverse_iterator<_Ty *>(_Array));
 }

template<class _Elem> inline
 reverse_iterator<const _Elem *>
  rbegin(::std:: initializer_list<_Elem> _Ilist)
 {
 return (reverse_iterator<const _Elem *>(_Ilist.end()));
 }

template<class _Elem> inline
 reverse_iterator<const _Elem *>
  rend(::std:: initializer_list<_Elem> _Ilist)
 {
 return (reverse_iterator<const _Elem *>(_Ilist.begin()));
 }


template<class _Container>
 auto inline crbegin(const _Container& _Cont)
  -> decltype(::std:: rbegin(_Cont))
 {
 return (::std:: rbegin(_Cont));
 }

template<class _Container>
 auto inline crend(const _Container& _Cont)
  -> decltype(::std:: rend(_Cont))
 {
 return (::std:: rend(_Cont));
 }


template<class _Container>
 constexpr auto inline size(const _Container& _Cont)
  -> decltype(_Cont.size())
 {
 return (_Cont.size());
 }

template<class _Ty,
 size_t _Size> inline
 constexpr size_t size(const _Ty(&)[_Size]) noexcept
 {
 return (_Size);
 }

template<class _Container>
 constexpr auto inline empty(const _Container& _Cont)
  -> decltype(_Cont.empty())
 {
 return (_Cont.empty());
 }

template<class _Ty,
 size_t _Size> inline
 constexpr bool empty(const _Ty(&)[_Size]) noexcept
 {
 return (false);
 }

template<class _Elem> inline
 constexpr bool empty(
  ::std:: initializer_list<_Elem> _Ilist) noexcept
 {
 return (_Ilist.size() == 0);
 }

template<class _Container>
 constexpr auto inline data(_Container& _Cont)
  -> decltype(_Cont.data())
 {
 return (_Cont.data());
 }

template<class _Container>
 constexpr auto inline data(const _Container& _Cont)
  -> decltype(_Cont.data())
 {
 return (_Cont.data());
 }

template<class _Ty,
 size_t _Size> inline
 constexpr _Ty *data(_Ty(&_Array)[_Size]) noexcept
 {
 return (_Array);
 }

template<class _Elem> inline
 constexpr const _Elem *data(
  ::std:: initializer_list<_Elem> _Ilist) noexcept
 {
 return (_Ilist.begin());
 }


template<class _Ty,
 size_t _Size>
 class _Array_const_iterator
  : public _Iterator012<random_access_iterator_tag,
   _Ty,
   ptrdiff_t,
   const _Ty *,
   const _Ty&,
   _Iterator_base>
 {
public:
 typedef _Array_const_iterator<_Ty, _Size> _Myiter;
 typedef random_access_iterator_tag iterator_category;

 typedef _Ty value_type;
 typedef size_t size_type;
 typedef ptrdiff_t difference_type;
 typedef const _Ty *pointer;
 typedef const _Ty& reference;
 enum {_EEN_SIZE = _Size};

 _Array_const_iterator()
  : _Ptr(0)
  {
  }

 explicit _Array_const_iterator(pointer _Parg, size_t _Off = 0)
  : _Ptr(_Parg + _Off)
  {
  }

 typedef pointer _Unchecked_type;

 _Myiter& _Rechecked(_Unchecked_type _Right)
  {
  _Ptr = _Right;
  return (*this);
  }

 _Unchecked_type _Unchecked() const
  {
  return (_Ptr);
  }

 reference operator*() const
  {
  return (*_Ptr);
  }

 pointer operator->() const
  {
  return (pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
  ++_Ptr;
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
  --_Ptr;
  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }

 _Myiter& operator+=(difference_type _Off)
  {
  _Ptr += _Off;
  return (*this);
  }

 _Myiter operator+(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp += _Off);
  }

 _Myiter& operator-=(difference_type _Off)
  {
  return (*this += -_Off);
  }

 _Myiter operator-(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp -= _Off);
  }

 difference_type operator-(const _Myiter& _Right) const
  {
  return (_Ptr - _Right._Ptr);
  }

 reference operator[](difference_type _Off) const
  {
  return (*(*this + _Off));
  }

 bool operator==(const _Myiter& _Right) const
  {
  return (_Ptr == _Right._Ptr);
  }

 bool operator!=(const _Myiter& _Right) const
  {
  return (!(*this == _Right));
  }

 bool operator<(const _Myiter& _Right) const
  {
  return (_Ptr < _Right._Ptr);
  }

 bool operator>(const _Myiter& _Right) const
  {
  return (_Right < *this);
  }

 bool operator<=(const _Myiter& _Right) const
  {
  return (!(_Right < *this));
  }

 bool operator>=(const _Myiter& _Right) const
  {
  return (!(*this < _Right));
  }

 pointer _Ptr;
# 1888 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility" 3
 };

template<class _Ty,
 size_t _Size> inline
 typename _Array_const_iterator<_Ty, _Size>::_Unchecked_type
  _Unchecked(_Array_const_iterator<_Ty, _Size> _Iter)
 {
 return (_Iter._Unchecked());
 }

template<class _Ty,
 size_t _Size> inline
 _Array_const_iterator<_Ty, _Size>&
  _Rechecked(_Array_const_iterator<_Ty, _Size>& _Iter,
   typename _Array_const_iterator<_Ty, _Size>
    ::_Unchecked_type _Right)
 {
 return (_Iter._Rechecked(_Right));
 }

template<class _Ty,
 size_t _Size> inline
 _Array_const_iterator<_Ty, _Size> operator+(
  typename _Array_const_iterator<_Ty, _Size>::difference_type _Off,
  _Array_const_iterator<_Ty, _Size> _Next)
 {
 return (_Next += _Off);
 }


template<class _Ty,
 size_t _Size>
 class _Array_iterator
  : public _Array_const_iterator<_Ty, _Size>
 {
public:
 typedef _Array_iterator<_Ty, _Size> _Myiter;
 typedef _Array_const_iterator<_Ty, _Size> _Mybase;
 typedef random_access_iterator_tag iterator_category;

 typedef _Ty value_type;
 typedef size_t size_type;
 typedef ptrdiff_t difference_type;
 typedef _Ty *pointer;
 typedef _Ty& reference;

 _Array_iterator()
  {
  }

 explicit _Array_iterator(pointer _Parg, size_t _Off = 0)
  : _Mybase(_Parg, _Off)
  {
  }
 enum {_EEN_SIZE = _Size};
 typedef pointer _Unchecked_type;

 _Myiter& _Rechecked(_Unchecked_type _Right)
  {
  ((_Mybase *)this)->_Rechecked(_Right);
  return (*this);
  }

 _Unchecked_type _Unchecked() const
  {
  return ((pointer)((_Mybase *)this)->_Unchecked());
  }

 reference operator*() const
  {
  return ((reference)**(_Mybase *)this);
  }

 pointer operator->() const
  {
  return (pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
  ++*(_Mybase *)this;
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
  --*(_Mybase *)this;
  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }

 _Myiter& operator+=(difference_type _Off)
  {
  *(_Mybase *)this += _Off;
  return (*this);
  }

 _Myiter operator+(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp += _Off);
  }

 _Myiter& operator-=(difference_type _Off)
  {
  return (*this += -_Off);
  }

 _Myiter operator-(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp -= _Off);
  }

 difference_type operator-(const _Mybase& _Right) const
  {
  return (*(_Mybase *)this - _Right);
  }

 reference operator[](difference_type _Off) const
  {
  return (*(*this + _Off));
  }
 };

template<class _Ty,
 size_t _Size> inline
 typename _Array_iterator<_Ty, _Size>::_Unchecked_type
  _Unchecked(_Array_iterator<_Ty, _Size> _Iter)
 {
 return (_Iter._Unchecked());
 }

template<class _Ty,
 size_t _Size> inline
 _Array_iterator<_Ty, _Size>&
  _Rechecked(_Array_iterator<_Ty, _Size>& _Iter,
   typename _Array_iterator<_Ty, _Size>
    ::_Unchecked_type _Right)
 {
 return (_Iter._Rechecked(_Right));
 }

template<class _Ty,
 size_t _Size> inline
 _Array_iterator<_Ty, _Size> operator+(
  typename _Array_iterator<_Ty, _Size>::difference_type _Off,
  _Array_iterator<_Ty, _Size> _Next)
 {
 return (_Next += _Off);
 }


template<class _RanIt>
 class move_iterator
 {
public:
 typedef move_iterator<_RanIt> _Myt;
 typedef typename iterator_traits<_RanIt>::iterator_category
  iterator_category;
 typedef typename iterator_traits<_RanIt>::value_type
  value_type;
 typedef typename iterator_traits<_RanIt>::difference_type
  difference_type;
 typedef _RanIt pointer;
 typedef typename iterator_traits<_RanIt>::reference _Ref0;
 typedef conditional_t<is_reference<_Ref0>::value,
  remove_reference_t<_Ref0>&&, _Ref0> reference;
 typedef _RanIt iterator_type;

 move_iterator()
  : current()
  {
  }

 explicit move_iterator(iterator_type _Right)
  : current(_Right)
  {
  }

 template<class _RanIt2>
  move_iterator(const move_iterator<_RanIt2>& _Right)
  : current(_Right.base())
  {
  }

 template<class _RanIt2>
  _Myt& operator=(const move_iterator<_RanIt2>& _Right)
  {
  current = _Right.base();
  return (*this);
  }

 _RanIt base() const
  {
  return (current);
  }

 reference operator*() const
  {
  return (static_cast<reference>(*current));
  }

 pointer operator->() const
  {
  return (current);
  }

 _Myt& operator++()
  {
  ++current;
  return (*this);
  }

 _Myt operator++(int)
  {
  _Myt _Tmp = *this;
  ++current;
  return (_Tmp);
  }

 _Myt& operator--()
  {
  --current;
  return (*this);
  }

 _Myt operator--(int)
  {
  _Myt _Tmp = *this;
  --current;
  return (_Tmp);
  }

 template<class _RanIt2>
  bool _Equal(const move_iterator<_RanIt2>& _Right) const
  {
  return (current == _Right.base());
  }



 _Myt& operator+=(difference_type _Off)
  {
  current += _Off;
  return (*this);
  }

 _Myt operator+(difference_type _Off) const
  {
  return (_Myt(current + _Off));
  }

 _Myt& operator-=(difference_type _Off)
  {
  current -= _Off;
  return (*this);
  }

 _Myt operator-(difference_type _Off) const
  {
  return (_Myt(current - _Off));
  }

 reference operator[](difference_type _Off) const
  {
  return (::std:: move(current[_Off]));
  }

 template<class _RanIt2>
  bool _Less(const move_iterator<_RanIt2>& _Right) const
  {
  return (current < _Right.base());
  }

 difference_type operator-(const _Myt& _Right) const
  {
  return (current - _Right.base());
  }

protected:
 iterator_type current;
 };

template<class _RanIt>
 struct _Is_checked_helper<move_iterator<_RanIt> >
  : public _Is_checked_helper<_RanIt>
 {
 };


template<class _RanIt,
 class _Diff> inline
 move_iterator<_RanIt>
  operator+(_Diff _Off,
  const move_iterator<_RanIt>& _Right)
 {
 return (_Right + _Off);
 }

template<class _RanIt1,
 class _RanIt2>
 auto inline operator-(
  move_iterator<_RanIt1>& _Left,
  const move_iterator<_RanIt2>& _Right)
   -> decltype(_Left.base() - _Right.base())
 {
 return (_Left.base() - _Right.base());
 }

template<class _RanIt1,
 class _RanIt2> inline
 bool operator==(
  const move_iterator<_RanIt1>& _Left,
  const move_iterator<_RanIt2>& _Right)
 {
 return (_Left._Equal(_Right));
 }

template<class _RanIt1,
 class _RanIt2> inline
 bool operator!=(
  const move_iterator<_RanIt1>& _Left,
  const move_iterator<_RanIt2>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _RanIt1,
 class _RanIt2> inline
 bool operator<(
  const move_iterator<_RanIt1>& _Left,
  const move_iterator<_RanIt2>& _Right)
 {
 return (_Left._Less(_Right));
 }

template<class _RanIt1,
 class _RanIt2> inline
 bool operator>(
  const move_iterator<_RanIt1>& _Left,
  const move_iterator<_RanIt2>& _Right)
 {
 return (_Right < _Left);
 }

template<class _RanIt1,
 class _RanIt2> inline
 bool operator<=(
  const move_iterator<_RanIt1>& _Left,
  const move_iterator<_RanIt2>& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _RanIt1,
 class _RanIt2> inline
 bool operator>=(
  const move_iterator<_RanIt1>& _Left,
  const move_iterator<_RanIt2>& _Right)
 {
 return (!(_Left < _Right));
 }


template<class _RanIt> inline
 move_iterator<_RanIt> make_move_iterator(_RanIt _Iter)
 {
 return (move_iterator<_RanIt>(_Iter));
 }


template<class _Traits>
 struct _Char_traits_eq
 {
 typedef typename _Traits::char_type _Elem;

 bool operator()(_Elem _Left, _Elem _Right) const
  {
  return (_Traits::eq(_Left, _Right));
  }
 };


template<class _Traits>
 struct _Char_traits_lt
 {
 typedef typename _Traits::char_type _Elem;

 bool operator()(_Elem _Left, _Elem _Right) const
  {
  return (_Traits::lt(_Left, _Right));
  }
 };


template<class _InIt,
 class _OutIt> inline
 _OutIt _Copy_memmove(_InIt _First, _InIt _Last,
  _OutIt _Dest)
 {
 const char * const _First_ch = reinterpret_cast<const char *>(_First);
 const char * const _Last_ch = reinterpret_cast<const char *>(_Last);
 char * const _Dest_ch = reinterpret_cast<char *>(_Dest);
 const size_t _Count = _Last_ch - _First_ch;
 :: memmove(_Dest_ch, _First_ch, _Count);
 return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));
 }

template<class _InIt,
 class _OutIt> inline
 _OutIt _Copy_unchecked1(_InIt _First, _InIt _Last,
  _OutIt _Dest, _General_ptr_iterator_tag)
 {
 for (; _First != _Last; ++_Dest, (void)++_First)
  *_Dest = *_First;
 return (_Dest);
 }

template<class _InIt,
 class _OutIt> inline
 _OutIt _Copy_unchecked1(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Trivially_copyable_ptr_iterator_tag)
 {
 return (_Copy_memmove(_First, _Last, _Dest));
 }

template<class _InIt,
 class _OutIt> inline
 _OutIt _Copy_unchecked(_InIt _First, _InIt _Last,
  _OutIt _Dest)
 {

 return (_Copy_unchecked1(_First, _Last,
  _Dest, _Ptr_copy_cat(_First, _Dest)));
 }

template<class _InIt,
 class _OutIt> inline
 _OutIt _Copy_no_deprecate1(_InIt _First, _InIt _Last,
  _OutIt _Dest, input_iterator_tag, _Any_tag)
 {
 return (_Rechecked(_Dest,
  _Copy_unchecked(_First, _Last, _Unchecked_idl0(_Dest))));
 }

template<class _InIt,
 class _OutIt> inline
 _OutIt _Copy_no_deprecate1(_InIt _First, _InIt _Last,
  _OutIt _Dest, random_access_iterator_tag, random_access_iterator_tag)
 {
                                         ;
 return (_Rechecked(_Dest,
  _Copy_unchecked(_First, _Last, _Unchecked(_Dest))));
 }

template<class _InIt,
 class _OutIt> inline
 _OutIt _Copy_no_deprecate(_InIt _First, _InIt _Last,
  _OutIt _Dest)
 {
                                       ;
 return (_Copy_no_deprecate1(_Unchecked(_First), _Unchecked(_Last),
  _Dest, _Iter_cat_t<_InIt>(), _Iter_cat_t<_OutIt>()));
 }

template<class _InIt,
 class _OutIt> inline
 _OutIt copy(_InIt _First, _InIt _Last,
  _OutIt _Dest)
 {
 struct _Unchecked_iterators { static void _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
 return (_Copy_no_deprecate(_First, _Last, _Dest));
 }
# 2390 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility" 3
template<class _InIt,
 class _Diff,
 class _OutIt> inline
 _OutIt _Copy_n_unchecked2(_InIt _First, _Diff _Count,
  _OutIt _Dest, input_iterator_tag)
 {
 if (0 < _Count)
  {
  *_Dest = *_First;
  while (0 < --_Count)
   *++_Dest = *++_First;
  return (++_Dest);
  }

 return (_Dest);
 }

template<class _InIt,
 class _Diff,
 class _OutIt> inline
 _OutIt _Copy_n_unchecked2(_InIt _First, _Diff _Count,
  _OutIt _Dest, forward_iterator_tag)
 {
 for (; 0 < _Count; --_Count, (void)++_Dest, ++_First)
  *_Dest = *_First;
 return (_Dest);
 }

template<class _InIt,
 class _Diff,
 class _OutIt> inline
 _OutIt _Copy_n_unchecked1(_InIt _First, _Diff _Count,
  _OutIt _Dest, _General_ptr_iterator_tag)
 {


 return (_Copy_n_unchecked2(_First, _Count,
  _Dest, _Iter_cat_t<_InIt>()));
 }

template<class _InIt,
 class _Diff,
 class _OutIt> inline
 _OutIt _Copy_n_unchecked1(_InIt _First, _Diff _Count,
  _OutIt _Dest, _Trivially_copyable_ptr_iterator_tag)
 {
 if (0 < _Count)
  return (_Copy_memmove(_First, _First + _Count, _Dest));
 return (_Dest);
 }

template<class _InIt,
 class _Diff,
 class _OutIt> inline
 _OutIt _Copy_n_unchecked(_InIt _First, _Diff _Count,
  _OutIt _Dest)
 {
 return (_Copy_n_unchecked1(_First, _Count,
  _Dest, _Ptr_copy_cat(_First, _Dest)));
 }

template<class _InIt,
 class _Diff,
 class _OutIt> inline
 _OutIt copy_n(_InIt _First, _Diff _Count,
  _OutIt _Dest)
 {

 struct _Unchecked_iterators { static void _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
 return (_Rechecked(_Dest,
  _Copy_n_unchecked(_Unchecked_n(_First, _Count), _Count, _Unchecked_n(_Dest, _Count))));
 }
# 2504 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility" 3
template<class _BidIt1,
 class _BidIt2> inline
 _BidIt2 _Copy_backward_memmove(_BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest)
 {
 const char * const _First_ch = reinterpret_cast<const char *>(_First);
 const char * const _Last_ch = reinterpret_cast<const char *>(_Last);
 char * const _Dest_ch = reinterpret_cast<char *>(_Dest);
 const size_t _Count = _Last_ch - _First_ch;
 return (static_cast<_BidIt2>(
  :: memmove(_Dest_ch - _Count, _First_ch, _Count)));
 }

template<class _BidIt1,
 class _BidIt2> inline
 _BidIt2 _Copy_backward_unchecked1(_BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest, _General_ptr_iterator_tag)
 {
 while (_First != _Last)
  *--_Dest = *--_Last;
 return (_Dest);
 }

template<class _BidIt1,
 class _BidIt2> inline
 _BidIt2 _Copy_backward_unchecked1(_BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest, _Trivially_copyable_ptr_iterator_tag)
 {
 return (_Copy_backward_memmove(_First, _Last, _Dest));
 }

template<class _BidIt1,
 class _BidIt2> inline
 _BidIt2 _Copy_backward_unchecked(_BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest)
 {
 return (_Copy_backward_unchecked1(_First, _Last,
  _Dest, _Ptr_copy_cat(_First, _Dest)));
 }

template<class _BidIt1,
 class _BidIt2> inline
 _BidIt2 _Copy_backward1(_BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest, input_iterator_tag, _Any_tag)
 {
 return (_Rechecked(_Dest,
  _Copy_backward_unchecked(_First, _Last, _Unchecked_idl0(_Dest))));
 }

template<class _BidIt1,
 class _BidIt2> inline
 _BidIt2 _Copy_backward1(_BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest, random_access_iterator_tag, random_access_iterator_tag)
 {
                                                  ;
 return (_Rechecked(_Dest,
  _Copy_backward_unchecked(_First, _Last, _Unchecked(_Dest))));
 }

template<class _BidIt1,
 class _BidIt2> inline
 _BidIt2 copy_backward(_BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest)
 {
 struct _Unchecked_iterators { static void _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
                                       ;
 return (_Copy_backward1(_Unchecked(_First), _Unchecked(_Last),
  _Dest, _Iter_cat_t<_BidIt1>(), _Iter_cat_t<_BidIt2>()));
 }


template<class _InIt,
 class _OutIt> inline
 _OutIt _Move_unchecked1(_InIt _First, _InIt _Last,
  _OutIt _Dest, _General_ptr_iterator_tag)
 {
 for (; _First != _Last; ++_Dest, (void)++_First)
  *_Dest = ::std:: move(*_First);
 return (_Dest);
 }

template<class _InIt,
 class _OutIt> inline
 _OutIt _Move_unchecked1(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Trivially_copyable_ptr_iterator_tag)
 {
 return (_Copy_memmove(_First, _Last, _Dest));
 }

template<class _InIt,
 class _OutIt> inline
 _OutIt _Move_unchecked(_InIt _First, _InIt _Last,
  _OutIt _Dest)
 {
 return (_Move_unchecked1(_First, _Last,
  _Dest, _Ptr_move_cat(_First, _Dest)));
 }

template<class _InIt,
 class _OutIt> inline
 _OutIt _Move_no_deprecate1(_InIt _First, _InIt _Last,
  _OutIt _Dest, input_iterator_tag, _Any_tag)
 {
 return (_Rechecked(_Dest,
  _Move_unchecked(_First, _Last, _Unchecked_idl0(_Dest))));
 }

template<class _InIt,
 class _OutIt> inline
 _OutIt _Move_no_deprecate1(_InIt _First, _InIt _Last,
  _OutIt _Dest, random_access_iterator_tag, random_access_iterator_tag)
 {
                                         ;
 return (_Rechecked(_Dest,
  _Move_unchecked(_First, _Last, _Unchecked(_Dest))));
 }

template<class _InIt,
 class _OutIt> inline
 _OutIt _Move_no_deprecate(_InIt _First, _InIt _Last,
  _OutIt _Dest)
 {
                                       ;
 return (_Move_no_deprecate1(_Unchecked(_First), _Unchecked(_Last),
  _Dest, _Iter_cat_t<_InIt>(), _Iter_cat_t<_OutIt>()));
 }

template<class _InIt,
 class _OutIt> inline
 _OutIt move(_InIt _First, _InIt _Last,
  _OutIt _Dest)
 {
 struct _Unchecked_iterators { static void _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
 return (_Move_no_deprecate(_First, _Last, _Dest));
 }
# 2654 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility" 3
template<class _BidIt1,
 class _BidIt2> inline
 _BidIt2 _Move_backward_unchecked1(_BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest, _General_ptr_iterator_tag)
 {
 while (_First != _Last)
  *--_Dest = ::std:: move(*--_Last);
 return (_Dest);
 }

template<class _BidIt1,
 class _BidIt2> inline
 _BidIt2 _Move_backward_unchecked1(_BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest, _Trivially_copyable_ptr_iterator_tag)
 {
 return (_Copy_backward_memmove(_First, _Last, _Dest));
 }

template<class _BidIt1,
 class _BidIt2> inline
 _BidIt2 _Move_backward_unchecked(_BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest)
 {
 return (_Move_backward_unchecked1(_First, _Last,
  _Dest, _Ptr_move_cat(_First, _Dest)));
 }

template<class _BidIt1,
 class _BidIt2> inline
 _BidIt2 _Move_backward1(_BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest, input_iterator_tag, _Any_tag)
 {
 return (_Rechecked(_Dest,
  _Move_backward_unchecked(_First, _Last, _Unchecked_idl0(_Dest))));
 }

template<class _BidIt1,
 class _BidIt2> inline
 _BidIt2 _Move_backward1(_BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest, random_access_iterator_tag, random_access_iterator_tag)
 {
                                                  ;
 return (_Rechecked(_Dest,
  _Move_backward_unchecked(_First, _Last, _Unchecked(_Dest))));
 }

template<class _BidIt1,
 class _BidIt2> inline
 _BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest)
 {
 struct _Unchecked_iterators { static void _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
                                       ;
 return (_Move_backward1(_Unchecked(_First), _Unchecked(_Last),
  _Dest, _Iter_cat_t<_BidIt1>(), _Iter_cat_t<_BidIt2>()));
 }


template<class _Ty>
 struct _Is_character
  : false_type
  {
  };

template<>
 struct _Is_character<char>
  : true_type
  {
  };

template<>
 struct _Is_character<signed char>
  : true_type
  {
  };

template<>
 struct _Is_character<unsigned char>
  : true_type
  {
  };

template<class _FwdIt,
 class _Ty>
 struct _Fill_memset_is_safe_helper
 {
 typedef _Iter_value_t<_FwdIt> _Value_type;
 typedef typename conjunction<
  is_pointer<_FwdIt>,
  disjunction<
   conjunction<
    _Is_character<_Ty>,
    _Is_character<_Value_type>>,
   conjunction<
    is_same<bool, _Ty>,
    is_same<bool, _Value_type>>
  >>::type type;
 };

template<class _FwdIt,
 class _Ty> inline
 typename _Fill_memset_is_safe_helper<_FwdIt, _Ty>::type
 _Fill_memset_is_safe(const _FwdIt&, const _Ty&)
 {
 return {};
 }

template<class _FwdIt,
 class _Ty> inline
 void _Fill_unchecked1(_FwdIt _First, _FwdIt _Last, const _Ty& _Val, false_type)
 {
 for (; _First != _Last; ++_First)
  *_First = _Val;
 }

template<class _FwdIt,
 class _Ty> inline
 void _Fill_unchecked1(_FwdIt _First, _FwdIt _Last, const _Ty& _Val, true_type)
 {
 :: memset(_First, _Val, _Last - _First);
 }

template<class _FwdIt,
 class _Ty> inline
 void _Fill_unchecked(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
 {
 _Fill_unchecked1(_First, _Last, _Val, _Fill_memset_is_safe(_First, _Val));
 }

template<class _FwdIt,
 class _Ty> inline
 void fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
 {
                            ;
 _Fill_unchecked(_Unchecked(_First), _Unchecked(_Last), _Val);
 }


template<class _OutIt,
 class _Diff,
 class _Ty> inline
 _OutIt _Fill_n_unchecked1(_OutIt _Dest, _Diff _Count, const _Ty& _Val, false_type)
 {
 for (; 0 < _Count; --_Count, (void)++_Dest)
  *_Dest = _Val;
 return (_Dest);
 }

template<class _OutIt,
 class _Diff,
 class _Ty> inline
 _OutIt _Fill_n_unchecked1(_OutIt _Dest, _Diff _Count, const _Ty& _Val, true_type)
 {
 if (0 < _Count)
  {
  :: memset(_Dest, _Val, _Count);
  return (_Dest + _Count);
  }

 return (_Dest);
 }

template<class _OutIt,
 class _Diff,
 class _Ty> inline
 _OutIt _Fill_n_unchecked(_OutIt _Dest, _Diff _Count, const _Ty& _Val)
 {

 return (_Fill_n_unchecked1(_Dest, _Count, _Val, _Fill_memset_is_safe(_Dest, _Val)));
 }

template<class _OutIt,
 class _Diff,
 class _Ty> inline
 _OutIt fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)
 {
 return (_Rechecked(_Dest,
  _Fill_n_unchecked(_Unchecked_n(_Dest, _Count), _Count, _Val)));
 }


template<class _Elem1,
 class _Elem2>
 struct _Value_equality_is_bitwise_equality
  : bool_constant<static_cast<_Elem1>(-1) == static_cast<_Elem2>(-1)>
 {



 };

template<class _Elem1,
 class _Elem2,
 class _Pr>
 struct _Equal_memcmp_is_safe_helper
  : false_type
 {

 };

template<class _Elem1,
 class _Elem2>
 struct _Equal_memcmp_is_safe_helper<_Elem1, _Elem2, equal_to<>>
  : conjunction<
   _Is_same_size<_Elem1, _Elem2>,
   is_integral<_Elem1>,
   is_integral<_Elem2>,
   negation<is_same<bool, _Elem1>>,
   negation<is_same<bool, _Elem2>>,
   negation<is_volatile<_Elem1>>,
   negation<is_volatile<_Elem2>>,


   _Value_equality_is_bitwise_equality<_Elem1, _Elem2>
  >::type
 {
 };

template<class _Elem1,
 class _Elem2>
 struct _Equal_memcmp_is_safe_helper<_Elem1 *, _Elem2 *, equal_to<>>
  : is_same<remove_cv_t<_Elem1>, remove_cv_t<_Elem2>>::type
 {
 };

template<class _Elem>
 struct _Equal_memcmp_is_safe_helper<_Elem, _Elem, _Char_traits_eq<char_traits<_Elem>>>
  : _Equal_memcmp_is_safe_helper<_Elem, _Elem, equal_to<>>::type
 {
 };

template<class _Elem>
 struct _Equal_memcmp_is_safe_helper<_Elem, _Elem, equal_to<_Elem>>
  : _Equal_memcmp_is_safe_helper<_Elem, _Elem, equal_to<>>::type
 {

 };

template<class _Iter1,
 class _Iter2,
 class _Pr> inline
 false_type _Equal_memcmp_is_safe(const _Iter1&, const _Iter2&, const _Pr&)
 {
 return {};
 }

template<class _Obj1,
 class _Obj2,
 class _Pr> inline
 typename _Equal_memcmp_is_safe_helper<
  remove_const_t<_Obj1>,
  remove_const_t<_Obj2>,
  _Pr>::type
  _Equal_memcmp_is_safe(_Obj1 * const&, _Obj2 * const&, const _Pr&)
 {
 return {};
 }

template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool _Equal_unchecked1(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _Pr& _Pred, false_type)
 {
 for (; _First1 != _Last1; ++_First1, (void)++_First2)
  if (!_Pred(*_First1, *_First2))
   return (false);
 return (true);
 }

template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool _Equal_unchecked1(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _Pr&, true_type)
 {
 const char * const _First1_ch = reinterpret_cast<const char *>(_First1);
 const char * const _First2_ch = reinterpret_cast<const char *>(_First2);
 const size_t _Count = reinterpret_cast<const char *>(_Last1) - _First1_ch;
 return (:: memcmp(_First1_ch, _First2_ch, _Count) == 0);
 }

template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool _Equal_unchecked(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _Pr& _Pred)
 {
 return (_Equal_unchecked1(_First1, _Last1, _First2, _Pred,
  _Equal_memcmp_is_safe(_First1, _First2, _Pred)));
 }

template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool _Equal_no_deprecate1(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _Pr& _Pred, input_iterator_tag, input_iterator_tag)
 {
 return (_Equal_unchecked(_First1, _Last1, _Unchecked_idl0(_First2), _Pred));
 }

template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool _Equal_no_deprecate1(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _Pr& _Pred, random_access_iterator_tag, random_access_iterator_tag)
 {
                                             ;
 return (_Equal_unchecked(_First1, _Last1, _Unchecked(_First2), _Pred));
 }

template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool _Equal_no_deprecate(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _Pr& _Pred)
 {
                                           ;
                                            ;
 return (_Equal_no_deprecate1(_Unchecked(_First1), _Unchecked(_Last1),
  _First2, _Pred, _Iter_cat_t<_InIt1>(), _Iter_cat_t<_InIt2>()));
 }

template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool equal(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _Pr _Pred)
 {
 struct _Unchecked_iterators { static void _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_First2)));
 return (_Equal_no_deprecate(_First1, _Last1, _First2, _Pred));
 }
# 3002 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility" 3
template<class _InIt1,
 class _InIt2> inline
 bool equal(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2)
 {
 return (::std:: equal(_First1, _Last1, _First2,
  equal_to<>()));
 }
# 3024 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility" 3
template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool _Equal_unchecked(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr& _Pred,
   input_iterator_tag, input_iterator_tag)
 {

                                                                 ;
 for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void)++_First2)
  if (!_Pred(*_First1, *_First2))
   return (false);
 return (_First1 == _Last1 && _First2 == _Last2);
 }

template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool _Equal_unchecked(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr& _Pred,
   random_access_iterator_tag, random_access_iterator_tag)
 {

 if (_Last1 - _First1 != _Last2 - _First2)
  return (false);
                                            ;
 return (_Equal_unchecked(_First1, _Last1, _First2, _Pred));
 }

template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool equal(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
 {
                              ;
                              ;
 return (_Equal_unchecked(_Unchecked(_First1), _Unchecked(_Last1),
  _Unchecked(_First2), _Unchecked(_Last2), _Pred,
   _Iter_cat_t<_InIt1>(), _Iter_cat_t<_InIt2>()));
 }


template<class _InIt1,
 class _InIt2> inline
 bool equal(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2)
 {
 return (::std:: equal(_First1, _Last1, _First2, _Last2,
  equal_to<>()));
 }


template<class _Elem1,
 class _Elem2,
 class _FTy>
 struct _Lex_compare_check_element_types_helper
  : conjunction<
   _Is_character<_Elem1>,
   _Is_character<_Elem2>,
   _Is_character<_FTy>,
   is_unsigned<_FTy>
  >::type
 {
 };

template<class _Elem1,
 class _Elem2>
 struct _Lex_compare_check_element_types_helper<_Elem1, _Elem2, void>
  : conjunction<
   _Is_character<_Elem1>,
   _Is_character<_Elem2>,
   is_unsigned<_Elem1>,
   is_unsigned<_Elem2>
  >::type
 {
 };

template<class _Memcmp_pr>
 struct _Lex_compare_optimize
 {
 };

template<class _Memcmp_pr,
 class _Obj1,
 class _Obj2,
 class _FTy>
 using _Lex_compare_check_element_types = _Lex_compare_optimize<conditional_t<
  _Lex_compare_check_element_types_helper<remove_const_t<_Obj1>, remove_const_t<_Obj2>, _FTy>::value,
  _Memcmp_pr, void>>;

template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 _Lex_compare_optimize<void> _Lex_compare_memcmp_classify(const _InIt1&, const _InIt2&, const _Pr&)
 {

 return {};
 }

template<class _Obj1,
 class _Obj2,
 class _FTy> inline
 _Lex_compare_check_element_types<less<int>, _Obj1, _Obj2, _FTy>
  _Lex_compare_memcmp_classify(_Obj1 * const&, _Obj2 * const&, const less<_FTy>&)
 {
 return {};
 }

template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool _Lex_compare_unchecked1(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr& _Pred, _Lex_compare_optimize<void>)
 {
 for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void)++_First2)
  {
  if (_Pred(*_First1, *_First2))
   return (true);
  else if (_Pred(*_First2, *_First1))
   return (false);
  }

 return (_First1 == _Last1 && _First2 != _Last2);
 }

template<class _InIt1,
 class _InIt2,
 class _Pr,
 class _Memcmp_pr> inline
 bool _Lex_compare_unchecked1(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr&, _Lex_compare_optimize<_Memcmp_pr>)
 {
 const size_t _Num1 = _Last1 - _First1;
 const size_t _Num2 = _Last2 - _First2;
 const int _Ans = :: memcmp(_First1, _First2, _Num1 < _Num2 ? _Num1 : _Num2);
 return (_Memcmp_pr{}(_Ans, 0) || _Ans == 0 && _Num1 < _Num2);
 }

template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool _Lex_compare_unchecked(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr& _Pred)
 {
 return (_Lex_compare_unchecked1(_First1, _Last1, _First2, _Last2, _Pred,
  _Lex_compare_memcmp_classify(_First1, _First2, _Pred)));
 }

template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
 {
                              ;
                              ;
                                                                 ;
 return (_Lex_compare_unchecked(_Unchecked(_First1), _Unchecked(_Last1),
  _Unchecked(_First2), _Unchecked(_Last2), _Pred));
 }


template<class _InIt1,
 class _InIt2> inline
 bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2)
 {
 return (::std:: lexicographical_compare(_First1, _Last1,
  _First2, _Last2, less<>()));
 }


template<class _Ty> inline
 bool _Within_limits(const _Ty& _Val, true_type, true_type, _Any_tag)
 {
 return ((-128) <= _Val && _Val <= 127);
 }

template<class _Ty> inline
 bool _Within_limits(const _Ty& _Val, true_type, false_type, true_type)
 {
 return (_Val <= 127 || static_cast<_Ty>((-128)) <= _Val);
 }

template<class _Ty> inline
 bool _Within_limits(const _Ty& _Val, true_type, false_type, false_type)
 {
 return (_Val <= 127);
 }

template<class _Ty> inline
 bool _Within_limits(const _Ty& _Val, false_type, true_type, _Any_tag)
 {
 return (0 <= _Val && _Val <= 0xff);
 }

template<class _Ty> inline
 bool _Within_limits(const _Ty& _Val, false_type, false_type, _Any_tag)
 {
 return (_Val <= 0xff);
 }

template<class _InIt,
 class _Ty> inline
 bool _Within_limits(_InIt, const _Ty& _Val)
 {
 typedef typename remove_pointer<_InIt>::type _Elem;
 return (_Within_limits(_Val, is_signed<_Elem>(), is_signed<_Ty>(),
  integral_constant<bool, -1 == static_cast<_Ty>(-1)>()));
 }

template<class _InIt> inline
 bool _Within_limits(_InIt, const bool&)
 {
 return (true);
 }

template<class _InIt,
 class _Ty> inline
 _InIt _Find_unchecked1(_InIt _First, _InIt _Last, const _Ty& _Val, true_type)
 {
 if (!_Within_limits(_First, _Val))
  return (_Last);
 _First = static_cast<_InIt>(:: memchr(
  _First, static_cast<unsigned char>(_Val), _Last - _First));
 return (_First ? _First : _Last);
 }

template<class _InIt,
 class _Ty> inline
 _InIt _Find_unchecked1(_InIt _First, _InIt _Last, const _Ty& _Val, false_type)
 {
 for (; _First != _Last; ++_First)
  if (*_First == _Val)
   break;
 return (_First);
 }

template<class _InIt,
 class _Ty> inline
 _InIt _Find_unchecked(_InIt _First, _InIt _Last, const _Ty& _Val)
 {

 typedef integral_constant<bool,
  (is_same<_InIt, char *>::value
  || is_same<_InIt, signed char *>::value
  || is_same<_InIt, unsigned char *>::value
  || is_same<_InIt, const char *>::value
  || is_same<_InIt, const signed char *>::value
  || is_same<_InIt, const unsigned char *>::value)
  && is_integral<_Ty>::value
 > _Memchr_opt;
 return (_Find_unchecked1(_First, _Last, _Val, _Memchr_opt()));
 }

template<class _InIt,
 class _Ty> inline
 _InIt find(_InIt _First, _InIt _Last, const _Ty& _Val)
 {
                            ;
 return (_Rechecked(_First,
  _Find_unchecked(_Unchecked(_First), _Unchecked(_Last), _Val)));
 }


template<class _InIt,
 class _Ty,
 class _Pr> inline
 _InIt _Find_pr(_InIt _First, _InIt _Last, const _Ty& _Val, _Pr& _Pred)
 {
 for (; _First != _Last; ++_First)
  if (_Pred(*_First, _Val))
   break;
 return (_First);
 }


template<class _InIt,
 class _Ty> inline
 _Iter_diff_t<_InIt>
  _Count_unchecked(_InIt _First, _InIt _Last, const _Ty& _Val)
 {
 _Iter_diff_t<_InIt> _Count = 0;

 for (; _First != _Last; ++_First)
  if (*_First == _Val)
   ++_Count;
 return (_Count);
 }

template<class _InIt,
 class _Ty> inline
 _Iter_diff_t<_InIt>
  count(_InIt _First, _InIt _Last, const _Ty& _Val)
 {
                            ;
 return (_Count_unchecked(_Unchecked(_First), _Unchecked(_Last), _Val));
 }


template<class _InIt,
 class _Ty,
 class _Pr> inline
 _Iter_diff_t<_InIt>
  _Count_pr(_InIt _First, _InIt _Last, const _Ty& _Val, _Pr& _Pred)
 {
 _Iter_diff_t<_InIt> _Count = 0;

 for (; _First != _Last; ++_First)
  if (_Pred(*_First, _Val))
   ++_Count;
 return (_Count);
 }


template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 void _Trim_matching_suffixes(_FwdIt1&, _FwdIt2&, _Pr&,
  forward_iterator_tag, forward_iterator_tag)
 {
 }

template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 void _Trim_matching_suffixes(_FwdIt1& _Last1, _FwdIt2& _Last2, _Pr& _Pred,
  bidirectional_iterator_tag, bidirectional_iterator_tag)
 {

 while (_Pred(*--_Last1, *--_Last2))
  ;
 ++_Last1;
 ++_Last2;
 }


template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 bool _Check_match_counts(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr& _Pred)
 {
 _Trim_matching_suffixes(_Last1, _Last2, _Pred,
  _Iter_cat_t<_FwdIt1>(), _Iter_cat_t<_FwdIt2>());
 for (_FwdIt1 _Next1 = _First1; _Next1 != _Last1; ++_Next1)
  if (_Next1 == _Find_pr(_First1, _Next1, *_Next1, _Pred))
   {
   _Iter_diff_t<_FwdIt2> _Count2 = _Count_pr(_First2, _Last2, *_Next1, _Pred);
   if (_Count2 == 0)
    return (false);
   _FwdIt1 _Skip1 = ::std:: next(_Next1);
   _Iter_diff_t<_FwdIt1> _Count1 = _Count_pr(_Skip1, _Last1, *_Next1, _Pred) + 1;
   if (_Count2 != _Count1)
    return (false);
   }

 return (true);
 }


template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 bool _Is_permutation_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _Pr& _Pred)
 {
 for (; _First1 != _Last1; ++_First1, (void)++_First2)
  if (!_Pred(*_First1, *_First2))
   {
   _FwdIt2 _Last2 = ::std:: next(_First2,
    ::std:: distance(_First1, _Last1));
   return (_Check_match_counts(_First1, _Last1,
    _First2, _Last2, _Pred));
   }

 return (true);
 }

template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 bool _Is_permutation_no_deprecate1(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _Pr& _Pred, forward_iterator_tag, forward_iterator_tag)
 {
 return (_Is_permutation_unchecked(_First1, _Last1, _Unchecked_idl0(_First2), _Pred));
 }

template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 bool _Is_permutation_no_deprecate1(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _Pr& _Pred, random_access_iterator_tag, random_access_iterator_tag)
 {
                                             ;
 return (_Is_permutation_unchecked(_First1, _Last1, _Unchecked(_First2), _Pred));
 }

template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 bool _Is_permutation_no_deprecate(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _Pr& _Pred)
 {
                                           ;
                                            ;
 return (_Is_permutation_no_deprecate1(_Unchecked(_First1), _Unchecked(_Last1),
  _First2, _Pred, _Iter_cat_t<_FwdIt1>(), _Iter_cat_t<_FwdIt2>()));
 }

template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _Pr _Pred)
 {
 struct _Unchecked_iterators { static void _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_First2)));
 return (_Is_permutation_no_deprecate(_First1, _Last1, _First2, _Pred));
 }
# 3460 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility" 3
template<class _FwdIt1,
 class _FwdIt2> inline
 bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2)
 {
 return (::std:: is_permutation(_First1, _Last1,
  _First2, equal_to<>()));
 }
# 3482 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility" 3
template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 bool _Is_permutation_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr& _Pred,
  forward_iterator_tag, forward_iterator_tag)
 {

                                                                 ;
 for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void)++_First2)
  if (!_Pred(*_First1, *_First2))
   {
   if (::std:: distance(_First1, _Last1)
    != ::std:: distance(_First2, _Last2))
    return (false);
   else
    return (_Check_match_counts(_First1, _Last1,
     _First2, _Last2, _Pred));
   }

 return (_First1 == _Last1 && _First2 == _Last2);
 }

template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 bool _Is_permutation_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr& _Pred,
  random_access_iterator_tag, random_access_iterator_tag)
 {

 if (_Last1 - _First1 != _Last2 - _First2)
  return (false);
                                            ;
 return (_Is_permutation_unchecked(_First1, _Last1, _First2, _Pred));
 }

template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
 {

                              ;
                              ;
 return (_Is_permutation_unchecked(_Unchecked(_First1), _Unchecked(_Last1),
  _Unchecked(_First2), _Unchecked(_Last2), _Pred,
  _Iter_cat_t<_FwdIt1>(), _Iter_cat_t<_FwdIt2>()));
 }


template<class _FwdIt1,
 class _FwdIt2> inline
 bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2)
 {
 return (::std:: is_permutation(_First1, _Last1,
  _First2, _Last2, equal_to<>()));
 }


template<class _BidIt> inline
 void _Reverse_unchecked(_BidIt _First, _BidIt _Last)
 {
 for (; _First != _Last && _First != --_Last; ++_First)
  ::std:: iter_swap(_First, _Last);
 }

template<class _BidIt> inline
 void reverse(_BidIt _First, _BidIt _Last)
 {
                            ;
 _Reverse_unchecked(_Unchecked(_First), _Unchecked(_Last));
 }


template<class _FwdIt> inline
 _FwdIt _Rotate_unchecked1(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last,
  forward_iterator_tag)
 {
 for (_FwdIt _Next = _Mid, _Res = _Last; ; )
  {
  ::std:: iter_swap(_First, _Next);
  if (++_First == _Mid)
   {
   if (++_Next == _Last)
    return (_Res == _Last ? _Mid : _Res);
   else
    _Mid = _Next;
   }
  else if (++_Next == _Last)
   {
   if (_Res == _Last)
    _Res = _First;
   _Next = _Mid;
   }
  }
 }

template<class _BidIt> inline
 pair<_BidIt, _BidIt> _Reverse_until_sentinel_unchecked(
  _BidIt _First, _BidIt _Sentinel, _BidIt _Last)
 {
 while (_First != _Sentinel && _Last != _Sentinel)
  ::std:: iter_swap(_First++, --_Last);
 return (::std:: make_pair(_First, _Last));
 }

template<class _BidIt> inline
 _BidIt _Rotate_unchecked1(_BidIt _First, _BidIt _Mid, _BidIt _Last,
  bidirectional_iterator_tag)
 {
 _Reverse_unchecked(_First, _Mid);
 _Reverse_unchecked(_Mid, _Last);
 pair<_BidIt, _BidIt> _Tmp = _Reverse_until_sentinel_unchecked(_First, _Mid, _Last);
 _Reverse_unchecked(_Tmp.first, _Tmp.second);
 return (_Mid != _Tmp.first ? _Tmp.first : _Tmp.second);
 }

template<class _RanIt> inline
 _RanIt _Rotate_unchecked1(_RanIt _First, _RanIt _Mid, _RanIt _Last,
  random_access_iterator_tag)
 {
 _Reverse_unchecked(_First, _Mid);
 _Reverse_unchecked(_Mid, _Last);
 _Reverse_unchecked(_First, _Last);
 return (_First + (_Last - _Mid));
 }

template<class _FwdIt> inline
 _FwdIt _Rotate_unchecked(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last)
 {
 if (_First == _Mid)
  return (_Last);
 if (_Mid == _Last)
  return (_First);
 return (_Rotate_unchecked1(_First, _Mid, _Last, _Iter_cat_t<_FwdIt>()));
 }

template<class _FwdIt> inline
 _FwdIt rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last)
 {
                           ;
                          ;
 return (_Rechecked(_First,
  _Rotate_unchecked(_Unchecked(_First), _Unchecked(_Mid),
  _Unchecked(_Last))));
 }


template<class _Diff,
 class _Urng>
 class _Rng_from_urng
 {
public:
 typedef typename make_unsigned<_Diff>::type _Ty0;
 typedef typename _Urng::result_type _Ty1;

 typedef typename _If<sizeof (_Ty1) < sizeof (_Ty0),
  _Ty0, _Ty1>::type _Udiff;


 explicit _Rng_from_urng(_Urng& _Func)
  : _Ref(_Func), _Bits(8 * sizeof (_Udiff)), _Bmask(_Udiff(-1))
  {
  for (; (_Urng::max)() - (_Urng::min)() < _Bmask; _Bmask >>= 1)
   --_Bits;
  }

 _Diff operator()(_Diff _Index)
  {
  for (; ; )
   {
   _Udiff _Ret = 0;
   _Udiff _Mask = 0;

   while (_Mask < _Udiff(_Index - 1))
    {
    _Ret <<= _Bits - 1;
    _Ret <<= 1;
    _Ret |= _Get_bits();
    _Mask <<= _Bits - 1;
    _Mask <<= 1;
    _Mask |= _Bmask;
    }


   if (_Ret / _Index < _Mask / _Index
    || _Mask % _Index == _Udiff(_Index - 1))
    return (_Ret % _Index);
   }
  }

 _Udiff _Get_all_bits()
  {
  _Udiff _Ret = 0;

  for (size_t _Num = 0; _Num < 8 * sizeof (_Udiff);
   _Num += _Bits)
   {
   _Ret <<= _Bits - 1;
   _Ret <<= 1;
   _Ret |= _Get_bits();
   }

  return (_Ret);
  }

 _Rng_from_urng(const _Rng_from_urng&) = delete;
 _Rng_from_urng& operator=(const _Rng_from_urng&) = delete;

private:
 _Udiff _Get_bits()
  {
  for (; ; )
   {
   _Udiff _Val = _Ref() - (_Urng::min)();

   if (_Val <= _Bmask)
    return (_Val);
   }
  }

 _Urng& _Ref;
 size_t _Bits;
 _Udiff _Bmask;
 };


template<class _Elem>
 class _Yarn
 {
public:
 typedef _Yarn<_Elem> _Myt;

                    _Yarn()
  : _Myptr(0), _Nul(0)
  {
  }

                    _Yarn(const _Myt& _Right)
  : _Myptr(0), _Nul(0)
  {
  *this = _Right;
  }

                    _Yarn(const _Elem *_Right)
  : _Myptr(0), _Nul(0)
  {
  *this = _Right;
  }

 _Myt& operator=(const _Myt& _Right)
  {
  return (*this = _Right._Myptr);
  }

 _Myt& operator=(const _Elem *_Right)
  {
  if (_Myptr != _Right)
   {
   _Tidy();

   if (_Right != 0)
    {
    const _Elem *_Ptr = _Right;
    while (*_Ptr != (_Elem)0)
     ++_Ptr;
    size_t _Count = ((const char *)++_Ptr - (const char *)_Right);






    _Myptr = (_Elem *):: malloc(_Count);


    if (_Myptr != 0)
     :: memcpy(_Myptr, _Right, _Count);
    }
   }

  return (*this);
  }

                    ~_Yarn() noexcept
  {
  _Tidy();
  }

 bool empty() const
  {
  return (_Myptr == 0);
  }

 const _Elem * c_str() const
  {
  return (_Myptr != 0 ? _Myptr : &_Nul);
  }

 bool _Empty() const
  {
  return (_Myptr == 0);
  }

 const _Elem * _C_str() const
  {
  return (_Myptr != 0 ? _Myptr : &_Nul);
  }

private:
 void _Tidy()
  {
  if (_Myptr != 0)





   :: free(_Myptr);


  _Myptr = 0;
  }

 _Elem *_Myptr;
 _Elem _Nul;
 };


template<class _Ty,
 class _Alloc>
 struct _Has_allocator_type
 {
 template<class _Uty>
  static auto _Fn(int)
   -> is_convertible<_Alloc,
    typename _Uty::allocator_type>;
 template<class _Uty>
  static auto _Fn(_Wrap_int)
   -> false_type;

 typedef decltype(_Fn<_Ty>(0)) type;
 };


struct allocator_arg_t
 {
 };

constexpr allocator_arg_t allocator_arg{};

[[noreturn]] void __cdecl _Xbad_alloc();
[[noreturn]] void __cdecl _Xinvalid_argument( const char *);
[[noreturn]] void __cdecl _Xlength_error( const char *);
[[noreturn]] void __cdecl _Xout_of_range( const char *);
[[noreturn]] void __cdecl _Xoverflow_error( const char *);
[[noreturn]] void __cdecl _Xruntime_error( const char *);
}

namespace std {

template<class _Ty,
 class _Alloc>
 struct uses_allocator
  : _Has_allocator_type<_Ty, _Alloc>::type
 {
 };


template<class _Ty,
 class _Alloc>
 constexpr bool uses_allocator_v = uses_allocator<_Ty, _Alloc>::value;

}

#pragma warning(pop)
#pragma pack(pop)
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory0" 2 3


#pragma pack(push,8)
#pragma warning(push, 3)







#pragma warning(disable: 4100)

namespace std {
# 45 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory0" 3
inline
 __declspec(allocator) void *_Allocate(size_t _Count, size_t _Sz,
  bool _Try_aligned_allocation = true)
 {
 void *_Ptr = 0;

 if (_Count == 0)
  return (_Ptr);


 if ((size_t)(-1) / _Sz < _Count)
  _Xbad_alloc();
 const size_t _User_size = _Count * _Sz;


 if (_Try_aligned_allocation
  && 4096 <= _User_size)
  {
  static_assert(sizeof (void *) < 32,
   "Big allocations should at least match vector register size");
  const size_t _Block_size = (sizeof(void *) + 32 - 1) + _User_size;
  if (_Block_size <= _User_size)
   _Xbad_alloc();
  const uintptr_t _Ptr_container =
   reinterpret_cast<uintptr_t>(::operator new(_Block_size));
  { if (!(_Ptr_container != 0)) { ((void)0); ::_invalid_parameter_noinfo_noreturn(); } ; };
  _Ptr = reinterpret_cast<void *>((_Ptr_container + (sizeof(void *) + 32 - 1))
   & ~(32 - 1));
  static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;




  }
 else


  {
  _Ptr = ::operator new(_User_size);
  { if (!(_Ptr != 0)) { ((void)0); ::_invalid_parameter_noinfo_noreturn(); } ; };
  }
 return (_Ptr);
 }


inline
 void _Deallocate(void * _Ptr, size_t _Count, size_t _Sz)
 {

 { if (!(_Count <= (size_t)(-1) / _Sz)) { ((void)0); ::_invalid_parameter_noinfo_noreturn(); } ; };
 const size_t _User_size = _Count * _Sz;
 if (4096 <= _User_size)
  {
  const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
  { if (!((_Ptr_user & (32 - 1)) == 0)) { ((void)0); ::_invalid_parameter_noinfo_noreturn(); } ; };

  const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
  const uintptr_t _Ptr_container =
   *reinterpret_cast<uintptr_t *>(_Ptr_ptr);
# 114 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory0" 3
  { if (!(_Ptr_container < _Ptr_user)) { ((void)0); ::_invalid_parameter_noinfo_noreturn(); } ; };






  { if (!(sizeof(void *) <= _Ptr_user - _Ptr_container)) { ((void)0); ::_invalid_parameter_noinfo_noreturn(); } ; };



  { if (!(_Ptr_user - _Ptr_container <= (sizeof(void *) + 32 - 1))) { ((void)0); ::_invalid_parameter_noinfo_noreturn(); } ; };


  _Ptr = reinterpret_cast<void *>(_Ptr_container);
  }


 ::operator delete(_Ptr);
 }


template<class _Ty1,
 class _Ty2> inline
 void _Construct(_Ty1 *_Ptr, _Ty2&& _Val)
 {
 void *_Vptr = _Ptr;
 ::new (_Vptr) _Ty1(::std:: forward<_Ty2>(_Val));
 }

template<class _Ty1> inline
 void _Construct(_Ty1 *_Ptr)
 {
 void *_Vptr = _Ptr;

 ::new (_Vptr) _Ty1();
 }


template<class _Alty>
 struct _Is_simple_alloc
  : _Cat_base<is_same<typename _Alty::size_type, size_t>::value
  && is_same<typename _Alty::difference_type, ptrdiff_t>::value
  && is_same<typename _Alty::pointer,
   typename _Alty::value_type *>::value
  && is_same<typename _Alty::const_pointer,
   const typename _Alty::value_type *>::value
  && is_same<typename _Alty::reference,
   typename _Alty::value_type&>::value
  && is_same<typename _Alty::const_reference,
   const typename _Alty::value_type&>::value>
 {
 };


template<class _Value_type>
 struct _Simple_types
 {
 typedef _Value_type value_type;
 typedef size_t size_type;
 typedef ptrdiff_t difference_type;
 typedef value_type *pointer;
 typedef const value_type *const_pointer;
 typedef value_type& reference;
 typedef const value_type& const_reference;
 };


template<class _Alty,
 class _Pointer>
 struct _Get_voidptr
 {
 typedef typename _Alty::template rebind<void>::other _Alvoid;
 typedef typename _Alvoid::pointer type;
 };

template<class _Alty,
 class _Ty>
 struct _Get_voidptr<_Alty, _Ty *>
 {
 typedef void *type;
 };


template<class _Ty>
 struct _Get_first_parameter;

template<template<class, class...> class _Ty,
 class _First,
 class... _Rest>
 struct _Get_first_parameter<_Ty<_First, _Rest...> >
 {
 typedef _First type;
 };


template<class _Newfirst,
 class _Ty>
 struct _Replace_first_parameter;

template<class _Newfirst,
 template<class, class...> class _Ty,
 class _First,
 class... _Rest>
 struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...> >
 {
 typedef _Ty<_Newfirst, _Rest...> type;
 };


template<class _Ty>
 struct _Get_element_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::element_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename _Get_first_parameter<_Uty>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



template<class _Ty>
 struct _Get_ptr_difference_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::difference_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<ptrdiff_t>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



template<class _Ty,
 class _Other>
 struct _Get_rebind_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::template rebind<_Other>::other>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename _Replace_first_parameter<_Other , _Uty>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



template<class _Ty>
 struct pointer_traits
 {
 typedef typename _Get_element_type<_Ty>::type element_type;
 typedef _Ty pointer;
 typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;

 template<class _Other>
  using rebind = typename _Get_rebind_type<_Ty, _Other>::type;

 typedef typename _If<is_void<element_type>::value,
  char&,
  typename add_lvalue_reference<element_type>::type>::type _Reftype;

 static pointer pointer_to(_Reftype _Val)
  {
  return (_Ty::pointer_to(_Val));
  }
 };


template<class _Ty>
 struct pointer_traits<_Ty *>
 {
 typedef _Ty element_type;
 typedef _Ty *pointer;
 typedef ptrdiff_t difference_type;

 template<class _Other>
  using rebind = _Other *;

 typedef typename _If<is_void<_Ty>::value,
  char&,
  typename add_lvalue_reference<_Ty>::type>::type _Reftype;

 static pointer pointer_to(_Reftype _Val)
  {
  return (::std:: addressof(_Val));
  }
 };



template<class _Ptrty> inline
 void _Destroy(_Ptrty _Ptr)
 {
 typedef typename pointer_traits<_Ptrty>::element_type _Ty;
 _Ptr->~_Ty();
 }


template<class _Ptrty> inline
 auto _Const_cast(_Ptrty _Ptr)
 {
 using _Elem = typename pointer_traits<_Ptrty>::element_type;
 using _Modifiable = remove_const_t<_Elem>;
 using _Dest = typename pointer_traits<_Ptrty>::template rebind<_Modifiable>;

 return (pointer_traits<_Dest>::pointer_to(const_cast<_Modifiable&>(*_Ptr)));
 }

template<class _Ty> inline
 auto _Const_cast(_Ty * _Ptr)
 {
 return (const_cast<remove_const_t<_Ty> *>(_Ptr));
 }



template<class _Ty>
 struct _Get_pointer_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::pointer>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename _Ty::value_type *>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



template<class _Ty>
 struct _Get_const_pointer_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::const_pointer>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename pointer_traits<typename _Get_pointer_type<_Ty>::type> ::template rebind<const typename _Ty::value_type> >; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };




template<class _Ty>
 struct _Get_void_pointer_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::void_pointer>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename pointer_traits<typename _Get_pointer_type<_Ty>::type> ::template rebind<void> >; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };




template<class _Ty>
 struct _Get_const_void_pointer_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::const_void_pointer>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename pointer_traits<typename _Get_pointer_type<_Ty>::type> ::template rebind<const void> >; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };




template<class _Ty>
 struct _Get_difference_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::difference_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename _Get_ptr_difference_type< typename _Get_pointer_type<_Ty>::type>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };




template<class _Ty>
 struct _Get_size_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::size_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename make_unsigned< typename _Get_difference_type<_Ty>::type>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };




template<class _Ty>
 struct _Get_propagate_on_container_copy
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::propagate_on_container_copy_assignment>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<false_type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



template<class _Ty>
 struct _Get_propagate_on_container_move
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::propagate_on_container_move_assignment>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<false_type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



template<class _Ty>
 struct _Get_propagate_on_container_swap
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::propagate_on_container_swap>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<false_type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



template<class _Ty>
 struct _Get_is_always_equal
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::is_always_equal>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename is_empty<_Ty>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



template<class _Ty>
 class allocator;
template<class _Alloc>
 struct _Wrap_alloc;

template<class _Alloc>
 struct _Unwrap_alloc
 {
 typedef _Alloc type;
 };

template<class _Alloc>
 struct _Unwrap_alloc<_Wrap_alloc<_Alloc>>
 {
 typedef _Alloc type;
 };



template<class _Alloc>
 using _Unwrap_alloc_t = typename _Unwrap_alloc<_Alloc>::type;



template<class _Alloc,
 class = void>
 struct _Is_default_allocator
  : false_type
 {
 };

template<class _Ty>
 struct _Is_default_allocator<allocator<_Ty>, typename allocator<_Ty>::_Not_user_specialized>
  : true_type
 {
 };


struct _Alloc_allocate
 {


 template<class _Alloc,
  class _Size_type,
  class _Const_void_pointer>
  static auto _Fn(int, _Alloc& _Al,
   _Size_type _Count,
   _Const_void_pointer _Hint)
   -> decltype(_Al.allocate(_Count, _Hint))
  {
  return (_Al.allocate(_Count, _Hint));
  }

 template<class _Alloc,
  class _Size_type,
  class _Const_void_pointer>
  static auto _Fn(_Wrap_int, _Alloc& _Al,
   _Size_type _Count,
   _Const_void_pointer)
   -> decltype(_Al.allocate(_Count))
  {
  return (_Al.allocate(_Count));
  }
 };


struct _Has_no_alloc_construct_tag
 {
 };

template<class _Void,
 class... _Types>
 struct _Has_no_alloc_construct
  : true_type
 {
 };

template<class _Alloc,
 class _Ptr,
 class... _Args>
 struct _Has_no_alloc_construct<
  void_t<
   _Has_no_alloc_construct_tag,
   decltype(::std:: declval<_Alloc&>().construct(::std:: declval<_Ptr>(), ::std:: declval<_Args>()...))>,
  _Alloc, _Ptr, _Args...>
  : false_type
 {
 };

template<class _Alloc,
 class _Ptr,
 class... _Args>
 using _Uses_default_construct = disjunction<
  _Is_default_allocator<_Alloc>,
  _Has_no_alloc_construct<void, _Alloc, _Ptr, _Args...>>;

template<class _Alloc,
 class _Ptr,
 class... _Args>
 using _Uses_default_construct_t = typename _Uses_default_construct<_Alloc, _Ptr, _Args...>::type;



struct _Has_no_alloc_destroy_tag
 {
 };

template<class _Alloc,
 class _Ptr,
 class = void>
 struct _Has_no_alloc_destroy
  : true_type
 {
 };

template<class _Alloc,
 class _Ptr>
 struct _Has_no_alloc_destroy<_Alloc, _Ptr, void_t<
   _Has_no_alloc_destroy_tag,
   decltype(::std:: declval<_Alloc&>().destroy(::std:: declval<_Ptr>()))>>
  : false_type
 {
 };

template<class _Alloc,
 class _Ptr>
 using _Uses_default_destroy = disjunction<
  _Is_default_allocator<_Alloc>,
  _Has_no_alloc_destroy<_Alloc, _Ptr>>;

template<class _Alloc,
 class _Ptr>
 using _Uses_default_destroy_t = typename _Uses_default_destroy<_Alloc, _Ptr>::type;



struct _Alloc_max_size
 {
 template<class _Ty>
  static auto _Fn(int, const _Ty& _Al) noexcept
   -> decltype(_Al.max_size())
  {
  return (_Al.max_size());
  }

 template<class _Ty>
  static auto _Fn(_Wrap_int, const _Ty&) noexcept
   -> typename _Get_size_type<_Ty>::type
  {
  return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)()
   / sizeof(typename _Ty::value_type));
  }
 };


struct _Alloc_select
 {


 template<class _Ty>
  static auto _Fn(int, const _Ty& _Al)
   -> decltype((_Ty)_Al.select_on_container_copy_construction())
  {
  return (_Al.select_on_container_copy_construction());
  }

 template<class _Ty>
  static auto _Fn(_Wrap_int, const _Ty& _Al)
   -> _Ty
  {
  return (_Al);
  }
 };


template<class _Alloc>
 struct allocator_traits
 {
 typedef _Alloc allocator_type;
 typedef typename _Alloc::value_type value_type;

 typedef typename _Get_pointer_type<_Alloc>::type
  pointer;
 typedef typename _Get_const_pointer_type<_Alloc>::type
  const_pointer;
 typedef typename _Get_void_pointer_type<_Alloc>::type
  void_pointer;
 typedef typename _Get_const_void_pointer_type<_Alloc>::type
  const_void_pointer;

 typedef typename _Get_size_type<_Alloc>::type size_type;
 typedef typename _Get_difference_type<_Alloc>::type difference_type;

 typedef typename _Get_propagate_on_container_copy<_Alloc>::type
  propagate_on_container_copy_assignment;
 typedef typename _Get_propagate_on_container_move<_Alloc>::type
  propagate_on_container_move_assignment;
 typedef typename _Get_propagate_on_container_swap<_Alloc>::type
  propagate_on_container_swap;
 typedef typename _Get_is_always_equal<_Alloc>::type
  is_always_equal;

 template<class _Other>
  using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;

 template<class _Other>
  using rebind_traits = allocator_traits<rebind_alloc<_Other> >;

 static __declspec(allocator) pointer allocate(_Alloc& _Al, size_type _Count)
  {
  return (_Al.allocate(_Count));
  }

 static __declspec(allocator) pointer allocate(_Alloc& _Al, size_type _Count,
  const_void_pointer _Hint)
  {
  return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
  }

 static void deallocate(_Alloc& _Al,
  pointer _Ptr, size_type _Count)
  {
  _Al.deallocate(_Ptr, _Count);
  }

 template<class _Ty,
  class... _Types>
  static void _Construct1(true_type, _Alloc&, _Ty *_Ptr,
   _Types&&... _Args)
  {
  ::new (static_cast<void *>(_Ptr))
   _Ty(::std:: forward<_Types>(_Args)...);
  }

 template<class _Ty,
  class... _Types>
  static void _Construct1(false_type, _Alloc& _Al, _Ty *_Ptr,
   _Types&&... _Args)
  {
  _Al.construct(_Ptr, ::std:: forward<_Types>(_Args)...);
  }

 template<class _Ty,
  class... _Types>
  static void construct(_Alloc& _Al, _Ty *_Ptr,
   _Types&&... _Args)
  {
  _Construct1(_Uses_default_construct_t<_Unwrap_alloc_t<_Alloc>, _Ty *, _Types...>(),
   _Al, _Ptr, ::std:: forward<_Types>(_Args)...);
  }

 template<class _Ty>
  static void _Destroy1(_Alloc&, _Ty *_Ptr, true_type)
  {
  _Ptr->~_Ty();
  }

 template<class _Ty>
  static void _Destroy1(_Alloc& _Al, _Ty *_Ptr, false_type)
  {
  _Al.destroy(_Ptr);
  }

 template<class _Ty>
  static void destroy(_Alloc& _Al, _Ty *_Ptr)
  {
  _Destroy1(_Al, _Ptr, _Uses_default_destroy_t<_Unwrap_alloc_t<_Alloc>, _Ty *>());
  }

 static size_type max_size(const _Alloc& _Al) noexcept
  {
  return (_Alloc_max_size::_Fn(0, _Al));
  }

 static _Alloc select_on_container_copy_construction(
  const _Alloc& _Al)
  {
  return (_Alloc_select::_Fn(0, _Al));
  }
 };


template<class _Ty>
 class allocator
 {
public:
 static_assert(!is_const<_Ty>::value,
  "The C++ Standard forbids containers of const elements "
  "because allocator<const T> is ill-formed.");

 typedef void _Not_user_specialized;

 typedef _Ty value_type;

 typedef value_type *pointer;
 typedef const value_type *const_pointer;

 typedef value_type& reference;
 typedef const value_type& const_reference;

 typedef size_t size_type;
 typedef ptrdiff_t difference_type;

 typedef true_type propagate_on_container_move_assignment;
 typedef true_type is_always_equal;

 template<class _Other>
  struct rebind
  {
  typedef allocator<_Other> other;
  };

 pointer address(reference _Val) const noexcept
  {
  return (::std:: addressof(_Val));
  }

 const_pointer address(const_reference _Val) const noexcept
  {
  return (::std:: addressof(_Val));
  }

 allocator() noexcept
  {
  }

 allocator(const allocator<_Ty>&) noexcept
  {
  }

 template<class _Other>
  allocator(const allocator<_Other>&) noexcept
  {
  }

 template<class _Other>
  allocator<_Ty>& operator=(const allocator<_Other>&)
  {
  return (*this);
  }

 void deallocate(pointer _Ptr, size_type _Count)
  {
  _Deallocate(_Ptr, _Count, sizeof (_Ty));
  }

 __declspec(allocator) pointer allocate(size_type _Count)
  {
  return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
  }

 __declspec(allocator) pointer allocate(size_type _Count, const void *)
  {
  return (allocate(_Count));
  }

 template<class _Objty,
  class... _Types>
  void construct(_Objty *_Ptr, _Types&&... _Args)
  {
  ::new ((void *)_Ptr) _Objty(::std:: forward<_Types>(_Args)...);
  }


 template<class _Uty>
  void destroy(_Uty *_Ptr)
  {
  _Ptr->~_Uty();
  }

 size_t max_size() const noexcept
  {
  return ((size_t)(-1) / sizeof (_Ty));
  }
 };


template<>
 class allocator<void>
 {
public:
 typedef void _Not_user_specialized;

 typedef void value_type;

 typedef void *pointer;
 typedef const void *const_pointer;

 template<class _Other>
  struct rebind
  {
  typedef allocator<_Other> other;
  };

 allocator() noexcept
  {
  }

 allocator(const allocator<void>&) noexcept
  {
  }

 template<class _Other>
  allocator(const allocator<_Other>&) noexcept
  {
  }

 template<class _Other>
  allocator<void>& operator=(const allocator<_Other>&)
  {
  return (*this);
  }
 };

template<class _Ty,
 class _Other> inline
 bool operator==(const allocator<_Ty>&,
  const allocator<_Other>&) noexcept
 {
 return (true);
 }

template<class _Ty,
 class _Other> inline
 bool operator!=(const allocator<_Ty>& _Left,
  const allocator<_Other>& _Right) noexcept
 {
 return (false);
 }


template<class _Ty>
 struct allocator_traits<allocator<_Ty> >
 {
 typedef allocator<_Ty> _Alloc;

 typedef _Alloc allocator_type;
 typedef _Ty value_type;

 typedef value_type *pointer;
 typedef const value_type *const_pointer;
 typedef void *void_pointer;
 typedef const void *const_void_pointer;

 typedef size_t size_type;
 typedef ptrdiff_t difference_type;

 typedef false_type propagate_on_container_copy_assignment;
 typedef true_type propagate_on_container_move_assignment;
 typedef false_type propagate_on_container_swap;
 typedef true_type is_always_equal;

 template<class _Other>
  using rebind_alloc = allocator<_Other>;

 template<class _Other>
  using rebind_traits = allocator_traits<allocator<_Other> >;

 static __declspec(allocator) pointer allocate(_Alloc& _Al, size_type _Count)
  {
  return (_Al.allocate(_Count));
  }

 static __declspec(allocator) pointer allocate(_Alloc& _Al, size_type _Count,
  const_void_pointer _Hint)
  {
  return (_Al.allocate(_Count, _Hint));
  }

 static void deallocate(_Alloc& _Al,
  pointer _Ptr, size_type _Count)
  {
  _Al.deallocate(_Ptr, _Count);
  }

 template<class _Objty,
  class... _Types>
  static void construct(_Alloc& _Al, _Objty *_Ptr,
   _Types&&... _Args)
  {
  _Al.construct(_Ptr, ::std:: forward<_Types>(_Args)...);
  }


 template<class _Uty>
  static void destroy(_Alloc& _Al, _Uty *_Ptr)
  {
  _Al.destroy(_Ptr);
  }

 static size_type max_size(const _Alloc& _Al) noexcept
  {
  return (_Al.max_size());
  }

 static _Alloc select_on_container_copy_construction(
  const _Alloc& _Al)
  {
  return (_Al);
  }
 };


template<class _Alloc>
 struct _Wrap_alloc
  : public _Alloc
 {
 typedef _Alloc _Mybase;
 typedef allocator_traits<_Alloc> _Mytraits;

 typedef typename _Mytraits::value_type value_type;

 typedef typename _Mytraits::pointer pointer;
 typedef typename _Mytraits::const_pointer const_pointer;
 typedef typename _Mytraits::void_pointer void_pointer;
 typedef typename _Mytraits::const_void_pointer const_void_pointer;

 typedef typename _If<is_void<value_type>::value,
  int, value_type>::type& reference;
 typedef typename _If<is_void<const value_type>::value,
  const int, const value_type>::type& const_reference;

 typedef typename _Mytraits::size_type size_type;
 typedef typename _Mytraits::difference_type difference_type;

 typedef typename _Mytraits::propagate_on_container_copy_assignment
  propagate_on_container_copy_assignment;
 typedef typename _Mytraits::propagate_on_container_move_assignment
  propagate_on_container_move_assignment;
 typedef typename _Mytraits::propagate_on_container_swap
  propagate_on_container_swap;
 typedef typename _Mytraits::is_always_equal
  is_always_equal;

 _Wrap_alloc select_on_container_copy_construction(_Nil = _Nil()) const
  {
  return (_Mytraits::select_on_container_copy_construction(*this));
  }

 template<class _Other>
  struct rebind
  {
  typedef typename _Mytraits::template rebind_alloc<_Other>
   _Other_alloc;
  typedef _Wrap_alloc<_Other_alloc> other;
  };

 pointer address(reference _Val) const
  {
  return (pointer_traits<pointer>::pointer_to(_Val));
  }

 const_pointer address(const_reference _Val) const
  {
  return (pointer_traits<const_pointer>::pointer_to(_Val));
  }

 _Wrap_alloc() noexcept(is_nothrow_default_constructible<_Alloc>::value)
  : _Mybase()
  {
  }

 _Wrap_alloc(const _Wrap_alloc& _Right) noexcept
  : _Mybase(_Right)
  {
  }

 _Wrap_alloc(_Wrap_alloc&& _Right) noexcept
  : _Mybase(::std:: move(_Right))
  {
  }

 template<class _Other>
  _Wrap_alloc(_Other&& _Right) noexcept
  : _Mybase(::std:: forward<_Other>(_Right))
  {
  }

 _Wrap_alloc& operator=(const _Wrap_alloc& _Right)
  {
  _Mybase::operator=(_Right);
  return (*this);
  }

 _Wrap_alloc& operator=(_Wrap_alloc&& _Right)
  {
  _Mybase::operator=(::std:: move(_Right));
  return (*this);
  }

 template<class _Other>
  _Wrap_alloc& operator=(_Other&& _Right)
  {
  _Mybase::operator=(::std:: forward<_Other>(_Right));
  return (*this);
  }

 __declspec(allocator) pointer allocate(size_type _Count)
  {
  return (_Mybase::allocate(_Count));
  }

 __declspec(allocator) pointer allocate(size_type _Count,
  const_void_pointer _Hint, _Nil = _Nil())
  {
  return (_Mytraits::allocate(*this, _Count, _Hint));
  }

 void deallocate(pointer _Ptr, size_type _Count)
  {
  _Mybase::deallocate(_Ptr, _Count);
  }

 template<class _Ty,
  class... _Types>
  void construct(_Ty *_Ptr,
   _Types&&... _Args)
  {
  _Mytraits::construct(*this, _Ptr,
   ::std:: forward<_Types>(_Args)...);
  }


 template<class _Ty>
  void destroy(_Ty *_Ptr)
  {
  _Mytraits::destroy(*this, _Ptr);
  }

 size_type max_size(_Nil = _Nil()) const noexcept
  {
  return (_Mytraits::max_size(*this));
  }
 };

template<class _Ty,
 class _Other> inline
 bool operator==(const _Wrap_alloc<_Ty>& _Left,
  const _Wrap_alloc<_Other>& _Right) noexcept
 {
 return (static_cast<const _Ty&>(_Left)
  == static_cast<const _Other&>(_Right));
 }

template<class _Ty,
 class _Other> inline
 bool operator!=(const _Wrap_alloc<_Ty>& _Left,
  const _Wrap_alloc<_Other>& _Right) noexcept
 {
 return (!(_Left == _Right));
 }


template<class _Alty> inline
 void _Pocca(_Alty& _Left, const _Alty& _Right, true_type) noexcept
 {
 _Left = _Right;
 }

template<class _Alty> inline
 void _Pocca(_Alty&, const _Alty&, false_type) noexcept
 {
 }

template<class _Alty> inline
 void _Pocca(_Alty& _Left, const _Alty& _Right) noexcept
 {
 typename _Alty::propagate_on_container_copy_assignment _Tag;
 _Pocca(_Left, _Right, _Tag);
 }


template<class _Alty> inline
 void _Pocma(_Alty& _Left, _Alty& _Right, true_type) noexcept
 {
 _Left = ::std:: move(_Right);
 }

template<class _Alty> inline
 void _Pocma(_Alty&, _Alty&, false_type) noexcept
 {
 }

template<class _Alty> inline
 void _Pocma(_Alty& _Left, _Alty& _Right) noexcept
 {
 typename _Alty::propagate_on_container_move_assignment _Tag;
 _Pocma(_Left, _Right, _Tag);
 }


template<class _Alty> inline
 void _Pocs(_Alty& _Left, _Alty& _Right, true_type) noexcept
 {
 _Swap_adl(_Left, _Right);
 }

template<class _Alty> inline
 void _Pocs(_Alty& _Left, _Alty& _Right, false_type) noexcept
 {
 if (_Left != _Right)
  {



  ::std:: terminate();

  }
 }

template<class _Alty> inline
 void _Pocs(_Alty& _Left, _Alty& _Right) noexcept
 {
 typename _Alty::propagate_on_container_swap _Tag;
 _Pocs(_Left, _Right, _Tag);
 }



template<class _Alloc,
 class _Ptr = typename _Wrap_alloc<_Alloc>::pointer> inline
 void _Destroy_range1(_Ptr _First, _Ptr _Last, _Wrap_alloc<_Alloc>& _Al, false_type)
 {
 for (; _First != _Last; ++_First)
  _Al.destroy(_Unfancy(_First));
 }

template<class _Alloc,
 class _Ptr = typename _Wrap_alloc<_Alloc>::pointer> inline
 void _Destroy_range1(_Ptr, _Ptr, _Wrap_alloc<_Alloc>&, true_type)
 {

 }

template<class _Alloc,
 class _Ptr = typename _Wrap_alloc<_Alloc>::pointer> inline
 void _Destroy_range(_Ptr _First, _Ptr _Last, _Wrap_alloc<_Alloc>& _Al)
 {


 typedef typename _Alloc::value_type _Val;
 _Destroy_range1(_First, _Last, _Al, typename conjunction<
  is_trivially_destructible<_Val>,
  _Uses_default_destroy<_Alloc, _Val *>>::type());
 }



template<class _FwdIt> inline
 void _Destroy_range1(_FwdIt _First, _FwdIt _Last, false_type)
 {
 for (; _First != _Last; ++_First)
  _Destroy(_First);
 }

template<class _FwdIt> inline
 void _Destroy_range1(_FwdIt, _FwdIt, true_type)
 {

 }

template<class _FwdIt> inline
 void _Destroy_range(_FwdIt _First, _FwdIt _Last)
 {


 _Destroy_range1(_First, _Last, is_trivially_destructible<_Iter_value_t<_FwdIt>>());
 }
}



# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xatomic0.h" 1 3







#pragma pack(push,8)
#pragma warning(push, 3)



namespace std {

typedef enum memory_order {
 memory_order_relaxed,
 memory_order_consume,
 memory_order_acquire,
 memory_order_release,
 memory_order_acq_rel,
 memory_order_seq_cst
 } memory_order;

typedef _Uint32t _Uint4_t;
typedef _Uint4_t _Atomic_integral_t;
# 47 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xatomic0.h" 3
typedef long _Atomic_flag_t;




typedef _Atomic_integral_t _Atomic_counter_t;

inline _Atomic_integral_t
 _Get_atomic_count(const _Atomic_counter_t& _Counter)
 {
 return (_Counter);
 }

inline void _Init_atomic_counter(_Atomic_counter_t& _Counter,
 _Atomic_integral_t _Value)
 {
 _Counter = _Value;
 }
# 75 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xatomic0.h" 3
extern "C" {
              void __cdecl _Lock_shared_ptr_spin_lock();
              void __cdecl _Unlock_shared_ptr_spin_lock();
}
}

#pragma warning(pop)
#pragma pack(pop)
# 1148 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory0" 2 3



# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\intrin.h" 1 3
# 18 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\intrin.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime.h" 1 3
# 18 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\intrin.h" 2 3

# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\setjmp.h" 1 3
# 11 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\setjmp.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime.h" 1 3
# 11 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\setjmp.h" 2 3
# 21 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\setjmp.h" 3
#pragma pack(push, 8)
# 21 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\setjmp.h" 3
 extern "C" {
# 31 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\setjmp.h" 3
    typedef struct __JUMP_BUFFER
    {
        unsigned long Ebp;
        unsigned long Ebx;
        unsigned long Edi;
        unsigned long Esi;
        unsigned long Esp;
        unsigned long Eip;
        unsigned long Registration;
        unsigned long TryLevel;
        unsigned long Cookie;
        unsigned long UnwindFunc;
        unsigned long UnwindData[6];
    } _JUMP_BUFFER;
# 145 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\setjmp.h" 3
    typedef int jmp_buf[16];
# 157 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\setjmp.h" 3
int __cdecl _setjmp(
          jmp_buf _Buf
    );


#pragma warning(push)
#pragma warning(disable: 4987)
 __declspec(noreturn) void __cdecl longjmp(
             jmp_buf _Buf,
             int _Value
        ) throw(...);
#pragma warning(pop)








}
# 177 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\setjmp.h" 3
#pragma pack(pop)
# 19 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\intrin.h" 2 3





# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 1 3
# 28 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\wmmintrin.h" 1 3
# 31 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\wmmintrin.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\nmmintrin.h" 1 3
# 32 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\nmmintrin.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\smmintrin.h" 1 3
# 32 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\smmintrin.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\tmmintrin.h" 1 3
# 25 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\tmmintrin.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\pmmintrin.h" 1 3
# 34 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\pmmintrin.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\emmintrin.h" 1 3
# 42 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\emmintrin.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmmintrin.h" 1 3
# 46 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmmintrin.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\mmintrin.h" 1 3
# 29 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\mmintrin.h" 3
extern "C" {




typedef union __declspec(intrin_type) __declspec(align(8)) __m64
{
    unsigned __int64 m64_u64;
    float m64_f32[2];
    __int8 m64_i8[8];
    __int16 m64_i16[4];
    __int32 m64_i32[2];
    __int64 m64_i64;
    unsigned __int8 m64_u8[8];
    unsigned __int16 m64_u16[4];
    unsigned __int32 m64_u32[2];
} __m64;



void _m_empty(void);
__m64 _m_from_int(int _I);
int _m_to_int(__m64 _M);
__m64 _m_packsswb(__m64 _MM1, __m64 _MM2);
__m64 _m_packssdw(__m64 _MM1, __m64 _MM2);
__m64 _m_packuswb(__m64 _MM1, __m64 _MM2);
__m64 _m_punpckhbw(__m64 _MM1, __m64 _MM2);
__m64 _m_punpckhwd(__m64 _MM1, __m64 _MM2);
__m64 _m_punpckhdq(__m64 _MM1, __m64 _MM2);
__m64 _m_punpcklbw(__m64 _MM1, __m64 _MM2);
__m64 _m_punpcklwd(__m64 _MM1, __m64 _MM2);
__m64 _m_punpckldq(__m64 _MM1, __m64 _MM2);


__m64 _m_paddb(__m64 _MM1, __m64 _MM2);
__m64 _m_paddw(__m64 _MM1, __m64 _MM2);
__m64 _m_paddd(__m64 _MM1, __m64 _MM2);
__m64 _m_paddsb(__m64 _MM1, __m64 _MM2);
__m64 _m_paddsw(__m64 _MM1, __m64 _MM2);
__m64 _m_paddusb(__m64 _MM1, __m64 _MM2);
__m64 _m_paddusw(__m64 _MM1, __m64 _MM2);
__m64 _m_psubb(__m64 _MM1, __m64 _MM2);
__m64 _m_psubw(__m64 _MM1, __m64 _MM2);
__m64 _m_psubd(__m64 _MM1, __m64 _MM2);
__m64 _m_psubsb(__m64 _MM1, __m64 _MM2);
__m64 _m_psubsw(__m64 _MM1, __m64 _MM2);
__m64 _m_psubusb(__m64 _MM1, __m64 _MM2);
__m64 _m_psubusw(__m64 _MM1, __m64 _MM2);
__m64 _m_pmaddwd(__m64 _MM1, __m64 _MM2);
__m64 _m_pmulhw(__m64 _MM1, __m64 _MM2);
__m64 _m_pmullw(__m64 _MM1, __m64 _MM2);


__m64 _m_psllw(__m64 _M, __m64 _Count);
__m64 _m_psllwi(__m64 _M, int _Count);
__m64 _m_pslld(__m64 _M, __m64 _Count);
__m64 _m_pslldi(__m64 _M, int _Count);
__m64 _m_psllq(__m64 _M, __m64 _Count);
__m64 _m_psllqi(__m64 _M, int _Count);
__m64 _m_psraw(__m64 _M, __m64 _Count);
__m64 _m_psrawi(__m64 _M, int _Count);
__m64 _m_psrad(__m64 _M, __m64 _Count);
__m64 _m_psradi(__m64 _M, int _Count);
__m64 _m_psrlw(__m64 _M, __m64 _Count);
__m64 _m_psrlwi(__m64 _M, int _Count);
__m64 _m_psrld(__m64 _M, __m64 _Count);
__m64 _m_psrldi(__m64 _M, int _Count);
__m64 _m_psrlq(__m64 _M, __m64 _Count);
__m64 _m_psrlqi(__m64 _M, int _Count);


__m64 _m_pand(__m64 _MM1, __m64 _MM2);
__m64 _m_pandn(__m64 _MM1, __m64 _MM2);
__m64 _m_por(__m64 _MM1, __m64 _MM2);
__m64 _m_pxor(__m64 _MM1, __m64 _MM2);


__m64 _m_pcmpeqb(__m64 _MM1, __m64 _MM2);
__m64 _m_pcmpeqw(__m64 _MM1, __m64 _MM2);
__m64 _m_pcmpeqd(__m64 _MM1, __m64 _MM2);
__m64 _m_pcmpgtb(__m64 _MM1, __m64 _MM2);
__m64 _m_pcmpgtw(__m64 _MM1, __m64 _MM2);
__m64 _m_pcmpgtd(__m64 _MM1, __m64 _MM2);


__m64 _mm_setzero_si64(void);
__m64 _mm_set_pi32(int _I1, int _I0);
__m64 _mm_set_pi16(short _S3, short _S2, short _S1, short _S0);
__m64 _mm_set_pi8(char _B7, char _B6, char _B5, char _B4,
                  char _B3, char _B2, char _B1, char _B0);
__m64 _mm_set1_pi32(int _I);
__m64 _mm_set1_pi16(short _S);
__m64 _mm_set1_pi8(char _B);
__m64 _mm_setr_pi32(int _I1, int _I0);
__m64 _mm_setr_pi16(short _S3, short _S2, short _S1, short _S0);
__m64 _mm_setr_pi8(char _B7, char _B6, char _B5, char _B4,
                   char _B3, char _B2, char _B1, char _B0);
# 186 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\mmintrin.h" 3
};
# 46 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmmintrin.h" 2 3
# 65 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmmintrin.h" 3
typedef union __declspec(intrin_type) __declspec(align(16)) __m128 {
     float m128_f32[4];
     unsigned __int64 m128_u64[2];
     __int8 m128_i8[16];
     __int16 m128_i16[8];
     __int32 m128_i32[4];
     __int64 m128_i64[2];
     unsigned __int8 m128_u8[16];
     unsigned __int16 m128_u16[8];
     unsigned __int32 m128_u32[4];
 } __m128;
# 188 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmmintrin.h" 3
extern "C" {







extern __m128 _mm_add_ss(__m128 _A, __m128 _B);
extern __m128 _mm_add_ps(__m128 _A, __m128 _B);
extern __m128 _mm_sub_ss(__m128 _A, __m128 _B);
extern __m128 _mm_sub_ps(__m128 _A, __m128 _B);
extern __m128 _mm_mul_ss(__m128 _A, __m128 _B);
extern __m128 _mm_mul_ps(__m128 _A, __m128 _B);
extern __m128 _mm_div_ss(__m128 _A, __m128 _B);
extern __m128 _mm_div_ps(__m128 _A, __m128 _B);
extern __m128 _mm_sqrt_ss(__m128 _A);
extern __m128 _mm_sqrt_ps(__m128 _A);
extern __m128 _mm_rcp_ss(__m128 _A);
extern __m128 _mm_rcp_ps(__m128 _A);
extern __m128 _mm_rsqrt_ss(__m128 _A);
extern __m128 _mm_rsqrt_ps(__m128 _A);
extern __m128 _mm_min_ss(__m128 _A, __m128 _B);
extern __m128 _mm_min_ps(__m128 _A, __m128 _B);
extern __m128 _mm_max_ss(__m128 _A, __m128 _B);
extern __m128 _mm_max_ps(__m128 _A, __m128 _B);





extern __m128 _mm_and_ps(__m128 _A, __m128 _B);
extern __m128 _mm_andnot_ps(__m128 _A, __m128 _B);
extern __m128 _mm_or_ps(__m128 _A, __m128 _B);
extern __m128 _mm_xor_ps(__m128 _A, __m128 _B);





extern __m128 _mm_cmpeq_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpeq_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmplt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmplt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmple_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmple_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpgt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpgt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpge_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpge_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpneq_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpneq_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnlt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnlt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnle_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnle_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpngt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpngt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnge_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnge_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpord_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpord_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpunord_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpunord_ps(__m128 _A, __m128 _B);
extern int _mm_comieq_ss(__m128 _A, __m128 _B);
extern int _mm_comilt_ss(__m128 _A, __m128 _B);
extern int _mm_comile_ss(__m128 _A, __m128 _B);
extern int _mm_comigt_ss(__m128 _A, __m128 _B);
extern int _mm_comige_ss(__m128 _A, __m128 _B);
extern int _mm_comineq_ss(__m128 _A, __m128 _B);
extern int _mm_ucomieq_ss(__m128 _A, __m128 _B);
extern int _mm_ucomilt_ss(__m128 _A, __m128 _B);
extern int _mm_ucomile_ss(__m128 _A, __m128 _B);
extern int _mm_ucomigt_ss(__m128 _A, __m128 _B);
extern int _mm_ucomige_ss(__m128 _A, __m128 _B);
extern int _mm_ucomineq_ss(__m128 _A, __m128 _B);





extern int _mm_cvt_ss2si(__m128 _A);
extern int _mm_cvtt_ss2si(__m128 _A);
extern __m128 _mm_cvt_si2ss(__m128, int);
extern float _mm_cvtss_f32(__m128 _A);





extern __m64 _mm_cvt_ps2pi(__m128 _A);
extern __m64 _mm_cvtt_ps2pi(__m128 _A);
extern __m128 _mm_cvt_pi2ps(__m128, __m64);
# 296 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmmintrin.h" 3
extern __m128 _mm_shuffle_ps(__m128 _A, __m128 _B, unsigned int _Imm8);
extern __m128 _mm_unpackhi_ps(__m128 _A, __m128 _B);
extern __m128 _mm_unpacklo_ps(__m128 _A, __m128 _B);
extern __m128 _mm_loadh_pi(__m128, __m64 const*);
extern __m128 _mm_movehl_ps(__m128, __m128);
extern __m128 _mm_movelh_ps(__m128, __m128);
extern void _mm_storeh_pi(__m64 *, __m128);
extern __m128 _mm_loadl_pi(__m128, __m64 const*);
extern void _mm_storel_pi(__m64 *, __m128);
extern int _mm_movemask_ps(__m128 _A);






extern int _m_pextrw(__m64, int);
extern __m64 _m_pinsrw(__m64, int, int);
extern __m64 _m_pmaxsw(__m64, __m64);
extern __m64 _m_pmaxub(__m64, __m64);
extern __m64 _m_pminsw(__m64, __m64);
extern __m64 _m_pminub(__m64, __m64);
extern int _m_pmovmskb(__m64);
extern __m64 _m_pmulhuw(__m64, __m64);
extern __m64 _m_pshufw(__m64, int);
extern void _m_maskmovq(__m64, __m64, char *);
extern __m64 _m_pavgb(__m64, __m64);
extern __m64 _m_pavgw(__m64, __m64);
extern __m64 _m_psadbw(__m64, __m64);






extern __m128 _mm_set_ss(float _A);
extern __m128 _mm_set_ps1(float _A);
extern __m128 _mm_set_ps(float _A, float _B, float _C, float _D);
extern __m128 _mm_setr_ps(float _A, float _B, float _C, float _D);
extern __m128 _mm_setzero_ps(void);
extern __m128 _mm_load_ss(float const*_A);
extern __m128 _mm_load_ps1(float const*_A);
extern __m128 _mm_load_ps(float const*_A);
extern __m128 _mm_loadr_ps(float const*_A);
extern __m128 _mm_loadu_ps(float const*_A);
extern void _mm_store_ss(float *_V, __m128 _A);
extern void _mm_store_ps1(float *_V, __m128 _A);
extern void _mm_store_ps(float *_V, __m128 _A);
extern void _mm_storer_ps(float *_V, __m128 _A);
extern void _mm_storeu_ps(float *_V, __m128 _A);
extern void _mm_prefetch(char const*_A, int _Sel);

extern void _mm_stream_pi(__m64 *, __m64);

extern void _mm_stream_ps(float *, __m128);
extern __m128 _mm_move_ss(__m128 _A, __m128 _B);

extern void _mm_sfence(void);
extern unsigned int _mm_getcsr(void);
extern void _mm_setcsr(unsigned int);
# 401 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmmintrin.h" 3
__inline __m128 _mm_cvtpi16_ps(__m64 _A)
{
  __m128 _Tmp;
  __m64 _Ext_val = _m_pcmpgtw(_mm_setzero_si64(), _A);

  _Tmp = _mm_cvt_pi2ps(_mm_setzero_ps(), _m_punpckhwd(_A, _Ext_val));
  return(_mm_cvt_pi2ps(_mm_movelh_ps(_Tmp, _Tmp),
                        _m_punpcklwd(_A, _Ext_val)));
}
# 420 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmmintrin.h" 3
__inline __m128 _mm_cvtpu16_ps(__m64 _A)
{
  __m128 _Tmp;
  __m64 _Ext_val = _mm_setzero_si64();

  _Tmp = _mm_cvt_pi2ps(_mm_setzero_ps(), _m_punpckhwd(_A, _Ext_val));
  return(_mm_cvt_pi2ps(_mm_movelh_ps(_Tmp, _Tmp),
                        _m_punpcklwd(_A, _Ext_val)));
}
# 439 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmmintrin.h" 3
__inline __m64 _mm_cvtps_pi16(__m128 _A)
{
  return _m_packssdw(_mm_cvt_ps2pi(_A),
                        _mm_cvt_ps2pi(_mm_movehl_ps(_A, _A)));
}
# 454 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmmintrin.h" 3
__inline __m128 _mm_cvtpi8_ps(__m64 _A)
{
  __m64 _Ext_val = _m_pcmpgtb(_mm_setzero_si64(), _A);

  return _mm_cvtpi16_ps(_m_punpcklbw(_A, _Ext_val));
}
# 471 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmmintrin.h" 3
__inline __m128 _mm_cvtpu8_ps(__m64 _A)
{
  return _mm_cvtpu16_ps(_m_punpcklbw(_A, _mm_setzero_si64()));
}
# 485 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmmintrin.h" 3
__inline __m64 _mm_cvtps_pi8(__m128 _A)
{
  return _m_packsswb(_mm_cvtps_pi16(_A), _mm_setzero_si64());
}
# 500 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmmintrin.h" 3
__inline __m128 _mm_cvtpi32x2_ps(__m64 _A, __m64 _B)
{
  return _mm_movelh_ps(_mm_cvt_pi2ps(_mm_setzero_ps(), _A),
                       _mm_cvt_pi2ps(_mm_setzero_ps(), _B));
}




};
# 42 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\emmintrin.h" 2 3


typedef union __declspec(intrin_type) __declspec(align(16)) __m128i {
    __int8 m128i_i8[16];
    __int16 m128i_i16[8];
    __int32 m128i_i32[4];
    __int64 m128i_i64[2];
    unsigned __int8 m128i_u8[16];
    unsigned __int16 m128i_u16[8];
    unsigned __int32 m128i_u32[4];
    unsigned __int64 m128i_u64[2];
} __m128i;

typedef struct __declspec(intrin_type) __declspec(align(16)) __m128d {
    double m128d_f64[2];
} __m128d;
# 69 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\emmintrin.h" 3
extern "C" {







extern __m128d _mm_add_sd(__m128d _A, __m128d _B);
extern __m128d _mm_add_pd(__m128d _A, __m128d _B);
extern __m128d _mm_sub_sd(__m128d _A, __m128d _B);
extern __m128d _mm_sub_pd(__m128d _A, __m128d _B);
extern __m128d _mm_mul_sd(__m128d _A, __m128d _B);
extern __m128d _mm_mul_pd(__m128d _A, __m128d _B);
extern __m128d _mm_sqrt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_sqrt_pd(__m128d _A);
extern __m128d _mm_div_sd(__m128d _A, __m128d _B);
extern __m128d _mm_div_pd(__m128d _A, __m128d _B);
extern __m128d _mm_min_sd(__m128d _A, __m128d _B);
extern __m128d _mm_min_pd(__m128d _A, __m128d _B);
extern __m128d _mm_max_sd(__m128d _A, __m128d _B);
extern __m128d _mm_max_pd(__m128d _A, __m128d _B);





extern __m128d _mm_and_pd(__m128d _A, __m128d _B);
extern __m128d _mm_andnot_pd(__m128d _A, __m128d _B);
extern __m128d _mm_or_pd(__m128d _A, __m128d _B);
extern __m128d _mm_xor_pd(__m128d _A, __m128d _B);





extern __m128d _mm_cmpeq_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpeq_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmplt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmplt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmple_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmple_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpgt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpgt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpge_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpge_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpneq_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpneq_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnlt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnlt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnle_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnle_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpngt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpngt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnge_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnge_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpord_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpord_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpunord_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpunord_sd(__m128d _A, __m128d _B);
extern int _mm_comieq_sd(__m128d _A, __m128d _B);
extern int _mm_comilt_sd(__m128d _A, __m128d _B);
extern int _mm_comile_sd(__m128d _A, __m128d _B);
extern int _mm_comigt_sd(__m128d _A, __m128d _B);
extern int _mm_comige_sd(__m128d _A, __m128d _B);
extern int _mm_comineq_sd(__m128d _A, __m128d _B);
extern int _mm_ucomieq_sd(__m128d _A, __m128d _B);
extern int _mm_ucomilt_sd(__m128d _A, __m128d _B);
extern int _mm_ucomile_sd(__m128d _A, __m128d _B);
extern int _mm_ucomigt_sd(__m128d _A, __m128d _B);
extern int _mm_ucomige_sd(__m128d _A, __m128d _B);
extern int _mm_ucomineq_sd(__m128d _A, __m128d _B);





extern __m128d _mm_cvtepi32_pd(__m128i _A);
extern __m128i _mm_cvtpd_epi32(__m128d _A);
extern __m128i _mm_cvttpd_epi32(__m128d _A);
extern __m128 _mm_cvtepi32_ps(__m128i _A);
extern __m128i _mm_cvtps_epi32(__m128 _A);
extern __m128i _mm_cvttps_epi32(__m128 _A);
extern __m128 _mm_cvtpd_ps(__m128d _A);
extern __m128d _mm_cvtps_pd(__m128 _A);
extern __m128 _mm_cvtsd_ss(__m128 _A, __m128d _B);
extern __m128d _mm_cvtss_sd(__m128d _A, __m128 _B);

extern int _mm_cvtsd_si32(__m128d _A);
extern int _mm_cvttsd_si32(__m128d _A);
extern __m128d _mm_cvtsi32_sd(__m128d _A, int _B);


extern __m64 _mm_cvtpd_pi32(__m128d _A);
extern __m64 _mm_cvttpd_pi32(__m128d _A);
extern __m128d _mm_cvtpi32_pd(__m64 _A);






extern __m128d _mm_unpackhi_pd(__m128d _A, __m128d _B);
extern __m128d _mm_unpacklo_pd(__m128d _A, __m128d _B);
extern int _mm_movemask_pd(__m128d _A);
extern __m128d _mm_shuffle_pd(__m128d _A, __m128d _B, int _I);





extern __m128d _mm_load_pd(double const*_Dp);
extern __m128d _mm_load1_pd(double const*_Dp);
extern __m128d _mm_loadr_pd(double const*_Dp);
extern __m128d _mm_loadu_pd(double const*_Dp);
extern __m128d _mm_load_sd(double const*_Dp);
extern __m128d _mm_loadh_pd(__m128d _A, double const*_Dp);
extern __m128d _mm_loadl_pd(__m128d _A, double const*_Dp);





extern __m128d _mm_set_sd(double _W);
extern __m128d _mm_set1_pd(double _A);
extern __m128d _mm_set_pd(double _Z, double _Y);
extern __m128d _mm_setr_pd(double _Y, double _Z);
extern __m128d _mm_setzero_pd(void);
extern __m128d _mm_move_sd(__m128d _A, __m128d _B);





extern void _mm_store_sd(double *_Dp, __m128d _A);
extern void _mm_store1_pd(double *_Dp, __m128d _A);
extern void _mm_store_pd(double *_Dp, __m128d _A);
extern void _mm_storeu_pd(double *_Dp, __m128d _A);
extern void _mm_storer_pd(double *_Dp, __m128d _A);
extern void _mm_storeh_pd(double *_Dp, __m128d _A);
extern void _mm_storel_pd(double *_Dp, __m128d _A);





extern __m128i _mm_add_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_add_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_add_epi32(__m128i _A, __m128i _B);

extern __m64 _mm_add_si64(__m64 _A, __m64 _B);

extern __m128i _mm_add_epi64(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epu16(__m128i _A, __m128i _B);
extern __m128i _mm_avg_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_avg_epu16(__m128i _A, __m128i _B);
extern __m128i _mm_madd_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_max_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_max_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_min_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_min_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_mulhi_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_mulhi_epu16(__m128i _A, __m128i _B);
extern __m128i _mm_mullo_epi16(__m128i _A, __m128i _B);

extern __m64 _mm_mul_su32(__m64 _A, __m64 _B);

extern __m128i _mm_mul_epu32(__m128i _A, __m128i _B);
extern __m128i _mm_sad_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_sub_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_sub_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_sub_epi32(__m128i _A, __m128i _B);

extern __m64 _mm_sub_si64(__m64 _A, __m64 _B);

extern __m128i _mm_sub_epi64(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epu16(__m128i _A, __m128i _B);





extern __m128i _mm_and_si128(__m128i _A, __m128i _B);
extern __m128i _mm_andnot_si128(__m128i _A, __m128i _B);
extern __m128i _mm_or_si128(__m128i _A, __m128i _B);
extern __m128i _mm_xor_si128(__m128i _A, __m128i _B);





extern __m128i _mm_slli_si128(__m128i _A, int _Imm);
extern __m128i _mm_slli_epi16(__m128i _A, int _Count);
extern __m128i _mm_sll_epi16(__m128i _A, __m128i _Count);
extern __m128i _mm_slli_epi32(__m128i _A, int _Count);
extern __m128i _mm_sll_epi32(__m128i _A, __m128i _Count);
extern __m128i _mm_slli_epi64(__m128i _A, int _Count);
extern __m128i _mm_sll_epi64(__m128i _A, __m128i _Count);
extern __m128i _mm_srai_epi16(__m128i _A, int _Count);
extern __m128i _mm_sra_epi16(__m128i _A, __m128i _Count);
extern __m128i _mm_srai_epi32(__m128i _A, int _Count);
extern __m128i _mm_sra_epi32(__m128i _A, __m128i _Count);
extern __m128i _mm_srli_si128(__m128i _A, int _Imm);
extern __m128i _mm_srli_epi16(__m128i _A, int _Count);
extern __m128i _mm_srl_epi16(__m128i _A, __m128i _Count);
extern __m128i _mm_srli_epi32(__m128i _A, int _Count);
extern __m128i _mm_srl_epi32(__m128i _A, __m128i _Count);
extern __m128i _mm_srli_epi64(__m128i _A, int _Count);
extern __m128i _mm_srl_epi64(__m128i _A, __m128i _Count);





extern __m128i _mm_cmpeq_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_cmpeq_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_cmpeq_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_cmpgt_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_cmpgt_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_cmpgt_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_cmplt_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_cmplt_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_cmplt_epi32(__m128i _A, __m128i _B);





extern __m128i _mm_cvtsi32_si128(int _A);
extern int _mm_cvtsi128_si32(__m128i _A);





extern __m128i _mm_packs_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_packs_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_packus_epi16(__m128i _A, __m128i _B);
extern int _mm_extract_epi16(__m128i _A, int _Imm);
extern __m128i _mm_insert_epi16(__m128i _A, int _B, int _Imm);
extern int _mm_movemask_epi8(__m128i _A);
extern __m128i _mm_shuffle_epi32(__m128i _A, int _Imm);
extern __m128i _mm_shufflehi_epi16(__m128i _A, int _Imm);
extern __m128i _mm_shufflelo_epi16(__m128i _A, int _Imm);
extern __m128i _mm_unpackhi_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_unpackhi_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_unpackhi_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_unpackhi_epi64(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi64(__m128i _A, __m128i _B);





extern __m128i _mm_load_si128(__m128i const*_P);
extern __m128i _mm_loadu_si128(__m128i const*_P);
extern __m128i _mm_loadl_epi64(__m128i const*_P);






extern __m128i _mm_set_epi64(__m64 _Q1, __m64 _Q0);

extern __m128i _mm_set_epi64x(__int64 _I1,__int64 _I0);
extern __m128i _mm_set_epi32(int _I3, int _I2, int _I1, int _I0);
extern __m128i _mm_set_epi16(short _W7, short _W6, short _W5, short _W4,
                             short _W3, short _W2, short _W1, short _W0);
extern __m128i _mm_set_epi8(char _B15, char _B14, char _B13, char _B12,
                            char _B11, char _B10, char _B9, char _B8,
                            char _B7, char _B6, char _B5, char _B4,
                            char _B3, char _B2, char _B1, char _B0);

extern __m128i _mm_set1_epi64(__m64 _Q);

extern __m128i _mm_set1_epi64x(__int64 i);
extern __m128i _mm_set1_epi32(int _I);
extern __m128i _mm_set1_epi16(short _W);
extern __m128i _mm_set1_epi8(char _B);
extern __m128i _mm_setl_epi64(__m128i _Q);

extern __m128i _mm_setr_epi64(__m64 _Q0, __m64 _Q1);

extern __m128i _mm_setr_epi32(int _I0, int _I1, int _I2, int _I3);
extern __m128i _mm_setr_epi16(short _W0, short _W1, short _W2, short _W3,
                              short _W4, short _W5, short _W6, short _W7);
extern __m128i _mm_setr_epi8(char _B15, char _B14, char _B13, char _B12,
                             char _B11, char _B10, char _B9, char _B8,
                             char _B7, char _B6, char _B5, char _B4,
                             char _B3, char _B2, char _B1, char _B0);
extern __m128i _mm_setzero_si128(void);





extern void _mm_store_si128(__m128i *_P, __m128i _B);
extern void _mm_storeu_si128(__m128i *_P, __m128i _B);
extern void _mm_storel_epi64(__m128i *_P, __m128i _Q);
extern void _mm_maskmoveu_si128(__m128i _D, __m128i _N, char *_P);





extern __m128i _mm_move_epi64(__m128i _Q);

extern __m128i _mm_movpi64_epi64(__m64 _Q);
extern __m64 _mm_movepi64_pi64(__m128i _Q);






extern void _mm_stream_pd(double *_Dp, __m128d _A);
extern void _mm_stream_si128(__m128i *_P, __m128i _A);
extern void _mm_clflush(void const*_P);
extern void _mm_lfence(void);
extern void _mm_mfence(void);
extern void _mm_stream_si32(int *_P, int _I);
extern void _mm_pause(void);





extern double _mm_cvtsd_f64(__m128d _A);







extern __m128 _mm_castpd_ps(__m128d);
extern __m128i _mm_castpd_si128(__m128d);
extern __m128d _mm_castps_pd(__m128);
extern __m128i _mm_castps_si128(__m128);
extern __m128 _mm_castsi128_ps(__m128i);
extern __m128d _mm_castsi128_pd(__m128i);
# 436 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\emmintrin.h" 3
};
# 34 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\pmmintrin.h" 2 3
# 58 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\pmmintrin.h" 3
extern "C" {







extern __m128 _mm_addsub_ps(__m128 , __m128 );
extern __m128 _mm_hadd_ps(__m128 , __m128 );
extern __m128 _mm_hsub_ps(__m128 , __m128 );
extern __m128 _mm_movehdup_ps(__m128 );
extern __m128 _mm_moveldup_ps(__m128 );





extern __m128d _mm_addsub_pd(__m128d , __m128d );
extern __m128d _mm_hadd_pd(__m128d , __m128d );
extern __m128d _mm_hsub_pd(__m128d , __m128d );
extern __m128d _mm_loaddup_pd(double const * );
extern __m128d _mm_movedup_pd(__m128d );




extern __m128i _mm_lddqu_si128(__m128i const * );







extern void _mm_monitor(void const * , unsigned , unsigned );




extern void _mm_mwait(unsigned , unsigned );


};
# 25 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\tmmintrin.h" 2 3
# 35 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\tmmintrin.h" 3
extern "C" {
# 45 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\tmmintrin.h" 3
    extern __m128i _mm_hadd_epi16 (__m128i, __m128i);
    extern __m128i _mm_hadd_epi32 (__m128i, __m128i);
    extern __m128i _mm_hadds_epi16 (__m128i, __m128i);


    extern __m64 _mm_hadd_pi16 (__m64, __m64);
    extern __m64 _mm_hadd_pi32 (__m64, __m64);
    extern __m64 _mm_hadds_pi16 (__m64, __m64);
# 63 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\tmmintrin.h" 3
    extern __m128i _mm_hsub_epi16 (__m128i, __m128i);
    extern __m128i _mm_hsub_epi32 (__m128i, __m128i);
    extern __m128i _mm_hsubs_epi16 (__m128i, __m128i);


    extern __m64 _mm_hsub_pi16 (__m64, __m64);
    extern __m64 _mm_hsub_pi32 (__m64, __m64);
    extern __m64 _mm_hsubs_pi16 (__m64, __m64);
# 82 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\tmmintrin.h" 3
    extern __m128i _mm_maddubs_epi16 (__m128i, __m128i);


    extern __m64 _mm_maddubs_pi16 (__m64, __m64);





    extern __m128i _mm_mulhrs_epi16 (__m128i, __m128i);


    extern __m64 _mm_mulhrs_pi16 (__m64, __m64);





    extern __m128i _mm_shuffle_epi8 (__m128i, __m128i);


    extern __m64 _mm_shuffle_pi8 (__m64, __m64);





    extern __m128i _mm_sign_epi8 (__m128i, __m128i);
    extern __m128i _mm_sign_epi16 (__m128i, __m128i);
    extern __m128i _mm_sign_epi32 (__m128i, __m128i);


    extern __m64 _mm_sign_pi8 (__m64, __m64);
    extern __m64 _mm_sign_pi16 (__m64, __m64);
    extern __m64 _mm_sign_pi32 (__m64, __m64);





    extern __m128i _mm_alignr_epi8 (__m128i, __m128i, int);


    extern __m64 _mm_alignr_pi8 (__m64, __m64, int);





    extern __m128i _mm_abs_epi8 (__m128i);
    extern __m128i _mm_abs_epi16 (__m128i);
    extern __m128i _mm_abs_epi32 (__m128i);


    extern __m64 _mm_abs_pi8 (__m64);
    extern __m64 _mm_abs_pi16 (__m64);
    extern __m64 _mm_abs_pi32 (__m64);



};
# 32 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\smmintrin.h" 2 3
# 83 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\smmintrin.h" 3
extern "C" {





        extern __m128i _mm_blend_epi16 (__m128i, __m128i, const int );
        extern __m128i _mm_blendv_epi8 (__m128i, __m128i, __m128i mask);




        extern __m128 _mm_blend_ps (__m128, __m128, const int );
        extern __m128 _mm_blendv_ps(__m128, __m128, __m128 );




        extern __m128d _mm_blend_pd (__m128d, __m128d, const int );
        extern __m128d _mm_blendv_pd(__m128d, __m128d, __m128d );




        extern __m128 _mm_dp_ps(__m128, __m128, const int );
        extern __m128d _mm_dp_pd(__m128d, __m128d, const int );




        extern __m128i _mm_cmpeq_epi64(__m128i, __m128i);



        extern __m128i _mm_min_epi8 (__m128i, __m128i);
        extern __m128i _mm_max_epi8 (__m128i, __m128i);

        extern __m128i _mm_min_epu16(__m128i, __m128i);
        extern __m128i _mm_max_epu16(__m128i, __m128i);

        extern __m128i _mm_min_epi32(__m128i, __m128i);
        extern __m128i _mm_max_epi32(__m128i, __m128i);
        extern __m128i _mm_min_epu32(__m128i, __m128i);
        extern __m128i _mm_max_epu32(__m128i, __m128i);




        extern __m128i _mm_mullo_epi32(__m128i, __m128i);




        extern __m128i _mm_mul_epi32(__m128i, __m128i);




        extern int _mm_testz_si128(__m128i , __m128i );




        extern int _mm_testc_si128(__m128i , __m128i );





        extern int _mm_testnzc_si128(__m128i , __m128i );







        extern __m128 _mm_insert_ps(__m128 , __m128 , const int );
# 170 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\smmintrin.h" 3
        extern int _mm_extract_ps(__m128 , const int );
# 188 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\smmintrin.h" 3
        extern __m128i _mm_insert_epi8 (__m128i , int , const int );
        extern __m128i _mm_insert_epi32(__m128i , int , const int );







        extern int _mm_extract_epi8 (__m128i , const int );
        extern int _mm_extract_epi32(__m128i , const int );
# 207 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\smmintrin.h" 3
        extern __m128i _mm_minpos_epu16(__m128i);



        extern __m128d _mm_round_pd(__m128d , int );
        extern __m128d _mm_round_sd(__m128d , __m128d , int );



        extern __m128 _mm_round_ps(__m128 , int );
        extern __m128 _mm_round_ss(__m128 , __m128 , int );



        extern __m128i _mm_cvtepi8_epi32 (__m128i);
        extern __m128i _mm_cvtepi16_epi32(__m128i);
        extern __m128i _mm_cvtepi8_epi64 (__m128i);
        extern __m128i _mm_cvtepi32_epi64(__m128i);
        extern __m128i _mm_cvtepi16_epi64(__m128i);
        extern __m128i _mm_cvtepi8_epi16 (__m128i);



        extern __m128i _mm_cvtepu8_epi32 (__m128i);
        extern __m128i _mm_cvtepu16_epi32(__m128i);
        extern __m128i _mm_cvtepu8_epi64 (__m128i);
        extern __m128i _mm_cvtepu32_epi64(__m128i);
        extern __m128i _mm_cvtepu16_epi64(__m128i);
        extern __m128i _mm_cvtepu8_epi16 (__m128i);





        extern __m128i _mm_packus_epi32(__m128i, __m128i);





        extern __m128i _mm_mpsadbw_epu8(__m128i , __m128i , const int );





        extern __m128i _mm_stream_load_si128(const __m128i*);


};
# 32 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\nmmintrin.h" 2 3




extern "C" {
# 83 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\nmmintrin.h" 3
    extern __m128i _mm_cmpistrm (__m128i , __m128i , const int );
    extern int _mm_cmpistri (__m128i , __m128i , const int );

    extern __m128i _mm_cmpestrm (__m128i , int , __m128i , int , const int );
    extern int _mm_cmpestri (__m128i , int , __m128i , int , const int );





    extern int _mm_cmpistrz (__m128i , __m128i , const int );
    extern int _mm_cmpistrc (__m128i , __m128i , const int );
    extern int _mm_cmpistrs (__m128i , __m128i , const int );
    extern int _mm_cmpistro (__m128i , __m128i , const int );
    extern int _mm_cmpistra (__m128i , __m128i , const int );

    extern int _mm_cmpestrz (__m128i , int , __m128i , int , const int );
    extern int _mm_cmpestrc (__m128i , int , __m128i , int , const int );
    extern int _mm_cmpestrs (__m128i , int , __m128i , int , const int );
    extern int _mm_cmpestro (__m128i , int , __m128i , int , const int );
    extern int _mm_cmpestra (__m128i , int , __m128i , int , const int );






    extern __m128i _mm_cmpgt_epi64(__m128i , __m128i );





    extern int _mm_popcnt_u32(unsigned int );
# 126 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\nmmintrin.h" 3
    extern unsigned int _mm_crc32_u8 (unsigned int , unsigned char );
    extern unsigned int _mm_crc32_u16(unsigned int , unsigned short );
    extern unsigned int _mm_crc32_u32(unsigned int , unsigned int );






};
# 31 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\wmmintrin.h" 2 3




extern "C" {






extern __m128i _mm_aesdec_si128(__m128i , __m128i );





extern __m128i _mm_aesdeclast_si128(__m128i , __m128i );





extern __m128i _mm_aesenc_si128(__m128i , __m128i );





extern __m128i _mm_aesenclast_si128(__m128i , __m128i );





extern __m128i _mm_aesimc_si128(__m128i );






extern __m128i _mm_aeskeygenassist_si128(__m128i , const int );







extern __m128i _mm_clmulepi64_si128(__m128i , __m128i ,
                                            const int );



};
# 28 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 2 3



extern "C" {





typedef union __declspec(intrin_type) __declspec(align(32)) __m256 {
    float m256_f32[8];
} __m256;

typedef struct __declspec(intrin_type) __declspec(align(32)) __m256d {
    double m256d_f64[4];
} __m256d;

typedef union __declspec(intrin_type) __declspec(align(32)) __m256i {
    __int8 m256i_i8[32];
    __int16 m256i_i16[16];
    __int32 m256i_i32[8];
    __int64 m256i_i64[4];
    unsigned __int8 m256i_u8[32];
    unsigned __int16 m256i_u16[16];
    unsigned __int32 m256i_u32[8];
    unsigned __int64 m256i_u64[4];
} __m256i;
# 106 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256d __cdecl _mm256_add_pd(__m256d, __m256d);
# 116 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256 __cdecl _mm256_add_ps(__m256, __m256);
# 129 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256d __cdecl _mm256_addsub_pd(__m256d, __m256d);
# 142 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256 __cdecl _mm256_addsub_ps(__m256, __m256);
# 151 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256d __cdecl _mm256_and_pd(__m256d, __m256d);
# 160 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256 __cdecl _mm256_and_ps(__m256, __m256);
# 169 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256d __cdecl _mm256_andnot_pd(__m256d, __m256d);
# 178 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256 __cdecl _mm256_andnot_ps(__m256, __m256);
# 192 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256d __cdecl _mm256_blend_pd(__m256d, __m256d, const int);
# 206 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256 __cdecl _mm256_blend_ps(__m256, __m256, const int);
# 216 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256d __cdecl _mm256_blendv_pd(__m256d, __m256d, __m256d);
# 226 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256 __cdecl _mm256_blendv_ps(__m256, __m256, __m256);
# 235 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256d __cdecl _mm256_div_pd(__m256d, __m256d);
# 244 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256 __cdecl _mm256_div_ps(__m256, __m256);
# 259 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256 __cdecl _mm256_dp_ps(__m256, __m256, const int);
# 268 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256d __cdecl _mm256_hadd_pd(__m256d, __m256d);
# 277 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256 __cdecl _mm256_hadd_ps(__m256, __m256);
# 286 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256d __cdecl _mm256_hsub_pd(__m256d, __m256d);
# 295 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256 __cdecl _mm256_hsub_ps(__m256, __m256);
# 304 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256d __cdecl _mm256_max_pd(__m256d, __m256d);
# 313 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256 __cdecl _mm256_max_ps(__m256, __m256);
# 322 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256d __cdecl _mm256_min_pd(__m256d, __m256d);
# 331 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256 __cdecl _mm256_min_ps(__m256, __m256);
# 341 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256d __cdecl _mm256_mul_pd(__m256d, __m256d);
# 351 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256 __cdecl _mm256_mul_ps(__m256, __m256);
# 360 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256d __cdecl _mm256_or_pd(__m256d, __m256d);
# 369 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256 __cdecl _mm256_or_ps(__m256, __m256);
# 381 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256d __cdecl _mm256_shuffle_pd(__m256d, __m256d, const int);
# 394 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256 __cdecl _mm256_shuffle_ps(__m256, __m256, const int);
# 403 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256d __cdecl _mm256_sub_pd(__m256d, __m256d);
# 413 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256 __cdecl _mm256_sub_ps(__m256, __m256);
# 422 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256d __cdecl _mm256_xor_pd(__m256d, __m256d);
# 431 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256 __cdecl _mm256_xor_ps(__m256, __m256);
# 447 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m128d __cdecl _mm_cmp_pd(__m128d, __m128d, const int);
extern __m256d __cdecl _mm256_cmp_pd(__m256d, __m256d, const int);
# 464 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m128 __cdecl _mm_cmp_ps(__m128, __m128, const int);
extern __m256 __cdecl _mm256_cmp_ps(__m256, __m256, const int);
# 478 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m128d __cdecl _mm_cmp_sd(__m128d, __m128d, const int);





extern int __cdecl _mm_comi_sd(__m128d, __m128d, const int);
# 497 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m128 __cdecl _mm_cmp_ss(__m128, __m128, const int);





extern int __cdecl _mm_comi_ss(__m128, __m128, const int);
# 512 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256d __cdecl _mm256_cvtepi32_pd(__m128i);
# 521 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256 __cdecl _mm256_cvtepi32_ps(__m256i);
# 531 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m128 __cdecl _mm256_cvtpd_ps(__m256d);
# 540 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256i __cdecl _mm256_cvtps_epi32(__m256);
# 550 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256d __cdecl _mm256_cvtps_pd(__m128);
# 563 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m128i __cdecl _mm256_cvttpd_epi32(__m256d);
# 572 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m128i __cdecl _mm256_cvtpd_epi32(__m256d);
# 585 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256i __cdecl _mm256_cvttps_epi32(__m256);







extern __m128 __cdecl _mm256_extractf128_ps(__m256, const int);
extern __m128d __cdecl _mm256_extractf128_pd(__m256d, const int);
extern __m128i __cdecl _mm256_extractf128_si256(__m256i, const int);






extern void __cdecl _mm256_zeroall(void);







extern void __cdecl _mm256_zeroupper(void);
# 620 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256 __cdecl _mm256_permutevar_ps(__m256, __m256i);
extern __m128 __cdecl _mm_permutevar_ps(__m128, __m128i);
# 631 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256 __cdecl _mm256_permute_ps(__m256, int);
extern __m128 __cdecl _mm_permute_ps(__m128, int);
# 642 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256d __cdecl _mm256_permutevar_pd(__m256d, __m256i);
extern __m128d __cdecl _mm_permutevar_pd(__m128d, __m128i);
# 653 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256d __cdecl _mm256_permute_pd(__m256d, int);
extern __m128d __cdecl _mm_permute_pd(__m128d, int);
# 663 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256 __cdecl _mm256_permute2f128_ps(__m256, __m256, int);
extern __m256d __cdecl _mm256_permute2f128_pd(__m256d, __m256d, int);
extern __m256i __cdecl _mm256_permute2f128_si256(__m256i, __m256i, int);
# 674 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256 __cdecl _mm256_broadcast_ss(float const *);
extern __m128 __cdecl _mm_broadcast_ss(float const *);







extern __m256d __cdecl _mm256_broadcast_sd(double const *);







extern __m256 __cdecl _mm256_broadcast_ps(__m128 const *);
extern __m256d __cdecl _mm256_broadcast_pd(__m128d const *);
# 702 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256 __cdecl _mm256_insertf128_ps(__m256, __m128, int);
extern __m256d __cdecl _mm256_insertf128_pd(__m256d, __m128d, int);
extern __m256i __cdecl _mm256_insertf128_si256(__m256i, __m128i, int);
# 713 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256d __cdecl _mm256_load_pd(double const *);
extern void __cdecl _mm256_store_pd(double *, __m256d);
# 723 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256 __cdecl _mm256_load_ps(float const *);
extern void __cdecl _mm256_store_ps(float *, __m256);
# 733 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256d __cdecl _mm256_loadu_pd(double const *);
extern void __cdecl _mm256_storeu_pd(double *, __m256d);
# 743 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256 __cdecl _mm256_loadu_ps(float const *);
extern void __cdecl _mm256_storeu_ps(float *, __m256);
# 753 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256i __cdecl _mm256_load_si256(__m256i const *);
extern void __cdecl _mm256_store_si256(__m256i *, __m256i);
# 763 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256i __cdecl _mm256_loadu_si256(__m256i const *);
extern void __cdecl _mm256_storeu_si256(__m256i *, __m256i);
# 836 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256d __cdecl _mm256_maskload_pd(double const *, __m256i);
extern void __cdecl _mm256_maskstore_pd(double *, __m256i, __m256d);
extern __m128d __cdecl _mm_maskload_pd(double const *, __m128i);
extern void __cdecl _mm_maskstore_pd(double *, __m128i, __m128d);
# 859 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256 __cdecl _mm256_maskload_ps(float const *, __m256i);
extern void __cdecl _mm256_maskstore_ps(float *, __m256i, __m256);
extern __m128 __cdecl _mm_maskload_ps(float const *, __m128i);
extern void __cdecl _mm_maskstore_ps(float *, __m128i, __m128);







extern __m256 __cdecl _mm256_movehdup_ps(__m256);







extern __m256 __cdecl _mm256_moveldup_ps(__m256);







extern __m256d __cdecl _mm256_movedup_pd(__m256d);
# 896 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256i __cdecl _mm256_lddqu_si256(__m256i const *);







extern void __cdecl _mm256_stream_si256(__m256i *, __m256i);
# 913 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern void __cdecl _mm256_stream_pd(double *, __m256d);
# 922 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern void __cdecl _mm256_stream_ps(float *, __m256);
# 932 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256 __cdecl _mm256_rcp_ps(__m256);
# 943 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256 __cdecl _mm256_rsqrt_ps(__m256);
# 952 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256d __cdecl _mm256_sqrt_pd(__m256d);
# 961 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256 __cdecl _mm256_sqrt_ps(__m256);
# 974 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256d __cdecl _mm256_round_pd(__m256d, int);
# 989 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256 __cdecl _mm256_round_ps(__m256, int);
# 999 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256d __cdecl _mm256_unpackhi_pd(__m256d, __m256d);







extern __m256 __cdecl _mm256_unpackhi_ps(__m256, __m256);







extern __m256d __cdecl _mm256_unpacklo_pd(__m256d, __m256d);







extern __m256 __cdecl _mm256_unpacklo_ps(__m256, __m256);
# 1033 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern int __cdecl _mm256_testz_si256(__m256i, __m256i);



extern int __cdecl _mm256_testc_si256(__m256i, __m256i);



extern int __cdecl _mm256_testnzc_si256(__m256i, __m256i);
# 1056 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern int __cdecl _mm256_testz_pd(__m256d, __m256d);
extern int __cdecl _mm256_testc_pd(__m256d, __m256d);
extern int __cdecl _mm256_testnzc_pd(__m256d, __m256d);
extern int __cdecl _mm_testz_pd(__m128d, __m128d);
extern int __cdecl _mm_testc_pd(__m128d, __m128d);
extern int __cdecl _mm_testnzc_pd(__m128d, __m128d);
# 1074 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern int __cdecl _mm256_testz_ps(__m256, __m256);
extern int __cdecl _mm256_testc_ps(__m256, __m256);
extern int __cdecl _mm256_testnzc_ps(__m256, __m256);
extern int __cdecl _mm_testz_ps(__m128, __m128);
extern int __cdecl _mm_testc_ps(__m128, __m128);
extern int __cdecl _mm_testnzc_ps(__m128, __m128);
# 1088 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern int __cdecl _mm256_movemask_pd(__m256d);
# 1097 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern int __cdecl _mm256_movemask_ps(__m256);




extern __m256d __cdecl _mm256_setzero_pd(void);
extern __m256 __cdecl _mm256_setzero_ps(void);
extern __m256i __cdecl _mm256_setzero_si256(void);




extern __m256d __cdecl _mm256_set_pd(double, double, double, double);
extern __m256 __cdecl _mm256_set_ps(float, float, float, float,
                                            float, float, float, float);
extern __m256i __cdecl _mm256_set_epi8(char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char);
extern __m256i __cdecl _mm256_set_epi16(short, short, short, short,
                                               short, short, short, short,
                                               short, short, short, short,
                                               short, short, short, short);
extern __m256i __cdecl _mm256_set_epi32(int, int, int, int,
                                               int, int, int, int);
extern __m256i __cdecl _mm256_set_epi64x(__int64, __int64,
                                                __int64, __int64);
# 1138 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m256d __cdecl _mm256_setr_pd(double, double, double, double);
extern __m256 __cdecl _mm256_setr_ps(float, float, float, float,
                                             float, float, float, float);
extern __m256i __cdecl _mm256_setr_epi8(char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char);
extern __m256i __cdecl _mm256_setr_epi16(short, short, short, short,
                                                short, short, short, short,
                                                short, short, short, short,
                                                short, short, short, short);
extern __m256i __cdecl _mm256_setr_epi32(int, int, int, int,
                                                int, int, int, int);
extern __m256i __cdecl _mm256_setr_epi64x(__int64, __int64,
                                                 __int64, __int64);







extern __m256d __cdecl _mm256_set1_pd(double);
extern __m256 __cdecl _mm256_set1_ps(float);
extern __m256i __cdecl _mm256_set1_epi8(char);
extern __m256i __cdecl _mm256_set1_epi16(short);
extern __m256i __cdecl _mm256_set1_epi32(int);
extern __m256i __cdecl _mm256_set1_epi64x(long long);







extern __m256 __cdecl _mm256_castpd_ps(__m256d);
extern __m256d __cdecl _mm256_castps_pd(__m256);
extern __m256i __cdecl _mm256_castps_si256(__m256);
extern __m256i __cdecl _mm256_castpd_si256(__m256d);
extern __m256 __cdecl _mm256_castsi256_ps(__m256i);
extern __m256d __cdecl _mm256_castsi256_pd(__m256i);
extern __m128 __cdecl _mm256_castps256_ps128(__m256);
extern __m128d __cdecl _mm256_castpd256_pd128(__m256d);
extern __m128i __cdecl _mm256_castsi256_si128(__m256i);
extern __m256 __cdecl _mm256_castps128_ps256(__m128);
extern __m256d __cdecl _mm256_castpd128_pd256(__m128d);
extern __m256i __cdecl _mm256_castsi128_si256(__m128i);






extern __m128 __cdecl _mm_cvtph_ps(__m128i);
extern __m256 __cdecl _mm256_cvtph_ps(__m128i);
extern __m128i __cdecl _mm_cvtps_ph(__m128 , const int );
extern __m128i __cdecl _mm256_cvtps_ph(__m256, int);
# 1219 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern unsigned __int64 __cdecl _xgetbv(unsigned int);


extern void __cdecl _xsetbv(unsigned int, unsigned __int64);






extern void __cdecl _xsave(void *, unsigned __int64);
# 1239 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern void __cdecl _xsaveopt(void *, unsigned __int64);
# 1248 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern void __cdecl _xsavec(void *, unsigned __int64);
# 1258 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern void __cdecl _xrstor(void const *, unsigned __int64);
# 1268 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern void __cdecl _xsaves(void *, unsigned __int64);
# 1278 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern void __cdecl _xrstors(void const *, unsigned __int64);
# 1287 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern void __cdecl _fxsave(void *);
# 1296 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern void __cdecl _fxrstor(void const *);
# 1307 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern int __cdecl _rdrand16_step(unsigned short *);
extern int __cdecl _rdrand32_step(unsigned int *);
# 1334 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern __m128 __cdecl _mm_fmadd_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmadd_pd(__m128d, __m128d, __m128d);
extern __m128 __cdecl _mm_fmadd_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmadd_sd(__m128d, __m128d, __m128d);
extern __m128 __cdecl _mm_fmsub_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmsub_pd(__m128d, __m128d, __m128d);
extern __m128 __cdecl _mm_fmsub_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmsub_sd(__m128d, __m128d, __m128d);
extern __m128 __cdecl _mm_fnmadd_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmadd_pd(__m128d, __m128d, __m128d);
extern __m128 __cdecl _mm_fnmadd_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmadd_sd(__m128d, __m128d, __m128d);
extern __m128 __cdecl _mm_fnmsub_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmsub_pd(__m128d, __m128d, __m128d);
extern __m128 __cdecl _mm_fnmsub_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmsub_sd(__m128d, __m128d, __m128d);

extern __m256 __cdecl _mm256_fmadd_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmadd_pd(__m256d, __m256d, __m256d);
extern __m256 __cdecl _mm256_fmsub_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmsub_pd(__m256d, __m256d, __m256d);
extern __m256 __cdecl _mm256_fnmadd_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fnmadd_pd(__m256d, __m256d, __m256d);
extern __m256 __cdecl _mm256_fnmsub_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fnmsub_pd(__m256d, __m256d, __m256d);





extern __m128 __cdecl _mm_fmaddsub_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmaddsub_pd(__m128d, __m128d, __m128d);
extern __m128 __cdecl _mm_fmsubadd_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmsubadd_pd(__m128d, __m128d, __m128d);

extern __m256 __cdecl _mm256_fmaddsub_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmaddsub_pd(__m256d, __m256d, __m256d);
extern __m256 __cdecl _mm256_fmsubadd_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmsubadd_pd(__m256d, __m256d, __m256d);





extern __m256i __cdecl _mm256_cmpeq_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpeq_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpeq_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpeq_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_cmpgt_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpgt_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpgt_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpgt_epi64(__m256i, __m256i);





extern __m256i __cdecl _mm256_max_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epu16(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epu32(__m256i, __m256i);

extern __m256i __cdecl _mm256_min_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epu16(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epu32(__m256i, __m256i);





extern __m256i __cdecl _mm256_and_si256(__m256i, __m256i);
extern __m256i __cdecl _mm256_andnot_si256(__m256i, __m256i);
extern __m256i __cdecl _mm256_or_si256(__m256i, __m256i);
extern __m256i __cdecl _mm256_xor_si256(__m256i, __m256i);





extern __m256i __cdecl _mm256_abs_epi8(__m256i);
extern __m256i __cdecl _mm256_abs_epi16(__m256i);
extern __m256i __cdecl _mm256_abs_epi32(__m256i);

extern __m256i __cdecl _mm256_add_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_add_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_add_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_add_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_adds_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_adds_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_adds_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_adds_epu16(__m256i, __m256i);

extern __m256i __cdecl _mm256_sub_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_sub_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_sub_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_sub_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_subs_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_subs_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_subs_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_subs_epu16(__m256i, __m256i);

extern __m256i __cdecl _mm256_avg_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_avg_epu16(__m256i, __m256i);

extern __m256i __cdecl _mm256_hadd_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_hadd_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_hadds_epi16(__m256i, __m256i);

extern __m256i __cdecl _mm256_hsub_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_hsub_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_hsubs_epi16(__m256i, __m256i);

extern __m256i __cdecl _mm256_madd_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_maddubs_epi16(__m256i, __m256i);

extern __m256i __cdecl _mm256_mulhi_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_mulhi_epu16(__m256i, __m256i);

extern __m256i __cdecl _mm256_mullo_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_mullo_epi32(__m256i, __m256i);

extern __m256i __cdecl _mm256_mul_epu32(__m256i, __m256i);
extern __m256i __cdecl _mm256_mul_epi32(__m256i, __m256i);

extern __m256i __cdecl _mm256_sign_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_sign_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_sign_epi32(__m256i, __m256i);

extern __m256i __cdecl _mm256_mulhrs_epi16(__m256i, __m256i);

extern __m256i __cdecl _mm256_sad_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_mpsadbw_epu8(__m256i, __m256i, const int);





extern __m256i __cdecl _mm256_slli_si256(__m256i, const int);

extern __m256i __cdecl _mm256_srli_si256(__m256i, const int);


extern __m256i __cdecl _mm256_sll_epi16(__m256i, __m128i);
extern __m256i __cdecl _mm256_sll_epi32(__m256i, __m128i);
extern __m256i __cdecl _mm256_sll_epi64(__m256i, __m128i);

extern __m256i __cdecl _mm256_slli_epi16(__m256i, int);
extern __m256i __cdecl _mm256_slli_epi32(__m256i, int);
extern __m256i __cdecl _mm256_slli_epi64(__m256i, int);

extern __m256i __cdecl _mm256_sllv_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_sllv_epi64(__m256i, __m256i);

extern __m128i __cdecl _mm_sllv_epi32(__m128i, __m128i);
extern __m128i __cdecl _mm_sllv_epi64(__m128i, __m128i);

extern __m256i __cdecl _mm256_sra_epi16(__m256i, __m128i);
extern __m256i __cdecl _mm256_sra_epi32(__m256i, __m128i);

extern __m256i __cdecl _mm256_srai_epi16(__m256i, int);
extern __m256i __cdecl _mm256_srai_epi32(__m256i, int);

extern __m256i __cdecl _mm256_srav_epi32(__m256i, __m256i);

extern __m128i __cdecl _mm_srav_epi32(__m128i, __m128i);

extern __m256i __cdecl _mm256_srl_epi16(__m256i, __m128i);
extern __m256i __cdecl _mm256_srl_epi32(__m256i, __m128i);
extern __m256i __cdecl _mm256_srl_epi64(__m256i, __m128i);

extern __m256i __cdecl _mm256_srli_epi16(__m256i, int);
extern __m256i __cdecl _mm256_srli_epi32(__m256i, int);
extern __m256i __cdecl _mm256_srli_epi64(__m256i, int);

extern __m256i __cdecl _mm256_srlv_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_srlv_epi64(__m256i, __m256i);

extern __m128i __cdecl _mm_srlv_epi32(__m128i, __m128i);
extern __m128i __cdecl _mm_srlv_epi64(__m128i, __m128i);





extern __m128i __cdecl _mm_blend_epi32(__m128i, __m128i, const int);

extern __m256i __cdecl _mm256_blend_epi32(__m256i,__m256i, const int);

extern __m256i __cdecl _mm256_alignr_epi8(__m256i, __m256i, const int);

extern __m256i __cdecl _mm256_blendv_epi8(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_blend_epi16(__m256i, __m256i, const int);

extern __m256i __cdecl _mm256_packs_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_packs_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_packus_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_packus_epi32(__m256i, __m256i);

extern __m256i __cdecl _mm256_unpackhi_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpackhi_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpackhi_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpackhi_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_unpacklo_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpacklo_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpacklo_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpacklo_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_shuffle_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_shuffle_epi32(__m256i, const int);

extern __m256i __cdecl _mm256_shufflehi_epi16(__m256i, const int);
extern __m256i __cdecl _mm256_shufflelo_epi16(__m256i, const int);

extern __m128i __cdecl _mm256_extracti128_si256(__m256i, const int);
extern __m256i __cdecl _mm256_inserti128_si256(__m256i, __m128i, const int);





extern __m128 __cdecl _mm_broadcastss_ps(__m128);
extern __m128d __cdecl _mm_broadcastsd_pd(__m128d);

extern __m128i __cdecl _mm_broadcastb_epi8(__m128i);
extern __m128i __cdecl _mm_broadcastw_epi16(__m128i);
extern __m128i __cdecl _mm_broadcastd_epi32(__m128i);
extern __m128i __cdecl _mm_broadcastq_epi64(__m128i);

extern __m256 __cdecl _mm256_broadcastss_ps(__m128);
extern __m256d __cdecl _mm256_broadcastsd_pd(__m128d);

extern __m256i __cdecl _mm256_broadcastb_epi8(__m128i);
extern __m256i __cdecl _mm256_broadcastw_epi16(__m128i);
extern __m256i __cdecl _mm256_broadcastd_epi32(__m128i);
extern __m256i __cdecl _mm256_broadcastq_epi64(__m128i);

extern __m256i __cdecl _mm256_broadcastsi128_si256(__m128i);






extern __m256i __cdecl _mm256_cvtepi8_epi16(__m128i);
extern __m256i __cdecl _mm256_cvtepi8_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepi8_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepi16_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepi16_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepi32_epi64(__m128i);

extern __m256i __cdecl _mm256_cvtepu8_epi16(__m128i);
extern __m256i __cdecl _mm256_cvtepu8_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepu8_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepu16_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepu16_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepu32_epi64(__m128i);






extern int __cdecl _mm256_movemask_epi8(__m256i);





extern __m128i __cdecl _mm_maskload_epi32(int const * ,
                                          __m128i );
extern __m128i __cdecl _mm_maskload_epi64(__int64 const * ,
                                          __m128i );

extern void __cdecl _mm_maskstore_epi32(int * ,
                                        __m128i ,
                                        __m128i );
extern void __cdecl _mm_maskstore_epi64(__int64 * ,
                                        __m128i ,
                                        __m128i );

extern __m256i __cdecl _mm256_maskload_epi32(int const * ,
                                             __m256i );
extern __m256i __cdecl _mm256_maskload_epi64(__int64 const * ,
                                             __m256i );

extern void __cdecl _mm256_maskstore_epi32(int * ,
                                           __m256i ,
                                           __m256i );
extern void __cdecl _mm256_maskstore_epi64(__int64 * ,
                                           __m256i ,
                                           __m256i );





extern __m256i __cdecl _mm256_permutevar8x32_epi32(__m256i, __m256i);
extern __m256 __cdecl _mm256_permutevar8x32_ps(__m256, __m256i);

extern __m256i __cdecl _mm256_permute4x64_epi64(__m256i, const int);
extern __m256d __cdecl _mm256_permute4x64_pd(__m256d, const int);

extern __m256i __cdecl _mm256_permute2x128_si256(__m256i, __m256i, const int);





extern __m256i __cdecl _mm256_stream_load_si256(__m256i const *);






extern __m256d __cdecl _mm256_mask_i32gather_pd(__m256d ,
                                                double const * ,
                                                __m128i ,
                                                __m256d ,
                                                const int );
extern __m256 __cdecl _mm256_mask_i32gather_ps(__m256 ,
                                                float const * ,
                                                __m256i ,
                                                __m256 ,
                                                const int );
extern __m256d __cdecl _mm256_mask_i64gather_pd(__m256d ,
                                                double const * ,
                                                __m256i ,
                                                __m256d ,
                                                const int );
extern __m128 __cdecl _mm256_mask_i64gather_ps(__m128 ,
                                                float const * ,
                                                __m256i ,
                                                __m128 ,
                                                const int );

extern __m128d __cdecl _mm_mask_i32gather_pd(__m128d ,
                                             double const * ,
                                             __m128i ,
                                             __m128d ,
                                             const int );
extern __m128 __cdecl _mm_mask_i32gather_ps(__m128 ,
                                             float const * ,
                                             __m128i ,
                                             __m128 ,
                                             const int );
extern __m128d __cdecl _mm_mask_i64gather_pd(__m128d ,
                                             double const * ,
                                             __m128i ,
                                             __m128d ,
                                             const int );
extern __m128 __cdecl _mm_mask_i64gather_ps(__m128 ,
                                             float const * ,
                                             __m128i ,
                                             __m128 ,
                                             const int );


extern __m256i __cdecl _mm256_mask_i32gather_epi32(__m256i ,
                                                   int const * ,
                                                   __m256i ,
                                                   __m256i ,
                                                   const int );
extern __m256i __cdecl _mm256_mask_i32gather_epi64(__m256i ,
                                                   __int64 const * ,
                                                   __m128i ,
                                                   __m256i ,
                                                   const int );
extern __m128i __cdecl _mm256_mask_i64gather_epi32(__m128i ,
                                                   int const * ,
                                                   __m256i ,
                                                   __m128i ,
                                                   const int );
extern __m256i __cdecl _mm256_mask_i64gather_epi64(__m256i ,
                                                   __int64 const * ,
                                                   __m256i ,
                                                   __m256i ,
                                                   const int );

extern __m128i __cdecl _mm_mask_i32gather_epi32(__m128i ,
                                                int const * ,
                                                __m128i ,
                                                __m128i ,
                                                const int );
extern __m128i __cdecl _mm_mask_i32gather_epi64(__m128i ,
                                                __int64 const * ,
                                                __m128i ,
                                                __m128i ,
                                                const int );
extern __m128i __cdecl _mm_mask_i64gather_epi32(__m128i ,
                                                int const * ,
                                                __m128i ,
                                                __m128i ,
                                                const int );
extern __m128i __cdecl _mm_mask_i64gather_epi64(__m128i ,
                                                __int64 const * ,
                                                __m128i ,
                                                __m128i ,
                                                const int );





extern __m256d __cdecl _mm256_i32gather_pd(double const * ,
                                           __m128i ,
                                           const int );
extern __m256 __cdecl _mm256_i32gather_ps(float const * ,
                                           __m256i ,
                                           const int );
extern __m256d __cdecl _mm256_i64gather_pd(double const * ,
                                           __m256i ,
                                           const int );
extern __m128 __cdecl _mm256_i64gather_ps(float const * ,
                                           __m256i ,
                                           const int );

extern __m128d __cdecl _mm_i32gather_pd(double const * ,
                                        __m128i ,
                                        const int );
extern __m128 __cdecl _mm_i32gather_ps(float const * ,
                                        __m128i ,
                                        const int );
extern __m128d __cdecl _mm_i64gather_pd(double const * ,
                                        __m128i ,
                                        const int );
extern __m128 __cdecl _mm_i64gather_ps(float const * ,
                                        __m128i ,
                                        const int );

extern __m256i __cdecl _mm256_i32gather_epi32(int const * ,
                                              __m256i ,
                                              const int );
extern __m256i __cdecl _mm256_i32gather_epi64(__int64 const * ,
                                              __m128i ,
                                              const int );
extern __m128i __cdecl _mm256_i64gather_epi32(int const * ,
                                              __m256i ,
                                              const int );
extern __m256i __cdecl _mm256_i64gather_epi64(__int64 const * ,
                                              __m256i ,
                                              const int );

extern __m128i __cdecl _mm_i32gather_epi32(int const * ,
                                           __m128i ,
                                           const int );
extern __m128i __cdecl _mm_i32gather_epi64(__int64 const * ,
                                           __m128i ,
                                           const int );
extern __m128i __cdecl _mm_i64gather_epi32(int const * ,
                                           __m128i ,
                                           const int );
extern __m128i __cdecl _mm_i64gather_epi64(__int64 const * ,
                                           __m128i ,
                                           const int );







extern unsigned int _bextr_u32(unsigned int ,
                                   unsigned int ,
                                   unsigned int );
extern unsigned int _blsi_u32(unsigned int);
extern unsigned int _blsmsk_u32(unsigned int);
extern unsigned int _blsr_u32(unsigned int);
extern unsigned int _bzhi_u32(unsigned int ,
                                  unsigned int );
extern unsigned int _mulx_u32(unsigned int ,
                                  unsigned int ,
                                  unsigned int * );
extern unsigned int _pdep_u32(unsigned int ,
                                  unsigned int );
extern unsigned int _pext_u32(unsigned int ,
                                  unsigned int );
extern unsigned int _rorx_u32(unsigned int ,
                                  const unsigned int );
extern int _sarx_i32(int ,
                                  unsigned int );
extern unsigned int _shlx_u32(unsigned int ,
                                  unsigned int );
extern unsigned int _shrx_u32(unsigned int ,
                                          unsigned int );
# 1862 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern unsigned int _lzcnt_u32(unsigned int);
# 1874 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern unsigned int _tzcnt_u32(unsigned int);
# 1884 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern void __cdecl _invpcid(unsigned int , void * );


extern void _Store_HLERelease(long volatile *,long);
extern void _StorePointer_HLERelease(void * volatile *,void *);

extern long _InterlockedExchange_HLEAcquire(long volatile *,long);
extern long _InterlockedExchange_HLERelease(long volatile *,long);
extern void * _InterlockedExchangePointer_HLEAcquire(void *volatile *,void *);
extern void * _InterlockedExchangePointer_HLERelease(void *volatile *,void *);

extern long _InterlockedCompareExchange_HLEAcquire(long volatile *,long,long);
extern long _InterlockedCompareExchange_HLERelease(long volatile *,long,long);
extern __int64 _InterlockedCompareExchange64_HLEAcquire(__int64 volatile *,__int64,__int64);
extern __int64 _InterlockedCompareExchange64_HLERelease(__int64 volatile *,__int64,__int64);
extern void * _InterlockedCompareExchangePointer_HLEAcquire(void *volatile *,void *,void *);
extern void * _InterlockedCompareExchangePointer_HLERelease(void *volatile *,void *,void *);

extern long _InterlockedExchangeAdd_HLEAcquire(long volatile *,long);
extern long _InterlockedExchangeAdd_HLERelease(long volatile *,long);

extern long _InterlockedAnd_HLEAcquire(long volatile *,long);
extern long _InterlockedAnd_HLERelease(long volatile *,long);
extern long _InterlockedOr_HLEAcquire(long volatile *,long);
extern long _InterlockedOr_HLERelease(long volatile *,long);
extern long _InterlockedXor_HLEAcquire(long volatile *,long);
extern long _InterlockedXor_HLERelease(long volatile *,long);

extern unsigned char _interlockedbittestandset_HLEAcquire(long *,long);
extern unsigned char _interlockedbittestandset_HLERelease(long *,long);
extern unsigned char _interlockedbittestandreset_HLEAcquire(long *,long);
extern unsigned char _interlockedbittestandreset_HLERelease(long *,long);
# 1948 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern unsigned int __cdecl _xbegin(void);
extern void __cdecl _xend(void);
extern void __cdecl _xabort(const unsigned int);
extern unsigned char __cdecl _xtest(void);
# 1960 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern int __cdecl _rdseed16_step(unsigned short *);
extern int __cdecl _rdseed32_step(unsigned int *);
# 1975 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern unsigned char __cdecl _addcarryx_u32(unsigned char ,
                                                   unsigned int ,
                                                   unsigned int ,
                                                   unsigned int * );
# 1992 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h" 3
extern unsigned short __cdecl _load_be_u16(void const*);
extern unsigned int __cdecl _load_be_u32(void const*);
extern unsigned __int64 __cdecl _load_be_u64(void const*);







extern void __cdecl _store_be_u16(void *, unsigned short);
extern void __cdecl _store_be_u32(void *, unsigned int);
extern void __cdecl _store_be_u64(void *, unsigned __int64);







extern __m128i __cdecl _mm_sha1msg1_epu32(__m128i, __m128i);
extern __m128i __cdecl _mm_sha1msg2_epu32(__m128i, __m128i);
extern __m128i __cdecl _mm_sha1nexte_epu32(__m128i, __m128i);
extern __m128i __cdecl _mm_sha1rnds4_epu32(__m128i, __m128i, const int);

extern __m128i __cdecl _mm_sha256msg1_epu32(__m128i, __m128i);
extern __m128i __cdecl _mm_sha256msg2_epu32(__m128i, __m128i);
extern __m128i __cdecl _mm_sha256rnds2_epu32(__m128i, __m128i, __m128i);




extern void * __cdecl _bnd_set_ptr_bounds(const void *, size_t);
extern void * __cdecl _bnd_narrow_ptr_bounds(const void *, const void *, size_t);
extern void * __cdecl _bnd_copy_ptr_bounds(const void *, const void *);
extern void * __cdecl _bnd_init_ptr_bounds(const void *);
extern void __cdecl _bnd_store_ptr_bounds(const void **, const void *);
extern void __cdecl _bnd_chk_ptr_lbounds(const void *);
extern void __cdecl _bnd_chk_ptr_ubounds(const void *);
extern void __cdecl _bnd_chk_ptr_bounds(const void *, size_t);
extern void * __cdecl _bnd_load_ptr_bounds(const void **, const void *);
extern const void * __cdecl _bnd_get_ptr_lbound(const void *);
extern const void * __cdecl _bnd_get_ptr_ubound(const void *);


};
# 24 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\intrin.h" 2 3

# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\ammintrin.h" 1 3
# 32 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\ammintrin.h" 3
extern "C" {
# 127 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\ammintrin.h" 3
__m128 _mm_macc_ps(__m128, __m128, __m128);
__m128d _mm_macc_pd(__m128d, __m128d, __m128d);
__m128 _mm_macc_ss(__m128, __m128, __m128);
__m128d _mm_macc_sd(__m128d, __m128d, __m128d);
__m128 _mm_maddsub_ps(__m128, __m128, __m128);
__m128d _mm_maddsub_pd(__m128d, __m128d, __m128d);
__m128 _mm_msubadd_ps(__m128, __m128, __m128);
__m128d _mm_msubadd_pd(__m128d, __m128d, __m128d);
__m128 _mm_msub_ps(__m128, __m128, __m128);
__m128d _mm_msub_pd(__m128d, __m128d, __m128d);
__m128 _mm_msub_ss(__m128, __m128, __m128);
__m128d _mm_msub_sd(__m128d, __m128d, __m128d);
__m128 _mm_nmacc_ps(__m128, __m128, __m128);
__m128d _mm_nmacc_pd(__m128d, __m128d, __m128d);
__m128 _mm_nmacc_ss(__m128, __m128, __m128);
__m128d _mm_nmacc_sd(__m128d, __m128d, __m128d);
__m128 _mm_nmsub_ps(__m128, __m128, __m128);
__m128d _mm_nmsub_pd(__m128d, __m128d, __m128d);
__m128 _mm_nmsub_ss(__m128, __m128, __m128);
__m128d _mm_nmsub_sd(__m128d, __m128d, __m128d);


__m128i _mm_maccs_epi16(__m128i, __m128i, __m128i);
__m128i _mm_macc_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maccsd_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maccd_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maccs_epi32(__m128i, __m128i, __m128i);
__m128i _mm_macc_epi32(__m128i, __m128i, __m128i);
__m128i _mm_maccslo_epi32(__m128i, __m128i, __m128i);
__m128i _mm_macclo_epi32(__m128i, __m128i, __m128i);
__m128i _mm_maccshi_epi32(__m128i, __m128i, __m128i);
__m128i _mm_macchi_epi32(__m128i, __m128i, __m128i);
__m128i _mm_maddsd_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maddd_epi16(__m128i, __m128i, __m128i);


__m128i _mm_haddw_epi8(__m128i);
__m128i _mm_haddd_epi8(__m128i);
__m128i _mm_haddq_epi8(__m128i);
__m128i _mm_haddd_epi16(__m128i);
__m128i _mm_haddq_epi16(__m128i);
__m128i _mm_haddq_epi32(__m128i);
__m128i _mm_haddw_epu8(__m128i);
__m128i _mm_haddd_epu8(__m128i);
__m128i _mm_haddq_epu8(__m128i);
__m128i _mm_haddd_epu16(__m128i);
__m128i _mm_haddq_epu16(__m128i);
__m128i _mm_haddq_epu32(__m128i);
__m128i _mm_hsubw_epi8(__m128i);
__m128i _mm_hsubd_epi16(__m128i);
__m128i _mm_hsubq_epi32(__m128i);


__m128i _mm_cmov_si128(__m128i, __m128i, __m128i);
__m128i _mm_perm_epi8(__m128i, __m128i, __m128i);


__m128i _mm_rot_epi8(__m128i, __m128i);
__m128i _mm_rot_epi16(__m128i, __m128i);
__m128i _mm_rot_epi32(__m128i, __m128i);
__m128i _mm_rot_epi64(__m128i, __m128i);
__m128i _mm_roti_epi8(__m128i, int);
__m128i _mm_roti_epi16(__m128i, int);
__m128i _mm_roti_epi32(__m128i, int);
__m128i _mm_roti_epi64(__m128i, int);
__m128i _mm_shl_epi8(__m128i, __m128i);
__m128i _mm_shl_epi16(__m128i, __m128i);
__m128i _mm_shl_epi32(__m128i, __m128i);
__m128i _mm_shl_epi64(__m128i, __m128i);
__m128i _mm_sha_epi8(__m128i, __m128i);
__m128i _mm_sha_epi16(__m128i, __m128i);
__m128i _mm_sha_epi32(__m128i, __m128i);
__m128i _mm_sha_epi64(__m128i, __m128i);



__m128i _mm_com_epu8(__m128i, __m128i, int);
__m128i _mm_com_epu16(__m128i, __m128i, int);
__m128i _mm_com_epu32(__m128i, __m128i, int);
__m128i _mm_com_epu64(__m128i, __m128i, int);
__m128i _mm_com_epi8(__m128i, __m128i, int);
__m128i _mm_com_epi16(__m128i, __m128i, int);
__m128i _mm_com_epi32(__m128i, __m128i, int);
__m128i _mm_com_epi64(__m128i, __m128i, int);



__m128 _mm_frcz_ps(__m128);
__m128d _mm_frcz_pd(__m128d);
__m128 _mm_frcz_ss(__m128, __m128);
__m128d _mm_frcz_sd(__m128d, __m128d);
# 226 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\ammintrin.h" 3
__m128 _mm_permute2_ps(__m128, __m128, __m128i, int);
__m128d _mm_permute2_pd(__m128d, __m128d, __m128i, int);



__m256 _mm256_macc_ps(__m256, __m256, __m256);
__m256d _mm256_macc_pd(__m256d, __m256d, __m256d);
__m256 _mm256_maddsub_ps(__m256, __m256, __m256);
__m256d _mm256_maddsub_pd(__m256d, __m256d, __m256d);
__m256 _mm256_msubadd_ps(__m256, __m256, __m256);
__m256d _mm256_msubadd_pd(__m256d, __m256d, __m256d);
__m256 _mm256_msub_ps(__m256, __m256, __m256);
__m256d _mm256_msub_pd(__m256d, __m256d, __m256d);
__m256 _mm256_nmacc_ps(__m256, __m256, __m256);
__m256d _mm256_nmacc_pd(__m256d, __m256d, __m256d);
__m256 _mm256_nmsub_ps(__m256, __m256, __m256);
__m256d _mm256_nmsub_pd(__m256d, __m256d, __m256d);
__m256i _mm256_cmov_si256(__m256i, __m256i, __m256i);
__m256 _mm256_frcz_ps(__m256);
__m256d _mm256_frcz_pd(__m256d);
__m256 _mm256_permute2_ps(__m256, __m256, __m256i, int);
__m256d _mm256_permute2_pd(__m256d, __m256d, __m256i, int);


void __llwpcb(void *);
void *__slwpcb();
void __lwpval32(unsigned int, unsigned int, unsigned int);
unsigned char __lwpins32(unsigned int, unsigned int, unsigned int);






unsigned int _bextr_u32(unsigned int, unsigned int, unsigned int);
unsigned int _andn_u32(unsigned int, unsigned int);
unsigned int _tzcnt_u32(unsigned int);
unsigned int _lzcnt_u32(unsigned int);
unsigned int _blsr_u32(unsigned int);
unsigned int _blsmsk_u32(unsigned int);
unsigned int _blsi_u32(unsigned int);
# 278 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\ammintrin.h" 3
unsigned int _bextri_u32(unsigned int, unsigned int);
unsigned int _blcfill_u32(unsigned int);
unsigned int _blsfill_u32(unsigned int);
unsigned int _blcs_u32(unsigned int);
unsigned int _tzmsk_u32(unsigned int);
unsigned int _blcic_u32(unsigned int);
unsigned int _blsic_u32(unsigned int);
unsigned int _t1mskc_u32(unsigned int);
unsigned int _blcmsk_u32(unsigned int);
unsigned int _blci_u32(unsigned int);
# 301 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\ammintrin.h" 3
void _mm_monitorx(void const *, unsigned int, unsigned int);
void _mm_mwaitx(unsigned int, unsigned int, unsigned int);

void _mm_clzero(void const *);


};
# 25 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\intrin.h" 2 3




# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\mm3dnow.h" 1 3
# 30 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\mm3dnow.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime.h" 1 3
# 30 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\mm3dnow.h" 2 3





extern "C" {




void _m_femms(void);
__m64 _m_pavgusb(__m64, __m64);
__m64 _m_pf2id(__m64);
__m64 _m_pfacc(__m64, __m64);
__m64 _m_pfadd(__m64, __m64);
__m64 _m_pfcmpeq(__m64, __m64);
__m64 _m_pfcmpge(__m64, __m64);
__m64 _m_pfcmpgt(__m64, __m64);
__m64 _m_pfmax(__m64, __m64);
__m64 _m_pfmin(__m64, __m64);
__m64 _m_pfmul(__m64, __m64);
__m64 _m_pfrcp(__m64);
__m64 _m_pfrcpit1(__m64, __m64);
__m64 _m_pfrcpit2(__m64, __m64);
__m64 _m_pfrsqrt(__m64);
__m64 _m_pfrsqit1(__m64, __m64);
__m64 _m_pfsub(__m64, __m64);
__m64 _m_pfsubr(__m64, __m64);
__m64 _m_pi2fd(__m64);
__m64 _m_pmulhrw(__m64, __m64);
void _m_prefetch(void*);
void _m_prefetchw(volatile const void*_Source);

__m64 _m_from_float(float);
float _m_to_float(__m64);



__m64 _m_pf2iw(__m64);
__m64 _m_pfnacc(__m64, __m64);
__m64 _m_pfpnacc(__m64, __m64);
__m64 _m_pi2fw(__m64);
__m64 _m_pswapd(__m64);


};
# 29 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\intrin.h" 2 3
# 44 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\intrin.h" 3
extern "C" {
# 129 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\intrin.h" 3
void * _AddressOfReturnAddress(void);
unsigned char _BitScanForward(unsigned long * _Index, unsigned long _Mask);


unsigned char _BitScanReverse(unsigned long * _Index, unsigned long _Mask);
# 155 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\intrin.h" 3
long _InterlockedAddLargeStatistic(__int64 volatile * _Addend, long _Value);



long _InterlockedAnd(long volatile * _Value, long _Mask);
short _InterlockedAnd16(short volatile * _Value, short _Mask);
# 170 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\intrin.h" 3
char _InterlockedAnd8(char volatile * _Value, char _Mask);
# 179 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\intrin.h" 3
long __cdecl _InterlockedCompareExchange(long volatile * _Destination, long _Exchange, long _Comparand);






short _InterlockedCompareExchange16(short volatile * _Destination, short _Exchange, short _Comparand);




__int64 _InterlockedCompareExchange64(__int64 volatile * _Destination, __int64 _Exchange, __int64 _Comparand);




char _InterlockedCompareExchange8(char volatile * _Destination, char _Exchange, char _Comparand);



void * _InterlockedCompareExchangePointer(void * volatile * _Destination, void * _Exchange, void * _Comparand);
# 209 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\intrin.h" 3
long __cdecl _InterlockedDecrement(long volatile * _Addend);

short _InterlockedDecrement16(short volatile * _Addend);
# 222 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\intrin.h" 3
long __cdecl _InterlockedExchange(long volatile * _Target, long _Value);

short _InterlockedExchange16(short volatile * _Target, short _Value);







char _InterlockedExchange8(char volatile * _Target, char _Value);



long __cdecl _InterlockedExchangeAdd(long volatile * _Addend, long _Value);
short _InterlockedExchangeAdd16(short volatile * _Addend, short _Value);







char _InterlockedExchangeAdd8(char volatile * _Addend, char _Value);






void * _InterlockedExchangePointer(void * volatile * _Target, void * _Value);






long __cdecl _InterlockedIncrement(long volatile * _Addend);

short _InterlockedIncrement16(short volatile * _Addend);
# 272 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\intrin.h" 3
long _InterlockedOr(long volatile * _Value, long _Mask);
short _InterlockedOr16(short volatile * _Value, short _Mask);
# 283 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\intrin.h" 3
char _InterlockedOr8(char volatile * _Value, char _Mask);
# 292 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\intrin.h" 3
long _InterlockedXor(long volatile * _Value, long _Mask);
short _InterlockedXor16(short volatile * _Value, short _Mask);
# 303 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\intrin.h" 3
char _InterlockedXor8(char volatile * _Value, char _Mask);
# 320 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\intrin.h" 3
void _ReadBarrier(void);






void _ReadWriteBarrier(void);
void * _ReturnAddress(void);

void _WriteBarrier(void);






void __addfsbyte(unsigned long, unsigned char);
void __addfsdword(unsigned long, unsigned long);
void __addfsword(unsigned long, unsigned short);
# 348 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\intrin.h" 3
void __code_seg(const char *);
void __cpuid(int[4], int);
void __cpuidex(int[4], int, int);
void __cdecl __debugbreak(void);

__int64 __emul(int, int);
unsigned __int64 __emulu(unsigned int, unsigned int);
__declspec(noreturn) void __fastfail(unsigned int);

unsigned int __getcallerseflags(void);
void __halt(void);


unsigned char __inbyte(unsigned short);
void __inbytestring(unsigned short, unsigned char *, unsigned long);
void __incfsbyte(unsigned long);
void __incfsdword(unsigned long);
void __incfsword(unsigned long);
# 374 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\intrin.h" 3
unsigned long __indword(unsigned short);
void __indwordstring(unsigned short, unsigned long *, unsigned long);
void __int2c(void);
void __invlpg(void *);
unsigned short __inword(unsigned short);
void __inwordstring(unsigned short, unsigned short *, unsigned long);
# 389 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\intrin.h" 3
void __lidt(void *);
unsigned __int64 __ll_lshift(unsigned __int64, int);
__int64 __ll_rshift(__int64, int);
unsigned int __lzcnt(unsigned int);
unsigned short __lzcnt16(unsigned short);

void __movsb(unsigned char *, unsigned char const *, size_t);
void __movsd(unsigned long *, unsigned long const *, size_t);

void __movsw(unsigned short *, unsigned short const *, size_t);

void __nop(void);
void __nvreg_restore_fence(void);
void __nvreg_save_fence(void);
void __outbyte(unsigned short, unsigned char);
void __outbytestring(unsigned short, unsigned char *, unsigned long);
void __outdword(unsigned short, unsigned long);
void __outdwordstring(unsigned short, unsigned long *, unsigned long);
void __outword(unsigned short, unsigned short);
void __outwordstring(unsigned short, unsigned short *, unsigned long);
unsigned int __popcnt(unsigned int);
unsigned short __popcnt16(unsigned short);




unsigned __int64 __rdtsc(void);
unsigned __int64 __rdtscp(unsigned int *);

unsigned long __readcr0(void);

unsigned long __readcr2(void);

unsigned long __readcr3(void);

unsigned long __readcr4(void);

unsigned long __readcr8(void);

unsigned int __readdr(unsigned int);

unsigned int __readeflags(void);
unsigned char __readfsbyte(unsigned long);
unsigned long __readfsdword(unsigned long);
unsigned __int64 __readfsqword(unsigned long);
unsigned short __readfsword(unsigned long);




unsigned __int64 __readmsr(unsigned long);
unsigned __int64 __readpmc(unsigned long);




unsigned long __segmentlimit(unsigned long);



void __sidt(void *);

void __stosb(unsigned char *, unsigned char, size_t);
void __stosd(unsigned long *, unsigned long, size_t);

void __stosw(unsigned short *, unsigned short, size_t);
void __svm_clgi(void);
void __svm_invlpga(void *, int);
void __svm_skinit(int);
void __svm_stgi(void);
void __svm_vmload(size_t);
void __svm_vmrun(size_t);
void __svm_vmsave(size_t);





void __ud2(void);
unsigned __int64 __ull_rshift(unsigned __int64, int);

void __vmx_off(void);




void __vmx_vmptrst(unsigned __int64 *);



void __wbinvd(void);



void __writecr0(unsigned int);

void __writecr3(unsigned int);

void __writecr4(unsigned int);

void __writecr8(unsigned int);

void __writedr(unsigned int, unsigned int);

void __writeeflags(unsigned int);
void __writefsbyte(unsigned long, unsigned char);
void __writefsdword(unsigned long, unsigned long);
void __writefsqword(unsigned long, unsigned __int64);
void __writefsword(unsigned long, unsigned short);




void __writemsr(unsigned long, unsigned __int64);





unsigned char _bittest(long const *, long);

unsigned char _bittestandcomplement(long *, long);

unsigned char _bittestandreset(long *, long);

unsigned char _bittestandset(long *, long);

unsigned __int64 __cdecl _byteswap_uint64( unsigned __int64);
unsigned long __cdecl _byteswap_ulong( unsigned long);
unsigned short __cdecl _byteswap_ushort( unsigned short);
void __cdecl _disable(void);
void __cdecl _enable(void);
unsigned char _interlockedbittestandreset(long volatile *, long);







unsigned char _interlockedbittestandset(long volatile *, long);
# 547 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\intrin.h" 3
unsigned long __cdecl _lrotl( unsigned long, int);
unsigned long __cdecl _lrotr( unsigned long, int);
void _m_empty(void);
void _m_femms(void);
__m64 _m_from_float(float);
__m64 _m_from_int(int);
void _m_maskmovq(__m64, __m64, char *);
__m64 _m_packssdw(__m64, __m64);
__m64 _m_packsswb(__m64, __m64);
__m64 _m_packuswb(__m64, __m64);
__m64 _m_paddb(__m64, __m64);
__m64 _m_paddd(__m64, __m64);
__m64 _m_paddsb(__m64, __m64);
__m64 _m_paddsw(__m64, __m64);
__m64 _m_paddusb(__m64, __m64);
__m64 _m_paddusw(__m64, __m64);
__m64 _m_paddw(__m64, __m64);
__m64 _m_pand(__m64, __m64);
__m64 _m_pandn(__m64, __m64);
__m64 _m_pavgb(__m64, __m64);
__m64 _m_pavgusb(__m64, __m64);
__m64 _m_pavgw(__m64, __m64);
__m64 _m_pcmpeqb(__m64, __m64);
__m64 _m_pcmpeqd(__m64, __m64);
__m64 _m_pcmpeqw(__m64, __m64);
__m64 _m_pcmpgtb(__m64, __m64);
__m64 _m_pcmpgtd(__m64, __m64);
__m64 _m_pcmpgtw(__m64, __m64);
int _m_pextrw(__m64, int);
__m64 _m_pf2id(__m64);
__m64 _m_pf2iw(__m64);
__m64 _m_pfacc(__m64, __m64);
__m64 _m_pfadd(__m64, __m64);
__m64 _m_pfcmpeq(__m64, __m64);
__m64 _m_pfcmpge(__m64, __m64);
__m64 _m_pfcmpgt(__m64, __m64);
__m64 _m_pfmax(__m64, __m64);
__m64 _m_pfmin(__m64, __m64);
__m64 _m_pfmul(__m64, __m64);
__m64 _m_pfnacc(__m64, __m64);
__m64 _m_pfpnacc(__m64, __m64);
__m64 _m_pfrcp(__m64);
__m64 _m_pfrcpit1(__m64, __m64);
__m64 _m_pfrcpit2(__m64, __m64);
__m64 _m_pfrsqit1(__m64, __m64);
__m64 _m_pfrsqrt(__m64);
__m64 _m_pfsub(__m64, __m64);
__m64 _m_pfsubr(__m64, __m64);
__m64 _m_pi2fd(__m64);
__m64 _m_pi2fw(__m64);
__m64 _m_pinsrw(__m64, int, int);
__m64 _m_pmaddwd(__m64, __m64);
__m64 _m_pmaxsw(__m64, __m64);
__m64 _m_pmaxub(__m64, __m64);
__m64 _m_pminsw(__m64, __m64);
__m64 _m_pminub(__m64, __m64);
int _m_pmovmskb(__m64);
__m64 _m_pmulhrw(__m64, __m64);
__m64 _m_pmulhuw(__m64, __m64);
__m64 _m_pmulhw(__m64, __m64);
__m64 _m_pmullw(__m64, __m64);
__m64 _m_por(__m64, __m64);
void _m_prefetch(void *);
void _m_prefetchw(volatile const void *);
__m64 _m_psadbw(__m64, __m64);
__m64 _m_pshufw(__m64, int);
__m64 _m_pslld(__m64, __m64);
__m64 _m_pslldi(__m64, int);
__m64 _m_psllq(__m64, __m64);
__m64 _m_psllqi(__m64, int);
__m64 _m_psllw(__m64, __m64);
__m64 _m_psllwi(__m64, int);
__m64 _m_psrad(__m64, __m64);
__m64 _m_psradi(__m64, int);
__m64 _m_psraw(__m64, __m64);
__m64 _m_psrawi(__m64, int);
__m64 _m_psrld(__m64, __m64);
__m64 _m_psrldi(__m64, int);
__m64 _m_psrlq(__m64, __m64);
__m64 _m_psrlqi(__m64, int);
__m64 _m_psrlw(__m64, __m64);
__m64 _m_psrlwi(__m64, int);
__m64 _m_psubb(__m64, __m64);
__m64 _m_psubd(__m64, __m64);
__m64 _m_psubsb(__m64, __m64);
__m64 _m_psubsw(__m64, __m64);
__m64 _m_psubusb(__m64, __m64);
__m64 _m_psubusw(__m64, __m64);
__m64 _m_psubw(__m64, __m64);
__m64 _m_pswapd(__m64);
__m64 _m_punpckhbw(__m64, __m64);
__m64 _m_punpckhdq(__m64, __m64);
__m64 _m_punpckhwd(__m64, __m64);
__m64 _m_punpcklbw(__m64, __m64);
__m64 _m_punpckldq(__m64, __m64);
__m64 _m_punpcklwd(__m64, __m64);
__m64 _m_pxor(__m64, __m64);
float _m_to_float(__m64);
int _m_to_int(__m64);
__m128i _mm_abs_epi16(__m128i);
__m128i _mm_abs_epi32(__m128i);
__m128i _mm_abs_epi8(__m128i);
__m64 _mm_abs_pi16(__m64);
__m64 _mm_abs_pi32(__m64);
__m64 _mm_abs_pi8(__m64);
__m128i _mm_add_epi16(__m128i, __m128i);
__m128i _mm_add_epi32(__m128i, __m128i);
__m128i _mm_add_epi64(__m128i, __m128i);
__m128i _mm_add_epi8(__m128i, __m128i);
__m128d _mm_add_pd(__m128d, __m128d);
__m128 _mm_add_ps(__m128, __m128);
__m128d _mm_add_sd(__m128d, __m128d);
__m64 _mm_add_si64(__m64, __m64);
__m128 _mm_add_ss(__m128, __m128);
__m128i _mm_adds_epi16(__m128i, __m128i);
__m128i _mm_adds_epi8(__m128i, __m128i);
__m128i _mm_adds_epu16(__m128i, __m128i);
__m128i _mm_adds_epu8(__m128i, __m128i);
__m128d _mm_addsub_pd(__m128d, __m128d);
__m128 _mm_addsub_ps(__m128, __m128);
__m128i _mm_alignr_epi8(__m128i, __m128i, int);
__m64 _mm_alignr_pi8(__m64, __m64, int);
__m128d _mm_and_pd(__m128d, __m128d);
__m128 _mm_and_ps(__m128, __m128);
__m128i _mm_and_si128(__m128i, __m128i);
__m128d _mm_andnot_pd(__m128d, __m128d);
__m128 _mm_andnot_ps(__m128, __m128);
__m128i _mm_andnot_si128(__m128i, __m128i);
__m128i _mm_avg_epu16(__m128i, __m128i);
__m128i _mm_avg_epu8(__m128i, __m128i);
__m128i _mm_blend_epi16(__m128i, __m128i, int);
__m128d _mm_blend_pd(__m128d, __m128d, int);
__m128 _mm_blend_ps(__m128, __m128, int);
__m128i _mm_blendv_epi8(__m128i, __m128i, __m128i);
__m128d _mm_blendv_pd(__m128d, __m128d, __m128d);
__m128 _mm_blendv_ps(__m128, __m128, __m128);
void _mm_clflush(void const *);
void _mm_clflushopt(void const *);
void _mm_clwb(void const *);
void _mm_clzero(void const *);
__m128i _mm_cmpeq_epi16(__m128i, __m128i);
__m128i _mm_cmpeq_epi32(__m128i, __m128i);
__m128i _mm_cmpeq_epi64(__m128i, __m128i);
__m128i _mm_cmpeq_epi8(__m128i, __m128i);
__m128d _mm_cmpeq_pd(__m128d, __m128d);
__m128 _mm_cmpeq_ps(__m128, __m128);
__m128d _mm_cmpeq_sd(__m128d, __m128d);
__m128 _mm_cmpeq_ss(__m128, __m128);
int _mm_cmpestra(__m128i, int, __m128i, int, int);
int _mm_cmpestrc(__m128i, int, __m128i, int, int);
int _mm_cmpestri(__m128i, int, __m128i, int, int);
__m128i _mm_cmpestrm(__m128i, int, __m128i, int, int);
int _mm_cmpestro(__m128i, int, __m128i, int, int);
int _mm_cmpestrs(__m128i, int, __m128i, int, int);
int _mm_cmpestrz(__m128i, int, __m128i, int, int);
__m128d _mm_cmpge_pd(__m128d, __m128d);
__m128 _mm_cmpge_ps(__m128, __m128);
__m128d _mm_cmpge_sd(__m128d, __m128d);
__m128 _mm_cmpge_ss(__m128, __m128);
__m128i _mm_cmpgt_epi16(__m128i, __m128i);
__m128i _mm_cmpgt_epi32(__m128i, __m128i);
__m128i _mm_cmpgt_epi64(__m128i, __m128i);
__m128i _mm_cmpgt_epi8(__m128i, __m128i);
__m128d _mm_cmpgt_pd(__m128d, __m128d);
__m128 _mm_cmpgt_ps(__m128, __m128);
__m128d _mm_cmpgt_sd(__m128d, __m128d);
__m128 _mm_cmpgt_ss(__m128, __m128);
int _mm_cmpistra(__m128i, __m128i, int);
int _mm_cmpistrc(__m128i, __m128i, int);
int _mm_cmpistri(__m128i, __m128i, int);
__m128i _mm_cmpistrm(__m128i, __m128i, int);
int _mm_cmpistro(__m128i, __m128i, int);
int _mm_cmpistrs(__m128i, __m128i, int);
int _mm_cmpistrz(__m128i, __m128i, int);
__m128d _mm_cmple_pd(__m128d, __m128d);
__m128 _mm_cmple_ps(__m128, __m128);
__m128d _mm_cmple_sd(__m128d, __m128d);
__m128 _mm_cmple_ss(__m128, __m128);
__m128i _mm_cmplt_epi16(__m128i, __m128i);
__m128i _mm_cmplt_epi32(__m128i, __m128i);
__m128i _mm_cmplt_epi8(__m128i, __m128i);
__m128d _mm_cmplt_pd(__m128d, __m128d);
__m128 _mm_cmplt_ps(__m128, __m128);
__m128d _mm_cmplt_sd(__m128d, __m128d);
__m128 _mm_cmplt_ss(__m128, __m128);
__m128d _mm_cmpneq_pd(__m128d, __m128d);
__m128 _mm_cmpneq_ps(__m128, __m128);
__m128d _mm_cmpneq_sd(__m128d, __m128d);
__m128 _mm_cmpneq_ss(__m128, __m128);
__m128d _mm_cmpnge_pd(__m128d, __m128d);
__m128 _mm_cmpnge_ps(__m128, __m128);
__m128d _mm_cmpnge_sd(__m128d, __m128d);
__m128 _mm_cmpnge_ss(__m128, __m128);
__m128d _mm_cmpngt_pd(__m128d, __m128d);
__m128 _mm_cmpngt_ps(__m128, __m128);
__m128d _mm_cmpngt_sd(__m128d, __m128d);
__m128 _mm_cmpngt_ss(__m128, __m128);
__m128d _mm_cmpnle_pd(__m128d, __m128d);
__m128 _mm_cmpnle_ps(__m128, __m128);
__m128d _mm_cmpnle_sd(__m128d, __m128d);
__m128 _mm_cmpnle_ss(__m128, __m128);
__m128d _mm_cmpnlt_pd(__m128d, __m128d);
__m128 _mm_cmpnlt_ps(__m128, __m128);
__m128d _mm_cmpnlt_sd(__m128d, __m128d);
__m128 _mm_cmpnlt_ss(__m128, __m128);
__m128d _mm_cmpord_pd(__m128d, __m128d);
__m128 _mm_cmpord_ps(__m128, __m128);
__m128d _mm_cmpord_sd(__m128d, __m128d);
__m128 _mm_cmpord_ss(__m128, __m128);
__m128d _mm_cmpunord_pd(__m128d, __m128d);
__m128 _mm_cmpunord_ps(__m128, __m128);
__m128d _mm_cmpunord_sd(__m128d, __m128d);
__m128 _mm_cmpunord_ss(__m128, __m128);
int _mm_comieq_sd(__m128d, __m128d);
int _mm_comieq_ss(__m128, __m128);
int _mm_comige_sd(__m128d, __m128d);
int _mm_comige_ss(__m128, __m128);
int _mm_comigt_sd(__m128d, __m128d);
int _mm_comigt_ss(__m128, __m128);
int _mm_comile_sd(__m128d, __m128d);
int _mm_comile_ss(__m128, __m128);
int _mm_comilt_sd(__m128d, __m128d);
int _mm_comilt_ss(__m128, __m128);
int _mm_comineq_sd(__m128d, __m128d);
int _mm_comineq_ss(__m128, __m128);
unsigned int _mm_crc32_u16(unsigned int, unsigned short);
unsigned int _mm_crc32_u32(unsigned int, unsigned int);

unsigned int _mm_crc32_u8(unsigned int, unsigned char);
__m128 _mm_cvt_pi2ps(__m128, __m64);
__m64 _mm_cvt_ps2pi(__m128);
__m128 _mm_cvt_si2ss(__m128, int);
int _mm_cvt_ss2si(__m128);
__m128i _mm_cvtepi16_epi32(__m128i);
__m128i _mm_cvtepi16_epi64(__m128i);
__m128i _mm_cvtepi32_epi64(__m128i);
__m128d _mm_cvtepi32_pd(__m128i);
__m128 _mm_cvtepi32_ps(__m128i);
__m128i _mm_cvtepi8_epi16(__m128i);
__m128i _mm_cvtepi8_epi32(__m128i);
__m128i _mm_cvtepi8_epi64(__m128i);
__m128i _mm_cvtepu16_epi32(__m128i);
__m128i _mm_cvtepu16_epi64(__m128i);
__m128i _mm_cvtepu32_epi64(__m128i);
__m128i _mm_cvtepu8_epi16(__m128i);
__m128i _mm_cvtepu8_epi32(__m128i);
__m128i _mm_cvtepu8_epi64(__m128i);
__m128i _mm_cvtpd_epi32(__m128d);
__m64 _mm_cvtpd_pi32(__m128d);
__m128 _mm_cvtpd_ps(__m128d);
__m128d _mm_cvtpi32_pd(__m64);
__m128i _mm_cvtps_epi32(__m128);
__m128d _mm_cvtps_pd(__m128);
int _mm_cvtsd_si32(__m128d);


__m128 _mm_cvtsd_ss(__m128, __m128d);
int _mm_cvtsi128_si32(__m128i);


__m128d _mm_cvtsi32_sd(__m128d, int);
__m128i _mm_cvtsi32_si128(int);






__m128d _mm_cvtss_sd(__m128d, __m128);


__m64 _mm_cvtt_ps2pi(__m128);
int _mm_cvtt_ss2si(__m128);
__m128i _mm_cvttpd_epi32(__m128d);
__m64 _mm_cvttpd_pi32(__m128d);
__m128i _mm_cvttps_epi32(__m128);
int _mm_cvttsd_si32(__m128d);




__m128d _mm_div_pd(__m128d, __m128d);
__m128 _mm_div_ps(__m128, __m128);
__m128d _mm_div_sd(__m128d, __m128d);
__m128 _mm_div_ss(__m128, __m128);
__m128d _mm_dp_pd(__m128d, __m128d, int);
__m128 _mm_dp_ps(__m128, __m128, int);
int _mm_extract_epi16(__m128i, int);
int _mm_extract_epi32(__m128i, int);

int _mm_extract_epi8(__m128i, int);
int _mm_extract_ps(__m128, int);
__m128i _mm_extract_si64(__m128i, __m128i);
__m128i _mm_extracti_si64(__m128i, int, int);
unsigned int _mm_getcsr(void);
__m128i _mm_hadd_epi16(__m128i, __m128i);
__m128i _mm_hadd_epi32(__m128i, __m128i);
__m128d _mm_hadd_pd(__m128d, __m128d);
__m64 _mm_hadd_pi16(__m64, __m64);
__m64 _mm_hadd_pi32(__m64, __m64);
__m128 _mm_hadd_ps(__m128, __m128);
__m128i _mm_hadds_epi16(__m128i, __m128i);
__m64 _mm_hadds_pi16(__m64, __m64);
__m128i _mm_hsub_epi16(__m128i, __m128i);
__m128i _mm_hsub_epi32(__m128i, __m128i);
__m128d _mm_hsub_pd(__m128d, __m128d);
__m64 _mm_hsub_pi16(__m64, __m64);
__m64 _mm_hsub_pi32(__m64, __m64);
__m128 _mm_hsub_ps(__m128, __m128);
__m128i _mm_hsubs_epi16(__m128i, __m128i);
__m64 _mm_hsubs_pi16(__m64, __m64);
__m128i _mm_insert_epi16(__m128i, int, int);
__m128i _mm_insert_epi32(__m128i, int, int);

__m128i _mm_insert_epi8(__m128i, int, int);
__m128 _mm_insert_ps(__m128, __m128, int);
__m128i _mm_insert_si64(__m128i, __m128i);
__m128i _mm_inserti_si64(__m128i, __m128i, int, int);
__m128i _mm_lddqu_si128(__m128i const *);
void _mm_lfence(void);
__m128d _mm_load1_pd(double const *);
__m128d _mm_load_pd(double const *);
__m128 _mm_load_ps(float const *);
__m128 _mm_load_ps1(float const *);
__m128d _mm_load_sd(double const *);
__m128i _mm_load_si128(__m128i const *);
__m128 _mm_load_ss(float const *);
__m128d _mm_loaddup_pd(double const *);
__m128d _mm_loadh_pd(__m128d, double const *);
__m128 _mm_loadh_pi(__m128, __m64 const *);
__m128i _mm_loadl_epi64(__m128i const *);
__m128d _mm_loadl_pd(__m128d, double const *);
__m128 _mm_loadl_pi(__m128, __m64 const *);
__m128d _mm_loadr_pd(double const *);
__m128 _mm_loadr_ps(float const *);
__m128d _mm_loadu_pd(double const *);
__m128 _mm_loadu_ps(float const *);
__m128i _mm_loadu_si128(__m128i const *);
__m128i _mm_madd_epi16(__m128i, __m128i);
__m128i _mm_maddubs_epi16(__m128i, __m128i);
__m64 _mm_maddubs_pi16(__m64, __m64);
void _mm_maskmoveu_si128(__m128i, __m128i, char *);
__m128i _mm_max_epi16(__m128i, __m128i);
__m128i _mm_max_epi32(__m128i, __m128i);
__m128i _mm_max_epi8(__m128i, __m128i);
__m128i _mm_max_epu16(__m128i, __m128i);
__m128i _mm_max_epu32(__m128i, __m128i);
__m128i _mm_max_epu8(__m128i, __m128i);
__m128d _mm_max_pd(__m128d, __m128d);
__m128 _mm_max_ps(__m128, __m128);
__m128d _mm_max_sd(__m128d, __m128d);
__m128 _mm_max_ss(__m128, __m128);
void _mm_mfence(void);
__m128i _mm_min_epi16(__m128i, __m128i);
__m128i _mm_min_epi32(__m128i, __m128i);
__m128i _mm_min_epi8(__m128i, __m128i);
__m128i _mm_min_epu16(__m128i, __m128i);
__m128i _mm_min_epu32(__m128i, __m128i);
__m128i _mm_min_epu8(__m128i, __m128i);
__m128d _mm_min_pd(__m128d, __m128d);
__m128 _mm_min_ps(__m128, __m128);
__m128d _mm_min_sd(__m128d, __m128d);
__m128 _mm_min_ss(__m128, __m128);
__m128i _mm_minpos_epu16(__m128i);
void _mm_monitor(void const *, unsigned int, unsigned int);
__m128i _mm_move_epi64(__m128i);
__m128d _mm_move_sd(__m128d, __m128d);
__m128 _mm_move_ss(__m128, __m128);
__m128d _mm_movedup_pd(__m128d);
__m128 _mm_movehdup_ps(__m128);
__m128 _mm_movehl_ps(__m128, __m128);
__m128 _mm_moveldup_ps(__m128);
__m128 _mm_movelh_ps(__m128, __m128);
int _mm_movemask_epi8(__m128i);
int _mm_movemask_pd(__m128d);
int _mm_movemask_ps(__m128);
__m64 _mm_movepi64_pi64(__m128i);
__m128i _mm_movpi64_epi64(__m64);
__m128i _mm_mpsadbw_epu8(__m128i, __m128i, int);
__m128i _mm_mul_epi32(__m128i, __m128i);
__m128i _mm_mul_epu32(__m128i, __m128i);
__m128d _mm_mul_pd(__m128d, __m128d);
__m128 _mm_mul_ps(__m128, __m128);
__m128d _mm_mul_sd(__m128d, __m128d);
__m128 _mm_mul_ss(__m128, __m128);
__m64 _mm_mul_su32(__m64, __m64);
__m128i _mm_mulhi_epi16(__m128i, __m128i);
__m128i _mm_mulhi_epu16(__m128i, __m128i);
__m128i _mm_mulhrs_epi16(__m128i, __m128i);
__m64 _mm_mulhrs_pi16(__m64, __m64);
__m128i _mm_mullo_epi16(__m128i, __m128i);
__m128i _mm_mullo_epi32(__m128i, __m128i);
void _mm_mwait(unsigned int, unsigned int);
__m128d _mm_or_pd(__m128d, __m128d);
__m128 _mm_or_ps(__m128, __m128);
__m128i _mm_or_si128(__m128i, __m128i);
__m128i _mm_packs_epi16(__m128i, __m128i);
__m128i _mm_packs_epi32(__m128i, __m128i);
__m128i _mm_packus_epi16(__m128i, __m128i);
__m128i _mm_packus_epi32(__m128i, __m128i);
void _mm_pause(void);
int _mm_popcnt_u32(unsigned int);

void _mm_prefetch(char const *, int);
__m128 _mm_rcp_ps(__m128);
__m128 _mm_rcp_ss(__m128);
__m128d _mm_round_pd(__m128d, int);
__m128 _mm_round_ps(__m128, int);
__m128d _mm_round_sd(__m128d, __m128d, int);
__m128 _mm_round_ss(__m128, __m128, int);
__m128 _mm_rsqrt_ps(__m128);
__m128 _mm_rsqrt_ss(__m128);
__m128i _mm_sad_epu8(__m128i, __m128i);
__m128i _mm_set1_epi16(short);
__m128i _mm_set1_epi32(int);
__m128i _mm_set1_epi64(__m64);
__m128i _mm_set1_epi64x(__int64);
__m128i _mm_set1_epi8(char);
__m128d _mm_set1_pd(double);
__m64 _mm_set1_pi16(short);
__m64 _mm_set1_pi32(int);
__m64 _mm_set1_pi8(char);
__m128i _mm_set_epi16(short, short, short, short, short, short, short, short);
__m128i _mm_set_epi32(int, int, int, int);
__m128i _mm_set_epi64(__m64, __m64);
__m128i _mm_set_epi64x(__int64, __int64);
__m128i _mm_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char);
__m128d _mm_set_pd(double, double);
__m64 _mm_set_pi16(short, short, short, short);
__m64 _mm_set_pi32(int, int);
__m64 _mm_set_pi8(char, char, char, char, char, char, char, char);
__m128 _mm_set_ps(float, float, float, float);
__m128 _mm_set_ps1(float);
__m128d _mm_set_sd(double);
__m128 _mm_set_ss(float);
void _mm_setcsr(unsigned int);
__m128i _mm_setl_epi64(__m128i);
__m128i _mm_setr_epi16(short, short, short, short, short, short, short, short);
__m128i _mm_setr_epi32(int, int, int, int);
__m128i _mm_setr_epi64(__m64, __m64);
__m128i _mm_setr_epi64x(__int64, __int64);
__m128i _mm_setr_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char);
__m128d _mm_setr_pd(double, double);
__m64 _mm_setr_pi16(short, short, short, short);
__m64 _mm_setr_pi32(int, int);
__m64 _mm_setr_pi8(char, char, char, char, char, char, char, char);
__m128 _mm_setr_ps(float, float, float, float);
__m128d _mm_setzero_pd(void);
__m128 _mm_setzero_ps(void);
__m128i _mm_setzero_si128(void);
__m64 _mm_setzero_si64(void);
void _mm_sfence(void);
__m128i _mm_shuffle_epi32(__m128i, int);
__m128i _mm_shuffle_epi8(__m128i, __m128i);
__m128d _mm_shuffle_pd(__m128d, __m128d, int);
__m64 _mm_shuffle_pi8(__m64, __m64);
__m128 _mm_shuffle_ps(__m128, __m128, unsigned int);
__m128i _mm_shufflehi_epi16(__m128i, int);
__m128i _mm_shufflelo_epi16(__m128i, int);
__m128i _mm_sign_epi16(__m128i, __m128i);
__m128i _mm_sign_epi32(__m128i, __m128i);
__m128i _mm_sign_epi8(__m128i, __m128i);
__m64 _mm_sign_pi16(__m64, __m64);
__m64 _mm_sign_pi32(__m64, __m64);
__m64 _mm_sign_pi8(__m64, __m64);
__m128i _mm_sll_epi16(__m128i, __m128i);
__m128i _mm_sll_epi32(__m128i, __m128i);
__m128i _mm_sll_epi64(__m128i, __m128i);
__m128i _mm_slli_epi16(__m128i, int);
__m128i _mm_slli_epi32(__m128i, int);
__m128i _mm_slli_epi64(__m128i, int);
__m128i _mm_slli_si128(__m128i, int);
__m128d _mm_sqrt_pd(__m128d);
__m128 _mm_sqrt_ps(__m128);
__m128d _mm_sqrt_sd(__m128d, __m128d);
__m128 _mm_sqrt_ss(__m128);
__m128i _mm_sra_epi16(__m128i, __m128i);
__m128i _mm_sra_epi32(__m128i, __m128i);
__m128i _mm_srai_epi16(__m128i, int);
__m128i _mm_srai_epi32(__m128i, int);
__m128i _mm_srl_epi16(__m128i, __m128i);
__m128i _mm_srl_epi32(__m128i, __m128i);
__m128i _mm_srl_epi64(__m128i, __m128i);
__m128i _mm_srli_epi16(__m128i, int);
__m128i _mm_srli_epi32(__m128i, int);
__m128i _mm_srli_epi64(__m128i, int);
__m128i _mm_srli_si128(__m128i, int);
void _mm_store1_pd(double *, __m128d);
void _mm_store_pd(double *, __m128d);
void _mm_store_ps(float *, __m128);
void _mm_store_ps1(float *, __m128);
void _mm_store_sd(double *, __m128d);
void _mm_store_si128(__m128i *, __m128i);
void _mm_store_ss(float *, __m128);
void _mm_storeh_pd(double *, __m128d);
void _mm_storeh_pi(__m64 *, __m128);
void _mm_storel_epi64(__m128i *, __m128i);
void _mm_storel_pd(double *, __m128d);
void _mm_storel_pi(__m64 *, __m128);
void _mm_storer_pd(double *, __m128d);
void _mm_storer_ps(float *, __m128);
void _mm_storeu_pd(double *, __m128d);
void _mm_storeu_ps(float *, __m128);
void _mm_storeu_si128(__m128i *, __m128i);
__m128i _mm_stream_load_si128(const __m128i *);
void _mm_stream_pd(double *, __m128d);
void _mm_stream_pi(__m64 *, __m64);
void _mm_stream_ps(float *, __m128);
void _mm_stream_sd(double *, __m128d);
void _mm_stream_si128(__m128i *, __m128i);
void _mm_stream_si32(int *, int);

void _mm_stream_ss(float *, __m128);
__m128i _mm_sub_epi16(__m128i, __m128i);
__m128i _mm_sub_epi32(__m128i, __m128i);
__m128i _mm_sub_epi64(__m128i, __m128i);
__m128i _mm_sub_epi8(__m128i, __m128i);
__m128d _mm_sub_pd(__m128d, __m128d);
__m128 _mm_sub_ps(__m128, __m128);
__m128d _mm_sub_sd(__m128d, __m128d);
__m64 _mm_sub_si64(__m64, __m64);
__m128 _mm_sub_ss(__m128, __m128);
__m128i _mm_subs_epi16(__m128i, __m128i);
__m128i _mm_subs_epi8(__m128i, __m128i);
__m128i _mm_subs_epu16(__m128i, __m128i);
__m128i _mm_subs_epu8(__m128i, __m128i);
int _mm_testc_si128(__m128i, __m128i);
int _mm_testnzc_si128(__m128i, __m128i);
int _mm_testz_si128(__m128i, __m128i);
int _mm_ucomieq_sd(__m128d, __m128d);
int _mm_ucomieq_ss(__m128, __m128);
int _mm_ucomige_sd(__m128d, __m128d);
int _mm_ucomige_ss(__m128, __m128);
int _mm_ucomigt_sd(__m128d, __m128d);
int _mm_ucomigt_ss(__m128, __m128);
int _mm_ucomile_sd(__m128d, __m128d);
int _mm_ucomile_ss(__m128, __m128);
int _mm_ucomilt_sd(__m128d, __m128d);
int _mm_ucomilt_ss(__m128, __m128);
int _mm_ucomineq_sd(__m128d, __m128d);
int _mm_ucomineq_ss(__m128, __m128);
__m128i _mm_unpackhi_epi16(__m128i, __m128i);
__m128i _mm_unpackhi_epi32(__m128i, __m128i);
__m128i _mm_unpackhi_epi64(__m128i, __m128i);
__m128i _mm_unpackhi_epi8(__m128i, __m128i);
__m128d _mm_unpackhi_pd(__m128d, __m128d);
__m128 _mm_unpackhi_ps(__m128, __m128);
__m128i _mm_unpacklo_epi16(__m128i, __m128i);
__m128i _mm_unpacklo_epi32(__m128i, __m128i);
__m128i _mm_unpacklo_epi64(__m128i, __m128i);
__m128i _mm_unpacklo_epi8(__m128i, __m128i);
__m128d _mm_unpacklo_pd(__m128d, __m128d);
__m128 _mm_unpacklo_ps(__m128, __m128);
__m128d _mm_xor_pd(__m128d, __m128d);
__m128 _mm_xor_ps(__m128, __m128);
__m128i _mm_xor_si128(__m128i, __m128i);

unsigned int __cdecl _rotl( unsigned int _Value, int _Shift);
unsigned short __cdecl _rotl16(unsigned short _Value, unsigned char _Shift);
unsigned __int64 __cdecl _rotl64( unsigned __int64 _Value, int _Shift);
unsigned char __cdecl _rotl8(unsigned char _Value, unsigned char _Shift);
unsigned int __cdecl _rotr( unsigned int _Value, int _Shift);
unsigned short __cdecl _rotr16(unsigned short _Value, unsigned char _Shift);
unsigned __int64 __cdecl _rotr64( unsigned __int64 _Value, int _Shift);
unsigned char __cdecl _rotr8(unsigned char _Value, unsigned char _Shift);
int __cdecl _setjmp(jmp_buf);


void _rsm(void);
void _lgdt(void *);
void _sgdt(void *);
void _clac(void);
void _stac(void);
unsigned char __cdecl _addcarry_u8(unsigned char, unsigned char, unsigned char, unsigned char *);
unsigned char __cdecl _subborrow_u8(unsigned char, unsigned char, unsigned char, unsigned char *);
unsigned char __cdecl _addcarry_u16(unsigned char, unsigned short, unsigned short, unsigned short *);
unsigned char __cdecl _subborrow_u16(unsigned char, unsigned short, unsigned short, unsigned short *);
unsigned char __cdecl _addcarry_u32(unsigned char, unsigned int, unsigned int, unsigned int *);
unsigned char __cdecl _subborrow_u32(unsigned char, unsigned int, unsigned int, unsigned int *);


void _mm_monitorx(void const *, unsigned int, unsigned int);
void _mm_mwaitx(unsigned int, unsigned int, unsigned int);


}
# 1151 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory0" 2 3
# 1168 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory0" 3
#pragma warning(pop)
#pragma pack(pop)
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory" 2 3


#pragma pack(push,8)
#pragma warning(push, 3)



#pragma warning(disable: 4700)

namespace std {

template<class _Ty> inline
 pair<_Ty *, ptrdiff_t>
  get_temporary_buffer(ptrdiff_t _Count) noexcept
 {
 _Ty *_Pbuf;

 if (_Count < 0)
  _Count = 0;
 else if (((size_t)(-1) / sizeof (_Ty) < _Count))
  _Xbad_alloc();
 for (_Pbuf = 0; 0 < _Count; _Count /= 2)
  if ((_Pbuf = (_Ty *)operator new(
   (size_t)_Count * sizeof (_Ty), nothrow)) != 0)
   break;

 return (pair<_Ty *, ptrdiff_t>(_Pbuf, _Count));
 }


template<class _Ty> inline
 void return_temporary_buffer(_Ty *_Pbuf)
 {
 operator delete(_Pbuf);
 }


template<class _InIt,
 class _FwdIt> inline
 _FwdIt _Uninitialized_copy_unchecked1(_InIt _First, _InIt _Last,
  _FwdIt _Dest, _General_ptr_iterator_tag)
 {
 _FwdIt _Next = _Dest;

 try {
 for (; _First != _Last; ++_Dest, (void)++_First)
  _Construct(_Unfancy(_Dest), *_First);
 } catch (...) {
 _Destroy_range(_Next, _Dest);
 throw;
 }

 return (_Dest);
 }

template<class _InIt,
 class _FwdIt> inline
 _FwdIt _Uninitialized_copy_unchecked1(_InIt _First, _InIt _Last,
  _FwdIt _Dest, _Really_trivial_ptr_iterator_tag)
 {
 return (_Copy_memmove(_First, _Last, _Dest));
 }

template<class _InIt,
 class _FwdIt> inline
 _FwdIt _Uninitialized_copy_unchecked(_InIt _First, _InIt _Last,
  _FwdIt _Dest)
 {
 return (_Uninitialized_copy_unchecked1(_First, _Last,
  _Dest, _Ptr_copy_cat(_First, _Dest)));
 }

template<class _InIt,
 class _FwdIt> inline
 _FwdIt _Uninitialized_copy1(_InIt _First, _InIt _Last,
  _FwdIt _Dest, input_iterator_tag, forward_iterator_tag)
 {
 return (_Rechecked(_Dest,
  _Uninitialized_copy_unchecked(_First, _Last, _Unchecked_idl0(_Dest))));
 }

template<class _InIt,
 class _FwdIt> inline
 _FwdIt _Uninitialized_copy1(_InIt _First, _InIt _Last,
  _FwdIt _Dest, random_access_iterator_tag, random_access_iterator_tag)
 {
                                         ;
 return (_Rechecked(_Dest,
  _Uninitialized_copy_unchecked(_First, _Last, _Unchecked(_Dest))));
 }

template<class _InIt,
 class _FwdIt> inline
 _FwdIt uninitialized_copy(_InIt _First, _InIt _Last,
  _FwdIt _Dest)
 {
 struct _Unchecked_iterators { static void _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
                                       ;
 return (_Uninitialized_copy1(_Unchecked(_First), _Unchecked(_Last),
  _Dest, _Iter_cat_t<_InIt>(), _Iter_cat_t<_FwdIt>()));
 }
# 122 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory" 3
template<class _InIt,
 class _Diff,
 class _FwdIt> inline
 _FwdIt _Uninitialized_copy_n_unchecked1(_InIt _First, _Diff _Count,
  _FwdIt _Dest, _General_ptr_iterator_tag)
 {
 _FwdIt _Next = _Dest;

 try {
 for (; 0 < _Count; --_Count, (void)++_Dest, ++_First)
  _Construct(_Unfancy(_Dest), *_First);
 } catch (...) {
 _Destroy_range(_Next, _Dest);
 throw;
 }

 return (_Dest);
 }

template<class _InIt,
 class _Diff,
 class _FwdIt> inline
 _FwdIt _Uninitialized_copy_n_unchecked1(_InIt _First, _Diff _Count,
  _FwdIt _Dest, _Really_trivial_ptr_iterator_tag)
 {
 if (0 < _Count)
  return (_Copy_memmove(_First, _First + _Count, _Dest));
 return (_Dest);
 }

template<class _InIt,
 class _Diff,
 class _FwdIt> inline
 _FwdIt _Uninitialized_copy_n_unchecked(_InIt _First, _Diff _Count,
  _FwdIt _Dest)
 {
 return (_Uninitialized_copy_n_unchecked1(_First, _Count,
  _Dest, _Ptr_copy_cat(_First, _Dest)));
 }

template<class _InIt,
 class _Diff,
 class _FwdIt> inline
 _FwdIt uninitialized_copy_n(_InIt _First, _Diff _Count,
  _FwdIt _Dest)
 {

 struct _Unchecked_iterators { static void _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
 return (_Rechecked(_Dest,
  _Uninitialized_copy_n_unchecked(_Unchecked_n(_First, _Count), _Count, _Unchecked_n(_Dest, _Count))));
 }
# 215 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory" 3
template<class _InIt,
 class _FwdIt,
 class _Alloc> inline
 _FwdIt _Uninitialized_copy_al_unchecked1(_InIt _First, _InIt _Last, _FwdIt _Dest,
  _Wrap_alloc<_Alloc>& _Al, _General_ptr_iterator_tag, _Any_tag)
 {
 _FwdIt _Next = _Dest;

 try {
 for (; _First != _Last; ++_Dest, (void)++_First)
  _Al.construct(_Unfancy(_Dest), *_First);
 } catch (...) {
 _Destroy_range(_Next, _Dest, _Al);
 throw;
 }

 return (_Dest);
 }

template<class _Ty1,
 class _Ty2,
 class _Alloc> inline
 _Ty2 *_Uninitialized_copy_al_unchecked1(_Ty1 *_First, _Ty1 *_Last, _Ty2 *_Dest,
  _Wrap_alloc<_Alloc>&, _Really_trivial_ptr_iterator_tag, true_type)
 {
 return (_Copy_memmove(_First, _Last, _Dest));
 }

template<class _InIt,
 class _FwdIt,
 class _Alloc> inline
 _FwdIt _Uninitialized_copy_al_unchecked(_InIt _First, _InIt _Last, _FwdIt _Dest,
  _Wrap_alloc<_Alloc>& _Al)
 {
 return (_Uninitialized_copy_al_unchecked1(_First, _Last, _Dest, _Al,
  _Ptr_copy_cat(_First, _Dest),
  _Uses_default_construct_t<_Alloc, decltype(_Unfancy(_Dest)), decltype(*_First)>()));
 }

template<class _InIt,
 class _FwdIt,
 class _Alloc> inline
 _FwdIt _Uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
  _Wrap_alloc<_Alloc>& _Al)
 {


 return (_Rechecked(_Dest,
  _Uninitialized_copy_al_unchecked(_Unchecked(_First), _Unchecked(_Last),
   _Unchecked(_Dest), _Al)));
 }


template<class _InIt,
 class _FwdIt,
 class _Alloc> inline
 _FwdIt _Uninitialized_move_al_unchecked1(_InIt _First, _InIt _Last, _FwdIt _Dest,
  _Wrap_alloc<_Alloc>& _Al, _General_ptr_iterator_tag, _Any_tag)
 {
 _FwdIt _Next = _Dest;

 try {
 for (; _First != _Last; ++_Dest, (void)++_First)
  _Al.construct(_Unfancy(_Dest), ::std:: move(*_First));
 } catch (...) {
 _Destroy_range(_Next, _Dest, _Al);
 throw;
 }

 return (_Dest);
 }

template<class _Ty1,
 class _Ty2,
 class _Alloc> inline
 _Ty2 *_Uninitialized_move_al_unchecked1(_Ty1 *_First, _Ty1 *_Last, _Ty2 *_Dest,
  _Wrap_alloc<_Alloc>&, _Really_trivial_ptr_iterator_tag, true_type)
 {
 return (_Copy_memmove(_First, _Last, _Dest));
 }

template<class _InIt,
 class _FwdIt,
 class _Alloc> inline
 _FwdIt _Uninitialized_move_al_unchecked(_InIt _First, _InIt _Last, _FwdIt _Dest,
  _Wrap_alloc<_Alloc>& _Al)
 {
 typedef decltype(::std:: move(*_First)) _Src_type;
 return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,
  _Ptr_move_cat(_First, _Dest),
  _Uses_default_construct_t<_Alloc, decltype(_Unfancy(_Dest)), _Src_type>()));
 }

template<class _InIt,
 class _FwdIt,
 class _Alloc> inline
 _FwdIt _Uninitialized_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
  _Wrap_alloc<_Alloc>& _Al)
 {


 return (_Rechecked(_Dest,
  _Uninitialized_move_al_unchecked(_Unchecked(_First), _Unchecked(_Last),
   _Unchecked(_Dest), _Al)));
 }


template<class _FwdIt,
 class _Tval> inline
 void _Uninitialized_fill_unchecked1(_FwdIt _First, _FwdIt _Last, const _Tval& _Val, false_type)
 {
 _FwdIt _Next = _First;

 try {
 for (; _First != _Last; ++_First)
  _Construct(_Unfancy(_First), _Val);
 } catch (...) {
 _Destroy_range(_Next, _First);
 throw;
 }
 }

template<class _FwdIt,
 class _Tval> inline
 void _Uninitialized_fill_unchecked1(_FwdIt _First, _FwdIt _Last, const _Tval& _Val, true_type)
 {
 :: memset(_First, _Val, _Last - _First);
 }

template<class _FwdIt,
 class _Tval> inline
 void _Uninitialized_fill_unchecked(_FwdIt _First, _FwdIt _Last, const _Tval& _Val)
 {
 _Uninitialized_fill_unchecked1(_First, _Last, _Val, _Fill_memset_is_safe(_First, _Val));
 }

template<class _FwdIt,
 class _Tval> inline
 void uninitialized_fill(_FwdIt _First, _FwdIt _Last, const _Tval& _Val)
 {
                            ;
 _Uninitialized_fill_unchecked(_Unchecked(_First), _Unchecked(_Last), _Val);
 }


template<class _FwdIt,
 class _Diff,
 class _Tval> inline
 _FwdIt _Uninitialized_fill_n_unchecked1(_FwdIt _First, _Diff _Count, const _Tval& _Val, false_type)
 {
 _FwdIt _Next = _First;

 try {
 for (; 0 < _Count; --_Count, (void)++_First)
  _Construct(_Unfancy(_First), _Val);
 } catch (...) {
 _Destroy_range(_Next, _First);
 throw;
 }

 return (_First);
 }

template<class _FwdIt,
 class _Diff,
 class _Tval> inline
 _FwdIt _Uninitialized_fill_n_unchecked1(_FwdIt _First, _Diff _Count, const _Tval& _Val, true_type)
 {
 if (0 < _Count)
  {
  :: memset(_First, _Val, _Count);
  return (_First + _Count);
  }

 return (_First);
 }

template<class _FwdIt,
 class _Diff,
 class _Tval> inline
 _FwdIt _Uninitialized_fill_n_unchecked(_FwdIt _First, _Diff _Count, const _Tval& _Val)
 {
 return (_Uninitialized_fill_n_unchecked1(_First, _Count, _Val, _Fill_memset_is_safe(_First, _Val)));
 }

template<class _FwdIt,
 class _Diff,
 class _Tval> inline
 _FwdIt uninitialized_fill_n(_FwdIt _First, _Diff _Count,
  const _Tval& _Val)
 {
 return (_Rechecked(_First,
  _Uninitialized_fill_n_unchecked(_Unchecked_n(_First, _Count), _Count, _Val)));
 }


template<class _FwdIt,
 class _Diff,
 class _Alloc> inline
 void _Uninit_alloc_fill_n1(_FwdIt _First, _Diff _Count, const _Iter_value_t<_FwdIt> * _Pval,
  _Wrap_alloc<_Alloc>& _Al, false_type)
 {
 _FwdIt _Next = _First;

 try {
 for (; 0 < _Count; --_Count, (void)++_First)
  _Al.construct(_Unfancy(_First), *_Pval);
 } catch (...) {
 _Destroy_range(_Next, _First, _Al);
 throw;
 }
 }

template<class _FwdIt,
 class _Diff,
 class _Alloc> inline
 void _Uninit_alloc_fill_n1(_FwdIt _First, _Diff _Count, const _Iter_value_t<_FwdIt> * _Pval,
  _Wrap_alloc<_Alloc>&, true_type)
 {
 :: memset(_First, *_Pval, _Count);
 }

template<class _FwdIt,
 class _Diff,
 class _Alloc> inline
 void _Uninitialized_fill_n(_FwdIt _First, _Diff _Count,
  const _Iter_value_t<_FwdIt> * _Pval, _Wrap_alloc<_Alloc>& _Al)
 {
 _Uninit_alloc_fill_n1(_First, _Count, _Pval, _Al,
  typename conjunction<decltype(_Fill_memset_is_safe(_First, *_Pval)),
   _Uses_default_construct<_Alloc, decltype(_Unfancy(_First)), decltype(*_Pval)>>::type());
 }

template<class _FwdIt,
 class _Diff,
 class _Alloc> inline
 void _Uninitialized_default_fill_n1(_FwdIt _First, _Diff _Count,
  _Wrap_alloc<_Alloc>& _Al, false_type)
 {
 _FwdIt _Next = _First;

 try {
 for (; 0 < _Count; --_Count, (void)++_First)
  _Al.construct(_Unfancy(_First));
 } catch (...) {
 _Destroy_range(_Next, _First, _Al);
 throw;
 }
 }

template<class _FwdIt,
 class _Diff,
 class _Alloc> inline
 void _Uninitialized_default_fill_n1(_FwdIt _First, _Diff _Count,
  _Wrap_alloc<_Alloc>&, true_type)
 {
 :: memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));
 }

template<class _FwdIt,
 class _Diff,
 class _Alloc> inline
 void _Uninitialized_default_fill_n(_FwdIt _First, _Diff _Count,
  _Wrap_alloc<_Alloc>& _Al)
 {
 typedef _Iter_value_t<_FwdIt> _Ty;
 _Uninitialized_default_fill_n1(_First, _Count, _Al,
  typename conjunction<
   is_pointer<_FwdIt>,
   is_scalar<_Ty>,
   negation<is_volatile<_Ty>>,
   negation<is_member_pointer<_Ty>>,
   _Uses_default_construct<_Alloc, decltype(_Unfancy(_First))>>::type());
 }


template<class _OutIt,
 class _Ty>
 class raw_storage_iterator
  : public _Outit
 {
public:
 explicit raw_storage_iterator(_OutIt _First)
  : _Next(_First)
  {
  }

 raw_storage_iterator& operator*()
  {
  return (*this);
  }

 raw_storage_iterator& operator=(const _Ty& _Val)
  {
  _Construct(_Unfancy(_Next), _Val);
  return (*this);
  }

 raw_storage_iterator& operator=(_Ty&& _Val)
  {
  _Construct(_Unfancy(_Next), ::std:: move(_Val));
  return (*this);
  }

 raw_storage_iterator& operator++()
  {
  ++_Next;
  return (*this);
  }

 raw_storage_iterator operator++(int)
  {
  raw_storage_iterator _Ans = *this;
  ++_Next;
  return (_Ans);
  }

 _OutIt base() const
  {
  return (_Next);
  }

private:
 _OutIt _Next;
 };


template<class _Ty>
 class _Temp_iterator
  : public _Outit
 {
public:
 typedef _Ty *_Pty;

 _Temp_iterator(ptrdiff_t _Count = 0)
  {
  _Buf._Begin = 0;
  _Buf._Current = 0;
  _Buf._Hiwater = 0;
  _Buf._Size = _Count;
  _Pbuf = &_Buf;
  }

 _Temp_iterator(const _Temp_iterator& _Right)
  {
  _Buf._Begin = 0;
  _Buf._Current = 0;
  _Buf._Hiwater = 0;
  _Buf._Size = 0;
  *this = _Right;
  }

 ~_Temp_iterator() noexcept
  {
  if (_Buf._Begin != 0)
   {
   for (_Pty _Next = _Buf._Begin;
    _Next != _Buf._Hiwater; ++_Next)
    _Destroy(_Next);
   ::std:: return_temporary_buffer(_Buf._Begin);
   }
  }

 _Temp_iterator& operator=(const _Temp_iterator& _Right)
  {
  _Pbuf = _Right._Pbuf;
  return (*this);
  }

 _Temp_iterator& operator=(const _Ty& _Val)
  {
  if (_Pbuf->_Current < _Pbuf->_Hiwater)
   *_Pbuf->_Current++ = _Val;
  else
   {
   _Pty _Ptr = _Pbuf->_Current;
   _Construct(_Ptr, _Val);
   _Pbuf->_Hiwater = ++_Pbuf->_Current;
   }

  return (*this);
  }

 _Temp_iterator& operator=(_Ty&& _Val)
  {
  if (_Pbuf->_Current < _Pbuf->_Hiwater)
   *_Pbuf->_Current++ =
    ::std:: forward<_Ty>(_Val);
  else
   {
   _Pty _Ptr = _Pbuf->_Current;
   _Construct(_Ptr, ::std:: forward<_Ty>(_Val));
   _Pbuf->_Hiwater = ++_Pbuf->_Current;
   }

  return (*this);
  }

 _Temp_iterator& operator*()
  {
  return (*this);
  }

 _Temp_iterator& operator++()
  {
  return (*this);
  }

 _Temp_iterator& operator++(int)
  {
  return (*this);
  }

 _Temp_iterator& _Init()
  {
  _Pbuf->_Current = _Pbuf->_Begin;
  return (*this);
  }

 _Pty _First() const
  {
  return (_Pbuf->_Begin);
  }

 _Pty _Last() const
  {
  return (_Pbuf->_Current);
  }

 ptrdiff_t _Maxlen()
  {
  if (_Pbuf->_Begin == 0 && 0 < _Pbuf->_Size)
   {
   pair<_Pty, ptrdiff_t> _Pair =

    ::std:: get_temporary_buffer<_Ty>(_Pbuf->_Size);

   _Pbuf->_Begin = _Pair.first;
   _Pbuf->_Current = _Pair.first;
   _Pbuf->_Hiwater = _Pair.first;
   _Pbuf->_Size = _Pair.second;
   }

  return (_Pbuf->_Size);
  }

private:
 struct _Bufpar
  {
  _Pty _Begin;
  _Pty _Current;
  _Pty _Hiwater;
  ptrdiff_t _Size;
  };
 _Bufpar _Buf;
 _Bufpar *_Pbuf;
 };



template<class _Ty>
 class auto_ptr;

template<class _Ty>
 struct auto_ptr_ref
  {
 explicit auto_ptr_ref(_Ty *_Right)
  : _Ref(_Right)
  {
  }

 _Ty *_Ref;
 };

template<class _Ty>
 class auto_ptr
  {
public:
 typedef auto_ptr<_Ty> _Myt;
 typedef _Ty element_type;

 explicit auto_ptr(_Ty *_Ptr = 0) noexcept
  : _Myptr(_Ptr)
  {
  }

 auto_ptr(_Myt& _Right) noexcept
  : _Myptr(_Right.release())
  {
  }

 auto_ptr(auto_ptr_ref<_Ty> _Right) noexcept
  {
  _Ty *_Ptr = _Right._Ref;
  _Right._Ref = 0;
  _Myptr = _Ptr;
  }

 template<class _Other>
  operator auto_ptr<_Other>() noexcept
  {
  return (auto_ptr<_Other>(*this));
  }

 template<class _Other>
  operator auto_ptr_ref<_Other>() noexcept
  {
  _Other *_Cvtptr = _Myptr;
  auto_ptr_ref<_Other> _Ans(_Cvtptr);
  _Myptr = 0;
  return (_Ans);
  }

 template<class _Other>
  _Myt& operator=(auto_ptr<_Other>& _Right) noexcept
  {
  reset(_Right.release());
  return (*this);
  }

 template<class _Other>
  auto_ptr(auto_ptr<_Other>& _Right) noexcept
  : _Myptr(_Right.release())
  {
  }

 _Myt& operator=(_Myt& _Right) noexcept
  {
  reset(_Right.release());
  return (*this);
  }

 _Myt& operator=(auto_ptr_ref<_Ty> _Right) noexcept
  {
  _Ty *_Ptr = _Right._Ref;
  _Right._Ref = 0;
  reset(_Ptr);
  return (*this);
  }

 ~auto_ptr() noexcept
  {
  delete _Myptr;
  }

 _Ty& operator*() const noexcept
  {





  return (*get());
  }

 _Ty *operator->() const noexcept
  {





  return (get());
  }

 _Ty *get() const noexcept
  {
  return (_Myptr);
  }

 _Ty *release() noexcept
  {
  _Ty *_Tmp = _Myptr;
  _Myptr = 0;
  return (_Tmp);
  }

 void reset(_Ty *_Ptr = 0)
  {
  if (_Ptr != _Myptr)
   delete _Myptr;
  _Myptr = _Ptr;
  }

private:
 _Ty *_Myptr;
 };

}


#pragma warning(pop)
#pragma pack(pop)
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\memory" 2 3







# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\typeinfo" 1 3
# 23 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\typeinfo" 3
#pragma pack(push,8)
#pragma warning(push, 3)


#pragma warning(disable: 4275)


# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime_typeinfo.h" 1 3
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime_typeinfo.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime.h" 1 3
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime_typeinfo.h" 2 3



#pragma pack(push, 8)







 struct __type_info_node;





    extern __type_info_node __type_info_root_node;




#pragma pack(push, 8)
# 32 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime_typeinfo.h" 3
 extern "C" {


#pragma warning(push)
#pragma warning(disable: 4510 4512 4610)
struct __std_type_info_data
{
    char const* _UndecoratedName;
    char const _DecoratedName[1];
};
#pragma warning(pop)

 int __cdecl __std_type_info_compare(
         __std_type_info_data const* _Lhs,
         __std_type_info_data const* _Rhs
    );

         size_t __cdecl __std_type_info_hash(
         __std_type_info_data const* _Data
    );

         char const* __cdecl __std_type_info_name(
            __std_type_info_data* _Data,
            __type_info_node* _RootNode
    );

}
# 58 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime_typeinfo.h" 3
#pragma pack(pop)



class type_info
{
public:

    type_info(type_info const&) = delete;
    type_info& operator=(type_info const&) = delete;

    size_t hash_code() const throw()
    {
        return __std_type_info_hash(&_Data);
    }

    bool operator==(type_info const& _Other) const throw()
    {
        return __std_type_info_compare(&_Data, &_Other._Data) == 0;
    }

    bool operator!=(type_info const& _Other) const throw()
    {
        return __std_type_info_compare(&_Data, &_Other._Data) != 0;
    }

    bool before(type_info const& _Other) const throw()
    {
        return __std_type_info_compare(&_Data, &_Other._Data) < 0;
    }

    char const* name() const throw()
    {



        return __std_type_info_name(&_Data, &__type_info_root_node);

    }

    char const* raw_name() const throw()
    {
        return _Data._DecoratedName;
    }

    virtual ~type_info() throw();

private:

    mutable __std_type_info_data _Data;
};

namespace std {
 using ::type_info;
}



namespace std {

class bad_cast
    : public exception
{
public:

    bad_cast() throw()
        : exception("bad cast", 1)
    {
    }

    static bad_cast __construct_from_string_literal(char const* const _Message) throw()
    {
        return bad_cast(_Message, 1);
    }

private:

    bad_cast(char const* const _Message, int) throw()
        : exception(_Message, 1)
    {
    }
};

class bad_typeid
    : public exception
{
public:

    bad_typeid() throw()
        : exception("bad typeid", 1)
    {
    }

    static bad_typeid __construct_from_string_literal(char const* const _Message) throw()
    {
        return bad_typeid(_Message, 1);
    }

private:

    friend class __non_rtti_object;

    bad_typeid(char const* const _Message, int) throw()
        : exception(_Message, 1)
    {
    }
};

class __non_rtti_object
    : public bad_typeid
{
public:

    static __non_rtti_object __construct_from_string_literal(char const* const _Message) throw()
    {
        return __non_rtti_object(_Message, 1);
    }

private:

    __non_rtti_object(char const* const _Message, int) throw()
        : bad_typeid(_Message, 1)
    {
    }
};

}



#pragma pack(pop)
# 29 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\typeinfo" 2 3
# 90 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\typeinfo" 3
#pragma pack(pop)
#pragma warning(pop)
# 13 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\memory" 2 3



#pragma pack(push,8)
#pragma warning(push, 3)



#pragma warning(disable: 28197)

namespace std {
template<class _Ty>
 struct default_delete;

template<class _Ty,
 class _Dx = default_delete<_Ty> >
 class unique_ptr;


class bad_weak_ptr
 : public ::std:: exception
 {
public:
 bad_weak_ptr() noexcept
  {
  }

 virtual const char * what() const throw()
  {
  return ("bad_weak_ptr");
  }
 };


class _Ref_count_base
 {
private:
 virtual void _Destroy() noexcept = 0;
 virtual void _Delete_this() noexcept = 0;

private:
 _Atomic_counter_t _Uses;
 _Atomic_counter_t _Weaks;

protected:
 _Ref_count_base()
  {
  _Init_atomic_counter(_Uses, 1);
  _Init_atomic_counter(_Weaks, 1);
  }

public:
 virtual ~_Ref_count_base() noexcept
  {
  }

 bool _Incref_nz()
  {
  for (; ; )
   {

   _Atomic_integral_t _Count =
    static_cast<volatile _Atomic_counter_t&>(_Uses);

   if (_Count == 0)
    return (false);

   if (static_cast<_Atomic_integral_t>(_InterlockedCompareExchange(
     reinterpret_cast<volatile long *>(&_Uses),
     _Count + 1, _Count)) == _Count)
    return (true);
# 95 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\memory" 3
   }
  }

 void _Incref()
  {
  _InterlockedIncrement(reinterpret_cast<volatile long *>(&_Uses));
  }

 void _Incwref()
  {
  _InterlockedIncrement(reinterpret_cast<volatile long *>(&_Weaks));
  }

 void _Decref()
  {
  if (_InterlockedDecrement(reinterpret_cast<volatile long *>(&_Uses)) == 0)
   {
   _Destroy();
   _Decwref();
   }
  }

 void _Decwref()
  {
  if (_InterlockedDecrement(reinterpret_cast<volatile long *>(&_Weaks)) == 0)
   _Delete_this();
  }

 long _Use_count() const noexcept
  {
  return (_Get_atomic_count(_Uses));
  }

 bool _Expired() const noexcept
  {
  return (_Use_count() == 0);
  }

 virtual void *_Get_deleter(const type_info&) const noexcept
  {
  return (0);
  }
 };


template<class _Ty>
 class _Ref_count
 : public _Ref_count_base
 {
public:
 _Ref_count(_Ty *_Px)
  : _Ref_count_base(), _Ptr(_Px)
  {
  }

private:
 virtual void _Destroy() noexcept
  {
  delete _Ptr;
  }

 virtual void _Delete_this() noexcept
  {
  delete this;
  }

 _Ty * _Ptr;
 };


template<class _Ty,
 class _Dx>
 class _Ref_count_del
 : public _Ref_count_base
 {
public:
 _Ref_count_del(_Ty *_Px, _Dx _Dt)
  : _Ref_count_base(), _Mypair(_One_then_variadic_args_t(), _Dt, _Px)
  {
  }

 virtual void *_Get_deleter(
  const type_info& _Typeid) const noexcept
  {
  return ((void *)(_Typeid == typeid(_Dx)
   ? ::std:: addressof(_Mypair._Get_first()) : 0));
  }

private:
 virtual void _Destroy() noexcept
  {
  _Mypair._Get_first()(_Mypair._Get_second());
  }

 virtual void _Delete_this() noexcept
  {
  delete this;
  }

 _Compressed_pair<_Dx, _Ty *> _Mypair;
 };


template<class _Ty,
 class _Dx,
 class _Alloc>
 class _Ref_count_del_alloc
 : public _Ref_count_base
 {
public:
 typedef _Ref_count_del_alloc<_Ty, _Dx, _Alloc> _Myt;
 typedef _Wrap_alloc<_Alloc> _Myalty0;
 typedef typename _Myalty0::template rebind<_Myt>::other _Myalty;

 _Ref_count_del_alloc(_Ty *_Px, _Dx _Dt, const _Alloc& _Ax)
  : _Ref_count_base(), _Mypair(_One_then_variadic_args_t(), _Dt,
   _One_then_variadic_args_t(), _Ax, _Px)
  {
  }

 virtual void *_Get_deleter(
  const type_info& _Typeid) const noexcept
  {
  return ((void *)(_Typeid == typeid(_Dx)
   ? ::std:: addressof(_Mypair._Get_first()) : 0));
  }

private:
 virtual void _Destroy() noexcept
  {
  _Mypair._Get_first()(_Mypair._Get_second()._Get_second());
  }

 virtual void _Delete_this() noexcept
  {
  _Myalty _Al = _Mypair._Get_second()._Get_first();
  _Al.destroy(this);
  _Al.deallocate(this, 1);
  }

 _Compressed_pair<_Dx, _Compressed_pair<_Myalty, _Ty *> > _Mypair;
 };


template<class _Ty>
 class weak_ptr;
template<class _Ty>
 class shared_ptr;
template<class _Ty>
 class enable_shared_from_this;

template<class _Ty1,
 class _Ty2>
 void _Do_enable(_Ty1 *, enable_shared_from_this<_Ty2> *,
  _Ref_count_base *);

template<class _Ty>
 inline void _Enable_shared(_Ty *_Ptr, _Ref_count_base *_Refptr,
  typename _Ty::_EStype * = 0)
 {
 if (_Ptr)
  _Do_enable(_Ptr,
   (enable_shared_from_this<typename _Ty::_EStype>*)_Ptr, _Refptr);
 }

inline void _Enable_shared(const volatile void *, const volatile void *)
 {
 }


template<class _Ty>
 class _Ptr_base
 {
public:
 typedef _Ptr_base<_Ty> _Myt;
 typedef _Ty element_type;

 constexpr _Ptr_base() noexcept
  : _Ptr(0), _Rep(0)
  {
  }

 _Ptr_base(_Myt&& _Right)
  : _Ptr(_Right._Ptr), _Rep(_Right._Rep)
  {
  _Right._Ptr = 0;
  _Right._Rep = 0;
  }

 template<class _Ty2>
  _Ptr_base(_Ptr_base<_Ty2>&& _Right)
  : _Ptr(_Right._Ptr), _Rep(_Right._Rep)
  {
  _Right._Ptr = 0;
  _Right._Rep = 0;
  }

 _Myt& operator=(_Myt&& _Right)
  {
  _Assign_rv(::std:: move(_Right));
  return (*this);
  }

 void _Assign_rv(_Myt&& _Right)
  {
  _Swap(_Right);
  }

 long use_count() const noexcept
  {
  return (_Rep ? _Rep->_Use_count() : 0);
  }

 void _Swap(_Ptr_base& _Right) noexcept
  {
  ::std:: swap(_Rep, _Right._Rep);
  ::std:: swap(_Ptr, _Right._Ptr);
  }

 template<class _Ty2>
  bool owner_before(const _Ptr_base<_Ty2>& _Right) const
  {
  return (_Rep < _Right._Rep);
  }

 void *_Get_deleter(const type_info& _Typeid) const noexcept
  {
  return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
  }

 _Ty *_Get() const noexcept
  {
  return (_Ptr);
  }

 bool _Expired() const noexcept
  {
  return (!_Rep || _Rep->_Expired());
  }

 void _Decref()
  {
  if (_Rep != 0)
   _Rep->_Decref();
  }

 void _Reset()
  {
  _Reset(0, 0);
  }

 template<class _Ty2>
  void _Reset(const _Ptr_base<_Ty2>& _Other)
  {
  _Reset(_Other._Ptr, _Other._Rep);
  }

 template<class _Ty2>
  void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
  {
  _Reset(_Other._Ptr, _Other._Rep, _Throw);
  }


 template<class _Ty2>
  void _Reset(auto_ptr<_Ty2>&& _Other)
  {
  _Ty2 *_Px = _Other.get();
  _Reset0(_Px, new _Ref_count<_Ty>(_Px));
  _Other.release();
  _Enable_shared(_Px, _Rep);
  }


 template<class _Ty2>
  void _Reset(_Ty *_Other_ptr, const _Ptr_base<_Ty2>& _Other)
  {
  _Reset(_Other_ptr, _Other._Rep);
  }

 void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
  {
  if (_Other_rep)
   _Other_rep->_Incref();
  _Reset0(_Other_ptr, _Other_rep);
  }

 void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
  {


  if (_Other_rep && _Other_rep->_Incref_nz())
   _Reset0(_Other_ptr, _Other_rep);
  else if (_Throw)
   throw bad_weak_ptr();
  }

 void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
  {
  if (_Rep != 0)
   _Rep->_Decref();
  _Rep = _Other_rep;
  _Ptr = _Other_ptr;
  }

 void _Decwref()
  {
  if (_Rep != 0)
   _Rep->_Decwref();
  }

 void _Resetw()
  {
  _Resetw((_Ty *)0, 0);
  }

 template<class _Ty2>
  void _Resetw(const _Ptr_base<_Ty2>& _Other)
  {
  _Resetw(_Other._Ptr, _Other._Rep);
  }

 template<class _Ty2>
  void _Resetw(_Ty2 *_Other_ptr, _Ref_count_base *_Other_rep)
  {
  if (_Other_rep)
   _Other_rep->_Incwref();
  if (_Rep != 0)
   _Rep->_Decwref();
  _Rep = _Other_rep;
  _Ptr = const_cast<remove_cv_t<_Ty2> *>(_Other_ptr);
  }

private:
 _Ty *_Ptr;
 _Ref_count_base *_Rep;
 template<class _Ty0>
  friend class _Ptr_base;
 };


template<class _Ty>
 class shared_ptr
  : public _Ptr_base<_Ty>
 {
public:
 typedef shared_ptr<_Ty> _Myt;
 typedef _Ptr_base<_Ty> _Mybase;

 constexpr shared_ptr() noexcept
  {
  }

 template<class _Ux>
  explicit shared_ptr(_Ux *_Px)
  {
  _Resetp(_Px);
  }

 template<class _Ux,
  class _Dx>
  shared_ptr(_Ux *_Px, _Dx _Dt)
  {
  _Resetp(_Px, _Dt);
  }

 constexpr shared_ptr(nullptr_t) noexcept
  {
  }

 template<class _Dx>
  shared_ptr(nullptr_t, _Dx _Dt)
  {
  _Resetp((_Ty *)0, _Dt);
  }

 template<class _Dx,
  class _Alloc>
  shared_ptr(nullptr_t, _Dx _Dt, _Alloc _Ax)
  {
  _Resetp((_Ty *)0, _Dt, _Ax);
  }

 template<class _Ux,
  class _Dx,
  class _Alloc>
  shared_ptr(_Ux *_Px, _Dx _Dt, _Alloc _Ax)
  {
  _Resetp(_Px, _Dt, _Ax);
  }

 template<class _Ty2>
  shared_ptr(const shared_ptr<_Ty2>& _Right, _Ty *_Px) noexcept
  {
  this->_Reset(_Px, _Right);
  }

 shared_ptr(const _Myt& _Other) noexcept
  {
  this->_Reset(_Other);
  }

 template<class _Ty2,
  class = typename enable_if<is_convertible<_Ty2 *, _Ty *>::value,
   void>::type>
  shared_ptr(const shared_ptr<_Ty2>& _Other) noexcept
  {
  this->_Reset(_Other);
  }

 template<class _Ty2>
  explicit shared_ptr(const weak_ptr<_Ty2>& _Other,
   bool _Throw = true)
  {
  this->_Reset(_Other, _Throw);
  }


 template<class _Ty2>
  shared_ptr(auto_ptr<_Ty2>&& _Other)
  {
  this->_Reset(::std:: move(_Other));
  }


 shared_ptr(_Myt&& _Right) noexcept
  : _Mybase(::std:: move(_Right))
  {
  }

 template<class _Ty2,
  class = typename enable_if<is_convertible<_Ty2 *, _Ty *>::value,
   void>::type>
  shared_ptr(shared_ptr<_Ty2>&& _Right) noexcept
  : _Mybase(::std:: move(_Right))
  {
  }


 template<class _Ux,
  class _Dx,
  class = typename enable_if<is_convertible<
   typename unique_ptr<_Ux, _Dx>::pointer, _Ty *>::value,
   void>::type>
  shared_ptr(unique_ptr<_Ux, _Dx>&& _Right)
  {
  _Resetp(_Right.release(), _Right.get_deleter());
  }

 template<class _Ux,
  class _Dx>
  _Myt& operator=(unique_ptr<_Ux, _Dx>&& _Right)
  {
  shared_ptr(::std:: move(_Right)).swap(*this);
  return (*this);
  }

 _Myt& operator=(_Myt&& _Right) noexcept
  {
  shared_ptr(::std:: move(_Right)).swap(*this);
  return (*this);
  }

 template<class _Ty2>
  _Myt& operator=(shared_ptr<_Ty2>&& _Right) noexcept
  {
  shared_ptr(::std:: move(_Right)).swap(*this);
  return (*this);
  }

 ~shared_ptr() noexcept
  {
  this->_Decref();
  }

 _Myt& operator=(const _Myt& _Right) noexcept
  {
  shared_ptr(_Right).swap(*this);
  return (*this);
  }

 template<class _Ty2>
  _Myt& operator=(const shared_ptr<_Ty2>& _Right) noexcept
  {
  shared_ptr(_Right).swap(*this);
  return (*this);
  }


 template<class _Ty2>
  _Myt& operator=(auto_ptr<_Ty2>&& _Right)
  {
  shared_ptr(::std:: move(_Right)).swap(*this);
  return (*this);
  }


 void reset() noexcept
  {
  shared_ptr().swap(*this);
  }

 template<class _Ux>
  void reset(_Ux *_Px)
  {
  shared_ptr(_Px).swap(*this);
  }

 template<class _Ux,
  class _Dx>
  void reset(_Ux *_Px, _Dx _Dt)
  {
  shared_ptr(_Px, _Dt).swap(*this);
  }

 template<class _Ux,
  class _Dx,
  class _Alloc>
  void reset(_Ux *_Px, _Dx _Dt, _Alloc _Ax)
  {
  shared_ptr(_Px, _Dt, _Ax).swap(*this);
  }

 void swap(_Myt& _Other) noexcept
  {
  this->_Swap(_Other);
  }

 _Ty *get() const noexcept
  {
  return (this->_Get());
  }

 typename add_lvalue_reference<_Ty>::type operator*() const noexcept
  {
  return (*this->_Get());
  }

 _Ty *operator->() const noexcept
  {
  return (this->_Get());
  }

 bool unique() const noexcept
  {
  return (this->use_count() == 1);
  }

 explicit operator bool() const noexcept
  {
  return (this->_Get() != 0);
  }

private:
 template<class _Ux>
  void _Resetp(_Ux *_Px)
  {
  try {
  _Resetp0(_Px, new _Ref_count<_Ux>(_Px));
  } catch (...) {
  delete _Px;
  throw;
  }
  }

 template<class _Ux,
  class _Dx>
  void _Resetp(_Ux *_Px, _Dx _Dt)
  {
  try {
  _Resetp0(_Px, new _Ref_count_del<_Ux, _Dx>(_Px, _Dt));
  } catch (...) {
  _Dt(_Px);
  throw;
  }
  }

 template<class _Ux,
  class _Dx,
  class _Alloc>
  void _Resetp(_Ux *_Px, _Dx _Dt, _Alloc _Ax)
  {
  typedef _Ref_count_del_alloc<_Ux, _Dx, _Alloc> _Refd;
  typedef _Wrap_alloc<_Alloc> _Alref0;
  typename _Alref0::template rebind<_Refd>::other _Alref(_Ax);

  try {
  _Refd *_Pref = _Alref.allocate(1);
  _Alref.construct(_Pref, _Px, _Dt, _Ax);
  _Resetp0(_Px, _Pref);
  } catch (...) {
  _Dt(_Px);
  throw;
  }
  }

public:
 template<class _Ux>
  void _Resetp0(_Ux *_Px, _Ref_count_base *_Rx)
  {
  this->_Reset0(_Px, _Rx);
  _Enable_shared(_Px, _Rx);
  }
 };

template<class _Ty1,
 class _Ty2>
 bool operator==(const shared_ptr<_Ty1>& _Left,
  const shared_ptr<_Ty2>& _Right) noexcept
 {
 return (_Left.get() == _Right.get());
 }

template<class _Ty1,
 class _Ty2>
 bool operator!=(const shared_ptr<_Ty1>& _Left,
  const shared_ptr<_Ty2>& _Right) noexcept
 {
 return (!(_Left == _Right));
 }

template<class _Ty1,
 class _Ty2>
 bool operator<(const shared_ptr<_Ty1>& _Left,
  const shared_ptr<_Ty2>& _Right) noexcept
 {
 return (less<decltype(_Always_false<_Ty1>::value
  ? _Left.get() : _Right.get())>()(
   _Left.get(), _Right.get()));
 }

template<class _Ty1,
 class _Ty2>
 bool operator>=(const shared_ptr<_Ty1>& _Left,
  const shared_ptr<_Ty2>& _Right) noexcept
 {
 return (!(_Left < _Right));
 }

template<class _Ty1,
 class _Ty2>
 bool operator>(const shared_ptr<_Ty1>& _Left,
  const shared_ptr<_Ty2>& _Right) noexcept
 {
 return (_Right < _Left);
 }

template<class _Ty1,
 class _Ty2>
 bool operator<=(const shared_ptr<_Ty1>& _Left,
  const shared_ptr<_Ty2>& _Right) noexcept
 {
 return (!(_Right < _Left));
 }

template<class _Ty>
 bool operator==(const shared_ptr<_Ty>& _Left,
  nullptr_t) noexcept
 {
 return (_Left.get() == (_Ty *)0);
 }

template<class _Ty>
 bool operator==(nullptr_t,
  const shared_ptr<_Ty>& _Right) noexcept
 {
 return ((_Ty *)0 == _Right.get());
 }

template<class _Ty>
 bool operator!=(const shared_ptr<_Ty>& _Left,
  nullptr_t _Right) noexcept
 {
 return (!(_Left == _Right));
 }

template<class _Ty>
 bool operator!=(nullptr_t _Left,
  const shared_ptr<_Ty>& _Right) noexcept
 {
 return (!(_Left == _Right));
 }

template<class _Ty>
 bool operator<(const shared_ptr<_Ty>& _Left,
  nullptr_t _Right) noexcept
 {
 return (less<_Ty *>()(_Left.get(), (_Ty *)0));
 }

template<class _Ty>
 bool operator<(nullptr_t _Left,
  const shared_ptr<_Ty>& _Right) noexcept
 {
 return (less<_Ty *>()((_Ty *)0, _Right.get()));
 }

template<class _Ty>
 bool operator>=(const shared_ptr<_Ty>& _Left,
  nullptr_t _Right) noexcept
 {
 return (!(_Left < _Right));
 }

template<class _Ty>
 bool operator>=(nullptr_t _Left,
  const shared_ptr<_Ty>& _Right) noexcept
 {
 return (!(_Left < _Right));
 }

template<class _Ty>
 bool operator>(const shared_ptr<_Ty>& _Left,
  nullptr_t _Right) noexcept
 {
 return (_Right < _Left);
 }

template<class _Ty>
 bool operator>(nullptr_t _Left,
  const shared_ptr<_Ty>& _Right) noexcept
 {
 return (_Right < _Left);
 }

template<class _Ty>
 bool operator<=(const shared_ptr<_Ty>& _Left,
  nullptr_t _Right) noexcept
 {
 return (!(_Right < _Left));
 }

template<class _Ty>
 bool operator<=(nullptr_t _Left,
  const shared_ptr<_Ty>& _Right) noexcept
 {
 return (!(_Right < _Left));
 }

template<class _Elem,
 class _Traits,
 class _Ty>
 basic_ostream<_Elem, _Traits>&
 operator<<(basic_ostream<_Elem, _Traits>& _Out,
  const shared_ptr<_Ty>& _Px)
 {
 return (_Out << _Px.get());
 }

template<class _Ty>
 void swap(shared_ptr<_Ty>& _Left,
  shared_ptr<_Ty>& _Right) noexcept
 {
 _Left.swap(_Right);
 }

template<class _Ty1,
 class _Ty2>
 shared_ptr<_Ty1>
  static_pointer_cast(const shared_ptr<_Ty2>& _Other) noexcept
 {
 typedef typename shared_ptr<_Ty1>::element_type _Elem1;
 _Elem1 *_Ptr = static_cast<_Elem1 *>(_Other.get());
 return (shared_ptr<_Ty1>(_Other, _Ptr));
 }

template<class _Ty1,
 class _Ty2>
 shared_ptr<_Ty1>
  const_pointer_cast(const shared_ptr<_Ty2>& _Other) noexcept
 {
 typedef typename shared_ptr<_Ty1>::element_type _Elem1;
 _Elem1 *_Ptr = const_cast<_Elem1 *>(_Other.get());
 return (shared_ptr<_Ty1>(_Other, _Ptr));
 }

template<class _Ty1,
 class _Ty2>
 shared_ptr<_Ty1>
  dynamic_pointer_cast(const shared_ptr<_Ty2>& _Other) noexcept
 {
 typedef typename shared_ptr<_Ty1>::element_type _Elem1;
 _Elem1 *_Ptr = dynamic_cast<_Elem1 *>(_Other.get());
 if (_Ptr)
  return (shared_ptr<_Ty1>(_Other, _Ptr));
 else
  return (shared_ptr<_Ty1>());
 }

template<class _Dx,
 class _Ty>
 _Dx *get_deleter(const shared_ptr<_Ty>& _Sx) noexcept
 {
 return ((_Dx *)_Sx._Get_deleter(typeid(_Dx)));
 }


template<class _Ty>
 class _Ref_count_obj
 : public _Ref_count_base
 {
public:
 template<class... _Types>
  _Ref_count_obj(_Types&&... _Args)
  : _Ref_count_base()
  {
  ::new ((void *)&_Storage) _Ty(::std:: forward<_Types>(_Args)...);
  }


 _Ty *_Getptr() const
  {
  return ((_Ty *)&_Storage);
  }

private:
 virtual void _Destroy() noexcept
  {
  _Getptr()->~_Ty();
  }

 virtual void _Delete_this() noexcept
  {
  delete this;
  }

 typename aligned_union<1, _Ty>::type _Storage;
 };


template<class _Ty,
 class _Alloc>
 class _Ref_count_obj_alloc
 : public _Ref_count_base
 {
public:
 typedef _Ref_count_obj_alloc<_Ty, _Alloc> _Myt;
 typedef _Wrap_alloc<_Alloc> _Myalty0;
 typedef typename _Myalty0::template rebind<_Myt>::other _Myalty;
 typedef typename aligned_union<1, _Ty>::type _Mystoragety;

 template<class... _Types>
  _Ref_count_obj_alloc(const _Alloc& _Al_arg, _Types&&... _Args)
  : _Ref_count_base(), _Mypair(_One_then_variadic_args_t(), _Al_arg)
  {
  ::new ((void *)_Getptr()) _Ty(::std:: forward<_Types>(_Args)...);
  }


 _Ty *_Getptr() const
  {
  return ((_Ty *)&_Mypair._Get_second());
  }

private:
 virtual void _Destroy() noexcept
  {
  _Getptr()->~_Ty();
  }

 virtual void _Delete_this() noexcept
  {
  _Myalty _Al = _Mypair._Get_first();
  _Al.destroy(this);
  _Al.deallocate(this, 1);
  }

 _Compressed_pair<_Myalty, _Mystoragety> _Mypair;
 };


template<class _Ty,
 class... _Types> inline
  shared_ptr<_Ty> make_shared(_Types&&... _Args)
 {
 _Ref_count_obj<_Ty> *_Rx =
  new _Ref_count_obj<_Ty>(::std:: forward<_Types>(_Args)...);

 shared_ptr<_Ty> _Ret;
 _Ret._Resetp0(_Rx->_Getptr(), _Rx);
 return (_Ret);
 }


template<class _Ty,
 class _Alloc,
 class... _Types> inline
 shared_ptr<_Ty> allocate_shared(
  const _Alloc& _Al_arg, _Types&&... _Args)
 {
 typedef _Ref_count_obj_alloc<_Ty, _Alloc> _Refoa;
 typedef _Wrap_alloc<_Alloc> _Alref0;
 typename _Alref0::template rebind<_Refoa>::other _Alref(_Al_arg);

 _Refoa *_Rx = _Alref.allocate(1);

 try {
  _Alref.construct(_Rx, _Al_arg, ::std:: forward<_Types>(_Args)...);
 } catch (...) {
  _Alref.deallocate(_Rx, 1);
 throw;
 }

 shared_ptr<_Ty> _Ret;
 _Ret._Resetp0(_Rx->_Getptr(), _Rx);
 return (_Ret);
 }



template<class _Ty>
 class weak_ptr
  : public _Ptr_base<_Ty>
 {
public:
 typedef weak_ptr<_Ty> _Myt;
 typedef _Ptr_base<_Ty> _Mybase;

 constexpr weak_ptr() noexcept
  {
  }

 weak_ptr(const weak_ptr& _Other) noexcept
  {
  this->_Resetw(_Other);
  }

 template<class _Ty2,
  class = typename enable_if<is_convertible<_Ty2 *, _Ty *>::value,
   void>::type>
  weak_ptr(const shared_ptr<_Ty2>& _Other) noexcept
  {
  this->_Resetw(_Other);
  }

 template<class _Ty2,
  class = typename enable_if<is_convertible<_Ty2 *, _Ty *>::value,
   void>::type>
  weak_ptr(const weak_ptr<_Ty2>& _Other) noexcept
  {
  this->_Resetw(_Other.lock());
  }

 weak_ptr(_Myt&& _Other) noexcept
  : _Mybase(::std:: move(_Other))
  {
  }

 template<class _Ty2,
  class = typename enable_if<is_convertible<_Ty2 *, _Ty *>::value,
   void>::type>
  weak_ptr(weak_ptr<_Ty2>&& _Other) noexcept
  {
  this->_Resetw(_Other.lock());
  _Other.reset();
  }

 ~weak_ptr() noexcept
  {
  this->_Decwref();
  }

 weak_ptr& operator=(const weak_ptr& _Right) noexcept
  {
  this->_Resetw(_Right);
  return (*this);
  }

 template<class _Ty2>
  weak_ptr& operator=(const weak_ptr<_Ty2>& _Right) noexcept
  {
  this->_Resetw(_Right.lock());
  return (*this);
  }

 _Myt& operator=(_Myt&& _Right) noexcept
  {
  weak_ptr(::std:: move(_Right)).swap(*this);
  return (*this);
  }

 template<class _Ty2>
  _Myt& operator=(weak_ptr<_Ty2>&& _Right) noexcept
  {
  weak_ptr(::std:: move(_Right)).swap(*this);
  return (*this);
  }

 template<class _Ty2>
  weak_ptr& operator=(const shared_ptr<_Ty2>& _Right) noexcept
  {
  this->_Resetw(_Right);
  return (*this);
  }

 void reset() noexcept
  {
  this->_Resetw();
  }

 void swap(weak_ptr& _Other) noexcept
  {
  this->_Swap(_Other);
  }

 bool expired() const noexcept
  {
  return (this->_Expired());
  }

 shared_ptr<_Ty> lock() const noexcept
  {
  return (shared_ptr<_Ty>(*this, false));
  }
 };

template<class _Ty>
 void swap(weak_ptr<_Ty>& _W1, weak_ptr<_Ty>& _W2) noexcept
 {
 _W1.swap(_W2);
 }


template<class _Ty>
 class enable_shared_from_this
 {
public:
 typedef _Ty _EStype;

 shared_ptr<_Ty> shared_from_this()
  {
  return (shared_ptr<_Ty>(_Wptr));
  }

 shared_ptr<const _Ty> shared_from_this() const
  {
  return (shared_ptr<const _Ty>(_Wptr));
  }

protected:
 constexpr enable_shared_from_this() noexcept
  {
  }

 enable_shared_from_this(const enable_shared_from_this&) noexcept
  {
  }

 enable_shared_from_this&
  operator=(const enable_shared_from_this&) noexcept
  {
  return (*this);
  }

 ~enable_shared_from_this() noexcept
  {
  }

private:
 template<class _Ty1,
  class _Ty2>
  friend void _Do_enable(
   _Ty1 *,
   enable_shared_from_this<_Ty2>*,
   _Ref_count_base *);

 weak_ptr<_Ty> _Wptr;
 };

template<class _Ty1,
 class _Ty2>
 inline void _Do_enable(
  _Ty1 *_Ptr,
  enable_shared_from_this<_Ty2> *_Es,
  _Ref_count_base *_Refptr)
 {
 _Es->_Wptr._Resetw(_Ptr, _Refptr);
 }
}

namespace std {



template<class _Ty>
 struct default_delete
 {
 constexpr default_delete() noexcept = default;

 template<class _Ty2,
  class = typename enable_if<is_convertible<_Ty2 *, _Ty *>::value,
   void>::type>
  default_delete(const default_delete<_Ty2>&) noexcept
  {
  }

 void operator()(_Ty *_Ptr) const noexcept
  {
  static_assert(0 < sizeof (_Ty),
   "can't delete an incomplete type");
  delete _Ptr;
  }
 };

template<class _Ty>
 struct default_delete<_Ty[]>
 {
 constexpr default_delete() noexcept = default;

 template<class _Uty,
  class = typename enable_if<is_convertible<_Uty(*)[], _Ty(*)[]>::value,
   void>::type>
  default_delete(const default_delete<_Uty[]>&) noexcept
  {
  }

 template<class _Uty,
  class = typename enable_if<is_convertible<_Uty(*)[], _Ty(*)[]>::value,
   void>::type>
  void operator()(_Uty *_Ptr) const noexcept
  {
  static_assert(0 < sizeof (_Uty),
   "can't delete an incomplete type");
  delete[] _Ptr;
  }
 };


template<class _Val,
 class _Ty>
 struct _Get_deleter_pointer_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::pointer>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<_Val *>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



template<class _Ty,
 class _Dx>
 class _Unique_ptr_base
 {
public:
 typedef typename remove_reference<_Dx>::type _Dx_noref;
 typedef typename _Get_deleter_pointer_type<_Ty, _Dx_noref>::type pointer;

 template<class _Ptr2,
  class _Dx2>
  _Unique_ptr_base(_Ptr2 _Ptr, _Dx2&& _Dt)
  : _Mypair(_One_then_variadic_args_t(), ::std:: forward<_Dx2>(_Dt), _Ptr)
  {
  }

 template<class _Ptr2>
  constexpr _Unique_ptr_base(_Ptr2 _Ptr)
  : _Mypair(_Zero_then_variadic_args_t(), _Ptr)
  {
  }

 _Dx& get_deleter() noexcept
  {
  return (_Mypair._Get_first());
  }

 const _Dx& get_deleter() const noexcept
  {
  return (_Mypair._Get_first());
  }

 pointer& _Myptr() noexcept
  {
  return (_Mypair._Get_second());
  }

 const pointer& _Myptr() const noexcept
  {
  return (_Mypair._Get_second());
  }

 _Compressed_pair<_Dx, pointer> _Mypair;
 };


template<class _Ty,
 class _Dx>
 class unique_ptr
  : public _Unique_ptr_base<_Ty, _Dx>
 {
public:
 typedef unique_ptr<_Ty, _Dx> _Myt;
 typedef _Unique_ptr_base<_Ty, _Dx> _Mybase;
 typedef typename _Mybase::pointer pointer;
 typedef _Ty element_type;
 typedef _Dx deleter_type;

 using _Mybase::get_deleter;

 constexpr unique_ptr() noexcept
  : _Mybase(pointer())
  {
  static_assert(!is_pointer<_Dx>::value,
   "unique_ptr constructed with null deleter pointer");
  }

 constexpr unique_ptr(nullptr_t) noexcept
  : _Mybase(pointer())
  {
  static_assert(!is_pointer<_Dx>::value,
   "unique_ptr constructed with null deleter pointer");
  }

 _Myt& operator=(nullptr_t) noexcept
  {
  reset();
  return (*this);
  }

 explicit unique_ptr(pointer _Ptr) noexcept
  : _Mybase(_Ptr)
  {
  static_assert(!is_pointer<_Dx>::value,
   "unique_ptr constructed with null deleter pointer");
  }

 unique_ptr(pointer _Ptr,
  typename _If<is_reference<_Dx>::value, _Dx,
   const typename remove_reference<_Dx>::type&>::type _Dt) noexcept
  : _Mybase(_Ptr, _Dt)
  {
  }

 unique_ptr(pointer _Ptr,
  typename remove_reference<_Dx>::type&& _Dt) noexcept
  : _Mybase(_Ptr, ::std:: move(_Dt))
  {
  static_assert(!is_reference<_Dx>::value,
   "unique_ptr constructed with reference to rvalue deleter");
  }

 unique_ptr(unique_ptr&& _Right) noexcept
  : _Mybase(_Right.release(),
   ::std:: forward<_Dx>(_Right.get_deleter()))
  {
  }

 template<class _Ty2,
  class _Dx2,
  class = typename enable_if<!is_array<_Ty2>::value
   && is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer,
    pointer>::value
   && (is_reference<_Dx>::value
    ? is_same<_Dx2, _Dx>::value
    : is_convertible<_Dx2, _Dx>::value),
   void>::type>
  unique_ptr(unique_ptr<_Ty2, _Dx2>&& _Right) noexcept
   : _Mybase(_Right.release(),
    ::std:: forward<_Dx2>(_Right.get_deleter()))
  {
  }


 template<class _Ty2,
  class = typename enable_if<is_convertible<_Ty2 *, _Ty *>::value
   && is_same<_Dx, default_delete<_Ty> >::value,
   void>::type>
  unique_ptr(auto_ptr<_Ty2>&& _Right) noexcept
   : _Mybase(_Right.release())
  {
  }


 template<class _Ty2,
  class _Dx2>
  typename enable_if<!is_array<_Ty2>::value
   && is_assignable<_Dx&, _Dx2&&>::value
   && is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer,
    pointer>::value,
   _Myt&>::type
  operator=(unique_ptr<_Ty2, _Dx2>&& _Right) noexcept
  {
  reset(_Right.release());
  this->get_deleter() = ::std:: forward<_Dx2>(_Right.get_deleter());
  return (*this);
  }

 _Myt& operator=(_Myt&& _Right) noexcept
  {
  if (this != &_Right)
   {
   reset(_Right.release());
   this->get_deleter() = ::std:: forward<_Dx>(_Right.get_deleter());
   }
  return (*this);
  }

 void swap(_Myt& _Right) noexcept
  {
  _Swap_adl(this->_Myptr(), _Right._Myptr());
  _Swap_adl(this->get_deleter(),
   _Right.get_deleter());
  }

 ~unique_ptr() noexcept
  {
  if (get() != pointer())
   this->get_deleter()(get());
  }

 typename add_lvalue_reference<_Ty>::type operator*() const
  {
  return (*get());
  }

 pointer operator->() const noexcept
  {
  return (pointer_traits<pointer>::pointer_to(**this));
  }

 pointer get() const noexcept
  {
  return (this->_Myptr());
  }

 explicit operator bool() const noexcept
  {
  return (get() != pointer());
  }

 pointer release() noexcept
  {
  pointer _Ans = get();
  this->_Myptr() = pointer();
  return (_Ans);
  }

 void reset(pointer _Ptr = pointer()) noexcept
  {
  pointer _Old = get();
  this->_Myptr() = _Ptr;
  if (_Old != pointer())
   this->get_deleter()(_Old);
  }

 unique_ptr(const _Myt&) = delete;
 _Myt& operator=(const _Myt&) = delete;
 };


template<class _Ty,
 class _Dx>
 class unique_ptr<_Ty[], _Dx>
  : public _Unique_ptr_base<_Ty, _Dx>
 {
public:
 typedef unique_ptr<_Ty[], _Dx> _Myt;
 typedef _Unique_ptr_base<_Ty, _Dx> _Mybase;
 typedef typename _Mybase::pointer pointer;
 typedef _Ty element_type;
 typedef _Dx deleter_type;

 using _Mybase::get_deleter;

 constexpr unique_ptr() noexcept
  : _Mybase(pointer())
  {
  static_assert(!is_pointer<_Dx>::value,
   "unique_ptr constructed with null deleter pointer");
  }

 template<class _Uty>
  using _Enable_ctor_reset = enable_if_t<
   is_same<_Uty, pointer>::value
   || (is_same<pointer, element_type *>::value
   && is_pointer<_Uty>::value
   && is_convertible<
    remove_pointer_t<_Uty>(*)[],
    element_type(*)[]
   >::value)>;

 template<class _Uty,
  class = _Enable_ctor_reset<_Uty> >
 explicit unique_ptr(_Uty _Ptr) noexcept
  : _Mybase(_Ptr)
  {
  static_assert(!is_pointer<_Dx>::value,
   "unique_ptr constructed with null deleter pointer");
  }

 template<class _Uty,
  class = _Enable_ctor_reset<_Uty> >
 unique_ptr(_Uty _Ptr,
  typename _If<is_reference<_Dx>::value, _Dx,
   const typename remove_reference<_Dx>::type&>::type _Dt) noexcept
  : _Mybase(_Ptr, _Dt)
  {
  }

 template<class _Uty,
  class = _Enable_ctor_reset<_Uty> >
 unique_ptr(_Uty _Ptr,
  typename remove_reference<_Dx>::type&& _Dt) noexcept
  : _Mybase(_Ptr, ::std:: move(_Dt))
  {
  static_assert(!is_reference<_Dx>::value,
   "unique_ptr constructed with reference to rvalue deleter");
  }

 unique_ptr(unique_ptr&& _Right) noexcept
  : _Mybase(_Right.release(),
   ::std:: forward<_Dx>(_Right.get_deleter()))
  {
  }

 _Myt& operator=(_Myt&& _Right) noexcept
  {
  if (this != &_Right)
   {
   reset(_Right.release());
   this->get_deleter() = ::std:: move(_Right.get_deleter());
   }
  return (*this);
  }

 template<class _Uty,
  class _Ex,
  bool _More,
  class _UP_pointer = typename unique_ptr<_Uty, _Ex>::pointer,
  class _UP_element_type = typename unique_ptr<_Uty, _Ex>::element_type>
  using _Enable_conversion = enable_if_t<
   is_array<_Uty>::value
   && is_same<pointer, element_type *>::value
   && is_same<_UP_pointer, _UP_element_type *>::value
   && is_convertible<_UP_element_type(*)[], element_type(*)[]>::value
   && _More>;

 template<class _Uty,
  class _Ex,
  class = _Enable_conversion<_Uty, _Ex,
   is_reference<_Dx>::value
   ? is_same<_Ex, _Dx>::value
   : is_convertible<_Ex, _Dx>::value> >
  unique_ptr(unique_ptr<_Uty, _Ex>&& _Right) noexcept
   : _Mybase(_Right.release(),
    ::std:: forward<_Ex>(_Right.get_deleter()))
  {
  }

 template<class _Uty,
  class _Ex,
  class = _Enable_conversion<_Uty, _Ex,
   is_assignable<_Dx&, _Ex&&>::value> >
  _Myt& operator=(unique_ptr<_Uty, _Ex>&& _Right) noexcept
  {
  reset(_Right.release());
  this->get_deleter() = ::std:: forward<_Ex>(_Right.get_deleter());
  return (*this);
  }

 constexpr unique_ptr(nullptr_t) noexcept
  : _Mybase(pointer())
  {
  static_assert(!is_pointer<_Dx>::value,
   "unique_ptr constructed with null deleter pointer");
  }

 _Myt& operator=(nullptr_t) noexcept
  {
  reset();
  return (*this);
  }

 void reset(nullptr_t = nullptr_t{}) noexcept
  {
  reset(pointer());
  }

 void swap(_Myt& _Right) noexcept
  {
  _Swap_adl(this->_Myptr(), _Right._Myptr());
  _Swap_adl(this->get_deleter(), _Right.get_deleter());
  }

 ~unique_ptr() noexcept
  {
  _Delete();
  }

 _Ty& operator[](size_t _Idx) const
  {
  return (get()[_Idx]);
  }

 pointer get() const noexcept
  {
  return (this->_Myptr());
  }

 explicit operator bool() const noexcept
  {
  return (get() != pointer());
  }

 pointer release() noexcept
  {
  pointer _Ans = get();
  this->_Myptr() = pointer();
  return (_Ans);
  }

 template<class _Uty,
  class = _Enable_ctor_reset<_Uty> >
 void reset(_Uty _Ptr) noexcept
  {
  pointer _Old = get();
  this->_Myptr() = _Ptr;
  if (_Old != pointer())
   this->get_deleter()(_Old);
  }

 unique_ptr(const _Myt&) = delete;

 _Myt& operator=(const _Myt&) = delete;

private:
 void _Delete()
  {
  if (get() != pointer())
   this->get_deleter()(get());
  }
 };



template<class _Ty,
 class... _Types> inline
 typename enable_if<!is_array<_Ty>::value,
  unique_ptr<_Ty> >::type make_unique(_Types&&... _Args)
 {
 return (unique_ptr<_Ty>(new _Ty(::std:: forward<_Types>(_Args)...)));
 }

template<class _Ty> inline
 typename enable_if<is_array<_Ty>::value && extent<_Ty>::value == 0,
  unique_ptr<_Ty> >::type make_unique(size_t _Size)
 {
 typedef typename remove_extent<_Ty>::type _Elem;
 return (unique_ptr<_Ty>(new _Elem[_Size]()));
 }

template<class _Ty,
 class... _Types>
 typename enable_if<extent<_Ty>::value != 0,
  void>::type make_unique(_Types&&...) = delete;


template<class _Ty,
 class _Dx,
 class = enable_if_t<_Is_swappable<_Dx>::value>>
 void swap(unique_ptr<_Ty, _Dx>& _Left,
  unique_ptr<_Ty, _Dx>& _Right) noexcept
 {
 _Left.swap(_Right);
 }

template<class _Ty1,
 class _Dx1,
 class _Ty2,
 class _Dx2>
 bool operator==(const unique_ptr<_Ty1, _Dx1>& _Left,
  const unique_ptr<_Ty2, _Dx2>& _Right)
 {
 return (_Left.get() == _Right.get());
 }

template<class _Ty1,
 class _Dx1,
 class _Ty2,
 class _Dx2>
 bool operator!=(const unique_ptr<_Ty1, _Dx1>& _Left,
  const unique_ptr<_Ty2, _Dx2>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _Ty1,
 class _Dx1,
 class _Ty2,
 class _Dx2>
 bool operator<(const unique_ptr<_Ty1, _Dx1>& _Left,
  const unique_ptr<_Ty2, _Dx2>& _Right)
 {
 typedef typename unique_ptr<_Ty1, _Dx1>::pointer _Ptr1;
 typedef typename unique_ptr<_Ty2, _Dx2>::pointer _Ptr2;
 typedef typename common_type<_Ptr1, _Ptr2>::type _Common;
 return (less<_Common>()(_Left.get(), _Right.get()));

 }

template<class _Ty1,
 class _Dx1,
 class _Ty2,
 class _Dx2>
 bool operator>=(const unique_ptr<_Ty1, _Dx1>& _Left,
  const unique_ptr<_Ty2, _Dx2>& _Right)
 {
 return (!(_Left < _Right));
 }

template<class _Ty1,
 class _Dx1,
 class _Ty2,
 class _Dx2>
 bool operator>(const unique_ptr<_Ty1, _Dx1>& _Left,
  const unique_ptr<_Ty2, _Dx2>& _Right)
 {
 return (_Right < _Left);
 }

template<class _Ty1,
 class _Dx1,
 class _Ty2,
 class _Dx2>
 bool operator<=(const unique_ptr<_Ty1, _Dx1>& _Left,
  const unique_ptr<_Ty2, _Dx2>& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _Ty,
 class _Dx>
 bool operator==(const unique_ptr<_Ty, _Dx>& _Left,
  nullptr_t) noexcept
 {
 return (!_Left);
 }

template<class _Ty,
 class _Dx>
 bool operator==(nullptr_t,
  const unique_ptr<_Ty, _Dx>& _Right) noexcept
 {
 return (!_Right);
 }

template<class _Ty,
 class _Dx>
 bool operator!=(const unique_ptr<_Ty, _Dx>& _Left,
  nullptr_t _Right) noexcept
 {
 return (!(_Left == _Right));
 }

template<class _Ty,
 class _Dx>
 bool operator!=(nullptr_t _Left,
  const unique_ptr<_Ty, _Dx>& _Right) noexcept
 {
 return (!(_Left == _Right));
 }

template<class _Ty,
 class _Dx>
 bool operator<(const unique_ptr<_Ty, _Dx>& _Left,
  nullptr_t _Right)
 {
 typedef typename unique_ptr<_Ty, _Dx>::pointer _Ptr;
 return (less<_Ptr>()(_Left.get(), _Right));
 }

template<class _Ty,
 class _Dx>
 bool operator<(nullptr_t _Left,
  const unique_ptr<_Ty, _Dx>& _Right)
 {
 typedef typename unique_ptr<_Ty, _Dx>::pointer _Ptr;
 return (less<_Ptr>()(_Left, _Right.get()));
 }

template<class _Ty,
 class _Dx>
 bool operator>=(const unique_ptr<_Ty, _Dx>& _Left,
  nullptr_t _Right)
 {
 return (!(_Left < _Right));
 }

template<class _Ty,
 class _Dx>
 bool operator>=(nullptr_t _Left,
  const unique_ptr<_Ty, _Dx>& _Right)
 {
 return (!(_Left < _Right));
 }

template<class _Ty,
 class _Dx>
 bool operator>(const unique_ptr<_Ty, _Dx>& _Left,
  nullptr_t _Right)
 {
 return (_Right < _Left);
 }

template<class _Ty,
 class _Dx>
 bool operator>(nullptr_t _Left,
  const unique_ptr<_Ty, _Dx>& _Right)
 {
 return (_Right < _Left);
 }

template<class _Ty,
 class _Dx>
 bool operator<=(const unique_ptr<_Ty, _Dx>& _Left,
  nullptr_t _Right)
 {
 return (!(_Right < _Left));
 }

template<class _Ty,
 class _Dx>
 bool operator<=(nullptr_t _Left,
  const unique_ptr<_Ty, _Dx>& _Right)
 {
 return (!(_Right < _Left));
 }



enum class pointer_safety {
 relaxed,
 preferred,
 strict
 };

typedef pointer_safety _Pointer_safety;

inline void declare_reachable(void *)
 {
 }

template<class _Ty> inline
 _Ty *undeclare_reachable(_Ty *_Ptr)
 {
 return (_Ptr);
 }

inline void declare_no_pointers(char *, size_t)
 {
 }

inline void undeclare_no_pointers(char *, size_t)
 {
 }

inline _Pointer_safety get_pointer_safety() noexcept
 {
 return (pointer_safety::relaxed);
 }


namespace tr1 {
using ::std:: allocate_shared;
using ::std:: bad_weak_ptr;
using ::std:: const_pointer_cast;
using ::std:: dynamic_pointer_cast;
using ::std:: enable_shared_from_this;
using ::std:: get_deleter;
using ::std:: make_shared;
using ::std:: shared_ptr;
using ::std:: static_pointer_cast;
using ::std:: swap;
using ::std:: weak_ptr;
}



template<class _Ty = void>
 struct owner_less;

template<class _Ty>
 struct owner_less<shared_ptr<_Ty> >
 {
 typedef shared_ptr<_Ty> first_argument_type;
 typedef shared_ptr<_Ty> second_argument_type;
 typedef bool result_type;

 bool operator()(const shared_ptr<_Ty>& _Left,
  const shared_ptr<_Ty>& _Right) const
  {
  return (_Left.owner_before(_Right));
  }

 bool operator()(const shared_ptr<_Ty>& _Left,
  const weak_ptr<_Ty>& _Right) const
  {
  return (_Left.owner_before(_Right));
  }

 bool operator()(const weak_ptr<_Ty>& _Left,
  const shared_ptr<_Ty>& _Right) const
  {
  return (_Left.owner_before(_Right));
  }
 };

template<class _Ty>
 struct owner_less<weak_ptr<_Ty> >
 {
 typedef weak_ptr<_Ty> first_argument_type;
 typedef weak_ptr<_Ty> second_argument_type;
 typedef bool result_type;

 bool operator()(const weak_ptr<_Ty>& _Left,
  const weak_ptr<_Ty>& _Right) const
  {
  return (_Left.owner_before(_Right));
  }

 bool operator()(const weak_ptr<_Ty>& _Left,
  const shared_ptr<_Ty>& _Right) const
  {
  return (_Left.owner_before(_Right));
  }

 bool operator()(const shared_ptr<_Ty>& _Left,
  const weak_ptr<_Ty>& _Right) const
  {
  return (_Left.owner_before(_Right));
  }
 };

template<>
 struct owner_less<void>
 {
 typedef int is_transparent;

 template<class _Ty,
  class _Uty>
  bool operator()(const shared_ptr<_Ty>& _Left, const shared_ptr<_Uty>& _Right) const
  {
  return (_Left.owner_before(_Right));
  }

 template<class _Ty,
  class _Uty>
  bool operator()(const shared_ptr<_Ty>& _Left, const weak_ptr<_Uty>& _Right) const
  {
  return (_Left.owner_before(_Right));
  }

 template<class _Ty,
  class _Uty>
  bool operator()(const weak_ptr<_Ty>& _Left, const shared_ptr<_Uty>& _Right) const
  {
  return (_Left.owner_before(_Right));
  }

 template<class _Ty,
  class _Uty>
  bool operator()(const weak_ptr<_Ty>& _Left, const weak_ptr<_Uty>& _Right) const
  {
  return (_Left.owner_before(_Right));
  }
 };


template<class _Ty,
 class _Dx>
 struct hash<unique_ptr<_Ty, _Dx> >
 {
 typedef unique_ptr<_Ty, _Dx> argument_type;
 typedef size_t result_type;

 size_t operator()(const argument_type& _Keyval) const
  {
  typedef typename argument_type::pointer _Ptrtype;
  return (hash<_Ptrtype>()(_Keyval.get()));
  }
 };

template<class _Ty>
 struct hash<shared_ptr<_Ty> >
 {
 typedef shared_ptr<_Ty> argument_type;
 typedef size_t result_type;

 size_t operator()(const argument_type& _Keyval) const
  {
  return (hash<_Ty *>()(_Keyval.get()));
  }
 };


inline void *align(size_t _Bound, size_t _Size,
 void *& _Ptr, size_t& _Space) noexcept
 {
 size_t _Off = (size_t)((uintptr_t)_Ptr & (_Bound - 1));
 if (0 < _Off)
  _Off = _Bound - _Off;
 if (_Space < _Off || _Space - _Off < _Size)
  return (0);
 else
  {
  _Ptr = (char *)_Ptr + _Off;
  _Space -= _Off;
  return (_Ptr);
  }
 }


struct _Shared_ptr_spin_lock
 {
 _Shared_ptr_spin_lock()
  {
  _Lock_shared_ptr_spin_lock();
  }

 ~_Shared_ptr_spin_lock() noexcept
  {
  _Unlock_shared_ptr_spin_lock();
  }
 };

template<class _Ty> inline
 bool atomic_is_lock_free(const shared_ptr<_Ty> *)
 {
 return (false);
 }

template<class _Ty> inline
 shared_ptr<_Ty> atomic_load_explicit(const shared_ptr<_Ty> *_Ptr,
  memory_order)
 {
 _Shared_ptr_spin_lock _Lock;
 shared_ptr<_Ty> _Result = *_Ptr;
 return (_Result);
 }

template<class _Ty> inline
 shared_ptr<_Ty> atomic_load(const shared_ptr<_Ty> *_Ptr)
 {
 return (::std:: atomic_load_explicit(_Ptr, memory_order_seq_cst));
 }

template<class _Ty> inline
 void atomic_store_explicit(shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> _Other,
  memory_order)
 {
 _Shared_ptr_spin_lock _Lock;
 _Ptr->swap(_Other);
 }

template<class _Ty> inline
 void atomic_store(shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> _Other)
 {
 ::std:: atomic_store_explicit(_Ptr, ::std:: move(_Other), memory_order_seq_cst);
 }

template<class _Ty> inline
 shared_ptr<_Ty> atomic_exchange_explicit(
  shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> _Other,
  memory_order)
 {
 _Shared_ptr_spin_lock _Lock;
 _Ptr->swap(_Other);
 return (_Other);
 }

template<class _Ty> inline
 shared_ptr<_Ty> atomic_exchange(
  shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> _Other)
 {
 return (::std:: atomic_exchange_explicit(_Ptr, ::std:: move(_Other), memory_order_seq_cst));
 }

template<class _Ty> inline
 bool atomic_compare_exchange_weak_explicit(
  shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> *_Exp, shared_ptr<_Ty> _Value,
  memory_order, memory_order)
 {
 shared_ptr<_Ty> _Old_exp;
 _Shared_ptr_spin_lock _Lock;
 bool _Success = _Ptr->get() == _Exp->get()
  && !_Ptr->owner_before(*_Exp)
  && !_Exp->owner_before(*_Ptr);
 if (_Success)
  _Ptr->swap(_Value);
 else
  {
  _Exp->swap(_Old_exp);
  *_Exp = *_Ptr;
  }
 return (_Success);
 }

template<class _Ty> inline
 bool atomic_compare_exchange_weak(
  shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> *_Exp,
   shared_ptr<_Ty> _Value)
 {
 return (::std:: atomic_compare_exchange_weak_explicit(_Ptr, _Exp, ::std:: move(_Value),
  memory_order_seq_cst, memory_order_seq_cst));
 }

template<class _Ty> inline
 bool atomic_compare_exchange_strong_explicit(
  shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> *_Exp, shared_ptr<_Ty> _Value,
  memory_order, memory_order)
 {
 return (::std:: atomic_compare_exchange_weak_explicit(_Ptr, _Exp, ::std:: move(_Value),
  memory_order_seq_cst, memory_order_seq_cst));
 }

template<class _Ty> inline
 bool atomic_compare_exchange_strong(
 shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> *_Exp,
  shared_ptr<_Ty> _Value)
 {
 return (::std:: atomic_compare_exchange_strong_explicit(_Ptr, _Exp, ::std:: move(_Value),
  memory_order_seq_cst, memory_order_seq_cst));
 }
}

#pragma warning(pop)
#pragma pack(pop)
# 55 "..\\..\\..\\JUCE\\modules\\juce_core/system/juce_StandardHeader.h" 2


# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vector" 1 3






# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\stdexcept" 1 3






# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xstring" 1 3







#pragma pack(push,8)
#pragma warning(push, 3)



namespace std {
#pragma warning(disable: 4127)

#pragma warning(disable: 4251)

template<class _Elem,
 class _Traits = char_traits<_Elem>,
 class _Ax = allocator<_Elem> >
 class basic_string;


template<class _Mystr>
 class _String_const_iterator
  : public _Iterator012<random_access_iterator_tag,
   typename _Mystr::value_type,
   typename _Mystr::difference_type,
   typename _Mystr::const_pointer,
   typename _Mystr::const_reference,
   _Iterator_base>
 {
public:
 typedef _String_const_iterator<_Mystr> _Myiter;
 typedef random_access_iterator_tag iterator_category;

 typedef typename _Mystr::value_type value_type;
 typedef typename _Mystr::difference_type difference_type;
 typedef typename _Mystr::const_pointer pointer;
 typedef typename _Mystr::const_reference reference;

 _String_const_iterator()
  : _Ptr()
  {
  }

 _String_const_iterator(pointer _Parg, const _Container_base *_Pstring)
  : _Ptr(_Parg)
  {
  this->_Adopt(_Pstring);
  }

 typedef pointer _Unchecked_type;

 _Myiter& _Rechecked(_Unchecked_type _Right)
  {
  _Ptr = _Right;
  return (*this);
  }

 _Unchecked_type _Unchecked() const
  {
  return (_Ptr);
  }

 reference operator*() const
  {
# 88 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xstring" 3
                                        ;

  return (*_Ptr);
  }

 pointer operator->() const
  {
  return (pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
# 117 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xstring" 3
  ++_Ptr;
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
# 147 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xstring" 3
  --_Ptr;
  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }

 _Myiter& operator+=(difference_type _Off)
  {
# 187 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xstring" 3
  _Ptr += _Off;
  return (*this);
  }

 _Myiter operator+(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp += _Off);
  }

 _Myiter& operator-=(difference_type _Off)
  {
  return (*this += -_Off);
  }

 _Myiter operator-(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp -= _Off);
  }

 difference_type operator-(const _Myiter& _Right) const
  {
  _Compat(_Right);
  return (_Ptr - _Right._Ptr);
  }

 reference operator[](difference_type _Off) const
  {
  return (*(*this + _Off));
  }

 bool operator==(const _Myiter& _Right) const
  {
  _Compat(_Right);
  return (_Ptr == _Right._Ptr);
  }

 bool operator!=(const _Myiter& _Right) const
  {
  return (!(*this == _Right));
  }

 bool operator<(const _Myiter& _Right) const
  {
  _Compat(_Right);
  return (_Ptr < _Right._Ptr);
  }

 bool operator>(const _Myiter& _Right) const
  {
  return (_Right < *this);
  }

 bool operator<=(const _Myiter& _Right) const
  {
  return (!(_Right < *this));
  }

 bool operator>=(const _Myiter& _Right) const
  {
  return (!(*this < _Right));
  }
# 268 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xstring" 3
 void _Compat(const _Myiter&) const
  {
  }


 pointer _Ptr;
 };

template<class _Mystr> inline
 typename _String_const_iterator<_Mystr>::_Unchecked_type
  _Unchecked(_String_const_iterator<_Mystr> _Iter)
 {
 return (_Iter._Unchecked());
 }

template<class _Mystr> inline
 _String_const_iterator<_Mystr>
  _Rechecked(_String_const_iterator<_Mystr>& _Iter,
   typename _String_const_iterator<_Mystr>
    ::_Unchecked_type _Right)
 {
 return (_Iter._Rechecked(_Right));
 }

template<class _Mystr> inline
 _String_const_iterator<_Mystr> operator+(
  typename _String_const_iterator<_Mystr>
   ::difference_type _Off,
  _String_const_iterator<_Mystr> _Next)
 {
 return (_Next += _Off);
 }


template<class _Mystr>
 class _String_iterator
  : public _String_const_iterator<_Mystr>
 {
public:
 typedef _String_iterator<_Mystr> _Myiter;
 typedef _String_const_iterator<_Mystr> _Mybase;
 typedef random_access_iterator_tag iterator_category;

 typedef typename _Mystr::value_type value_type;
 typedef typename _Mystr::difference_type difference_type;
 typedef typename _Mystr::pointer pointer;
 typedef typename _Mystr::reference reference;

 _String_iterator()
  {
  }

 _String_iterator(pointer _Parg, const _Container_base *_Pstring)
  : _Mybase(_Parg, _Pstring)
  {
  }

 typedef pointer _Unchecked_type;

 _Myiter& _Rechecked(_Unchecked_type _Right)
  {
  this->_Ptr = _Right;
  return (*this);
  }

 _Unchecked_type _Unchecked() const
  {
  return (_Const_cast(this->_Ptr));
  }

 reference operator*() const
  {
  return ((reference)**(_Mybase *)this);
  }

 pointer operator->() const
  {
  return (pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
  ++*(_Mybase *)this;
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
  --*(_Mybase *)this;
  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }

 _Myiter& operator+=(difference_type _Off)
  {
  *(_Mybase *)this += _Off;
  return (*this);
  }

 _Myiter operator+(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp += _Off);
  }

 _Myiter& operator-=(difference_type _Off)
  {
  return (*this += -_Off);
  }

 _Myiter operator-(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp -= _Off);
  }

 difference_type operator-(const _Mybase& _Right) const
  {
  return (*(_Mybase *)this - _Right);
  }

 reference operator[](difference_type _Off) const
  {
  return (*(*this + _Off));
  }
 };

template<class _Mystr> inline
 typename _String_iterator<_Mystr>::_Unchecked_type
  _Unchecked(_String_iterator<_Mystr> _Iter)
 {
 return (_Iter._Unchecked());
 }

template<class _Mystr> inline
 _String_iterator<_Mystr>
  _Rechecked(_String_iterator<_Mystr>& _Iter,
   typename _String_iterator<_Mystr>
    ::_Unchecked_type _Right)
 {
 return (_Iter._Rechecked(_Right));
 }

template<class _Mystr> inline
 _String_iterator<_Mystr> operator+(
  typename _String_iterator<_Mystr>
   ::difference_type _Off,
  _String_iterator<_Mystr> _Next)
 {
 return (_Next += _Off);
 }


template<class _Value_type,
 class _Size_type,
 class _Difference_type,
 class _Pointer,
 class _Const_pointer,
 class _Reference,
 class _Const_reference>
 struct _String_iter_types
 {
 typedef _Value_type value_type;
 typedef _Size_type size_type;
 typedef _Difference_type difference_type;
 typedef _Pointer pointer;
 typedef _Const_pointer const_pointer;
 typedef _Reference reference;
 typedef _Const_reference const_reference;
 };

template<class _Ty,
 class _Alloc0>
 struct _String_base_types
 {
 typedef _Alloc0 _Alloc;
 typedef _String_base_types<_Ty, _Alloc> _Myt;

 typedef _Wrap_alloc<_Alloc> _Alty0;
 typedef typename _Alty0::template rebind<_Ty>::other _Alty;


 typedef typename _If<_Is_simple_alloc<_Alty>::value,
  _Simple_types<typename _Alty::value_type>,
  _String_iter_types<typename _Alty::value_type,
   typename _Alty::size_type,
   typename _Alty::difference_type,
   typename _Alty::pointer,
   typename _Alty::const_pointer,
   typename _Alty::reference,
   typename _Alty::const_reference> >::type
  _Val_types;
 };


template<class _Val_types>
 class _String_val
  : public _Container_base
 {
public:
 typedef _String_val<_Val_types> _Myt;

 typedef typename _Val_types::value_type value_type;
 typedef typename _Val_types::size_type size_type;
 typedef typename _Val_types::difference_type difference_type;
 typedef typename _Val_types::pointer pointer;
 typedef typename _Val_types::const_pointer const_pointer;
 typedef typename _Val_types::reference reference;
 typedef typename _Val_types::const_reference const_reference;

 typedef _String_iterator<_Myt> iterator;
 typedef _String_const_iterator<_Myt> const_iterator;

 _String_val()
  : _Bx(),
  _Mysize(0),
  _Myres(0)
  {
  }

 enum
  {
  _BUF_SIZE = 16 / sizeof (value_type) < 1 ? 1
   : 16 / sizeof (value_type)};
 enum
  {
  _ALLOC_MASK = sizeof (value_type) <= 1 ? 15
   : sizeof (value_type) <= 2 ? 7
   : sizeof (value_type) <= 4 ? 3
   : sizeof (value_type) <= 8 ? 1 : 0};

 value_type *_Myptr()
  {
  return (this->_BUF_SIZE <= _Myres
   ? _Unfancy(_Bx._Ptr)
   : _Bx._Buf);
  }

 const value_type *_Myptr() const
  {
  return (this->_BUF_SIZE <= _Myres
   ? _Unfancy(_Bx._Ptr)
   : _Bx._Buf);
  }

 union _Bxty
  {
  _Bxty()
   {
   }

  ~_Bxty() noexcept
   {
   }

  value_type _Buf[_BUF_SIZE];
  pointer _Ptr;
  char _Alias[_BUF_SIZE];
  } _Bx;

 size_type _Mysize;
 size_type _Myres;
 };


template<class _Alloc_types>
 class _String_alloc
 {
public:
 typedef _String_alloc<_Alloc_types> _Myt;
 typedef typename _Alloc_types::_Alloc _Alloc;
 typedef typename _Alloc_types::_Alty _Alty;
 typedef typename _Alloc_types::_Val_types _Val_types;

 typedef typename _Val_types::value_type value_type;
 typedef typename _Val_types::size_type size_type;
 typedef typename _Val_types::difference_type difference_type;
 typedef typename _Val_types::pointer pointer;
 typedef typename _Val_types::const_pointer const_pointer;
 typedef typename _Val_types::reference reference;
 typedef typename _Val_types::const_reference const_reference;

 typedef _String_iterator<_String_val<_Val_types> > iterator;
 typedef _String_const_iterator<_String_val<_Val_types> > const_iterator;

 enum
  {
  _BUF_SIZE = _String_val<_Val_types>::_BUF_SIZE
  };

 enum
  {
  _ALLOC_MASK = _String_val<_Val_types>::_ALLOC_MASK
  };

 value_type *_Myptr()
  {
  return (_Get_data()._Myptr());
  }

 const value_type *_Myptr() const
  {
  return (_Get_data()._Myptr());
  }


 _String_alloc()
  : _Mypair(_Zero_then_variadic_args_t())
  {
  }

 template<class _Any_alloc,
  class = enable_if_t<!is_same<decay_t<_Any_alloc>, _Myt>::value> >
  _String_alloc(_Any_alloc&& _Al)
  : _Mypair(_One_then_variadic_args_t(),
   ::std:: forward<_Any_alloc>(_Al))
  {
  }

 void _Copy_alloc(const _Alty& _Al)
  {
  _Pocca(_Getal(), _Al);
  }

 void _Move_alloc(_Alty& _Al)
  {
  _Pocma(_Getal(), _Al);
  }
# 680 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xstring" 3
 void _Orphan_all()
  {
  _Get_data()._Orphan_all();
  }

 void _Swap_all(_Myt& _Right)
  {
  _Get_data()._Swap_all(_Right._Get_data());
  }

 _Alty& _Getal() noexcept
  {
  return (_Mypair._Get_first());
  }

 const _Alty& _Getal() const noexcept
  {
  return (_Mypair._Get_first());
  }

 _String_val<_Val_types>& _Get_data() noexcept
  {
  return (_Mypair._Get_second());
  }

 const _String_val<_Val_types>& _Get_data() const noexcept
  {
  return (_Mypair._Get_second());
  }

 typedef typename _String_val<_Val_types>::_Bxty _Bxty;

 _Bxty& _Bx() noexcept
  {
  return (_Get_data()._Bx);
  }

 const _Bxty& _Bx() const noexcept
  {
  return (_Get_data()._Bx);
  }

 size_type& _Mysize() noexcept
  {
  return (_Get_data()._Mysize);
  }

 const size_type& _Mysize() const noexcept
  {
  return (_Get_data()._Mysize);
  }

 size_type& _Myres() noexcept
  {
  return (_Get_data()._Myres);
  }

 const size_type& _Myres() const noexcept
  {
  return (_Get_data()._Myres);
  }

private:
 _Compressed_pair<_Alty, _String_val<_Val_types> > _Mypair;
 };


template<class _Elem,
 class _Traits,
 class _Alloc>
 class basic_string
  : public _String_alloc<_String_base_types<_Elem, _Alloc> >
 {
public:
 typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
 typedef _String_alloc<_String_base_types<_Elem, _Alloc> > _Mybase;
 typedef _Traits traits_type;
 typedef _Alloc allocator_type;

 typedef typename _Mybase::_Alty _Alty;

 typedef typename _Mybase::value_type value_type;
 typedef typename _Mybase::size_type size_type;
 typedef typename _Mybase::difference_type difference_type;
 typedef typename _Mybase::pointer pointer;
 typedef typename _Mybase::const_pointer const_pointer;
 typedef typename _Mybase::reference reference;
 typedef typename _Mybase::const_reference const_reference;

 typedef typename _Mybase::iterator iterator;
 typedef typename _Mybase::const_iterator const_iterator;

 typedef ::std:: reverse_iterator<iterator> reverse_iterator;
 typedef ::std:: reverse_iterator<const_iterator> const_reverse_iterator;

 basic_string(const _Myt& _Right)

  : _Mybase(_Right._Getal().select_on_container_copy_construction())


  {
  _Tidy();
  assign(_Right, 0, npos);
  }

 basic_string(const _Myt& _Right, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Tidy();
  assign(_Right, 0, npos);
  }

 basic_string() noexcept(is_nothrow_default_constructible<_Alloc>::value)
  : _Mybase()
  {
  _Tidy();
  }

 explicit basic_string(const _Alloc& _Al) noexcept
  : _Mybase(_Al)
  {
  _Tidy();
  }

 basic_string(const _Myt& _Right, size_type _Roff,
  size_type _Count = npos)
  : _Mybase(_Right._Getal())
  {
  _Tidy();
  assign(_Right, _Roff, _Count);
  }

 basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
  const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Tidy();
  assign(_Right, _Roff, _Count);
  }

 basic_string(const _Elem *_Ptr, size_type _Count)
  : _Mybase()
  {
  _Tidy();
  assign(_Ptr, _Count);
  }

 basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Tidy();
  assign(_Ptr, _Count);
  }

 basic_string(const _Elem *_Ptr)
  : _Mybase()
  {
  _Tidy();
  assign(_Ptr);
  }

 basic_string(const _Elem *_Ptr, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Tidy();
  assign(_Ptr);
  }

 basic_string(size_type _Count, _Elem _Ch)
  : _Mybase()
  {
  _Tidy();
  assign(_Count, _Ch);
  }

 basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Tidy();
  assign(_Count, _Ch);
  }

 template<class _Iter,
  class = typename enable_if<_Is_iterator<_Iter>::value,
   void>::type>
  basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
  : _Mybase(_Al)
  {
                             ;
  _Tidy();
  _Construct(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>());
  }

 template<class _Iter>
  void _Construct(_Iter _First,
   _Iter _Last, input_iterator_tag)
  {
  try {
  for (; _First != _Last; ++_First)
   append((size_type)1, (_Elem)*_First);
  } catch (...) {
  _Tidy(true);
  throw;
  }
  }

 template<class _Iter>
  void _Construct(_Iter _First,
   _Iter _Last, forward_iterator_tag)
  {
  size_type _Count = ::std:: distance(_First, _Last);
  reserve(_Count);
  _Construct(_First, _Last, input_iterator_tag());
  }

 void _Construct(_Elem *_First,
  _Elem *_Last, random_access_iterator_tag)
  {
  if (_First != _Last)
   assign(_First, _Last - _First);
  }

 void _Construct(const _Elem *_First,
  const _Elem *_Last, random_access_iterator_tag)
  {
  if (_First != _Last)
   assign(_First, _Last - _First);
  }

 basic_string(_Myt&& _Right) noexcept
  : _Mybase(::std:: move(_Right._Getal()))
  {
  _Tidy();
  _Assign_rv(::std:: forward<_Myt>(_Right));
  }

 basic_string(_Myt&& _Right, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  if (this->_Getal() != _Right._Getal())
   assign(_Right.begin(), _Right.end());
  else
   _Assign_rv(::std:: forward<_Myt>(_Right));
  }

 _Myt& operator=(_Myt&& _Right)
  noexcept(_Alty::propagate_on_container_move_assignment::value || _Alty::is_always_equal::value)

  {
  if (this != &_Right)
   {
   _Tidy(true);

   if (_Alty::propagate_on_container_move_assignment::value
    && this->_Getal() != _Right._Getal())
    this->_Move_alloc(_Right._Getal());

   if (this->_Getal() != _Right._Getal())
    assign(_Right.begin(), _Right.end());
   else
    _Assign_rv(::std:: forward<_Myt>(_Right));
   }
  return (*this);
  }

 _Myt& assign(_Myt&& _Right) noexcept
  {
  if (this == &_Right)
   ;
  else if (get_allocator() != _Right.get_allocator()
   && this->_BUF_SIZE <= _Right._Myres())
   *this = _Right;
  else
   {
   _Tidy(true);
   _Assign_rv(::std:: forward<_Myt>(_Right));
   }
  return (*this);
  }

 void _Assign_rv(_Myt&& _Right)
  {
  if (_Right._Myres() < this->_BUF_SIZE)
   _Traits::move(this->_Bx()._Buf, _Right._Bx()._Buf,
    _Right._Mysize() + 1);
  else
   {
   this->_Getal().construct(::std:: addressof(this->_Bx()._Ptr), _Right._Bx()._Ptr);
   _Right._Bx()._Ptr = pointer();
   }
  this->_Mysize() = _Right._Mysize();
  this->_Myres() = _Right._Myres();
  _Right._Tidy();
  }

 basic_string(::std:: initializer_list<_Elem> _Ilist,
  const _Alloc& _Al = allocator_type())
  : _Mybase(_Al)
  {
  _Tidy();
  assign(_Ilist.begin(), _Ilist.end());
  }

 _Myt& operator=(::std:: initializer_list<_Elem> _Ilist)
  {
  return (assign(_Ilist.begin(), _Ilist.end()));
  }

 _Myt& operator+=(::std:: initializer_list<_Elem> _Ilist)
  {
  return (append(_Ilist.begin(), _Ilist.end()));
  }

 _Myt& assign(::std:: initializer_list<_Elem> _Ilist)
  {
  return (assign(_Ilist.begin(), _Ilist.end()));
  }

 _Myt& append(::std:: initializer_list<_Elem> _Ilist)
  {
  return (append(_Ilist.begin(), _Ilist.end()));
  }

 iterator insert(const_iterator _Where,
  ::std:: initializer_list<_Elem> _Ilist)
  {
  return (insert(_Where, _Ilist.begin(), _Ilist.end()));
  }

 _Myt& replace(const_iterator _First, const_iterator _Last,
  ::std:: initializer_list<_Elem> _Ilist)
  {
  return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
  }

 ~basic_string() noexcept
  {
  _Tidy(true);
  }

          static const size_type npos;

 _Myt& operator=(const _Myt& _Right)
  {
  if (this != &_Right)
   {
   if (this->_Getal() != _Right._Getal()
    && _Alty::propagate_on_container_copy_assignment::value)
    {
    _Tidy(true);
    this->_Copy_alloc(_Right._Getal());
    }

   assign(_Right);
   }
  return (*this);
  }

 _Myt& operator=(const _Elem *_Ptr)
  {
  return (assign(_Ptr));
  }

 _Myt& operator=(_Elem _Ch)
  {
  return (assign(1, _Ch));
  }

 _Myt& operator+=(const _Myt& _Right)
  {
  return (append(_Right));
  }

 _Myt& operator+=(const _Elem *_Ptr)
  {
  return (append(_Ptr));
  }

 _Myt& operator+=(_Elem _Ch)
  {
  return (append((size_type)1, _Ch));
  }

 _Myt& append(const _Myt& _Right)
  {
  return (append(_Right, 0, npos));
  }

 _Myt& append(const _Myt& _Right,
  size_type _Roff, size_type _Count = npos)
  {
  _Right._Check_offset(_Roff);
  _Count = _Right._Clamp_suffix_size(_Roff, _Count);
  if (npos - this->_Mysize() <= _Count)
   _Xlen();

  const size_type _Num = this->_Mysize() + _Count;
  if (0 < _Count && _Grow(_Num))
   {
   _Traits::copy(this->_Myptr() + this->_Mysize(),
    _Right._Myptr() + _Roff, _Count);
   _Eos(_Num);
   }
  return (*this);
  }

 _Myt& append(const _Elem *_Ptr, size_type _Count)
  {
                                      ;
  if (_Inside(_Ptr))
   return (append(*this,
    _Ptr - this->_Myptr(), _Count));
  if (npos - this->_Mysize() <= _Count)
   _Xlen();

  const size_type _Num = this->_Mysize() + _Count;
  if (0 < _Count && _Grow(_Num))
   {
   _Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);
   _Eos(_Num);
   }
  return (*this);
  }

 _Myt& append(const _Elem *_Ptr)
  {
                      ;
  return (append(_Ptr, _Traits::length(_Ptr)));
  }

 _Myt& append(size_type _Count, _Elem _Ch)
  {
  if (npos - this->_Mysize() <= _Count)
   _Xlen();

  const size_type _Num = this->_Mysize() + _Count;
  if (0 < _Count && _Grow(_Num))
   {
   _Chassign(this->_Mysize(), _Count, _Ch);
   _Eos(_Num);
   }
  return (*this);
  }

 template<class _Iter>
  typename enable_if<_Is_iterator<_Iter>::value,
   _Myt&>::type
  append(_Iter _First, _Iter _Last)
  {
  return (replace(end(), end(), _First, _Last));
  }

 _Myt& append(const_pointer _First, const_pointer _Last)
  {
  return (replace(end(), end(), _First, _Last));
  }

 _Myt& append(const_iterator _First, const_iterator _Last)
  {
  return (replace(end(), end(), _First, _Last));
  }

 _Myt& assign(const _Myt& _Right)
  {
  return (assign(_Right, 0, npos));
  }

 _Myt& assign(const _Myt& _Right,
  size_type _Roff, size_type _Count = npos)
  {
  _Right._Check_offset(_Roff);
  _Count = _Right._Clamp_suffix_size(_Roff, _Count);

  if (this == &_Right)
   erase((size_type)(_Roff + _Count)), erase(0, _Roff);
  else if (_Grow(_Count))
   {
   _Traits::copy(this->_Myptr(),
    _Right._Myptr() + _Roff, _Count);
   _Eos(_Count);
   }
  return (*this);
  }

 _Myt& assign(const _Elem *_Ptr, size_type _Count)
  {
                                      ;
  if (_Inside(_Ptr))
   return (assign(*this,
    _Ptr - this->_Myptr(), _Count));

  if (_Grow(_Count))
   {
   _Traits::copy(this->_Myptr(), _Ptr, _Count);
   _Eos(_Count);
   }
  return (*this);
  }

 _Myt& assign(const _Elem *_Ptr)
  {
                      ;
  return (assign(_Ptr, _Traits::length(_Ptr)));
  }

 _Myt& assign(size_type _Count, _Elem _Ch)
  {
  if (_Count == npos)
   _Xlen();

  if (_Grow(_Count))
   {
   _Chassign(0, _Count, _Ch);
   _Eos(_Count);
   }
  return (*this);
  }

 template<class _Iter>
  typename enable_if<_Is_iterator<_Iter>::value,
   _Myt&>::type
  assign(_Iter _First, _Iter _Last)
  {
  return (replace(begin(), end(), _First, _Last));
  }

 _Myt& assign(const_pointer _First, const_pointer _Last)
  {
  return (replace(begin(), end(), _First, _Last));
  }

 _Myt& assign(const_iterator _First, const_iterator _Last)
  {
  return (replace(begin(), end(), _First, _Last));
  }

 _Myt& insert(size_type _Off, const _Myt& _Right)
  {
  return (insert(_Off, _Right, 0, npos));
  }

 _Myt& insert(size_type _Off,
  const _Myt& _Right, size_type _Roff, size_type _Count = npos)
  {
  _Check_offset(_Off);
  _Right._Check_offset(_Roff);
  _Count = _Right._Clamp_suffix_size(_Roff, _Count);
  if (npos - this->_Mysize() <= _Count)
   _Xlen();

  const size_type _Num = this->_Mysize() + _Count;
  if (0 < _Count && _Grow(_Num))
   {
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off,
    this->_Mysize() - _Off);
   if (this == &_Right)
    _Traits::move(this->_Myptr() + _Off,
     this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
      _Count);
   else
    _Traits::copy(this->_Myptr() + _Off,
     _Right._Myptr() + _Roff, _Count);
   _Eos(_Num);
   }
  return (*this);
  }

 _Myt& insert(size_type _Off,
  const _Elem *_Ptr, size_type _Count)
  {
                                      ;
  if (_Inside(_Ptr))
   return (insert(_Off, *this,
    _Ptr - this->_Myptr(), _Count));
  _Check_offset(_Off);
  if (npos - this->_Mysize() <= _Count)
   _Xlen();
  const size_type _Num = this->_Mysize() + _Count;
  if (0 < _Count && _Grow(_Num))
   {
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off,
    this->_Mysize() - _Off);
   _Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);
   _Eos(_Num);
   }
  return (*this);
  }

 _Myt& insert(size_type _Off, const _Elem *_Ptr)
  {
                      ;
  return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
  }

 _Myt& insert(size_type _Off,
  size_type _Count, _Elem _Ch)
  {
  _Check_offset(_Off);
  if (npos - this->_Mysize() <= _Count)
   _Xlen();
  const size_type _Num = this->_Mysize() + _Count;
  if (0 < _Count && _Grow(_Num))
   {
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off,
    this->_Mysize() - _Off);
   _Chassign(_Off, _Count, _Ch);
   _Eos(_Num);
   }
  return (*this);
  }

 iterator insert(const_iterator _Where)
  {
  return (insert(_Where, _Elem()));
  }

 iterator insert(const_iterator _Where, _Elem _Ch)
  {
  size_type _Off = _Where - begin();
  insert(_Off, 1, _Ch);
  return (begin() + _Off);
  }

 iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
  {
  size_type _Off = _Where - begin();
  insert(_Off, _Count, _Ch);
  return (begin() + _Off);
  }

 template<class _Iter>
  typename enable_if<_Is_iterator<_Iter>::value,
   iterator>::type
  insert(const_iterator _Where, _Iter _First, _Iter _Last)
  {
  size_type _Off = _Where - begin();
  replace(_Where, _Where, _First, _Last);
  return (begin() + _Off);
  }

 iterator insert(const_iterator _Where,
  const_pointer _First, const_pointer _Last)
  {
  size_type _Off = _Where - begin();
  replace(_Where, _Where, _First, _Last);
  return (begin() + _Off);
  }

 iterator insert(const_iterator _Where,
  const_iterator _First, const_iterator _Last)
  {
  size_type _Off = _Where - begin();
  replace(_Where, _Where, _First, _Last);
  return (begin() + _Off);
  }

 _Myt& erase(size_type _Off = 0)
  {
  _Check_offset(_Off);
  _Eos(_Off);
  return (*this);
  }

 _Myt& erase(size_type _Off, size_type _Count)
  {
  _Check_offset(_Off);
  if (this->_Mysize() - _Off <= _Count)
   _Eos(_Off);
  else if (0 < _Count)
   {
   value_type *_Ptr = this->_Myptr() + _Off;
   size_type _Newsize = this->_Mysize() - _Count;
   _Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
   _Eos(_Newsize);
   }
  return (*this);
  }

 iterator erase(const_iterator _Where)
  {
  size_type _Count = _Where - begin();
  erase(_Count, 1);
  return (begin() + _Count);
  }

 iterator erase(const_iterator _First, const_iterator _Last)
  {
                             ;
  size_type _Count = _First - begin();
  erase(_Count, _Last - _First);
  return (begin() + _Count);
  }

 void clear() noexcept
  {
  _Eos(0);
  }

 _Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
  {
  return (replace(_Off, _N0, _Right, 0, npos));
  }

 _Myt& replace(size_type _Off,
  size_type _N0, const _Myt& _Right, size_type _Roff,
   size_type _Count = npos)
  {
  _Check_offset(_Off);
  _Right._Check_offset(_Roff);
  _N0 = _Clamp_suffix_size(_Off, _N0);
  _Count = _Right._Clamp_suffix_size(_Roff, _Count);
  if (npos - _Count <= this->_Mysize() - _N0)
   _Xlen();

  const size_type _Nm = this->_Mysize() - _N0 - _Off;
  const size_type _Newsize = this->_Mysize() + _Count - _N0;
  if (this->_Mysize() < _Newsize)
   _Grow(_Newsize);

  if (_Count == _N0)
   {
   _Traits::move(this->_Myptr() + _Off,
    _Right._Myptr() + _Roff, _Count);
   }
  else if (this != &_Right)
   {
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off + _N0, _Nm);
   _Traits::copy(this->_Myptr() + _Off,
    _Right._Myptr() + _Roff, _Count);
   }
  else if (_Count < _N0)
   {
   _Traits::move(this->_Myptr() + _Off,
    this->_Myptr() + _Roff, _Count);
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off + _N0, _Nm);
   }
  else if (_Roff <= _Off)
   {
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off + _N0, _Nm);
   _Traits::move(this->_Myptr() + _Off,
    this->_Myptr() + _Roff, _Count);
   }
  else if (_Off + _N0 <= _Roff)
   {
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off + _N0, _Nm);
   _Traits::move(this->_Myptr() + _Off,
    this->_Myptr() + (_Roff + _Count - _N0),
    _Count);
   }
  else
   {
   _Traits::move(this->_Myptr() + _Off,
    this->_Myptr() + _Roff, _N0);
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off + _N0, _Nm);
   _Traits::move(this->_Myptr() + _Off + _N0,
    this->_Myptr() + _Roff + _Count,
    _Count - _N0);
   }

  _Eos(_Newsize);
  return (*this);
  }

 _Myt& replace(size_type _Off,
  size_type _N0, const _Elem *_Ptr, size_type _Count)
  {
                                      ;
  if (_Inside(_Ptr))
   return (replace(_Off, _N0, *this,
    _Ptr - this->_Myptr(),
    _Count));
  _Check_offset(_Off);
  _N0 = _Clamp_suffix_size(_Off, _N0);
  if (npos - _Count <= this->_Mysize() - _N0)
   _Xlen();
  size_type _Nm = this->_Mysize() - _N0 - _Off;

  if (_Count < _N0)
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off + _N0,
    _Nm);
  const size_type _Num = this->_Mysize() + _Count - _N0;
  if ((0 < _Count || 0 < _N0)
   && _Grow(_Num))
   {
   if (_N0 < _Count)
    _Traits::move(this->_Myptr() + _Off + _Count,
     this->_Myptr() + _Off + _N0, _Nm);
   _Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);
   _Eos(_Num);
   }
  return (*this);
  }

 _Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
  {
                      ;
  return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
  }

 _Myt& replace(size_type _Off,
  size_type _N0, size_type _Count, _Elem _Ch)
  {
  _Check_offset(_Off);
  _N0 = _Clamp_suffix_size(_Off, _N0);
  if (npos - _Count <= this->_Mysize() - _N0)
   _Xlen();
  size_type _Nm = this->_Mysize() - _N0 - _Off;

  if (_Count < _N0)
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off + _N0,
    _Nm);
  const size_type _Num = this->_Mysize() + _Count - _N0;
  if ((0 < _Count || 0 < _N0)
   && _Grow(_Num))
   {
   if (_N0 < _Count)
    _Traits::move(this->_Myptr() + _Off + _Count,
     this->_Myptr() + _Off + _N0, _Nm);
   _Chassign(_Off, _Count, _Ch);
   _Eos(_Num);
   }
  return (*this);
  }

 _Myt& replace(const_iterator _First, const_iterator _Last,
  const _Myt& _Right)
  {
  return (replace(_First - begin(), _Last - _First, _Right));
  }

 _Myt& replace(const_iterator _First, const_iterator _Last,
  const _Elem *_Ptr, size_type _Count)
  {
  return (replace(_First - begin(), _Last - _First, _Ptr, _Count));
  }

 _Myt& replace(const_iterator _First, const_iterator _Last,
  const _Elem *_Ptr)
  {
  return (replace(_First - begin(), _Last - _First, _Ptr));
  }

 _Myt& replace(const_iterator _First, const_iterator _Last,
  size_type _Count, _Elem _Ch)
  {
  return (replace(_First - begin(), _Last - _First, _Count, _Ch));
  }

 template<class _Iter>
  typename enable_if<_Is_iterator<_Iter>::value,
   _Myt&>::type
  replace(const_iterator _First, const_iterator _Last,
   _Iter _First2, _Iter _Last2)
  {
  _Myt _Right(_First2, _Last2);
  replace(_First, _Last, _Right);
  return (*this);
  }

 _Myt& replace(const_iterator _First, const_iterator _Last,
  const_pointer _First2, const_pointer _Last2)
  {
  if (_First2 == _Last2)
   erase(_First - begin(), _Last - _First);
  else
   replace(_First - begin(), _Last - _First,
    &*_First2, _Last2 - _First2);
  return (*this);
  }

 _Myt& replace(const_iterator _First, const_iterator _Last,
  pointer _First2, pointer _Last2)
  {
  if (_First2 == _Last2)
   erase(_First - begin(), _Last - _First);
  else
   replace(_First - begin(), _Last - _First,
    &*_First2, _Last2 - _First2);
  return (*this);
  }

 _Myt& replace(const_iterator _First, const_iterator _Last,
  const_iterator _First2, const_iterator _Last2)
  {
  if (_First2 == _Last2)
   erase(_First - begin(), _Last - _First);
  else
   replace(_First - begin(), _Last - _First,
    &*_First2, _Last2 - _First2);
  return (*this);
  }

 _Myt& replace(const_iterator _First, const_iterator _Last,
  iterator _First2, iterator _Last2)
  {
  if (_First2 == _Last2)
   erase(_First - begin(), _Last - _First);
  else
   replace(_First - begin(), _Last - _First,
    &*_First2, _Last2 - _First2);
  return (*this);
  }

 iterator begin() noexcept
  {
  auto _Mydata = &this->_Get_data();
  return (iterator(this->_Getal().address(*_Mydata->_Myptr()), _Mydata));
  }

 const_iterator begin() const noexcept
  {
  auto _Mydata = &this->_Get_data();
  return (const_iterator(this->_Getal().address(*_Mydata->_Myptr()), _Mydata));
  }

 iterator end() noexcept
  {
  auto _Mydata = &this->_Get_data();
  return (iterator(this->_Getal().address(*_Mydata->_Myptr()) + _Mydata->_Mysize, _Mydata));
  }

 const_iterator end() const noexcept
  {
  auto _Mydata = &this->_Get_data();
  return (const_iterator(this->_Getal().address(*_Mydata->_Myptr()) + _Mydata->_Mysize, _Mydata));
  }

 reverse_iterator rbegin() noexcept
  {
  return (reverse_iterator(end()));
  }

 const_reverse_iterator rbegin() const noexcept
  {
  return (const_reverse_iterator(end()));
  }

 reverse_iterator rend() noexcept
  {
  return (reverse_iterator(begin()));
  }

 const_reverse_iterator rend() const noexcept
  {
  return (const_reverse_iterator(begin()));
  }

 const_iterator cbegin() const noexcept
  {
  return (begin());
  }

 const_iterator cend() const noexcept
  {
  return (end());
  }

 const_reverse_iterator crbegin() const noexcept
  {
  return (rbegin());
  }

 const_reverse_iterator crend() const noexcept
  {
  return (rend());
  }

 void shrink_to_fit()
  {
  if ((size() | this->_ALLOC_MASK) < capacity())
   {
   _Myt _Tmp(*this);
   swap(_Tmp);
   }
  }

 reference at(size_type _Off)
  {
  _Check_offset_exclusive(_Off);
  return (this->_Myptr()[_Off]);
  }

 const_reference at(size_type _Off) const
  {
  _Check_offset_exclusive(_Off);
  return (this->_Myptr()[_Off]);
  }

 reference operator[](size_type _Off)
  {
# 1688 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xstring" 3
  return (this->_Myptr()[_Off]);
  }

 const_reference operator[](size_type _Off) const
  {
# 1701 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xstring" 3
  return (this->_Myptr()[_Off]);
  }

 void push_back(_Elem _Ch)
  {
  auto& _Dx = this->_Get_data();
  auto& _Sz = _Dx._Mysize;
  if (_Sz == _Dx._Myres)
   _Grow(_Sz + 1);
  auto _Ptr = _Dx._Myptr();
  _Traits::assign(_Ptr[_Sz], _Ch);
  ++_Sz;
  _Traits::assign(_Ptr[_Sz], _Elem());
  }

 void pop_back()
  {
  erase(this->_Mysize() - 1);
  }

 reference front()
  {
  return (*begin());
  }

 const_reference front() const
  {
  return (*begin());
  }

 reference back()
  {
  return (*(end() - 1));
  }

 const_reference back() const
  {
  return (*(end() - 1));
  }

 const _Elem *c_str() const noexcept
  {
  return (this->_Myptr());
  }

 const _Elem *data() const noexcept
  {
  return (this->_Myptr());
  }
# 1758 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xstring" 3
 size_type length() const noexcept
  {
  return (this->_Mysize());
  }

 size_type size() const noexcept
  {
  return (this->_Mysize());
  }

 size_type max_size() const noexcept
  {
  const size_type _Num = this->_Getal().max_size();
  return (_Num <= 1 ? 1 : _Num - 1);
  }

 void resize(size_type _Newsize)
  {
  resize(_Newsize, _Elem());
  }

 void resize(size_type _Newsize, _Elem _Ch)
  {
  if (_Newsize <= this->_Mysize())
   _Eos(_Newsize);
  else
   append(_Newsize - this->_Mysize(), _Ch);
  }

 size_type capacity() const noexcept
  {
  return (this->_Myres());
  }

 void reserve(size_type _Newcap = 0)
  {
  if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)
   {
   size_type _Size = this->_Mysize();
   if (_Grow(_Newcap, true))
    _Eos(_Size);
   }
  }

 bool empty() const noexcept
  {
  return (this->_Mysize() == 0);
  }


 size_type copy(_Elem *_Ptr,
  size_type _Count, size_type _Off = 0) const
  {
                                      ;
  _Check_offset(_Off);
  _Count = _Clamp_suffix_size(_Off, _Count);
  _Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
  return (_Count);
  }

 size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
  size_type _Count, size_type _Off = 0) const
  {
                                       ;
  _Check_offset(_Off);
  _Count = _Clamp_suffix_size(_Off, _Count);
  _Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
  return (_Count);
  }

 void _Swap_bx(_Myt& _Right)
  {
  if (this->_BUF_SIZE <= this->_Myres())
   if (this->_BUF_SIZE <= _Right._Myres())
    _Swap_adl(this->_Bx()._Ptr, _Right._Bx()._Ptr);
   else
    {
    pointer _Ptr = this->_Bx()._Ptr;
    this->_Getal().destroy(::std:: addressof(this->_Bx()._Ptr));
    _Traits::copy(this->_Bx()._Buf,
     _Right._Bx()._Buf, _Right._Mysize() + 1);
    this->_Getal().construct(::std:: addressof(_Right._Bx()._Ptr), _Ptr);
    }
  else
   if (_Right._Myres() < this->_BUF_SIZE)
    ::std:: swap(this->_Bx()._Buf, _Right._Bx()._Buf);
   else
    {
    pointer _Ptr = _Right._Bx()._Ptr;
    this->_Getal().destroy(::std:: addressof(_Right._Bx()._Ptr));
    _Traits::copy(_Right._Bx()._Buf,
     this->_Bx()._Buf, this->_Mysize() + 1);
    this->_Getal().construct(::std:: addressof(this->_Bx()._Ptr), _Ptr);
    }
  }

 void swap(_Myt& _Right)
  noexcept(_Alty::propagate_on_container_swap::value || _Alty::is_always_equal::value)

  {
  if (this != &_Right)
   {
   _Pocs(this->_Getal(), _Right._Getal());
   this->_Swap_all(_Right);
   _Swap_bx(_Right);
   ::std:: swap(this->_Mysize(), _Right._Mysize());
   ::std:: swap(this->_Myres(), _Right._Myres());
   }
  }

 size_type find(const _Myt& _Right, size_type _Off = 0) const noexcept
  {
  return (find(_Right._Myptr(), _Off, _Right.size()));
  }

 size_type find(const _Elem *_Ptr,
  size_type _Off, size_type _Count) const
  {
                                      ;
  if (_Count == 0 && _Off <= this->_Mysize())
   return (_Off);

  size_type _Nm;
  if (_Off < this->_Mysize() && _Count <= (_Nm = this->_Mysize() - _Off))
   {
   const _Elem *_Uptr, *_Vptr;
   for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
    (_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
    _Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
    if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
     return (_Uptr - this->_Myptr());
   }

  return (npos);
  }

 size_type find(const _Elem *_Ptr, size_type _Off = 0) const
  {
                      ;
  return (find(_Ptr, _Off, _Traits::length(_Ptr)));
  }

 size_type find(_Elem _Ch, size_type _Off = 0) const
  {
  return (find((const _Elem *)&_Ch, _Off, 1));
  }

 size_type rfind(const _Myt& _Right, size_type _Off = npos) const noexcept
  {
  return (rfind(_Right._Myptr(), _Off, _Right.size()));
  }

 size_type rfind(const _Elem *_Ptr,
  size_type _Off, size_type _Count) const
  {
                                      ;
  if (_Count == 0)
   return (_Off < this->_Mysize() ? _Off
    : this->_Mysize());
  if (_Count <= this->_Mysize())
   {
   const _Elem *_Uptr = this->_Myptr() +
    (_Off < this->_Mysize() - _Count ? _Off
     : this->_Mysize() - _Count);
   for (; ; --_Uptr)
    if (_Traits::eq(*_Uptr, *_Ptr)
     && _Traits::compare(_Uptr, _Ptr, _Count) == 0)
     return (_Uptr - this->_Myptr());
    else if (_Uptr == this->_Myptr())
     break;
   }

  return (npos);
  }

 size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
  {
                      ;
  return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
  }

 size_type rfind(_Elem _Ch, size_type _Off = npos) const
  {
  return (rfind((const _Elem *)&_Ch, _Off, 1));
  }

 size_type find_first_of(const _Myt& _Right,
  size_type _Off = 0) const noexcept
  {
  return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
  }

 size_type find_first_of(const _Elem *_Ptr,
  size_type _Off, size_type _Count) const
  {
                                      ;
  if (0 < _Count && _Off < this->_Mysize())
   {
   const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
   for (const _Elem *_Uptr = this->_Myptr() + _Off;
    _Uptr < _Vptr; ++_Uptr)
    if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
     return (_Uptr - this->_Myptr());
   }

  return (npos);
  }

 size_type find_first_of(const _Elem *_Ptr,
  size_type _Off = 0) const
  {
                      ;
  return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
  }

 size_type find_first_of(_Elem _Ch,
  size_type _Off = 0) const
  {
  return (find((const _Elem *)&_Ch, _Off, 1));
  }

 size_type find_last_of(const _Myt& _Right,
  size_type _Off = npos) const noexcept
  {
  return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
  }

 size_type find_last_of(const _Elem *_Ptr,
  size_type _Off, size_type _Count) const
  {
                                      ;
  if (0 < _Count && 0 < this->_Mysize())
   {
   const _Elem *_Uptr = this->_Myptr()
    + (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
   for (; ; --_Uptr)
    if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
     return (_Uptr - this->_Myptr());
    else if (_Uptr == this->_Myptr())
     break;
   }

  return (npos);
  }

 size_type find_last_of(const _Elem *_Ptr,
  size_type _Off = npos) const
  {
                      ;
  return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
  }

 size_type find_last_of(_Elem _Ch,
  size_type _Off = npos) const
  {
  return (rfind((const _Elem *)&_Ch, _Off, 1));
  }

 size_type find_first_not_of(const _Myt& _Right,
  size_type _Off = 0) const noexcept
  {
  return (find_first_not_of(_Right._Myptr(), _Off,
   _Right.size()));
  }

 size_type find_first_not_of(const _Elem *_Ptr,
  size_type _Off, size_type _Count) const
  {
                                      ;
  if (_Off < this->_Mysize())
   {
   const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
   for (const _Elem *_Uptr = this->_Myptr() + _Off;
    _Uptr < _Vptr; ++_Uptr)
    if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
     return (_Uptr - this->_Myptr());
   }
  return (npos);
  }

 size_type find_first_not_of(const _Elem *_Ptr,
  size_type _Off = 0) const
  {
                      ;
  return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
  }

 size_type find_first_not_of(_Elem _Ch,
  size_type _Off = 0) const
  {
  return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
  }

 size_type find_last_not_of(const _Myt& _Right,
  size_type _Off = npos) const noexcept
  {
  return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
  }

 size_type find_last_not_of(const _Elem *_Ptr,
  size_type _Off, size_type _Count) const
  {
                                      ;
  if (0 < this->_Mysize())
   {
   const _Elem *_Uptr = this->_Myptr()
    + (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
   for (; ; --_Uptr)
    if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
     return (_Uptr - this->_Myptr());
    else if (_Uptr == this->_Myptr())
     break;
   }
  return (npos);
  }

 size_type find_last_not_of(const _Elem *_Ptr,
  size_type _Off = npos) const
  {
                      ;
  return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
  }

 size_type find_last_not_of(_Elem _Ch,
  size_type _Off = npos) const
  {
  return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
  }

 _Myt substr(size_type _Off = 0, size_type _Count = npos) const
  {
  return (_Myt(*this, _Off, _Count, get_allocator()));
  }

 static int _Traits_compare(const _Elem * const _Left, const size_type _Left_size,
  const _Elem * const _Right, const size_type _Right_size)
  {
  const size_type _Min_size = _Left_size < _Right_size ? _Left_size : _Right_size;
  const int _Ans = _Traits::compare(_Left, _Right, _Min_size);

  if (_Ans != 0)
   return (_Ans);

  if (_Left_size < _Right_size)
   return (-1);

  if (_Left_size > _Right_size)
   return (1);

  return (0);
  }

 size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const
  {
  const size_type _Max_effective_size = this->_Mysize() - _Off;
  if (_Size <= _Max_effective_size)
   return (_Size);
  else
   return (_Max_effective_size);
  }

 int compare(const _Myt& _Right) const noexcept
  {
  return (_Traits_compare(this->_Myptr(), this->_Mysize(),
   _Right._Myptr(), _Right._Mysize()));
  }

 int compare(size_type _Off,
  size_type _N0, const _Myt& _Right) const
  {
  _Check_offset(_Off);
  return (_Traits_compare(this->_Myptr() + _Off, _Clamp_suffix_size(_Off, _N0),
   _Right._Myptr(), _Right._Mysize()));
  }

 int compare(size_type _Off,
  size_type _N0, const _Myt& _Right,
  size_type _Roff, size_type _Count = npos) const
  {
  _Check_offset(_Off);
  _Right._Check_offset(_Roff);
  return (_Traits_compare(this->_Myptr() + _Off, _Clamp_suffix_size(_Off, _N0),
   _Right._Myptr() + _Roff, _Right._Clamp_suffix_size(_Roff, _Count)));
  }

 int compare(const _Elem *_Ptr) const
  {
                      ;
  return (_Traits_compare(this->_Myptr(), this->_Mysize(),
   _Ptr, _Traits::length(_Ptr)));
  }

 int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
  {
                      ;
  _Check_offset(_Off);
  return (_Traits_compare(this->_Myptr() + _Off, _Clamp_suffix_size(_Off, _N0),
   _Ptr, _Traits::length(_Ptr)));
  }

 int compare(size_type _Off,
  size_type _N0, const _Elem *_Ptr, size_type _Count) const
  {
                                      ;
  _Check_offset(_Off);
  return (_Traits_compare(this->_Myptr() + _Off, _Clamp_suffix_size(_Off, _N0),
   _Ptr, _Count));
  }

 allocator_type get_allocator() const noexcept
  {
  allocator_type _Ret(this->_Getal());
  return (_Ret);
  }

 void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
  {
  if (_Count == 1)
   _Traits::assign(*(this->_Myptr() + _Off), _Ch);
  else
   _Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
  }

 void _Copy(size_type _Newsize, size_type _Oldlen)
  {
  size_type _Newres = _Newsize | this->_ALLOC_MASK;
  if (max_size() < _Newres)
   _Newres = _Newsize;
  else if (this->_Myres() / 2 <= _Newres / 3)
   ;
  else if (this->_Myres() <= max_size() - this->_Myres() / 2)
   _Newres = this->_Myres()
    + this->_Myres() / 2;
  else
   _Newres = max_size();

  pointer _Ptr;
  try {
   _Ptr = this->_Getal().allocate(_Newres + 1);
  } catch (...) {
   _Newres = _Newsize;
   try {
    _Ptr = this->_Getal().allocate(_Newres + 1);
   } catch (...) {
   _Tidy(true);
   throw;
   }
  }

  if (0 < _Oldlen)
   _Traits::copy(_Unfancy(_Ptr), this->_Myptr(),
    _Oldlen);
  _Tidy(true);
  this->_Getal().construct(::std:: addressof(this->_Bx()._Ptr), _Ptr);
  this->_Myres() = _Newres;
  _Eos(_Oldlen);
  }

 void _Eos(size_type _Newsize)
  {
  auto& _Dx = this->_Get_data();
  _Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());
  }

 bool _Grow(size_type _Newsize,
  bool _Trim = false)
  {
  if (max_size() < _Newsize)
   _Xlen();
  if (this->_Myres() < _Newsize)
   _Copy(_Newsize, this->_Mysize());
  else if (_Trim && _Newsize < this->_BUF_SIZE)
   _Tidy(true,
    _Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
  else if (_Newsize == 0)
   _Eos(0);
  return (0 < _Newsize);
  }

 bool _Inside(const _Elem *_Ptr)
  {
  if (_Ptr == nullptr_t{} || _Ptr < this->_Myptr()
   || this->_Myptr() + this->_Mysize() <= _Ptr)
   return (false);
  else
   return (true);
  }

 void _Tidy(bool _Built = false,
  size_type _Newsize = 0)
  {
  if (!_Built)
   ;
  else if (this->_BUF_SIZE <= this->_Myres())
   {
   pointer _Ptr = this->_Bx()._Ptr;
   this->_Getal().destroy(::std:: addressof(this->_Bx()._Ptr));
   if (0 < _Newsize)
    _Traits::copy(this->_Bx()._Buf,
     _Unfancy(_Ptr), _Newsize);
   this->_Getal().deallocate(_Ptr, this->_Myres() + 1);
   }
  this->_Myres() = this->_BUF_SIZE - 1;
  _Eos(_Newsize);
  }

 [[noreturn]] void _Xlen() const
  {
  _Xlength_error("string too long");
  }

 void _Check_offset(const size_type _Off) const
  {
  if (this->_Mysize() < _Off)
   _Xran();
  }

 void _Check_offset_exclusive(const size_type _Off) const
  {
  if (this->_Mysize() <= _Off)
   _Xran();
  }

 [[noreturn]] void _Xran() const
  {
  _Xout_of_range("invalid string position");
  }
 };


template<class _Elem,
 class _Traits,
 class _Alloc>
          const typename basic_string<_Elem, _Traits, _Alloc>::size_type
  basic_string<_Elem, _Traits, _Alloc>::npos =
   (typename basic_string<_Elem, _Traits, _Alloc>::size_type)(-1);



template<class _Elem,
 class _Traits,
 class _Alloc> inline
 void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
  basic_string<_Elem, _Traits, _Alloc>& _Right)
   noexcept(noexcept(_Left.swap(_Right)))
 {
 _Left.swap(_Right);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 basic_string<_Elem, _Traits, _Alloc> _Ans;
 _Ans.reserve(_Left.size() + _Right.size());
 _Ans += _Left;
 _Ans += _Right;
 return (_Ans);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  const _Elem *_Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 basic_string<_Elem, _Traits, _Alloc> _Ans;
 _Ans.reserve(_Traits::length(_Left) + _Right.size());
 _Ans += _Left;
 _Ans += _Right;
 return (_Ans);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  const _Elem _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 basic_string<_Elem, _Traits, _Alloc> _Ans;
 _Ans.reserve(1 + _Right.size());
 _Ans += _Left;
 _Ans += _Right;
 return (_Ans);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const _Elem *_Right)
 {
 basic_string<_Elem, _Traits, _Alloc> _Ans;
 _Ans.reserve(_Left.size() + _Traits::length(_Right));
 _Ans += _Left;
 _Ans += _Right;
 return (_Ans);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const _Elem _Right)
 {
 basic_string<_Elem, _Traits, _Alloc> _Ans;
 _Ans.reserve(_Left.size() + 1);
 _Ans += _Left;
 _Ans += _Right;
 return (_Ans);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  basic_string<_Elem, _Traits, _Alloc>&& _Right)
 {
 return (::std:: move(_Right.insert(0, _Left)));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  basic_string<_Elem, _Traits, _Alloc>&& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (::std:: move(_Left.append(_Right)));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  basic_string<_Elem, _Traits, _Alloc>&& _Left,
  basic_string<_Elem, _Traits, _Alloc>&& _Right)
 {
 if (_Right.size() <= _Left.capacity() - _Left.size()
  || _Right.capacity() - _Right.size() < _Left.size())
  return (::std:: move(_Left.append(_Right)));
 else
  return (::std:: move(_Right.insert(0, _Left)));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  const _Elem *_Left,
  basic_string<_Elem, _Traits, _Alloc>&& _Right)
 {
 return (::std:: move(_Right.insert(0, _Left)));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  const _Elem _Left,
  basic_string<_Elem, _Traits, _Alloc>&& _Right)
 {
 typedef typename basic_string<_Elem, _Traits, _Alloc>::size_type
  size_type;
 return (::std:: move(_Right.insert((size_type)0, (size_type)1, _Left)));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  basic_string<_Elem, _Traits, _Alloc>&& _Left,
  const _Elem *_Right)
 {
 return (::std:: move(_Left.append(_Right)));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  basic_string<_Elem, _Traits, _Alloc>&& _Left,
  const _Elem _Right)
 {
 return (::std:: move(_Left.append(1, _Right)));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator==(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
 {
 return (_Left.compare(_Right) == 0);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator==(
  const _Elem * _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (_Right.compare(_Left) == 0);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator==(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const _Elem *_Right)
 {
 return (_Left.compare(_Right) == 0);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator!=(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
 {
 return (!(_Left == _Right));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator!=(
  const _Elem *_Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator!=(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const _Elem *_Right)
 {
 return (!(_Left == _Right));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator<(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
 {
 return (_Left.compare(_Right) < 0);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator<(
  const _Elem * _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (_Right.compare(_Left) > 0);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator<(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const _Elem *_Right)
 {
 return (_Left.compare(_Right) < 0);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator>(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
 {
 return (_Right < _Left);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator>(
  const _Elem * _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (_Right < _Left);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator>(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const _Elem *_Right)
 {
 return (_Right < _Left);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator<=(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
 {
 return (!(_Right < _Left));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator<=(
  const _Elem * _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator<=(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const _Elem *_Right)
 {
 return (!(_Right < _Left));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator>=(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
 {
 return (!(_Left < _Right));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator>=(
  const _Elem * _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (!(_Left < _Right));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator>=(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const _Elem *_Right)
 {
 return (!(_Left < _Right));
 }

typedef basic_string<char, char_traits<char>, allocator<char> >
 string;
typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >
 wstring;


template<class _Elem,
 class _Traits,
 class _Alloc>
 struct hash<basic_string<_Elem, _Traits, _Alloc> >
 {
 typedef basic_string<_Elem, _Traits, _Alloc> argument_type;
 typedef size_t result_type;

 size_t operator()(const argument_type& _Keyval) const
  {
  return (_Hash_seq((const unsigned char *)_Keyval.c_str(),
   _Keyval.size() * sizeof (_Elem)));
  }
 };

typedef basic_string<char16_t, char_traits<char16_t>, allocator<char16_t> >
 u16string;
typedef basic_string<char32_t, char_traits<char32_t>, allocator<char32_t> >
 u32string;
}


#pragma warning(pop)
#pragma pack(pop)
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\stdexcept" 2 3


#pragma pack(push,8)
#pragma warning(push, 3)


namespace std {

class logic_error
 : public ::std:: exception
 {
public:
 typedef ::std:: exception _Mybase;

 explicit logic_error(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit logic_error(const char *_Message)
  : _Mybase(_Message)
  {
  }
# 40 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\stdexcept" 3
 };


class domain_error
 : public logic_error
 {
public:
 typedef logic_error _Mybase;

 explicit domain_error(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit domain_error(const char *_Message)
  : _Mybase(_Message)
  {
  }
# 68 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\stdexcept" 3
 };


class invalid_argument
 : public logic_error
 {
public:
 typedef logic_error _Mybase;

 explicit invalid_argument(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit invalid_argument(const char *_Message)
  : _Mybase(_Message)
  {
  }
# 96 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\stdexcept" 3
 };


class length_error
 : public logic_error
 {
public:
 typedef logic_error _Mybase;

 explicit length_error(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit length_error(const char *_Message)
  : _Mybase(_Message)
  {
  }
# 124 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\stdexcept" 3
 };


class out_of_range
 : public logic_error
 {
public:
 typedef logic_error _Mybase;

 explicit out_of_range(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit out_of_range(const char *_Message)
  : _Mybase(_Message)
  {
  }
# 152 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\stdexcept" 3
 };


class runtime_error
 : public ::std:: exception
 {
public:
 typedef ::std:: exception _Mybase;

 explicit runtime_error(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit runtime_error(const char *_Message)
  : _Mybase(_Message)
  {
  }
# 180 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\stdexcept" 3
 };


class overflow_error
 : public runtime_error
 {
public:
 typedef runtime_error _Mybase;

 explicit overflow_error(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit overflow_error(const char *_Message)
  : _Mybase(_Message)
  {
  }
# 208 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\stdexcept" 3
 };


class underflow_error
 : public runtime_error
 {
public:
 typedef runtime_error _Mybase;

 explicit underflow_error(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit underflow_error(const char *_Message)
  : _Mybase(_Message)
  {
  }
# 236 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\stdexcept" 3
 };


class range_error
 : public runtime_error
 {
public:
 typedef runtime_error _Mybase;

 explicit range_error(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit range_error(const char *_Message)
  : _Mybase(_Message)
  {
  }
# 264 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\stdexcept" 3
 };
}

#pragma warning(pop)
#pragma pack(pop)
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vector" 2 3


#pragma pack(push,8)
#pragma warning(push, 3)



#pragma warning(disable: 4127)
#pragma warning(disable: 4244)

namespace std {



template<class _Myvec>
 class _Vector_const_iterator
  : public _Iterator012<random_access_iterator_tag,
   typename _Myvec::value_type,
   typename _Myvec::difference_type,
   typename _Myvec::const_pointer,
   typename _Myvec::const_reference,
   _Iterator_base>
 {
public:
 typedef _Vector_const_iterator<_Myvec> _Myiter;
 typedef random_access_iterator_tag iterator_category;

 typedef typename _Myvec::value_type value_type;
 typedef typename _Myvec::difference_type difference_type;
 typedef typename _Myvec::const_pointer pointer;
 typedef typename _Myvec::const_reference reference;
 typedef typename _Myvec::pointer _Tptr;

 _Vector_const_iterator()
  : _Ptr()
  {
  }

 _Vector_const_iterator(_Tptr _Parg, const _Container_base *_Pvector)
  : _Ptr(_Parg)
  {
  this->_Adopt(_Pvector);
  }

 typedef pointer _Unchecked_type;

 _Myiter& _Rechecked(_Unchecked_type _Right)
  {
  _Ptr = _Const_cast(_Right);
  return (*this);
  }

 _Unchecked_type _Unchecked() const
  {
  return (_Ptr);
  }

 reference operator*() const
  {
# 84 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vector" 3
                                    ;

  return (*_Ptr);
  }

 pointer operator->() const
  {
  return (pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
# 113 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vector" 3
  ++_Ptr;
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
# 143 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vector" 3
  --_Ptr;
  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }

 _Myiter& operator+=(difference_type _Off)
  {
# 179 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vector" 3
  _Ptr += _Off;
  return (*this);
  }

 _Myiter operator+(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp += _Off);
  }

 _Myiter& operator-=(difference_type _Off)
  {
  return (*this += -_Off);
  }

 _Myiter operator-(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp -= _Off);
  }

 difference_type operator-(const _Myiter& _Right) const
  {
  _Compat(_Right);
  return (_Ptr - _Right._Ptr);
  }

 reference operator[](difference_type _Off) const
  {
  return (*(*this + _Off));
  }

 bool operator==(const _Myiter& _Right) const
  {
  _Compat(_Right);
  return (_Ptr == _Right._Ptr);
  }

 bool operator!=(const _Myiter& _Right) const
  {
  return (!(*this == _Right));
  }

 bool operator<(const _Myiter& _Right) const
  {
  _Compat(_Right);
  return (_Ptr < _Right._Ptr);
  }

 bool operator>(const _Myiter& _Right) const
  {
  return (_Right < *this);
  }

 bool operator<=(const _Myiter& _Right) const
  {
  return (!(_Right < *this));
  }

 bool operator>=(const _Myiter& _Right) const
  {
  return (!(*this < _Right));
  }
# 260 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vector" 3
 void _Compat(const _Myiter&) const
  {
  }


 _Tptr _Ptr;
 };

template<class _Myvec> inline
 typename _Vector_const_iterator<_Myvec>::_Unchecked_type
  _Unchecked(_Vector_const_iterator<_Myvec> _Iter)
 {
 return (_Iter._Unchecked());
 }

template<class _Myvec> inline
 _Vector_const_iterator<_Myvec>&
  _Rechecked(_Vector_const_iterator<_Myvec>& _Iter,
   typename _Vector_const_iterator<_Myvec>
    ::_Unchecked_type _Right)
 {
 return (_Iter._Rechecked(_Right));
 }

template<class _Myvec> inline
 _Vector_const_iterator<_Myvec> operator+(
  typename _Vector_const_iterator<_Myvec>::difference_type _Off,
  _Vector_const_iterator<_Myvec> _Next)
 {
 return (_Next += _Off);
 }


template<class _Myvec>
 class _Vector_iterator
  : public _Vector_const_iterator<_Myvec>
 {
public:
 typedef _Vector_iterator<_Myvec> _Myiter;
 typedef _Vector_const_iterator<_Myvec> _Mybase;
 typedef random_access_iterator_tag iterator_category;

 typedef typename _Myvec::value_type value_type;
 typedef typename _Myvec::difference_type difference_type;
 typedef typename _Myvec::pointer pointer;
 typedef typename _Myvec::reference reference;

 _Vector_iterator()
  {
  }

 _Vector_iterator(pointer _Parg, const _Container_base *_Pvector)
  : _Mybase(_Parg, _Pvector)
  {
  }

 typedef pointer _Unchecked_type;

 _Myiter& _Rechecked(_Unchecked_type _Right)
  {
  this->_Ptr = _Right;
  return (*this);
  }

 _Unchecked_type _Unchecked() const
  {
  return (this->_Ptr);
  }

 reference operator*() const
  {
  return ((reference)**(_Mybase *)this);
  }

 pointer operator->() const
  {
  return (pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
  ++*(_Mybase *)this;
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
  --*(_Mybase *)this;
  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }

 _Myiter& operator+=(difference_type _Off)
  {
  *(_Mybase *)this += _Off;
  return (*this);
  }

 _Myiter operator+(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp += _Off);
  }

 _Myiter& operator-=(difference_type _Off)
  {
  return (*this += -_Off);
  }

 _Myiter operator-(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp -= _Off);
  }

 difference_type operator-(const _Mybase& _Right) const
  {
  return (*(_Mybase *)this - _Right);
  }

 reference operator[](difference_type _Off) const
  {
  return (*(*this + _Off));
  }
 };

template<class _Myvec> inline
 typename _Vector_iterator<_Myvec>::_Unchecked_type
  _Unchecked(_Vector_iterator<_Myvec> _Iter)
 {
 return (_Iter._Unchecked());
 }

template<class _Myvec> inline
 _Vector_iterator<_Myvec>&
  _Rechecked(_Vector_iterator<_Myvec>& _Iter,
   typename _Vector_iterator<_Myvec>
    ::_Unchecked_type _Right)
 {
 return (_Iter._Rechecked(_Right));
 }

template<class _Myvec> inline
 _Vector_iterator<_Myvec> operator+(
  typename _Vector_iterator<_Myvec>::difference_type _Off,
  _Vector_iterator<_Myvec> _Next)
 {
 return (_Next += _Off);
 }


template<class _Value_type,
 class _Size_type,
 class _Difference_type,
 class _Pointer,
 class _Const_pointer,
 class _Reference,
 class _Const_reference>
 struct _Vec_iter_types
 {
 typedef _Value_type value_type;
 typedef _Size_type size_type;
 typedef _Difference_type difference_type;
 typedef _Pointer pointer;
 typedef _Const_pointer const_pointer;
 typedef _Reference reference;
 typedef _Const_reference const_reference;
 };

template<class _Ty,
 class _Alloc0>
 struct _Vec_base_types
 {
 typedef _Alloc0 _Alloc;
 typedef _Vec_base_types<_Ty, _Alloc> _Myt;

 typedef _Wrap_alloc<_Alloc> _Alty0;
 typedef typename _Alty0::template rebind<_Ty>::other _Alty;


 typedef typename _If<_Is_simple_alloc<_Alty>::value,
  _Simple_types<typename _Alty::value_type>,
  _Vec_iter_types<typename _Alty::value_type,
   typename _Alty::size_type,
   typename _Alty::difference_type,
   typename _Alty::pointer,
   typename _Alty::const_pointer,
   typename _Alty::reference,
   typename _Alty::const_reference> >::type
  _Val_types;
 };


template<class _Val_types>
 class _Vector_val
  : public _Container_base
 {
public:
 typedef _Vector_val<_Val_types> _Myt;

 typedef typename _Val_types::value_type value_type;
 typedef typename _Val_types::size_type size_type;
 typedef typename _Val_types::difference_type difference_type;
 typedef typename _Val_types::pointer pointer;
 typedef typename _Val_types::const_pointer const_pointer;
 typedef typename _Val_types::reference reference;
 typedef typename _Val_types::const_reference const_reference;

 typedef _Vector_iterator<_Myt> iterator;
 typedef _Vector_const_iterator<_Myt> const_iterator;

 _Vector_val()
  : _Myfirst(),
  _Mylast(),
  _Myend()
  {
  }

 pointer _Myfirst;
 pointer _Mylast;
 pointer _Myend;
 };


template<class _Alloc_types>
 class _Vector_alloc
 {
public:
 typedef _Vector_alloc<_Alloc_types> _Myt;
 typedef typename _Alloc_types::_Alloc _Alloc;
 typedef typename _Alloc_types::_Alty _Alty;
 typedef typename _Alloc_types::_Val_types _Val_types;

 typedef typename _Val_types::value_type value_type;
 typedef typename _Val_types::size_type size_type;
 typedef typename _Val_types::difference_type difference_type;
 typedef typename _Val_types::pointer pointer;
 typedef typename _Val_types::const_pointer const_pointer;
 typedef typename _Val_types::reference reference;
 typedef typename _Val_types::const_reference const_reference;

 typedef _Vector_iterator<_Vector_val<_Val_types> > iterator;
 typedef _Vector_const_iterator<_Vector_val<_Val_types> > const_iterator;


 _Vector_alloc()
  : _Mypair(_Zero_then_variadic_args_t())
  {
  }

 template<class _Any_alloc,
  class = enable_if_t<!is_same<decay_t<_Any_alloc>, _Myt>::value> >
  _Vector_alloc(_Any_alloc&& _Al)
  : _Mypair(_One_then_variadic_args_t(),
   ::std:: forward<_Any_alloc>(_Al))
  {
  }

 void _Copy_alloc(const _Alty& _Al)
  {
  _Pocca(_Getal(), _Al);
  }

 void _Move_alloc(_Alty& _Al)
  {
  _Pocma(_Getal(), _Al);
  }
# 611 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vector" 3
 void _Orphan_all()
  {
  _Get_data()._Orphan_all();
  }

 void _Swap_all(_Myt& _Right)
  {
  _Get_data()._Swap_all(_Right._Get_data());
  }

 _Alty& _Getal() noexcept
  {
  return (_Mypair._Get_first());
  }

 const _Alty& _Getal() const noexcept
  {
  return (_Mypair._Get_first());
  }

 _Vector_val<_Val_types>& _Get_data() noexcept
  {
  return (_Mypair._Get_second());
  }

 const _Vector_val<_Val_types>& _Get_data() const noexcept
  {
  return (_Mypair._Get_second());
  }

 pointer& _Myfirst() noexcept
  {
  return (_Get_data()._Myfirst);
  }

 const pointer& _Myfirst() const noexcept
  {
  return (_Get_data()._Myfirst);
  }

 pointer& _Mylast() noexcept
  {
  return (_Get_data()._Mylast);
  }

 const pointer& _Mylast() const noexcept
  {
  return (_Get_data()._Mylast);
  }

 pointer& _Myend() noexcept
  {
  return (_Get_data()._Myend);
  }

 const pointer& _Myend() const noexcept
  {
  return (_Get_data()._Myend);
  }

private:
 _Compressed_pair<_Alty, _Vector_val<_Val_types> > _Mypair;
 };


template<class _Ty,
 class _Alloc = allocator<_Ty> >
 class vector
  : public _Vector_alloc<_Vec_base_types<_Ty, _Alloc> >
 {
public:
 typedef vector<_Ty, _Alloc> _Myt;
 typedef _Vector_alloc<_Vec_base_types<_Ty, _Alloc> > _Mybase;
 typedef _Alloc allocator_type;

 typedef typename _Mybase::_Alty _Alty;

 typedef typename _Mybase::value_type value_type;
 typedef typename _Mybase::size_type size_type;
 typedef typename _Mybase::difference_type difference_type;
 typedef typename _Mybase::pointer pointer;
 typedef typename _Mybase::const_pointer const_pointer;
 typedef typename _Mybase::reference reference;
 typedef typename _Mybase::const_reference const_reference;




 typedef typename _Mybase::iterator iterator;
 typedef typename _Mybase::const_iterator const_iterator;

 typedef ::std:: reverse_iterator<iterator> reverse_iterator;
 typedef ::std:: reverse_iterator<const_iterator> const_reverse_iterator;

 vector() noexcept(is_nothrow_default_constructible<_Alloc>::value)
  : _Mybase()
  {
  }

 explicit vector(const _Alloc& _Al) noexcept
  : _Mybase(_Al)
  {
  }

 explicit vector(size_type _Count)
  : _Mybase()
  {
  if (_Buy(_Count))
   {
   try {
   _Uninitialized_default_fill_n(this->_Myfirst(), _Count,
    this->_Getal());
   this->_Mylast() += _Count;
   } catch (...) {
   _Tidy();
   throw;
   }
   }
  }

 vector(size_type _Count, const value_type& _Val)
  : _Mybase()
  {
  _Construct_n(_Count, ::std:: addressof(_Val));
  }

 vector(size_type _Count, const value_type& _Val, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Construct_n(_Count, ::std:: addressof(_Val));
  }

 vector(const _Myt& _Right)

  : _Mybase(_Right._Getal().select_on_container_copy_construction())


  {
  if (_Buy(_Right.size()))
   try {
   this->_Mylast() = _Ucopy(_Right.begin(), _Right.end(),
    this->_Myfirst());
   } catch (...) {
   _Tidy();
   throw;
   }
  }

 vector(const _Myt& _Right, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  if (_Buy(_Right.size()))
   try {
   this->_Mylast() = _Ucopy(_Right.begin(), _Right.end(),
    this->_Myfirst());
   } catch (...) {
   _Tidy();
   throw;
   }
  }

 template<class _Iter,
  class = typename enable_if<_Is_iterator<_Iter>::value,
   void>::type>
  vector(_Iter _First, _Iter _Last)
  : _Mybase()
  {
  _Construct(_First, _Last);
  }

 template<class _Iter,
  class = typename enable_if<_Is_iterator<_Iter>::value,
   void>::type>
  vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Construct(_First, _Last);
  }

 template<class _Iter>
  void _Construct(_Iter _First, _Iter _Last)
  {
  _Construct(_First, _Last, _Iter_cat_t<_Iter>());
  }

 template<class _Iter>
  void _Construct(_Iter _First, _Iter _Last,
   input_iterator_tag)
  {
  try {

  for (; _First != _Last; ++_First)
   emplace_back(*_First);

  } catch (...) {
  _Tidy();
  throw;
  }
  }

 template<class _Iter>
  void _Construct(_Iter _First, _Iter _Last,
   forward_iterator_tag)
  {
  if (_Buy(::std:: distance(_First, _Last)))
   {
   try {
   this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
   } catch (...) {
   _Tidy();
   throw;
   }
   }
  }

 void _Construct_n(size_type _Count, const value_type *_Pval)
  {
  if (_Buy(_Count))
   {
   try {
   this->_Mylast() = _Ufill(this->_Myfirst(), _Count, _Pval);
   } catch (...) {
   _Tidy();
   throw;
   }
   }
  }

 vector(_Myt&& _Right) noexcept
  : _Mybase(::std:: move(_Right._Getal()))
  {
  _Assign_rv(::std:: forward<_Myt>(_Right), true_type());
  }

 vector(_Myt&& _Right, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Assign_rv(::std:: forward<_Myt>(_Right));
  }

 _Myt& operator=(_Myt&& _Right)
  noexcept(_Alty::propagate_on_container_move_assignment::value || _Alty::is_always_equal::value)

  {
  if (this != &_Right)
   {
   _Tidy();
   if (_Alty::propagate_on_container_move_assignment::value
    && this->_Getal() != _Right._Getal())
    this->_Move_alloc(_Right._Getal());

   _Assign_rv(::std:: forward<_Myt>(_Right));
   }
  return (*this);
  }

 void _Assign_rv(_Myt&& _Right, true_type)
  {
  this->_Swap_all((_Myt&)_Right);
  this->_Myfirst() = _Right._Myfirst();
  this->_Mylast() = _Right._Mylast();
  this->_Myend() = _Right._Myend();

  _Right._Myfirst() = pointer();
  _Right._Mylast() = pointer();
  _Right._Myend() = pointer();
  }

 void _Assign_rv(_Myt&& _Right, false_type)
  {
  if (get_allocator() == _Right.get_allocator())
   _Assign_rv(::std:: forward<_Myt>(_Right), true_type());
  else
   _Construct(::std:: make_move_iterator(_Right.begin()),
    ::std:: make_move_iterator(_Right.end()));
  }

 void _Assign_rv(_Myt&& _Right)
  {
  _Assign_rv(::std:: forward<_Myt>(_Right),
   typename _Alty::propagate_on_container_move_assignment());
  }


 void push_back(value_type&& _Val)
  {
  if (_Inside(::std:: addressof(_Val)))
   {
   size_type _Idx = ::std:: addressof(_Val) - _Unfancy(this->_Myfirst());
   if (this->_Mylast() == this->_Myend())
    _Reserve(1);
   _Orphan_range(this->_Mylast(), this->_Mylast());
   this->_Getal().construct(_Unfancy(this->_Mylast()),
    ::std:: forward<value_type>(this->_Myfirst()[_Idx]));
   ++this->_Mylast();
   }
  else
   {
   if (this->_Mylast() == this->_Myend())
    _Reserve(1);
   _Orphan_range(this->_Mylast(), this->_Mylast());
   this->_Getal().construct(_Unfancy(this->_Mylast()),
    ::std:: forward<value_type>(_Val));
   ++this->_Mylast();
   }
  }

 iterator insert(const_iterator _Where, _Ty&& _Val)
  {
  return (emplace(_Where, ::std:: move(_Val)));
  }

 template<class... _Valty>
  void emplace_back(_Valty&&... _Val)
  {
  if (this->_Mylast() == this->_Myend())
   _Reserve(1);
  _Orphan_range(this->_Mylast(), this->_Mylast());
  this->_Getal().construct(_Unfancy(this->_Mylast()),
   ::std:: forward<_Valty>(_Val)...);
  ++this->_Mylast();
  }

 template<class... _Valty>
  iterator emplace(const_iterator _Where, _Valty&&... _Val)
  {
  size_type _Off = (_Where)._Ptr - this->_Myfirst();






  emplace_back(::std:: forward<_Valty>(_Val)...);
  ::std:: rotate(begin() + _Off, end() - 1, end());
  return (begin() + _Off);
  }


 vector(::std:: initializer_list<value_type> _Ilist,
  const _Alloc& _Al = allocator_type())
  : _Mybase(_Al)
  {
  _Construct(_Ilist.begin(), _Ilist.end());
  }

 _Myt& operator=(::std:: initializer_list<value_type> _Ilist)
  {
  assign(_Ilist.begin(), _Ilist.end());
  return (*this);
  }

 void assign(::std:: initializer_list<value_type> _Ilist)
  {
  assign(_Ilist.begin(), _Ilist.end());
  }

 iterator insert(const_iterator _Where,
  ::std:: initializer_list<value_type> _Ilist)
  {
  return (insert(_Where, _Ilist.begin(), _Ilist.end()));
  }

 ~vector() noexcept
  {
  _Tidy();
  }

 _Myt& operator=(const _Myt& _Right)
  {
  if (this != &_Right)
   {
   if (this->_Getal() != _Right._Getal()
    && _Alty::propagate_on_container_copy_assignment::value)
    {
    _Tidy();
    this->_Copy_alloc(_Right._Getal());
    }

   this->_Orphan_all();

   if (_Right.empty())
    clear();
   else if (_Right.size() <= size())
    {
    pointer _Ptr = _Copy_unchecked(_Right._Myfirst(),
     _Right._Mylast(), this->_Myfirst());
    _Destroy(_Ptr, this->_Mylast());
    this->_Mylast() = this->_Myfirst() + _Right.size();
    }
   else if (_Right.size() <= capacity())
    {
    pointer _Ptr = _Right._Myfirst() + size();
    _Copy_unchecked(_Right._Myfirst(),
     _Ptr, this->_Myfirst());
    this->_Mylast() = _Ucopy(_Ptr, _Right._Mylast(),
     this->_Mylast());
    }
   else
    {
    if (this->_Myfirst() != pointer())
     {
     _Destroy(this->_Myfirst(), this->_Mylast());
     this->_Getal().deallocate(this->_Myfirst(),
      this->_Myend() - this->_Myfirst());
     }
    if (_Buy(_Right.size()))
     try {
     this->_Mylast() =
      _Ucopy(_Right._Myfirst(), _Right._Mylast(),
      this->_Myfirst());
     } catch (...) {
     _Tidy();
     throw;
     }
    }
   }
  return (*this);
  }

 void reserve(size_type _Count)
  {
  if (capacity() < _Count)
   {
   if (max_size() < _Count)
    _Xlen();
   _Reallocate(_Count);
   }
  }

 size_type capacity() const noexcept
  {
  return (this->_Myend() - this->_Myfirst());
  }

 size_type _Unused_capacity() const noexcept
  {
  return (this->_Myend() - this->_Mylast());
  }

 size_type _Has_unused_capacity() const noexcept
  {
  return (this->_Myend() != this->_Mylast());
  }

 iterator begin() noexcept
  {
  return (iterator(this->_Myfirst(), &this->_Get_data()));
  }

 const_iterator begin() const noexcept
  {
  return (const_iterator(this->_Myfirst(), &this->_Get_data()));
  }

 iterator end() noexcept
  {
  return (iterator(this->_Mylast(), &this->_Get_data()));
  }

 const_iterator end() const noexcept
  {
  return (const_iterator(this->_Mylast(), &this->_Get_data()));
  }

 iterator _Make_iter(const_iterator _Where) const
  {
  return (iterator(_Where._Ptr, &this->_Get_data()));
  }

 reverse_iterator rbegin() noexcept
  {
  return (reverse_iterator(end()));
  }

 const_reverse_iterator rbegin() const noexcept
  {
  return (const_reverse_iterator(end()));
  }

 reverse_iterator rend() noexcept
  {
  return (reverse_iterator(begin()));
  }

 const_reverse_iterator rend() const noexcept
  {
  return (const_reverse_iterator(begin()));
  }

 const_iterator cbegin() const noexcept
  {
  return (begin());
  }

 const_iterator cend() const noexcept
  {
  return (end());
  }

 const_reverse_iterator crbegin() const noexcept
  {
  return (rbegin());
  }

 const_reverse_iterator crend() const noexcept
  {
  return (rend());
  }

 void shrink_to_fit()
  {
  if (_Has_unused_capacity())
   {
   if (empty())
    _Tidy();
   else
    _Reallocate(size());
   }
  }

 void resize(size_type _Newsize)
  {
  if (_Newsize < size())
   _Pop_back_n(size() - _Newsize);
  else if (size() < _Newsize)
   {
   _Reserve(_Newsize - size());
   try {
   _Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),
    this->_Getal());
   } catch (...) {
   _Tidy();
   throw;
   }
   this->_Mylast() += _Newsize - size();
   }
  }

 void resize(size_type _Newsize, const value_type& _Val)
  {
  if (_Newsize < size())
   _Pop_back_n(size() - _Newsize);
  else if (size() < _Newsize)
   {
   const value_type *_Ptr = ::std:: addressof(_Val);

   if (_Inside(_Ptr))
    {
    const difference_type _Idx = _Ptr
     - _Unfancy(this->_Myfirst());
    _Reserve(_Newsize - size());
    _Ptr = _Unfancy(this->_Myfirst()) + _Idx;
    }
   else
    _Reserve(_Newsize - size());

   try {
   _Ufill(this->_Mylast(), _Newsize - size(), _Ptr);
   } catch (...) {
   _Tidy();
   throw;
   }
   this->_Mylast() += _Newsize - size();
   }
  }

 size_type size() const noexcept
  {
  return (this->_Mylast() - this->_Myfirst());
  }

 size_type max_size() const noexcept
  {
  return (this->_Getal().max_size());
  }

 bool empty() const noexcept
  {
  return (this->_Myfirst() == this->_Mylast());
  }

 _Alloc get_allocator() const noexcept
  {
  _Alloc _Ret(this->_Getal());
  return (_Ret);
  }

 const_reference at(size_type _Pos) const
  {
  if (size() <= _Pos)
   _Xran();
  return (*(this->_Myfirst() + _Pos));
  }

 reference at(size_type _Pos)
  {
  if (size() <= _Pos)
   _Xran();
  return (*(this->_Myfirst() + _Pos));
  }

 const_reference operator[](size_type _Pos) const
  {
# 1226 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vector" 3
  return (*(this->_Myfirst() + _Pos));
  }

 reference operator[](size_type _Pos)
  {
# 1242 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vector" 3
  return (*(this->_Myfirst() + _Pos));
  }

 _Ty * data() noexcept
  {
  return (_Unfancy(this->_Myfirst()));
  }

 const _Ty * data() const noexcept
  {
  return (_Unfancy(this->_Myfirst()));
  }

 reference front()
  {
  return (*begin());
  }

 const_reference front() const
  {
  return (*begin());
  }

 reference back()
  {
  return (*(end() - 1));
  }

 const_reference back() const
  {
  return (*(end() - 1));
  }

 void push_back(const value_type& _Val)
  {
  if (_Inside(::std:: addressof(_Val)))
   {
   size_type _Idx = ::std:: addressof(_Val) - _Unfancy(this->_Myfirst());
   if (this->_Mylast() == this->_Myend())
    _Reserve(1);
   _Orphan_range(this->_Mylast(), this->_Mylast());
   this->_Getal().construct(_Unfancy(this->_Mylast()),
    this->_Myfirst()[_Idx]);
   ++this->_Mylast();
   }
  else
   {
   if (this->_Mylast() == this->_Myend())
    _Reserve(1);
   _Orphan_range(this->_Mylast(), this->_Mylast());
   this->_Getal().construct(_Unfancy(this->_Mylast()),
    _Val);
   ++this->_Mylast();
   }
  }
# 1312 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vector" 3
 void pop_back()
  {
  this->_Getal().destroy(_Unfancy(this->_Mylast() - 1));
  --this->_Mylast();
  }


 template<class _Iter>
  typename enable_if<_Is_iterator<_Iter>::value,
   void>::type
  assign(_Iter _First, _Iter _Last)
  {
  clear();
  _Assign(_First, _Last, _Iter_cat_t<_Iter>());
  }

 template<class _Iter>
  void _Assign(_Iter _First, _Iter _Last,
   input_iterator_tag)
  {
  for (; _First != _Last; ++_First)
   emplace_back(*_First);
  }

 template<class _Iter>
  void _Assign(_Iter _First, _Iter _Last,
   forward_iterator_tag)
  {
  size_type _Newsize = ::std:: distance(_First, _Last);

  if (capacity() < _Newsize)
   {
   size_type _Newcapacity = _Grow_to(_Newsize);
   _Tidy();
   _Buy(_Newcapacity);
   }

  this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
  }

 void assign(size_type _Count, const value_type& _Val)
  {
  clear();
  insert(begin(), _Count, _Val);
  }

 iterator insert(const_iterator _Where, const _Ty& _Val)
  {
  return (_Insert_n(_Where, (size_type)1, _Val));
  }

 iterator insert(const_iterator _Where, size_type _Count,
  const _Ty& _Val)
  {
  return (_Insert_n(_Where, _Count, _Val));
  }

 template<class _Iter>
  typename enable_if<_Is_iterator<_Iter>::value,
   iterator>::type
  insert(const_iterator _Where, _Iter _First, _Iter _Last)
  {
  size_type _Off = (_Where)._Ptr - this->_Myfirst();
  _Insert(_Where, _First, _Last, _Iter_cat_t<_Iter>());
  return (begin() + _Off);
  }

 template<class _Iter>
  void _Insert(const_iterator _Where,
   _Iter _First, _Iter _Last,
    input_iterator_tag)
  {
  size_type _Off = (_Where)._Ptr - this->_Myfirst();






  if (_First != _Last)
   {
   size_type _Oldsize = size();

   try {
   for (; _First != _Last; ++_First)
    push_back(*_First);

   } catch (...) {
   erase(begin() + _Oldsize, end());
   throw;
   }

   ::std:: rotate(begin() + _Off, begin() + _Oldsize, end());
   }
  }

 template<class _Iter>
  void _Insert(const_iterator _Where,
   _Iter _First, _Iter _Last,
    forward_iterator_tag)
  {
# 1421 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vector" 3
  size_type _Count = ::std:: distance(_First, _Last);
  if (_Count == 0)
   ;
  else if (_Unused_capacity() < _Count)
   {
   if (max_size() - size() < _Count)
    _Xlen();

   size_type _Capacity = _Grow_to(size() + _Count);
   pointer _Newvec = this->_Getal().allocate(_Capacity);
   pointer _Ptr = _Newvec;

   try {
   _Ptr = _Umove(this->_Myfirst(), (_Where)._Ptr,
    _Newvec);
   _Ptr = _Ucopy(_First, _Last, _Ptr);
   _Umove((_Where)._Ptr, this->_Mylast(),
    _Ptr);
   } catch (...) {
   _Destroy(_Newvec, _Ptr);
   this->_Getal().deallocate(_Newvec, _Capacity);
   throw;
   }

   _Count += size();
   if (this->_Myfirst() != pointer())
    {
    _Destroy(this->_Myfirst(), this->_Mylast());
    this->_Getal().deallocate(this->_Myfirst(),
     this->_Myend() - this->_Myfirst());
    }

   this->_Orphan_all();
   this->_Myend() = _Newvec + _Capacity;
   this->_Mylast() = _Newvec + _Count;
   this->_Myfirst() = _Newvec;
   }
  else
   {
   _Ucopy(_First, _Last, this->_Mylast());
   ::std:: rotate((_Where)._Ptr, this->_Mylast(),
    this->_Mylast() + _Count);
   this->_Mylast() += _Count;
   _Orphan_range((_Where)._Ptr, this->_Mylast());
   }
  }
# 1483 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vector" 3
 iterator erase(const_iterator _Where)
  {
  _Move_unchecked((_Where)._Ptr + 1, this->_Mylast(),
   (_Where)._Ptr);
  _Destroy(this->_Mylast() - 1, this->_Mylast());
  --this->_Mylast();
  return (_Make_iter(_Where));
  }


 iterator erase(const_iterator _First_arg,
  const_iterator _Last_arg)
  {
  if (_First_arg == begin() && _Last_arg == end())
   clear();
  else if (_First_arg != _Last_arg)
   {
   iterator _First = _Make_iter(_First_arg);
   iterator _Last = _Make_iter(_Last_arg);

   if (_First != _Last)
    {
# 1515 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vector" 3
    pointer _Ptr = _Move_unchecked((_Last)._Ptr, this->_Mylast(),
     (_First)._Ptr);


    _Destroy(_Ptr, this->_Mylast());
    this->_Mylast() = _Ptr;
    }
   }
  return (_Make_iter(_First_arg));
  }

 void _Pop_back_n(size_type _Count)
  {
  pointer _Ptr = this->_Mylast() - _Count;





  _Destroy(_Ptr, this->_Mylast());
  this->_Mylast() = _Ptr;
  }

 void clear() noexcept
  {
  this->_Orphan_all();
  _Destroy(this->_Myfirst(), this->_Mylast());
  this->_Mylast() = this->_Myfirst();
  }

 void swap(_Myt& _Right)
  noexcept(_Alty::propagate_on_container_swap::value || _Alty::is_always_equal::value)

  {
  if (this != &_Right)
   {
   _Pocs(this->_Getal(), _Right._Getal());
   this->_Swap_all(_Right);
   _Swap_adl(this->_Myfirst(), _Right._Myfirst());
   _Swap_adl(this->_Mylast(), _Right._Mylast());
   _Swap_adl(this->_Myend(), _Right._Myend());
   }
  }

protected:
 bool _Buy(size_type _Capacity)
  {
  this->_Myfirst() = pointer();
  this->_Mylast() = pointer();
  this->_Myend() = pointer();

  if (_Capacity == 0)
   return (false);
  else if (max_size() < _Capacity)
   _Xlen();
  else
   {
   this->_Myfirst() = this->_Getal().allocate(_Capacity);
   this->_Mylast() = this->_Myfirst();
   this->_Myend() = this->_Myfirst() + _Capacity;
   }
  return (true);
  }

 void _Destroy(pointer _First, pointer _Last)
  {
  _Destroy_range(_First, _Last, this->_Getal());
  }

 size_type _Grow_to(size_type _Count) const
  {
  size_type _Capacity = capacity();

  _Capacity = max_size() - _Capacity / 2 < _Capacity
   ? 0 : _Capacity + _Capacity / 2;
  if (_Capacity < _Count)
   _Capacity = _Count;
  return (_Capacity);
  }

 bool _Inside(const value_type *_Ptr) const
  {
  return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);
  }

 void _Reallocate(size_type _Count)
  {
  pointer _Ptr = this->_Getal().allocate(_Count);

  try {
  _Umove(this->_Myfirst(), this->_Mylast(), _Ptr);
  } catch (...) {
  this->_Getal().deallocate(_Ptr, _Count);
  throw;
  }

  size_type _Size = size();
  if (this->_Myfirst() != pointer())
   {
   _Destroy(this->_Myfirst(), this->_Mylast());
   this->_Getal().deallocate(this->_Myfirst(),
    this->_Myend() - this->_Myfirst());
   }

  this->_Orphan_all();
  this->_Myend() = _Ptr + _Count;
  this->_Mylast() = _Ptr + _Size;
  this->_Myfirst() = _Ptr;
  }

 void _Reserve(size_type _Count)
  {
  if (_Unused_capacity() < _Count)
   {
   if (max_size() - size() < _Count)
    _Xlen();
   _Reallocate(_Grow_to(size() + _Count));
   }
  }

 void _Tidy()
  {
  if (this->_Myfirst() != pointer())
   {
   this->_Orphan_all();
   _Destroy(this->_Myfirst(), this->_Mylast());
   this->_Getal().deallocate(this->_Myfirst(),
    this->_Myend() - this->_Myfirst());
   this->_Myfirst() = pointer();
   this->_Mylast() = pointer();
   this->_Myend() = pointer();
   }
  }

 template<class _Iter>
  pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
  {
  return (_Uninitialized_copy(_First, _Last,
   _Ptr, this->_Getal()));
  }

 template<class _Iter>
  pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
  {
  return (_Uninitialized_move(_First, _Last,
   _Ptr, this->_Getal()));
  }

 iterator _Insert_n(const_iterator _Where,
  size_type _Count, const value_type& _Val)
  {







  size_type _Off = (_Where)._Ptr - this->_Myfirst();
  if (_Count == 0)
   ;
  else if (_Unused_capacity() < _Count)
   {
   if (max_size() - size() < _Count)
    _Xlen();

   size_type _Capacity = _Grow_to(size() + _Count);
   pointer _Newvec = this->_Getal().allocate(_Capacity);
   size_type _Whereoff = (_Where)._Ptr - this->_Myfirst();
   int _Ncopied = 0;

   try {
   _Ufill(_Newvec + _Whereoff, _Count,
    ::std:: addressof(_Val));
   ++_Ncopied;
   _Umove(this->_Myfirst(), (_Where)._Ptr,
    _Newvec);
   ++_Ncopied;
   _Umove((_Where)._Ptr, this->_Mylast(),
    _Newvec + (_Whereoff + _Count));
   } catch (...) {
   if (1 < _Ncopied)
    _Destroy(_Newvec, _Newvec + _Whereoff);
   if (0 < _Ncopied)
    _Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
   this->_Getal().deallocate(_Newvec, _Capacity);
   throw;
   }

   _Count += size();
   if (this->_Myfirst() != pointer())
    {
    _Destroy(this->_Myfirst(), this->_Mylast());
    this->_Getal().deallocate(this->_Myfirst(),
     this->_Myend() - this->_Myfirst());
    }

   this->_Orphan_all();
   this->_Myend() = _Newvec + _Capacity;
   this->_Mylast() = _Newvec + _Count;
   this->_Myfirst() = _Newvec;
   }
  else if ((size_type)(this->_Mylast() - (_Where)._Ptr)
   < _Count)
   {
   value_type _Tmp = _Val;

   _Umove((_Where)._Ptr, this->_Mylast(),
    (_Where)._Ptr + _Count);

   try {
   _Ufill(this->_Mylast(),
    _Count - (this->_Mylast() - (_Where)._Ptr),
    ::std:: addressof(_Tmp));
   } catch (...) {
   _Destroy((_Where)._Ptr + _Count,
    this->_Mylast() + _Count);
   throw;
   }

   this->_Mylast() += _Count;
   _Orphan_range((_Where)._Ptr, this->_Mylast());
   ::std:: fill((_Where)._Ptr, this->_Mylast() - _Count,
    _Tmp);
   }
  else
   {
   value_type _Tmp = _Val;

   pointer _Oldend = this->_Mylast();
   this->_Mylast() = _Umove(_Oldend - _Count, _Oldend,
    this->_Mylast());

   _Orphan_range((_Where)._Ptr, this->_Mylast());
   _Move_backward_unchecked((_Where)._Ptr, _Oldend - _Count,
    _Oldend);
   ::std:: fill((_Where)._Ptr,
    (_Where)._Ptr + _Count, _Tmp);
   }
  return (begin() + _Off);
  }

 pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
  {
  _Uninitialized_fill_n(_Ptr, _Count, _Pval, this->_Getal());
  return (_Ptr + _Count);
  }

 [[noreturn]] void _Xlen() const
  {
  _Xlength_error("vector<T> too long");
  }

 [[noreturn]] void _Xran() const
  {
  _Xout_of_range("invalid vector<T> subscript");
  }
# 1792 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vector" 3
 void _Orphan_range(pointer, pointer) const
  {
  }

 };



template<class _Ty,
 class _Alloc> inline
 void swap(vector<_Ty, _Alloc>& _Left, vector<_Ty, _Alloc>& _Right)
  noexcept(noexcept(_Left.swap(_Right)))
 {
 _Left.swap(_Right);
 }

template<class _Ty,
 class _Alloc> inline
 bool operator==(const vector<_Ty, _Alloc>& _Left,
  const vector<_Ty, _Alloc>& _Right)
 {
 return (_Left.size() == _Right.size()
  && ::std:: equal(_Left.begin(), _Left.end(), _Right.begin()));
 }

template<class _Ty,
 class _Alloc> inline
 bool operator!=(const vector<_Ty, _Alloc>& _Left,
  const vector<_Ty, _Alloc>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _Ty,
 class _Alloc> inline
 bool operator<(const vector<_Ty, _Alloc>& _Left,
  const vector<_Ty, _Alloc>& _Right)
 {
 return (::std:: lexicographical_compare(_Left.begin(), _Left.end(),
  _Right.begin(), _Right.end()));
 }

template<class _Ty,
 class _Alloc> inline
 bool operator>(const vector<_Ty, _Alloc>& _Left,
  const vector<_Ty, _Alloc>& _Right)
 {
 return (_Right < _Left);
 }

template<class _Ty,
 class _Alloc> inline
 bool operator<=(const vector<_Ty, _Alloc>& _Left,
  const vector<_Ty, _Alloc>& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _Ty,
 class _Alloc> inline
 bool operator>=(const vector<_Ty, _Alloc>& _Left,
  const vector<_Ty, _Alloc>& _Right)
 {
 return (!(_Left < _Right));
 }




typedef unsigned int _Vbase;
const int _VBITS = 8 * sizeof (_Vbase);


template<class _Alloc>
 class _Vb_iter_base
  : public _Iterator012<random_access_iterator_tag,
   bool,
   typename _Alloc::difference_type,
   bool *,
   bool,
   _Iterator_base>
 {
public:
 typedef typename _Alloc::size_type _Sizet;
 typedef vector<bool, _Alloc> _Mycont;

 _Vb_iter_base()
  : _Myptr(0), _Myoff(0)
  {
  }

 _Vb_iter_base(const _Vbase *_Ptr, _Sizet _Off,
  const _Container_base *_Mypvbool)
  : _Myptr(_Ptr), _Myoff(_Off)
  {
  this->_Adopt(_Mypvbool);
  }

 void _Advance(_Sizet _Off)
  {
  _Myoff += _Off;
  _Myptr += _Myoff / _VBITS;
  _Myoff %= _VBITS;
  }

 int _Valid(_Sizet _Inc) const
  {
# 1908 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vector" 3
  (void) _Inc;
  return (-1);

  }

 const _Vbase *_Myptr;
 _Sizet _Myoff;
 };


template<class _Alloc>
 class _Vb_reference
  : public _Vb_iter_base<_Alloc>
 {
 typedef _Vb_iter_base<_Alloc> _Mybase;
 typedef _Vb_reference<_Alloc> _Mytype;

 _Vb_reference() noexcept
  {
  }

public:
 _Vb_reference(const _Mybase& _Right)
  : _Mybase(_Right._Myptr, _Right._Myoff, _Right._Getcont())
  {
  }

 _Mytype& operator=(const _Mytype& _Right) noexcept
  {
  return (*this = bool(_Right));
  }

 _Mytype& operator=(bool _Val) noexcept
  {
  if (_Val)
   *(_Vbase *)_Getptr() |= _Mask();
  else
   *(_Vbase *)_Getptr() &= (~_Mask());
  return (*this);
  }

 void flip() noexcept
  {
  *(_Vbase *)_Getptr() ^= _Mask();
  }

 operator bool() const noexcept
  {
  return ((*_Getptr() & _Mask()) != 0);
  }

 const _Vbase *_Getptr() const
  {
# 1975 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vector" 3
  return (this->_Myptr);
  }

protected:
 _Vbase _Mask() const
  {
  return ((_Vbase)(1) << this->_Myoff);
  }
 };

template<class _Alloc> inline
 void swap(_Vb_reference<_Alloc> _Left,
  _Vb_reference<_Alloc> _Right)
 {
 bool _Val = _Left;
 _Left = _Right;
 _Right = _Val;
 }


template<class _Alloc>
 class _Vb_const_iterator
  : public _Vb_iter_base<_Alloc>
 {
public:
 typedef _Vb_iter_base<_Alloc> _Mybase;
 typedef _Vb_const_iterator<_Alloc> _Mytype;

 typedef _Vb_reference<_Alloc> _Reft;
 typedef bool const_reference;

 typedef random_access_iterator_tag iterator_category;
 typedef bool value_type;
 typedef typename _Alloc::size_type size_type;
 typedef typename _Alloc::difference_type difference_type;
 typedef const_reference *pointer;
 typedef const_reference reference;

 _Vb_const_iterator()
  {
  }

 _Vb_const_iterator(const _Vbase *_Ptr, const _Container_base *_Mypvbool)
  : _Mybase(_Ptr, 0, _Mypvbool)
  {
  }

 const_reference operator*() const
  {
  return (_Reft(*this));
  }

 _Mytype& operator++()
  {
  _Inc();
  return (*this);
  }

 _Mytype operator++(int)
  {
  _Mytype _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Mytype& operator--()
  {
  _Dec();
  return (*this);
  }

 _Mytype operator--(int)
  {
  _Mytype _Tmp = *this;
  --*this;
  return (_Tmp);
  }

 _Mytype& operator+=(difference_type _Off)
  {
  if (_Off < 0 && this->_Myoff < 0 - (size_type)_Off)
   {
   this->_Myoff += _Off;
   this->_Myptr -= 1 + ((size_type)(-1) - this->_Myoff) / _VBITS;
   this->_Myoff %= _VBITS;
   }
  else
   {
   this->_Myoff += _Off;
   this->_Myptr += this->_Myoff / _VBITS;
   this->_Myoff %= _VBITS;
   }
  return (*this);
  }

 _Mytype operator+(difference_type _Off) const
  {
  _Mytype _Tmp = *this;
  return (_Tmp += _Off);
  }

 _Mytype& operator-=(difference_type _Off)
  {
  return (*this += -_Off);
  }

 _Mytype operator-(difference_type _Off) const
  {
  _Mytype _Tmp = *this;
  return (_Tmp -= _Off);
  }

 difference_type operator-(
  const _Mytype& _Right) const
  {
  _Compat(_Right);
  return (_VBITS * (this->_Myptr - _Right._Myptr)
   + (difference_type)this->_Myoff
   - (difference_type)_Right._Myoff);
  }

 const_reference operator[](difference_type _Off) const
  {
  return (*(*this + _Off));
  }

 bool operator==(const _Mytype& _Right) const
  {
  _Compat(_Right);
  return (this->_Myptr == _Right._Myptr
   && this->_Myoff == _Right._Myoff);
  }

 bool operator!=(const _Mytype& _Right) const
  {
  return (!(*this == _Right));
  }

 bool operator<(const _Mytype& _Right) const
  {
  _Compat(_Right);
  return (this->_Myptr < _Right._Myptr
   || (this->_Myptr == _Right._Myptr
    && this->_Myoff < _Right._Myoff));
  }

 bool operator>(const _Mytype& _Right) const
  {
  return (_Right < *this);
  }

 bool operator<=(const _Mytype& _Right) const
  {
  return (!(_Right < *this));
  }

 bool operator>=(const _Mytype& _Right) const
  {
  return (!(*this < _Right));
  }
# 2150 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vector" 3
 void _Compat(const _Mytype&) const
  {
  }


 void _Dec()
  {
  if (this->_Myoff != 0)
   --this->_Myoff;
  else
   {
# 2173 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vector" 3
   this->_Myoff = _VBITS - 1;
   --this->_Myptr;
   }
  }

 void _Inc()
  {
  if (this->_Myoff < _VBITS - 1)
   ++this->_Myoff;
  else
   {
# 2196 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vector" 3
   this->_Myoff = 0;
   ++this->_Myptr;
   }
  }
 };

template<class _Alloc> inline
 _Vb_const_iterator<_Alloc> operator+(
  typename _Alloc::difference_type _Off,
  _Vb_const_iterator<_Alloc> _Right)
  {
  return (_Right += _Off);
  }

template<class _Alloc>
 struct _Is_checked_helper<_Vb_const_iterator<_Alloc> >
  : public true_type
 {
 };


template<class _Alloc>
 class _Vb_iterator
  : public _Vb_const_iterator<_Alloc>
 {
public:
 typedef _Vb_const_iterator<_Alloc> _Mybase;
 typedef _Vb_iterator<_Alloc> _Mytype;

 typedef _Vb_reference<_Alloc> _Reft;
 typedef bool const_reference;

 typedef random_access_iterator_tag iterator_category;
 typedef bool value_type;
 typedef typename _Alloc::size_type size_type;
 typedef typename _Alloc::difference_type difference_type;
 typedef _Reft *pointer;
 typedef _Reft reference;

 _Vb_iterator()
  {
  }

 _Vb_iterator(_Vbase *_Ptr, _Container_base *_Mypvbool)
  : _Mybase(_Ptr, _Mypvbool)
  {
  }

 reference operator*() const
  {
  return (_Reft(*this));
  }

 _Mytype& operator++()
  {
  ++*(_Mybase *)this;
  return (*this);
  }

 _Mytype operator++(int)
  {
  _Mytype _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Mytype& operator--()
  {
  --*(_Mybase *)this;
  return (*this);
  }

 _Mytype operator--(int)
  {
  _Mytype _Tmp = *this;
  --*this;
  return (_Tmp);
  }

 _Mytype& operator+=(difference_type _Off)
  {
  *(_Mybase *)this += _Off;
  return (*this);
  }

 _Mytype operator+(difference_type _Off) const
  {
  _Mytype _Tmp = *this;
  return (_Tmp += _Off);
  }

 _Mytype& operator-=(difference_type _Off)
  {
  return (*this += -_Off);
  }

 _Mytype operator-(difference_type _Off) const
  {
  _Mytype _Tmp = *this;
  return (_Tmp -= _Off);
  }

 difference_type operator-(const _Mybase& _Right) const
  {
  return (*(_Mybase *)this - _Right);
  }

 reference operator[](difference_type _Off) const
  {
  return (*(*this + _Off));
  }
 };

template<class _Alloc> inline
 _Vb_iterator<_Alloc> operator+(typename _Alloc::difference_type _Off,
  _Vb_iterator<_Alloc> _Right)
  {
  return (_Right += _Off);
  }

template<class _Alloc>
 struct _Is_checked_helper<_Vb_iterator<_Alloc> >
  : public true_type
 {
 };


template<class _Alloc>
 class _Vb_val
  : public _Container_base
 {
public:
 typedef vector<_Vbase, _Alloc> _Vectype;
 typedef typename _Vectype::_Alty _Alty;
 typedef typename _Alty::size_type size_type;

 _Vb_val(size_type _Count, const bool& _Val)
  : _Myvec(_Nw(_Count), (_Vbase) (_Val ? -1 : 0))
  {
  _Alloc_proxy();
  _Mysize = 0;
  }

 _Vb_val(size_type _Count, const bool& _Val, const _Alloc& _Al)
  : _Myvec(_Nw(_Count), (_Vbase)(_Val ? -1 : 0), _Al)
  {
  _Alloc_proxy();
  _Mysize = 0;
  }

 _Vb_val(const _Vb_val& _Right)
  : _Myvec(_Right._Myvec),
   _Mysize(_Right._Mysize)
  {
  _Alloc_proxy();
  }

 _Vb_val(const _Vb_val& _Right, const _Alloc& _Al)
  : _Myvec(_Right._Myvec, _Al),
   _Mysize(_Right._Mysize)
  {
  _Alloc_proxy();
  }

 _Vb_val(_Vb_val&& _Right)
  : _Myvec(::std:: forward<_Vectype>(_Right._Myvec)),
   _Mysize(_Right._Mysize)
  {
  _Right._Mysize = 0;
  _Alloc_proxy();
  }

 _Vb_val(_Vb_val&& _Right, const _Alloc& _Al)
  : _Myvec(::std:: forward<_Vectype>(_Right._Myvec), _Al),
   _Mysize(_Right._Mysize)
  {
  _Right._Mysize = 0;
  _Alloc_proxy();
  }

 ~_Vb_val() noexcept
  {
  _Free_proxy();
  }


 void _Alloc_proxy()
  {
  }

 void _Free_proxy()
  {
  }
# 2411 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vector" 3
 static size_type _Nw(size_type _Count)
  {
  return ((_Count + _VBITS - 1) / _VBITS);
  }

 _Vectype _Myvec;
 typename _Alty::size_type _Mysize;
 };



template<class _Alloc>
 class vector<bool, _Alloc>
  : public _Vb_val<_Alloc>
 {
public:
 typedef vector<bool, _Alloc> _Myt;
 typedef _Vb_val<_Alloc> _Mybase;
 typedef typename _Mybase::_Alty _Alty;
 typedef typename _Mybase::_Vectype _Vectype;

 typedef typename _Alty::size_type size_type;
 typedef typename _Alty::difference_type difference_type;
 typedef bool _Ty;
 typedef _Alloc allocator_type;

 typedef _Vb_reference<_Alty> reference;
 typedef bool const_reference;
 typedef bool value_type;

 typedef reference _Reft;
 typedef _Vb_const_iterator<_Alty> const_iterator;
 typedef _Vb_iterator<_Alty> iterator;

 typedef iterator pointer;
 typedef const_iterator const_pointer;
 typedef ::std:: reverse_iterator<iterator> reverse_iterator;
 typedef ::std:: reverse_iterator<const_iterator> const_reverse_iterator;

 static const int _VBITS = ::std:: _VBITS;
 enum {_EEN_VBITS = _VBITS};
 vector()
  : _Mybase(0, false)
  {
  }

 explicit vector(const _Alloc& _Al)
  : _Mybase(0, false, _Al)
  {
  }

 explicit vector(size_type _Count, const _Alloc& _Al = _Alloc())
  : _Mybase(_Count, false, _Al)
  {
  _Trim(_Count);
  }

 vector(size_type _Count, const bool& _Val, const _Alloc& _Al = _Alloc())
  : _Mybase(_Count, _Val, _Al)
  {
  _Trim(_Count);
  }

 vector(const _Myt& _Right)
  : _Mybase(_Right)
  {
  }

 vector(const _Myt& _Right, const _Alloc& _Al)
  : _Mybase(_Right, _Al)
  {
  }

 template<class _Iter,
  class = typename enable_if<_Is_iterator<_Iter>::value,
   void>::type>
  vector(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
  : _Mybase(0, false, _Al)
  {
  _BConstruct(_First, _Last);
  }

 template<class _Iter>
  void _BConstruct(_Iter _First, _Iter _Last)
  {
  insert(begin(), _First, _Last);
  }

 vector(_Myt&& _Right)
  : _Mybase(::std:: forward<_Myt>(_Right))
  {
  }

 vector(_Myt&& _Right, const _Alloc& _Al)
  : _Mybase(::std:: forward<_Myt>(_Right), _Al)
  {
  }

 _Myt& operator=(_Myt&& _Right)
  {
  if (this != &_Right)
   {
   clear();

   if (_Alty::propagate_on_container_move_assignment::value
    && this->get_allocator() != _Right.get_allocator())
    {
    this->_Free_proxy();
    this->_Myvec = ::std:: move(_Right._Myvec);
    this->_Alloc_proxy();
    }
   else
    this->_Myvec = ::std:: move(_Right._Myvec);


   this->_Mysize = _Right._Mysize;
   _Right._Mysize = 0;
   }
  return (*this);
  }

 template<class... _Valty>
  void emplace_back(_Valty&&... _Val)
  {
  bool _Tmp(::std:: forward<_Valty>(_Val)...);
  push_back(_Tmp);
  }

 template<class... _Valty>
  iterator emplace(const_iterator _Where, _Valty&&... _Val)
  {
  bool _Tmp(::std:: forward<_Valty>(_Val)...);
  return (insert(_Where, _Tmp));
  }


 vector(::std:: initializer_list<bool> _Ilist,
   const _Alloc& _Al = allocator_type())
  : _Mybase(0, false, _Al)
  {
  insert(begin(), _Ilist.begin(), _Ilist.end());
  }

 _Myt& operator=(::std:: initializer_list<bool> _Ilist)
  {
  assign(_Ilist.begin(), _Ilist.end());
  return (*this);
  }

 void assign(::std:: initializer_list<bool> _Ilist)
  {
  assign(_Ilist.begin(), _Ilist.end());
  }

 iterator insert(const_iterator _Where,
   ::std:: initializer_list<bool> _Ilist)
  {
  return (insert(_Where, _Ilist.begin(), _Ilist.end()));
  }

 ~vector() noexcept
  {
  }

 _Myt& operator=(const _Myt& _Right)
  {
  this->_Mysize = _Right._Mysize;
  this->_Myvec = _Right._Myvec;
  return (*this);
  }

 void reserve(size_type _Count)
  {
  this->_Myvec.reserve(this->_Nw(_Count));
  }

 size_type capacity() const noexcept
  {
  return (this->_Myvec.capacity() * _VBITS);
  }

 iterator begin() noexcept
  {
  return (iterator(this->_Myvec.data(), this));
  }

 const_iterator begin() const noexcept
  {
  return (const_iterator(this->_Myvec.data(), this));
  }

 iterator end() noexcept
  {
  iterator _Tmp = begin();
  if (0 < this->_Mysize)
   _Tmp += this->_Mysize;
  return (_Tmp);
  }

 const_iterator end() const noexcept
  {
  const_iterator _Tmp = begin();
  if (0 < this->_Mysize)
   _Tmp += this->_Mysize;
  return (_Tmp);
  }

 const_iterator cbegin() const noexcept
  {
  return (begin());
  }

 const_iterator cend() const noexcept
  {
  return (end());
  }

 const_reverse_iterator crbegin() const noexcept
  {
  return (rbegin());
  }

 const_reverse_iterator crend() const noexcept
  {
  return (rend());
  }

 void shrink_to_fit()
  {
  if (this->_Myvec._Has_unused_capacity())
   {
   _Myt _Tmp(*this);
   swap(_Tmp);
   }
  }

 iterator _Make_iter(const_iterator _Where)
  {
  iterator _Tmp = begin();
  if (0 < this->_Mysize)
   _Tmp += _Where - begin();
  return (_Tmp);
  }

 reverse_iterator rbegin() noexcept
  {
  return (reverse_iterator(end()));
  }

 const_reverse_iterator rbegin() const noexcept
  {
  return (const_reverse_iterator(end()));
  }

 reverse_iterator rend() noexcept
  {
  return (reverse_iterator(begin()));
  }

 const_reverse_iterator rend() const noexcept
  {
  return (const_reverse_iterator(begin()));
  }

 void resize(size_type _Newsize, bool _Val = false)
  {
  if (size() < _Newsize)
   _Insert_n(end(), _Newsize - size(), _Val);
  else if (_Newsize < size())
   erase(begin() + _Newsize, end());
  }

 size_type size() const noexcept
  {
  return (this->_Mysize);
  }

 size_type max_size() const noexcept
  {
  const size_type _Maxsize = this->_Myvec.max_size();
  return (_Maxsize < (size_type)(-1) / _VBITS
   ? _Maxsize * _VBITS : (size_type)(-1));
  }

 bool empty() const noexcept
  {
  return (size() == 0);
  }

 _Alloc get_allocator() const noexcept
  {
  _Alloc _Ret(this->_Myvec.get_allocator());
  return (_Ret);
  }

 const_reference at(size_type _Off) const
  {
  if (size() <= _Off)
   _Xran();
  return ((*this)[_Off]);
  }

 reference at(size_type _Off)
  {
  if (size() <= _Off)
   _Xran();
  return ((*this)[_Off]);
  }

 const_reference operator[](size_type _Off) const
  {
  const_iterator _It = begin();
  _It._Advance(_Off);
  return (*_It);
  }

 reference operator[](size_type _Off)
  {
  iterator _It = begin();
  _It._Advance(_Off);
  return (*_It);
  }

 reference front()
  {
  return (*begin());
  }

 const_reference front() const
  {
  return (*begin());
  }

 reference back()
  {
  return (*(end() - 1));
  }

 const_reference back() const
  {
  return (*(end() - 1));
  }

 void push_back(const bool& _Val)
  {
  insert(end(), _Val);
  }

 void pop_back()
  {
  erase(end() - 1);
  }

 template<class _Iter>
  typename enable_if<_Is_iterator<_Iter>::value,
   void>::type
  assign(_Iter _First, _Iter _Last)
  {
  erase(begin(), end());
  insert(begin(), _First, _Last);
  }

 void assign(size_type _Count, const bool& _Val)
  {
  erase(begin(), end());
  _Insert_n(begin(), _Count, _Val);
  }

 iterator insert(const_iterator _Where, const bool& _Val)
  {
  return (_Insert_n(_Where, (size_type)1, _Val));
  }

 iterator insert(const_iterator _Where, size_type _Count,
  const bool& _Val)
  {
  return (_Insert_n(_Where, _Count, _Val));
  }

 template<class _Iter>
  typename enable_if<_Is_iterator<_Iter>::value,
   iterator>::type
  insert(const_iterator _Where, _Iter _First, _Iter _Last)
  {
  size_type _Off = _Where - begin();
  _Insert(_Where, _First, _Last, _Iter_cat_t<_Iter>());
  return (begin() + _Off);
  }

 template<class _Iter>
  void _Insert(const_iterator _Where,
   _Iter _First, _Iter _Last,
    input_iterator_tag)
  {
  size_type _Off = _Where - begin();

  for (; _First != _Last; ++_First, (void)++_Off)
   insert(begin() + _Off, *_First);
  }

 template<class _Iter>
  void _Insert(const_iterator _Where,
   _Iter _First, _Iter _Last,
   forward_iterator_tag)
  {
                             ;
  size_type _Count = ::std:: distance(_First, _Last);
  size_type _Off = _Insert_x(_Where, _Count);
  ::std:: copy(_First, _Last, begin() + _Off);
  }

 iterator erase(const_iterator _Where_arg)
  {
  iterator _Where = _Make_iter(_Where_arg);
  size_type _Off = _Where - begin();
# 2834 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vector" 3
  ::std:: copy(_Where + 1, end(), _Where);


  _Trim(this->_Mysize - 1);
  return (begin() + _Off);
  }

 iterator erase(const_iterator _First_arg,
  const_iterator _Last_arg)
  {
  iterator _First = _Make_iter(_First_arg);
  iterator _Last = _Make_iter(_Last_arg);
  size_type _Off = _First - begin();

  if (_First != _Last)
   {
# 2859 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vector" 3
   iterator _Next = ::std:: copy(_Last, end(), _First);
   _Trim(_Next - begin());

   }
  return (begin() + _Off);
  }

 void clear() noexcept
  {
  erase(begin(), end());
  }

 void flip() noexcept
  {
  for (typename _Vectype::iterator _Next = this->_Myvec.begin();
   _Next != this->_Myvec.end(); ++_Next)
   *_Next = (_Vbase)~*_Next;
  _Trim(this->_Mysize);
  }

 void swap(_Myt& _Right)
  {
  if (this != &_Right)
   {
   this->_Swap_all(_Right);
   this->_Myvec.swap(_Right._Myvec);
   ::std:: swap(this->_Mysize, _Right._Mysize);
   }
  }

 static void swap(reference _Left, reference _Right) noexcept
  {
  bool _Val = _Left;

  _Left = _Right;
  _Right = _Val;
  }

 size_t hash() const
  {
  return (_Hash_seq((const unsigned char *)this->_Myvec.data(),
   this->_Myvec.size() * sizeof (_Vbase)));
  }

 iterator _Insert_n(const_iterator _Where,
  size_type _Count, const bool& _Val)
  {
  size_type _Off = _Insert_x(_Where, _Count);
  ::std:: fill(begin() + _Off, begin() + (_Off + _Count), _Val);
  return (begin() + _Off);
  }

 size_type _Insert_x(const_iterator _Where, size_type _Count)
  {
  size_type _Off = _Where - begin();







  if (_Count == 0)
   ;
  else if (max_size() - size() < _Count)
   _Xlen();
  else
   {
   this->_Myvec.resize(this->_Nw(size() + _Count), 0);
   if (empty())
    this->_Mysize += _Count;
   else
    {
    iterator _Oldend = end();
    this->_Mysize += _Count;
    ::std:: copy_backward(begin() + _Off, _Oldend, end());
    }




   }
  return (_Off);
  }
# 2969 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vector" 3
 void _Orphan_range(size_type, size_type) const
  {
  }


 void _Trim(size_type _Size)
  {
  if (max_size() < _Size)
   _Xlen();
  size_type _Words = this->_Nw(_Size);

  if (_Words < this->_Myvec.size())
   this->_Myvec.erase(this->_Myvec.begin() + _Words,
    this->_Myvec.end());
  this->_Mysize = _Size;
  _Size %= _VBITS;
  if (0 < _Size)
   this->_Myvec[_Words - 1] &= ((_Vbase)(1) << _Size) - 1;
  }

 [[noreturn]] void _Xlen() const
  {
  _Xlength_error("vector<bool> too long");
  }

 [[noreturn]] void _Xran() const
  {
  _Xout_of_range("invalid vector<bool> subscript");
  }
 };

template<class _Alloc> inline
 bool operator==(const vector<bool, _Alloc>& _Left,
  const vector<bool, _Alloc>& _Right)
 {
 return (_Left.size() == _Right.size()
  && ::std:: equal(_Left._Myvec.begin(), _Left._Myvec.end(),
   _Right._Myvec.begin()));
 }

template<class _Alloc> inline
 bool operator!=(const vector<bool, _Alloc>& _Left,
  const vector<bool, _Alloc>& _Right)
 {
 return (!(_Left == _Right));
 }


template<class _Alloc>
 struct hash<vector<bool, _Alloc> >
 {
 typedef vector<bool, _Alloc> argument_type;
 typedef size_t result_type;

 size_t operator()(const argument_type& _Keyval) const
  {
  return (_Keyval.hash());
  }
 };
}


#pragma warning(pop)
#pragma pack(pop)
# 57 "..\\..\\..\\JUCE\\modules\\juce_core/system/juce_StandardHeader.h" 2

# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\iostream" 1 3





# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\istream" 1 3





# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\ostream" 1 3





# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\ios" 1 3





# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xlocnum" 1 3
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xlocnum" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\streambuf" 1 3





# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xiosbase" 1 3





# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xlocale" 1 3
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xlocale" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xlocinfo" 1 3





# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xlocinfo.h" 1 3





# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\ctype.h" 1 3
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\ctype.h" 3
#pragma pack(push, 8)
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\ctype.h" 3
 extern "C" {
# 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\ctype.h" 3
                        int __cdecl _isctype( int _C, int _Type);
                        int __cdecl _isctype_l( int _C, int _Type, _locale_t _Locale);
                                           int __cdecl isalpha( int _C);
                        int __cdecl _isalpha_l( int _C, _locale_t _Locale);
                                           int __cdecl isupper( int _C);
                        int __cdecl _isupper_l( int _C, _locale_t _Locale);
                                           int __cdecl islower( int _C);
                        int __cdecl _islower_l( int _C, _locale_t _Locale);


                                           int __cdecl isdigit( int _C);

                        int __cdecl _isdigit_l( int _C, _locale_t _Locale);
                        int __cdecl isxdigit( int _C);
                        int __cdecl _isxdigit_l( int _C, _locale_t _Locale);


                                           int __cdecl isspace( int _C);

                        int __cdecl _isspace_l( int _C, _locale_t _Locale);
                        int __cdecl ispunct( int _C);
                        int __cdecl _ispunct_l( int _C, _locale_t _Locale);
                        int __cdecl isblank( int _C);
                        int __cdecl _isblank_l( int _C, _locale_t _Locale);
                                           int __cdecl isalnum( int _C);
                        int __cdecl _isalnum_l( int _C, _locale_t _Locale);
                        int __cdecl isprint( int _C);
                        int __cdecl _isprint_l( int _C, _locale_t _Locale);
                        int __cdecl isgraph( int _C);
                        int __cdecl _isgraph_l( int _C, _locale_t _Locale);
                        int __cdecl iscntrl( int _C);
                        int __cdecl _iscntrl_l( int _C, _locale_t _Locale);


                                           int __cdecl toupper( int _C);


                                           int __cdecl tolower( int _C);

                                           int __cdecl _tolower( int _C);
                        int __cdecl _tolower_l( int _C, _locale_t _Locale);
                                           int __cdecl _toupper( int _C);
                        int __cdecl _toupper_l( int _C, _locale_t _Locale);

                        int __cdecl __isascii( int _C);
                        int __cdecl __toascii( int _C);
                        int __cdecl __iscsymf( int _C);
                        int __cdecl __iscsym( int _C);
# 144 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\ctype.h" 3
    __inline __crt_locale_data_public* __cdecl __acrt_get_locale_data_prefix(void const volatile* const _LocalePointers)
    {
        _locale_t const _TypedLocalePointers = (_locale_t)_LocalePointers;
        return (__crt_locale_data_public*)_TypedLocalePointers->locinfo;
    }





    __inline int __cdecl _chvalidchk_l(
                 int const _C,
                 int const _Mask,
                 _locale_t const _Locale
        )
    {



        if (_Locale)
        {
            return __acrt_get_locale_data_prefix(_Locale)->_locale_pctype[_C] & _Mask;
        }

        return (__pctype_func()[(_C)] & (_Mask));

    }




    __inline int __cdecl _ischartype_l(
                 int const _C,
                 int const _Mask,
                 _locale_t const _Locale
        )
    {
        if (_Locale && __acrt_get_locale_data_prefix(_Locale)->_locale_mb_cur_max > 1)
        {
            return _isctype_l(_C, _Mask, _Locale);
        }

        return _chvalidchk_l(_C, _Mask, _Locale);
    }
# 234 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\ctype.h" 3
}
# 234 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\ctype.h" 3
#pragma pack(pop)
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xlocinfo.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\locale.h" 1 3
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\locale.h" 3
#pragma pack(push, 8)
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\locale.h" 3
 extern "C" {
# 29 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\locale.h" 3
struct lconv
{
    char* decimal_point;
    char* thousands_sep;
    char* grouping;
    char* int_curr_symbol;
    char* currency_symbol;
    char* mon_decimal_point;
    char* mon_thousands_sep;
    char* mon_grouping;
    char* positive_sign;
    char* negative_sign;
    char int_frac_digits;
    char frac_digits;
    char p_cs_precedes;
    char p_sep_by_space;
    char n_cs_precedes;
    char n_sep_by_space;
    char p_sign_posn;
    char n_sign_posn;
    wchar_t* _W_decimal_point;
    wchar_t* _W_thousands_sep;
    wchar_t* _W_int_curr_symbol;
    wchar_t* _W_currency_symbol;
    wchar_t* _W_mon_decimal_point;
    wchar_t* _W_mon_thousands_sep;
    wchar_t* _W_positive_sign;
    wchar_t* _W_negative_sign;
};
# 79 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\locale.h" 3
         void __cdecl _lock_locales(void);
         void __cdecl _unlock_locales(void);


         int __cdecl _configthreadlocale(
         int _Flag
    );


         char* __cdecl setlocale(
               int _Category,
               char const* _Locale
    );


         struct lconv* __cdecl localeconv(void);


         _locale_t __cdecl _get_current_locale(void);


         _locale_t __cdecl _create_locale(
           int _Category,
           char const* _Locale
    );

         void __cdecl _free_locale(
             _locale_t _Locale
    );



         wchar_t* __cdecl _wsetlocale(
               int _Category,
               wchar_t const* _Locale
    );


         _locale_t __cdecl _wcreate_locale(
           int _Category,
           wchar_t const* _Locale
    );



         wchar_t** __cdecl ___lc_locale_name_func(void);
         unsigned int __cdecl ___lc_codepage_func (void);
         unsigned int __cdecl ___lc_collate_cp_func (void);



}
# 130 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\locale.h" 3
#pragma pack(pop)
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xlocinfo.h" 2 3




#pragma pack(push,8)
#pragma warning(push, 3)






extern "C" {
# 56 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xlocinfo.h" 3
typedef struct _Collvec
 {
 unsigned int _Page;
 wchar_t *_LocaleName;
 } _Collvec;

typedef struct _Ctypevec
 {
 unsigned int _Page;
 const short *_Table;
 int _Delfl;
 wchar_t *_LocaleName;
 } _Ctypevec;

typedef struct _Cvtvec
 {
 unsigned int _Page;
 unsigned int _Mbcurmax;
 int _Isclocale;
 unsigned char _Isleadbyte[32];
 } _Cvtvec;


              _Collvec __cdecl _Getcoll(void);
              _Ctypevec __cdecl _Getctype(void);
              _Cvtvec __cdecl _Getcvt(void);
              int __cdecl _Getdateorder(void);
# 93 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xlocinfo.h" 3
         int __cdecl _Mbrtowc( wchar_t *, const char *, size_t,
 mbstate_t *, const _Cvtvec *);


              float __cdecl _Stof(const char *,
                                  char **, long);
              double __cdecl _Stod(const char *,
                                  char **, long);
              long double __cdecl _Stold(const char *,
                                  char **, long);

              int __cdecl _Strcoll(const char *, const char *,
 const char *, const char *, const _Collvec *);
              size_t __cdecl _Strxfrm(
                                                             char *_String1,
        char *_End1, const char *, const char *, const _Collvec *);
              int __cdecl _Tolower(int, const _Ctypevec *);
              int __cdecl _Toupper(int, const _Ctypevec *);
              int __cdecl _Wcrtomb( char *, wchar_t, mbstate_t *,
 const _Cvtvec *);
              int __cdecl _Wcscoll(const wchar_t *, const wchar_t *,
 const wchar_t *, const wchar_t *, const _Collvec *);
              size_t __cdecl _Wcsxfrm(
                                                             wchar_t *_String1,
        wchar_t *_End1, const wchar_t *, const wchar_t *, const _Collvec *);

              short __cdecl _Getwctype(wchar_t, const _Ctypevec *);
              const wchar_t *__cdecl _Getwctypes(const wchar_t *,
 const wchar_t *, short *, const _Ctypevec *);
              wchar_t __cdecl _Towlower(wchar_t, const _Ctypevec *);
              wchar_t __cdecl _Towupper(wchar_t, const _Ctypevec *);



}




extern "C" {


         char *__cdecl _Getdays(void);



         char *__cdecl _Getmonths(void);

         void *__cdecl _Gettnames(void);


         size_t __cdecl _Strftime( char *,
      size_t _Maxsize, const char *, const struct tm *,
          void *);



         wchar_t *__cdecl _W_Getdays(void);



         wchar_t *__cdecl _W_Getmonths(void);

         void *__cdecl _W_Gettnames(void);


         size_t __cdecl _Wcsftime( wchar_t *,
      size_t _Maxsize, const wchar_t *, const struct tm *,
          void *);
}
# 172 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xlocinfo.h" 3
         _locale_t __cdecl _GetLocaleForCP(unsigned int);



#pragma warning(pop)
#pragma pack(pop)
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xlocinfo" 2 3




#pragma pack(push,8)
#pragma warning(push, 3)



#pragma warning(disable: 4412)

namespace std {

class _Timevec
 {
public:
                    _Timevec(void *_Ptr = 0)
  : _Timeptr(_Ptr)
  {
  }

                    _Timevec(const _Timevec& _Right)
  {
  *this = _Right;
  }

                    ~_Timevec() noexcept
  {
  free(_Timeptr);
  }

 _Timevec& operator=(const _Timevec& _Right)
  {
  _Timeptr = _Right._Timeptr;
  ((_Timevec *)&_Right)->_Timeptr = 0;
  return (*this);
  }

 void * _Getptr() const
  {
  return (_Timeptr);
  }

private:
 void *_Timeptr;
 };


class _Locinfo
 {
public:
 typedef ::_Collvec _Collvec;
 typedef ::_Ctypevec _Ctypevec;
 typedef ::_Cvtvec _Cvtvec;
 typedef ::std:: _Timevec _Timevec;

 static void __cdecl _Locinfo_ctor(
  _Locinfo *, const char *);
 static void __cdecl _Locinfo_ctor(
  _Locinfo *, int, const char *);
 static void __cdecl _Locinfo_dtor(
  _Locinfo *);
 static _Locinfo& __cdecl _Locinfo_Addcats(
  _Locinfo *, int, const char *);

                    _Locinfo(const char *_Pch = "C")

  : _Lock(0)


  {
  if (_Pch == 0)
   throw runtime_error("bad locale name");
  _Locinfo_ctor(this, _Pch);
  }

                    _Locinfo(int _Cat, const char *_Pch)

  : _Lock(0)


  {
  if (_Pch == 0)
   throw runtime_error("bad locale name");
  _Locinfo_ctor(this, _Cat, _Pch);
  }

                    ~_Locinfo() noexcept
  {
  _Locinfo_dtor(this);
  }

 _Locinfo& _Addcats(int _Cat, const char *_Pch)
  {
  if (_Pch == 0)
   throw runtime_error("bad locale name");
  return (_Locinfo_Addcats(this, _Cat, _Pch));
  }

 const char * _Getname() const
  {
  return (_Newlocname._C_str());
  }

 _Collvec _Getcoll() const
  {
  return (::_Getcoll());
  }

 _Ctypevec _Getctype() const
  {
  return (::_Getctype());
  }

 _Cvtvec _Getcvt() const
  {
  return (::_Getcvt());
  }

 const lconv * _Getlconv() const
  {
  return (localeconv());
  }

 _Timevec _Gettnames() const
  {
  return (_Timevec(::_Gettnames()));
  }

 const char * _Getdays() const
  {
  const char *_Ptr = ::_Getdays();

  if (_Ptr != 0)
   {
   ((_Locinfo *)this)->_Days = _Ptr;
   free((void *)_Ptr);
   }
  return (!_Days._Empty() ? _Days._C_str()
   : ":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday"
    ":Thu:Thursday:Fri:Friday:Sat:Saturday");
  }

 const char * _Getmonths() const
  {
  const char *_Ptr = ::_Getmonths();

  if (_Ptr != 0)
   {
   ((_Locinfo *)this)->_Months = _Ptr;
   free((void *)_Ptr);
   }
  return (!_Months._Empty() ? _Months._C_str()
   : ":Jan:January:Feb:February:Mar:March"
    ":Apr:April:May:May:Jun:June"
    ":Jul:July:Aug:August:Sep:September"
    ":Oct:October:Nov:November:Dec:December");
  }

 const char * _Getfalse() const
  {
  return ("false");
  }

 const char * _Gettrue() const
  {
  return ("true");
  }

 int _Getdateorder() const
  {
  return (::_Getdateorder());
  }

 _Timevec _W_Gettnames() const
  {
  return (_Timevec(::_W_Gettnames()));
  }

 const unsigned short * _W_Getdays() const
  {
  const wchar_t *_Ptr = ::_W_Getdays();

  if (_Ptr != 0)
   {
   ((_Locinfo *)this)->_W_Days = _Ptr;
   free((void *)_Ptr);
   }
  return ((const unsigned short *)(!_W_Days._Empty()
   ? _W_Days._C_str()
   : L":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday"
    L":Thu:Thursday:Fri:Friday:Sat:Saturday"));
  }

 const unsigned short * _W_Getmonths() const
  {
  const wchar_t *_Ptr = ::_W_Getmonths();

  if (_Ptr != 0)
   {
   ((_Locinfo *)this)->_W_Months = _Ptr;
   free((void *)_Ptr);
   }
  return ((const unsigned short *)(!_W_Months._Empty()
   ? _W_Months._C_str()
   : L":Jan:January:Feb:February:Mar:March"
    L":Apr:April:May:May:Jun:June"
    L":Jul:July:Aug:August:Sep:September"
    L":Oct:October:Nov:November:Dec:December"));
  }

 _Locinfo(const _Locinfo&) = delete;
 _Locinfo& operator=(const _Locinfo&) = delete;

private:




 _Lockit _Lock;


 _Yarn<char> _Days;
 _Yarn<char> _Months;
 _Yarn<wchar_t> _W_Days;
 _Yarn<wchar_t> _W_Months;
 _Yarn<char> _Oldlocname;
 _Yarn<char> _Newlocname;
 };


template<class _Elem> inline
 int __cdecl _LStrcoll(const _Elem *_First1, const _Elem *_Last1,
  const _Elem *_First2, const _Elem *_Last2,
   const _Locinfo::_Collvec *)
 {
 for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)
  if (*_First1 < *_First2)
   return (-1);
  else if (*_First2 < *_First1)
   return (+1);
 return (_First2 != _Last2 ? -1 : _First1 != _Last1 ? +1 : 0);
 }

template<> inline
 int __cdecl _LStrcoll(const char *_First1, const char *_Last1,
  const char *_First2, const char *_Last2,
   const _Locinfo::_Collvec *_Vector)
 {
 return (_Strcoll(_First1, _Last1, _First2, _Last2, _Vector));
 }

template<> inline
 int __cdecl _LStrcoll(const wchar_t *_First1, const wchar_t *_Last1,
  const wchar_t *_First2, const wchar_t *_Last2,
   const _Locinfo::_Collvec *_Vector)
 {
 return (_Wcscoll(_First1, _Last1, _First2, _Last2, _Vector));
 }


template<class _Elem> inline
 size_t __cdecl _LStrxfrm(_Elem *_First1, _Elem *_Last1,
  const _Elem *_First2, const _Elem *_Last2,
   const _Locinfo::_Collvec *)
 {
 size_t _Count = _Last2 - _First2;
 if (_Count <= (size_t)(_Last1 - _First1))
  ::memcpy_s((_First1), ((_Last1 - _First1) * sizeof (_Elem)), (_First2), (_Count * sizeof (_Elem)));

 return (_Count);
 }

template<> inline
 size_t __cdecl _LStrxfrm(
                               char *_First1, char *_Last1,
  const char *_First2, const char *_Last2,
   const _Locinfo::_Collvec *_Vector)
 {
 return (_Strxfrm(_First1, _Last1, _First2, _Last2, _Vector));
 }

template<> inline
 size_t __cdecl _LStrxfrm(
                               wchar_t *_First1, wchar_t *_Last1,
  const wchar_t *_First2, const wchar_t *_Last2,
   const _Locinfo::_Collvec *_Vector)
 {
 return (_Wcsxfrm(_First1, _Last1, _First2, _Last2, _Vector));
 }
}

#pragma warning(pop)
#pragma pack(pop)
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xlocale" 2 3


# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xfacet" 1 3







#pragma pack(push,8)
#pragma warning(push, 3)








namespace std {

class _Facet_base
 {
public:
 virtual ~_Facet_base() noexcept
  {
  }


 virtual void _Incref() = 0;


 virtual _Facet_base * _Decref() = 0;
 };





void __cdecl _Facet_Register(_Facet_base *);

}

#pragma warning(pop)
#pragma pack(pop)
# 12 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xlocale" 2 3


#pragma pack(push,8)
#pragma warning(push, 3)



#pragma warning(disable: 4412 28197)

namespace std {

template<class _Dummy>
 class _Locbase
 {
public:
          static const int collate = ((1 << (1)) >> 1);
          static const int ctype = ((1 << (2)) >> 1);
          static const int monetary = ((1 << (3)) >> 1);
          static const int numeric = ((1 << (4)) >> 1);
          static const int time = ((1 << (5)) >> 1);
          static const int messages = ((1 << (6)) >> 1);
          static const int all = (((1 << ((6 + 1))) >> 1) - 1);
          static const int none = 0;
 };

template<class _Dummy>
 const int _Locbase<_Dummy>::collate;
template<class _Dummy>
 const int _Locbase<_Dummy>::ctype;
template<class _Dummy>
 const int _Locbase<_Dummy>::monetary;
template<class _Dummy>
 const int _Locbase<_Dummy>::numeric;
template<class _Dummy>
 const int _Locbase<_Dummy>::time;
template<class _Dummy>
 const int _Locbase<_Dummy>::messages;
template<class _Dummy>
 const int _Locbase<_Dummy>::all;
template<class _Dummy>
 const int _Locbase<_Dummy>::none;


class locale;
template<class _Facet>
 const _Facet& __cdecl use_facet(const locale&);
template<class _Elem>
 class collate;

struct _Crt_new_delete
 {
# 96 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xlocale" 3
 };

class locale
 : public _Locbase<int>, public _Crt_new_delete
 {
public:
 typedef int category;


 class id
  {
 public:
                     id(size_t _Val = 0)
   : _Id(_Val)
   {
   }

                     operator size_t()
   {
   if (_Id == 0)
    {
    { ::std:: _Lockit _Lock(0);
     if (_Id == 0)
      _Id = ++_Id_cnt;
    }
    }
   return (_Id);
   }

 private:
  size_t _Id;

                          static int _Id_cnt;

 public:
                     id(const id&) = delete;
  id& operator=(const id&) = delete;
  };

 class _Locimp;


 class facet
  : public _Facet_base, public _Crt_new_delete
  {
 public:
  static size_t __cdecl _Getcat(const facet ** = 0,
   const locale * = 0)
   {
   return ((size_t)(-1));
   }

  virtual void _Incref()
   {
   _InterlockedIncrement(reinterpret_cast<volatile long *>(&_Myrefs));
   }

  virtual _Facet_base * _Decref()
   {
   if (_InterlockedDecrement(reinterpret_cast<volatile long *>(&_Myrefs)) == 0)
    return (this);
   else
    return (0);
   }

 private:
  _Atomic_counter_t _Myrefs;

 protected:
  explicit facet(size_t _Initrefs = 0)
   {
   _Init_atomic_counter(_Myrefs, (_Atomic_integral_t)_Initrefs);
   }

  virtual ~facet() noexcept
   {
   }

 public:
                     facet(const facet&) = delete;
  facet& operator=(const facet&) = delete;
  };


#pragma warning(push)
#pragma warning(disable: 4275)

 class _Locimp
  : public facet
  {
 protected:
                     ~_Locimp() noexcept
  {
  _Locimp_dtor(this);
  }

 private:
  static _Locimp *__cdecl
   _New_Locimp(bool _Transparent = false);
  static _Locimp *__cdecl
   _New_Locimp(const _Locimp& _Right);

  static void __cdecl
   _Locimp_dtor(_Locimp *);
  static void __cdecl
   _Locimp_Addfac(_Locimp *, facet *, size_t);
  static void __cdecl
   _Locimp_ctor(_Locimp *, const _Locimp&);

  friend class locale;

                     _Locimp(bool _Transparent)
   : locale::facet(1), _Facetvec(0), _Facetcount(0),
    _Catmask(none), _Xparent(_Transparent),
     _Name("*")
   {
   }

                     _Locimp(const _Locimp& _Right)
   : locale::facet(1), _Facetvec(0), _Facetcount(_Right._Facetcount),
    _Catmask(_Right._Catmask), _Xparent(_Right._Xparent),
     _Name(_Right._Name.c_str())
   {
   _Locimp_ctor(this, _Right);
   }

  void _Addfac(facet *_Pfacet, size_t _Id)
   {
   _Locimp_Addfac(this, _Pfacet, _Id);
   }

  static _Locimp *__cdecl _Makeloc(const _Locinfo&,
   category, _Locimp *, const locale *);

  static void __cdecl _Makewloc(const _Locinfo&,
   category, _Locimp *, const locale *);


  static void __cdecl _Makeushloc(const _Locinfo&,
   category, _Locimp *, const locale *);


  static void __cdecl _Makexloc(const _Locinfo&,
   category, _Locimp *, const locale *);

  facet **_Facetvec;
  size_t _Facetcount;
  category _Catmask;
  bool _Xparent;
  _Yarn<char> _Name;

                          static _Locimp *_Clocptr;

public:
  _Locimp& operator=(const _Locimp&) = delete;
  };

#pragma warning(pop)

 template<class _Elem,
  class _Traits,
  class _Alloc>
  bool operator()(const basic_string<_Elem, _Traits, _Alloc>& _Left,
   const basic_string<_Elem, _Traits, _Alloc>& _Right) const
  {
  const ::std:: collate<_Elem>& _Coll_fac =
   use_facet< ::std:: collate<_Elem> >(*this);

  return (_Coll_fac.compare(_Left.c_str(), _Left.c_str() + _Left.size(),
   _Right.c_str(), _Right.c_str() + _Right.size()) < 0);
  }

 template<class _Facet>
  locale combine(const locale& _Loc) const
  {
  _Facet *_Facptr;

  try {
   _Facptr = (_Facet *)&use_facet<_Facet>(_Loc);
  } catch (...) {
   _Xruntime_error("locale::combine facet missing");
  }

  _Locimp *_Newimp = _Locimp::_New_Locimp(*_Ptr);
  _Newimp->_Addfac(_Facptr, _Facet::id);
  _Newimp->_Catmask = none;
  _Newimp->_Name = "*";
  return (locale(_Newimp));
  }

 template<class _Facet>
  locale(const locale& _Loc, const _Facet *_Facptr)
   : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
  {
  if (_Facptr != 0)
   {
   _Ptr->_Addfac((_Facet *)_Facptr, _Facet::id);
   _Ptr->_Catmask = none;
   _Ptr->_Name = "*";
   }
  }

 locale(_Uninitialized)
  {
  }
# 323 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xlocale" 3
 locale(const locale& _Right) noexcept
  : _Ptr(_Right._Ptr)
  {
  _Ptr->_Incref();
  }

 locale() noexcept
  : _Ptr(_Init(true))
  {
  }


 locale(const locale& _Loc, const locale& _Other,
  category _Cat)
  : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
  {
  if (_Cat != none)
   {
   try {
    { _Locinfo _Lobj;
     _Locimp::_Makeloc(_Lobj, _Cat, _Ptr, &_Other);
     _Lobj._Addcats(_Loc._Ptr->_Catmask,
      _Loc.name().c_str());
     _Lobj._Addcats(_Other._Ptr->_Catmask,
      _Other.name().c_str());
     _Ptr->_Catmask = _Loc._Ptr->_Catmask
      | _Other._Ptr->_Catmask;
     _Ptr->_Name = _Lobj._Getname();
    }
   } catch (...) {
   delete _Ptr->_Decref();
   throw;
   }
   }
  }

private:
 void _Construct(const string &_Str,
  category _Cat)
  {
  bool _Bad = false;
  _Init();
  if (_Cat != none)
   {
   try {
    { _Locinfo _Lobj(_Cat, _Str.c_str());
     if (_Badname(_Lobj))
      _Bad = true;
     else
      {
      _Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0);
      _Ptr->_Catmask = _Cat;
      _Ptr->_Name = _Str.c_str();
      }
    }
   } catch (...) {
   delete _Ptr->_Decref();
   throw;
   }
   }

  if (_Bad)
   {
   delete _Ptr->_Decref();
   _Xruntime_error("bad locale name");
   }
  }

public:
 explicit locale(const char *_Locname,
  category _Cat = all)
  : _Ptr(_Locimp::_New_Locimp())
  {


  if (_Locname == 0)
   _Xruntime_error("bad locale name");
  _Construct(_Locname, _Cat);
  }

 locale(const locale& _Loc, const char *_Locname,
  category _Cat)
  : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
  {


  if (_Locname == 0)
   _Xruntime_error("bad locale name");
  _Construct(_Locname, _Cat);
  }

 explicit locale(const string& _Str,
  category _Cat = all)
  : _Ptr(_Locimp::_New_Locimp())
  {
  _Construct(_Str, _Cat);
  }

 locale(const locale& _Loc, const string& _Str,
  category _Cat)
  : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
  {
  _Construct(_Str, _Cat);
  }


 ~locale() noexcept
  {
  if (_Ptr != 0)
   delete _Ptr->_Decref();
  }

 locale& operator=(const locale& _Right) noexcept
  {
  if (_Ptr != _Right._Ptr)
   {
   delete _Ptr->_Decref();
   _Ptr = _Right._Ptr;
   _Ptr->_Incref();
   }
  return (*this);
  }


 string name() const
  {
  return (_Ptr == 0 ? string() : _Ptr->_Name.c_str());
  }

 const char *c_str() const
  {
  return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());
  }

 const facet *_Getfacet(size_t _Id) const
  {
  const facet *_Facptr = _Id < _Ptr->_Facetcount
   ? _Ptr->_Facetvec[_Id] : 0;
  if (_Facptr != 0 || !_Ptr->_Xparent)
   return (_Facptr);
  else
   {
   locale::_Locimp *_Ptr0 = _Getgloballocale();
   return (_Id < _Ptr0->_Facetcount
    ? _Ptr0->_Facetvec[_Id]
    : 0);
   }
  }

 bool operator==(const locale& _Loc) const
  {
  return (_Ptr == _Loc._Ptr
   || (name().compare("*") != 0
    && name().compare(_Loc.name()) == 0));
  }

 bool operator!=(const locale& _Right) const
  {
  return (!(*this == _Right));
  }

 static const locale& __cdecl
  classic();

 static locale __cdecl
  global(const locale&);

 static locale __cdecl
  empty();

private:
 locale(_Locimp *_Ptrimp)
  : _Ptr(_Ptrimp)
  {
  }

 static _Locimp *__cdecl
  _Init(bool _Do_incref = false);
 static _Locimp *__cdecl
  _Getgloballocale();
 static void __cdecl
  _Setgloballocale(void *);

 bool _Badname(const _Locinfo& _Lobj)
  {
  return (:: strcmp(_Lobj._Getname(), "*") == 0);
  }

 _Locimp *_Ptr;
 };
# 535 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xlocale" 3
template<class _Facet>
 struct _Facetptr
 {
                         static const locale::facet *_Psave;
 };

template<class _Facet>
                         const locale::facet *_Facetptr<_Facet>::
  _Psave = 0;






template<class _Facet> inline
 const _Facet& __cdecl use_facet(const locale& _Loc)

 {





 { ::std:: _Lockit _Lock(0);
  const locale::facet *_Psave =
   _Facetptr<_Facet>::_Psave;

  size_t _Id = _Facet::id;
  const locale::facet *_Pf = _Loc._Getfacet(_Id);

  if (_Pf != 0)
   ;
  else if (_Psave != 0)
   _Pf = _Psave;
  else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))



   throw ::std:: bad_cast();





  else
   {
   _Pf = _Psave;
   _Facetptr<_Facet>::_Psave = _Psave;

   locale::facet *_Pfmod = (_Facet *)_Psave;
   _Pfmod->_Incref();





   _Facet_Register(_Pfmod);

   }

  return ((const _Facet&)(*_Pf));
 }

 }


template<class _Elem,
 class _InIt> inline
 int __cdecl _Getloctxt(_InIt& _First, _InIt& _Last, size_t _Numfields,
  const _Elem *_Ptr)
 {
 for (size_t _Off = 0; _Ptr[_Off] != (_Elem)0; ++_Off)
  if (_Ptr[_Off] == _Ptr[0])
   ++_Numfields;
 string _Str(_Numfields, '\0');

 int _Ans = -2;
 for (size_t _Column = 1; ; ++_Column, (void)++_First, _Ans = -1)
  {
  bool _Prefix = false;
  size_t _Off = 0;
  size_t _Field = 0;

  for (; _Field < _Numfields; ++_Field)
   {
   for (; _Ptr[_Off] != (_Elem)0 && _Ptr[_Off] != _Ptr[0]; ++_Off)
    ;

   if (_Str[_Field] != '\0')
    _Off += _Str[_Field];
   else if (_Ptr[_Off += _Column] == _Ptr[0]
    || _Ptr[_Off] == (_Elem)0)
    {
    _Str[_Field] = (char)(_Column < 127
     ? _Column : 127);
    _Ans = (int)_Field;
    }
   else if (_First == _Last || _Ptr[_Off] != *_First)
    _Str[_Field] = (char)(_Column < 127
     ? _Column : 127);
   else
    _Prefix = true;
   }

  if (!_Prefix || _First == _Last)
   break;
  }
 return (_Ans);
 }





template<class _Elem> inline
 char __cdecl _Maklocbyte(_Elem _Char,
  const _Locinfo::_Cvtvec&)
 {
 return ((char)(unsigned char)_Char);
 }

template<> inline
 char __cdecl _Maklocbyte(wchar_t _Char,
  const _Locinfo::_Cvtvec& _Cvt)
 {
 char _Byte = '\0';
 mbstate_t _Mbst1 = {};
 _Wcrtomb(&_Byte, _Char, &_Mbst1, &_Cvt);
 return (_Byte);
 }


template<> inline
 char __cdecl _Maklocbyte(unsigned short _Char,
  const _Locinfo::_Cvtvec &_Cvt)
 {
 char _Byte = '\0';
 mbstate_t _Mbst1 = {};
 _Wcrtomb(&_Byte, (wchar_t)_Char, &_Mbst1, &_Cvt);
 return (_Byte);
 }






template<class _Elem> inline
 _Elem __cdecl _Maklocchr(char _Byte, _Elem *,
  const _Locinfo::_Cvtvec&)
 {
 return ((_Elem)(unsigned char)_Byte);
 }

template<> inline
 wchar_t __cdecl _Maklocchr(char _Byte, wchar_t *,
  const _Locinfo::_Cvtvec& _Cvt)
 {
 wchar_t _Wc = L'\0';
 mbstate_t _Mbst1 = {};
 _Mbrtowc(&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);
 return (_Wc);
 }


template<> inline
 unsigned short __cdecl _Maklocchr(char _Byte, unsigned short *,
  const _Locinfo::_Cvtvec &_Cvt)
 {
 unsigned short _Wc = (unsigned short)0;
 mbstate_t _Mbst1 = {};
 _Mbrtowc((wchar_t *)&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);
 return (_Wc);
 }






template<class _Elem> inline
 _Elem *__cdecl _Maklocstr(const char *_Ptr, _Elem *,
  const _Locinfo::_Cvtvec&)
 {
 size_t _Count = :: strlen(_Ptr) + 1;

 _Elem *_Ptrdest = (_Elem *)calloc(_Count, sizeof (_Elem));


 if (!_Ptrdest)
  _Xbad_alloc();

#pragma warning(push)
#pragma warning(disable: 6011)
 for (_Elem *_Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr)
  *_Ptrnext = (_Elem)(unsigned char)*_Ptr;
#pragma warning(pop)

 return (_Ptrdest);
 }

template<> inline
 wchar_t *__cdecl _Maklocstr(const char *_Ptr, wchar_t *,
  const _Locinfo::_Cvtvec& _Cvt)
 {
 size_t _Count, _Count1;
 size_t _Wchars;
 const char *_Ptr1;
 int _Bytes;
 wchar_t _Wc;
 mbstate_t _Mbst1 = {};

 _Count1 = :: strlen(_Ptr) + 1;
 for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count;
  _Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars)
  if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0)
   break;
 ++_Wchars;

 wchar_t *_Ptrdest = (wchar_t *)calloc(_Wchars, sizeof (wchar_t));


 if (!_Ptrdest)
  _Xbad_alloc();
 wchar_t *_Ptrnext = _Ptrdest;
 mbstate_t _Mbst2 = {};

#pragma warning(push)
#pragma warning(disable: 6011)
 for (; 0 < _Wchars;
  _Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext)
  if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0)
   break;
 *_Ptrnext = L'\0';
#pragma warning(pop)

 return (_Ptrdest);
 }


template<> inline
 unsigned short *__cdecl _Maklocstr(const char *_Ptr, unsigned short *,
  const _Locinfo::_Cvtvec &_Cvt)
 {
 size_t _Count, _Count1;
 size_t _Wchars;
 const char *_Ptr1;
 int _Bytes;
 unsigned short _Wc;
 mbstate_t _Mbst1 = {};

 _Count1 = :: strlen(_Ptr) + 1;
 for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count;
  _Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars)
  if ((_Bytes =
   _Mbrtowc((wchar_t *)&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0)
   break;
 ++_Wchars;

 wchar_t *_Ptrdest = (wchar_t *)calloc(_Wchars, sizeof (wchar_t));


 if (!_Ptrdest)
  _Xbad_alloc();

 wchar_t *_Ptrnext = _Ptrdest;
 mbstate_t _Mbst2 = {};
 for (; 0 < _Wchars;
  _Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext)
  if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0)
   break;
 *_Ptrnext = L'\0';
 return ((unsigned short *)_Ptrdest);
 }



#pragma warning(push)
#pragma warning(disable: 4275)

class codecvt_base
 : public locale::facet
 {
public:
 enum
  {
  ok, partial, error, noconv};
 typedef int result;

                    codecvt_base(size_t _Refs = 0)
  : locale::facet(_Refs)
  {
  }

 bool always_noconv() const noexcept
  {
  return (do_always_noconv());
  }

 int max_length() const noexcept
  {
  return (do_max_length());
  }

 int encoding() const noexcept
  {
  return (do_encoding());
  }

                    ~codecvt_base() noexcept
  {
  }

protected:
 virtual bool do_always_noconv() const noexcept
  {
  return (false);
  }

 virtual int do_max_length() const noexcept
  {
  return (1);
  }

 virtual int do_encoding() const noexcept
  {
  return (1);
  }
 };

#pragma warning(pop)


template<class _Elem,
 class _Byte,
 class _Statype>
 class codecvt
  : public codecvt_base
 {
public:
 typedef _Elem intern_type;
 typedef _Byte extern_type;
 typedef _Statype state_type;

 result in(_Statype& _State,
  const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
  _Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
  {
  return (do_in(_State,
   _First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
  }

 result out(_Statype& _State,
  const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
  return (do_out(_State,
   _First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
  }

 result unshift(_Statype& _State,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
  return (do_unshift(_State, _First2, _Last2, _Mid2));
  }

 int length(_Statype& _State, const _Byte *_First1,
  const _Byte *_Last1, size_t _Count) const
  {
  return (do_length(_State, _First1, _Last1, _Count));
  }

                         static locale::id id;

 explicit codecvt(size_t _Refs = 0)
  : codecvt_base(_Refs)
  {
  _Init(_Locinfo());
  }

                    codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
  : codecvt_base(_Refs)
  {
  _Init(_Lobj);
  }

 static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
  const locale *_Ploc = 0)
  {
  if (_Ppf != 0 && *_Ppf == 0)
   *_Ppf = new codecvt<_Elem, _Byte, _Statype>(
    _Locinfo(_Ploc->c_str()));
  return (2);
  }

protected:
 virtual ~codecvt() noexcept
  {
  }

 void _Init(const _Locinfo&)
  {
  }

 virtual bool do_always_noconv() const noexcept
  {
  return (is_same<_Byte, _Elem>::value);
  }

 virtual result do_in(_Statype&,
  const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
  _Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
  {
  _Mid1 = _First1, _Mid2 = _First2;
  if (is_same<_Byte, _Elem>::value)
   return (noconv);
  else
   {
   for (; _Mid1 != _Last1 && _Mid2 != _Last2; ++_Mid1, ++_Mid2)
    *_Mid2 = (_Elem)*_Mid1;
   return (ok);
   }
  }

 virtual result do_out(_Statype&,
  const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
  _Mid1 = _First1, _Mid2 = _First2;
  if (is_same<_Byte, _Elem>::value)
   return (noconv);
  else
   {
   for (; _Mid1 != _Last1 && _Mid2 != _Last2; ++_Mid1, ++_Mid2)
    *_Mid2 = (_Byte)*_Mid1;
   return (ok);
   }
  }

 virtual result do_unshift(_Statype&,
  _Byte *_First2, _Byte *, _Byte *&_Mid2) const
  {
  _Mid2 = _First2;
  return (ok);
  }

 virtual int do_length(_Statype&, const _Byte *_First1,
  const _Byte *_Last1, size_t _Count) const
  {
  return ((int)(_Count < (size_t)(_Last1 - _First1)
   ? _Count : _Last1 - _First1));
  }
 };


template<class _Elem,
 class _Byte,
 class _Statype>
                         locale::id codecvt<_Elem, _Byte, _Statype>::id;


enum _Codecvt_mode {
 _Consume_header = 4,
 _Generate_header = 2
 };


template<>
 class codecvt<char16_t, char, _Mbstatet>
 : public codecvt_base
 {
public:
 typedef codecvt<char16_t, char, _Mbstatet> _Mybase;
 typedef char16_t _Elem;
 typedef char _Byte;
 typedef _Mbstatet _Statype;
 typedef _Elem intern_type;
 typedef _Byte extern_type;
 typedef _Statype state_type;

 result in(_Statype& _State,
  const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
  _Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
  {
  return (do_in(_State,
   _First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
  }

 result out(_Statype& _State,
  const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
  return (do_out(_State,
   _First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
  }

 result unshift(_Statype& _State,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
  return (do_unshift(_State,
   _First2, _Last2, _Mid2));
  }

 int length(_Statype& _State, const _Byte *_First1,
  const _Byte *_Last1, size_t _Count) const
  {
  return (do_length(_State, _First1, _Last1, _Count));
  }

                         static locale::id id;

 explicit codecvt(size_t _Refs = 0)
  : codecvt_base(_Refs), _Maxcode(0x10ffff), _Mode(_Consume_header)
  {
  { _Locinfo _Lobj;
   _Init(_Lobj);
  }
  }

                    codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
  : codecvt_base(_Refs), _Maxcode(0x10ffff), _Mode(_Consume_header)
  {
  _Init(_Lobj);
  }

                    codecvt(const _Locinfo& _Lobj, unsigned long _Maxcode_arg,
  _Codecvt_mode _Mode_arg, size_t _Refs = 0)
  : codecvt_base(_Refs), _Maxcode(_Maxcode_arg), _Mode(_Mode_arg)
  {
  _Init(_Lobj);
  }

 static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
  const locale *_Ploc = 0)
  {
  if (_Ppf != 0 && *_Ppf == 0)
   *_Ppf = new codecvt<_Elem, _Byte, _Statype>(
    _Locinfo(_Ploc->c_str()));
  return (2);
  }

protected:
 virtual ~codecvt() noexcept
  {
  }

 void _Init(const _Locinfo&)
  {
  }

 virtual result do_in(_Statype& _State,
  const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
  _Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
  {
  unsigned short *_Pstate = (unsigned short *)&_State;
  _Mid1 = _First1;
  _Mid2 = _First2;

  for (; _Mid1 != _Last1 && _Mid2 != _Last2; )
   {
   unsigned char _By = (unsigned char)*_Mid1;
   unsigned long _Ch;
   int _Nextra, _Nskip;

   if (*_Pstate <= 1)
    ;
   else if (_By < 0x80 || 0xc0 <= _By)
    return (_Mybase::error);
   else
    {
    ++_Mid1;
    *_Mid2++ = (_Elem)(*_Pstate | (_By & 0x3f));
    *_Pstate = 1;
    continue;
    }

   if (_By < 0x80)
    _Ch = _By, _Nextra = 0;
   else if (_By < 0xc0)
    {
    ++_Mid1;
    return (_Mybase::error);
    }
   else if (_By < 0xe0)
    _Ch = _By & 0x1f, _Nextra = 1;
   else if (_By < 0xf0)
    _Ch = _By & 0x0f, _Nextra = 2;
   else if (_By < 0xf8)
    _Ch = _By & 0x07, _Nextra = 3;
   else
    _Ch = _By & 0x03, _Nextra = _By < 0xfc ? 4 : 5;

   _Nskip = _Nextra < 3 ? 0 : 1;
   _First1 = _Mid1;

   if (_Nextra == 0)
    ++_Mid1;
   else if (_Last1 - _Mid1 < _Nextra + 1 - _Nskip)
    break;
   else
    for (++_Mid1; _Nskip < _Nextra; --_Nextra, ++_Mid1)
     if ((_By = (unsigned char)*_Mid1) < 0x80 || 0xc0 <= _By)
      return (_Mybase::error);
     else
      _Ch = _Ch << 6 | (_By & 0x3f);
   if (0 < _Nskip)
    _Ch <<= 6;

   if ((_Maxcode < 0x10ffff ? _Maxcode : 0x10ffff) < _Ch)
    return (_Mybase::error);
   else if (0xffff < _Ch)
    {
    unsigned short _Ch0 =
     (unsigned short)(0xd800 | (_Ch >> 10) - 0x0040);

    *_Mid2++ = (_Elem)_Ch0;
    *_Pstate = (unsigned short)(0xdc00 | (_Ch & 0x03ff));
    continue;
    }

   if (_Nskip == 0)
    ;
   else if (_Mid1 == _Last1)
    {
    _Mid1 = _First1;
    break;
    }
   else if ((_By = (unsigned char)*_Mid1++) < 0x80 || 0xc0 <= _By)
    return (_Mybase::error);
   else
    _Ch |= _By & 0x3f;

   if (*_Pstate == 0)
    {
    *_Pstate = 1;

    if ((_Mode & _Consume_header) != 0 && _Ch == 0xfeff)
     {
     result _Ans = do_in(_State, _Mid1, _Last1, _Mid1,
      _First2, _Last2, _Mid2);

     if (_Ans == _Mybase::partial)
      {
      *_Pstate = 0;
      _Mid1 = _First1;
      }
     return (_Ans);
     }
    }

   *_Mid2++ = (_Elem)_Ch;
   }

  return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
  }

 virtual result do_out(_Statype& _State,
  const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
  unsigned short *_Pstate = (unsigned short *)&_State;
  _Mid1 = _First1;
  _Mid2 = _First2;

  for (; _Mid1 != _Last1 && _Mid2 != _Last2; )
   {
   unsigned long _Ch;
   unsigned short _Ch1 = (unsigned short)*_Mid1;
   bool _Save = false;

   if (1 < *_Pstate)
    {
    if (_Ch1 < 0xdc00 || 0xe000 <= _Ch1)
     return (_Mybase::error);
    _Ch = (*_Pstate << 10) | (_Ch1 - 0xdc00);
    }
   else if (0xd800 <= _Ch1 && _Ch1 < 0xdc00)
    {
    _Ch = (_Ch1 - 0xd800 + 0x0040) << 10;
    _Save = true;
    }
   else
    _Ch = _Ch1;

   _Byte _By;
   int _Nextra;

   if (_Ch < 0x0080)
    _By = (_Byte)_Ch, _Nextra = 0;
   else if (_Ch < 0x0800)
    _By = (_Byte)(0xc0 | _Ch >> 6), _Nextra = 1;
   else if (_Ch < 0x10000)
    _By = (_Byte)(0xe0 | _Ch >> 12), _Nextra = 2;
   else
    _By = (_Byte)(0xf0 | _Ch >> 18), _Nextra = 3;

   int _Nput = _Nextra < 3 ? _Nextra + 1 : _Save ? 1 : 3;

   if (_Last2 - _Mid2 < _Nput)
    break;
   else if (*_Pstate != 0 || (_Mode & _Generate_header) == 0)
    ;
   else if (_Last2 - _Mid2 < 3 + _Nput)
    break;
   else
    {
    *_Mid2++ = (_Byte)(unsigned char)0xef;
    *_Mid2++ = (_Byte)(unsigned char)0xbb;
    *_Mid2++ = (_Byte)(unsigned char)0xbf;
    }

   ++_Mid1;
   if (_Save || _Nextra < 3)
    {
    *_Mid2++ = _By;
    --_Nput;
    }
   for (; 0 < _Nput; --_Nput)
    *_Mid2++ = (_Byte)((_Ch >> 6 * --_Nextra & 0x3f) | 0x80);

   *_Pstate = (unsigned short)(_Save ? _Ch >> 10 : 1);
   }

  return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
  }

 virtual result do_unshift(_Statype& _State,
  _Byte *_First2, _Byte *, _Byte *& _Mid2) const
  {
  unsigned short *_Pstate = (unsigned short *)&_State;
  _Mid2 = _First2;

  return (1 < *_Pstate
   ? _Mybase::error : _Mybase::ok);
  }

 virtual int do_length(_Statype& _State, const _Byte *_First1,
  const _Byte *_Last1, size_t _Count) const
  {
  size_t _Wchars = 0;
  _Statype _Mystate = _State;

  for (; _Wchars < _Count && _First1 != _Last1; )
   {
   const _Byte *_Mid1;
   _Elem *_Mid2;
   _Elem _Ch;

   switch (do_in(_Mystate, _First1, _Last1, _Mid1,
    &_Ch, &_Ch + 1, _Mid2))
    {
   case _Mybase::noconv:
    return ((int)(_Wchars + (_Last1 - _First1)));

   case _Mybase::ok:
    if (_Mid2 == &_Ch + 1)
     ++_Wchars;
    _First1 = _Mid1;
    break;

   default:
    return ((int)_Wchars);
    }
   }

  return ((int)_Wchars);
  }

 virtual bool do_always_noconv() const noexcept
  {
  return (false);
  }

 virtual int do_max_length() const noexcept
  {
  return ((_Mode & _Consume_header) != 0 ? 9
   : (_Mode & _Generate_header) != 0 ? 7
   : 6);
  }

 virtual int do_encoding() const noexcept
  {
  return (0);
  }

private:
 unsigned long _Maxcode;
 _Codecvt_mode _Mode;
 };


template<>
 class codecvt<char32_t, char, _Mbstatet>
 : public codecvt_base
 {
public:
 typedef codecvt<char32_t, char, _Mbstatet> _Mybase;
 typedef char32_t _Elem;
 typedef char _Byte;
 typedef _Mbstatet _Statype;
 typedef _Elem intern_type;
 typedef _Byte extern_type;
 typedef _Statype state_type;

 result in(_Statype& _State,
  const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
  _Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
  {
  return (do_in(_State,
   _First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
  }

 result out(_Statype& _State,
  const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
  return (do_out(_State,
   _First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
  }

 result unshift(_Statype& _State,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
  return (do_unshift(_State,
   _First2, _Last2, _Mid2));
  }

 int length(_Statype& _State, const _Byte *_First1,
  const _Byte *_Last1, size_t _Count) const
  {
  return (do_length(_State, _First1, _Last1, _Count));
  }

                         static locale::id id;

 explicit codecvt(size_t _Refs = 0)
  : codecvt_base(_Refs), _Maxcode(0xffffffff), _Mode(_Consume_header)
  {
  { _Locinfo _Lobj;
   _Init(_Lobj);
  }
  }

                    codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
  : codecvt_base(_Refs), _Maxcode(0xffffffff), _Mode(_Consume_header)
  {
  _Init(_Lobj);
  }

                    codecvt(const _Locinfo& _Lobj, unsigned long _Maxcode_arg,
  _Codecvt_mode _Mode_arg, size_t _Refs = 0)
  : codecvt_base(_Refs), _Maxcode(_Maxcode_arg), _Mode(_Mode_arg)
  {
  _Init(_Lobj);
  }

 static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
  const locale *_Ploc = 0)
  {
  if (_Ppf != 0 && *_Ppf == 0)
   *_Ppf = new codecvt<_Elem, _Byte, _Statype>(
    _Locinfo(_Ploc->c_str()));
  return (2);
  }

protected:
 virtual ~codecvt() noexcept
  {
  }

 void _Init(const _Locinfo&)
  {
  }

 virtual result do_in(_Statype& _State,
  const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
  _Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
  {
  char *_Pstate = (char *)&_State;
  _Mid1 = _First1;
  _Mid2 = _First2;

  for (; _Mid1 != _Last1 && _Mid2 != _Last2; )
   {
   unsigned char _By = (unsigned char)*_Mid1;
   unsigned long _Ch;
   int _Nextra;

   if (_By < 0x80)
    _Ch = _By, _Nextra = 0;
   else if (_By < 0xc0)
    {
    ++_Mid1;
    return (_Mybase::error);
    }
   else if (_By < 0xe0)
    _Ch = _By & 0x1f, _Nextra = 1;
   else if (_By < 0xf0)
    _Ch = _By & 0x0f, _Nextra = 2;
   else if (_By < 0xf8)
    _Ch = _By & 0x07, _Nextra = 3;
   else
    _Ch = _By & 0x03, _Nextra = _By < 0xfc ? 4 : 5;

   if (_Nextra == 0)
    ++_Mid1;
   else if (_Last1 - _Mid1 < _Nextra + 1)
    break;
   else
    for (++_Mid1; 0 < _Nextra; --_Nextra, ++_Mid1)
     if ((_By = (unsigned char)*_Mid1) < 0x80 || 0xc0 <= _By)
      return (_Mybase::error);
     else
      _Ch = _Ch << 6 | (_By & 0x3f);

   if (*_Pstate == 0)
    {
    *_Pstate = 1;

    if ((_Mode & _Consume_header) != 0 && _Ch == 0xfeff)
     {
     result _Ans = do_in(_State, _Mid1, _Last1, _Mid1,
      _First2, _Last2, _Mid2);

     if (_Ans == _Mybase::partial)
      {
      *_Pstate = 0;
      _Mid1 = _First1;
      }
     return (_Ans);
     }
    }

   if (_Maxcode < _Ch)
    return (_Mybase::error);
   *_Mid2++ = (_Elem)_Ch;
   }

  return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
  }

 virtual result do_out(_Statype& _State,
  const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
  char *_Pstate = (char *)&_State;
  _Mid1 = _First1;
  _Mid2 = _First2;

  for (; _Mid1 != _Last1 && _Mid2 != _Last2; )
   {
   _Byte _By;
   int _Nextra;
   unsigned long _Ch = (unsigned long)*_Mid1;

   if (_Maxcode < _Ch)
    return (_Mybase::error);

   if (_Ch < 0x0080)
    _By = (_Byte)_Ch, _Nextra = 0;
   else if (_Ch < 0x0800)
    _By = (_Byte)(0xc0 | _Ch >> 6), _Nextra = 1;
   else if (_Ch < 0x00010000)
    _By = (_Byte)(0xe0 | _Ch >> 12), _Nextra = 2;
   else if (_Ch < 0x00200000)
    _By = (_Byte)(0xf0 | _Ch >> 18), _Nextra = 3;
   else if (_Ch < 0x04000000)
    _By = (_Byte)(0xf8 | _Ch >> 24), _Nextra = 4;
   else
    _By = (_Byte)(0xfc | (_Ch >> 30 & 0x03)), _Nextra = 5;

   if (*_Pstate == 0)
    {
    *_Pstate = 1;
    if ((_Mode & _Generate_header) == 0)
     ;
    else if (_Last2 - _Mid2 < 3 + 1 + _Nextra)
     return (_Mybase::partial);
    else
     {
     *_Mid2++ = (_Byte)(unsigned char)0xef;
     *_Mid2++ = (_Byte)(unsigned char)0xbb;
     *_Mid2++ = (_Byte)(unsigned char)0xbf;
     }
    }

   if (_Last2 - _Mid2 < 1 + _Nextra)
    break;

   ++_Mid1;
   for (*_Mid2++ = _By; 0 < _Nextra; )
    *_Mid2++ = (_Byte)((_Ch >> 6 * --_Nextra & 0x3f) | 0x80);
   }
  return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
  }

 virtual result do_unshift(_Statype&,
  _Byte *_First2, _Byte *, _Byte *& _Mid2) const
  {
  _Mid2 = _First2;
  return (_Mybase::ok);
  }

 virtual int do_length(_Statype& _State, const _Byte *_First1,
  const _Byte *_Last1, size_t _Count) const
  {
  int _Wchars = 0;
  _Statype _Mystate = _State;

  for (; (size_t)_Wchars < _Count && _First1 != _Last1; )
   {
   const _Byte *_Mid1;
   _Elem *_Mid2;
   _Elem _Ch;

   switch (do_in(_Mystate, _First1, _Last1, _Mid1,
    &_Ch, &_Ch + 1, _Mid2))
    {
   case _Mybase::noconv:
    return ((int)(_Wchars + (int)(_Last1 - _First1)));

   case _Mybase::ok:
    if (_Mid2 == &_Ch + 1)
     ++_Wchars;
    _First1 = _Mid1;
    break;

   default:
    return ((int)_Wchars);
    }
   }

  return ((int)_Wchars);
  }

 virtual bool do_always_noconv() const noexcept
  {
  return (false);
  }

 virtual int do_max_length() const noexcept
  {
  return ((_Mode & (_Consume_header | _Generate_header)) != 0
   ? 9 : 6);
  }

 virtual int do_encoding() const noexcept
  {
  return ((_Mode & (_Consume_header | _Generate_header)) != 0
   ? -1 : 0);
  }

private:
 unsigned long _Maxcode;
 _Codecvt_mode _Mode;
 };


template<>
 class codecvt<wchar_t, char, _Mbstatet>
 : public codecvt_base
 {
public:
 typedef wchar_t _Elem;
 typedef char _Byte;
 typedef _Mbstatet _Statype;
 typedef _Elem intern_type;
 typedef _Byte extern_type;
 typedef _Statype state_type;

 result in(_Statype& _State,
  const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
  _Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
  {
  return (do_in(_State,
   _First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
  }

 result out(_Statype& _State,
  const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
  return (do_out(_State,
   _First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
  }

 result unshift(_Statype& _State,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
  return (do_unshift(_State,
   _First2, _Last2, _Mid2));
  }

 int length(_Statype& _State, const _Byte *_First1,
  const _Byte *_Last1, size_t _Count) const
  {
  return (do_length(_State, _First1, _Last1, _Count));
  }

                         static locale::id id;

 explicit codecvt(size_t _Refs = 0)
  : codecvt_base(_Refs)
  {
  { _Locinfo _Lobj;
   _Init(_Lobj);
  }
  }

                    codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
  : codecvt_base(_Refs)
  {
  _Init(_Lobj);
  }

 static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
  const locale *_Ploc = 0)
  {
  if (_Ppf != 0 && *_Ppf == 0)
   *_Ppf = new codecvt<_Elem, _Byte, _Statype>(
    _Locinfo(_Ploc->c_str()));
  return (2);
  }

protected:
 virtual ~codecvt() noexcept
  {
  }

 void _Init(const _Locinfo& _Lobj)
  {
  _Cvt = _Lobj._Getcvt();
  }

 virtual result do_in(_Statype& _State,
  const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
   _Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
  {
                               ;
                               ;
  _Mid1 = _First1, _Mid2 = _First2;
  result _Ans = _Mid1 == _Last1 ? ok : partial;
  int _Bytes;

  while (_Mid1 != _Last1 && _Mid2 != _Last2)
   switch (_Bytes = _Mbrtowc(_Mid2, _Mid1, _Last1 - _Mid1,
    &_State, &_Cvt))
   {
   case -2:
    _Mid1 = _Last1;
    return (_Ans);

   case -1:
    return (error);

   case 0:
    if (*_Mid2 == (_Elem)0)
     _Bytes = (int):: strlen(_Mid1) + 1;


   default:
    if (_Bytes == -3)
     _Bytes = 0;
    _Mid1 += _Bytes;
    ++_Mid2;
    _Ans = ok;
   }
  return (_Ans);
  }

 virtual result do_out(_Statype& _State,
  const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
   _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
                               ;
                               ;
  _Mid1 = _First1, _Mid2 = _First2;
  int _Bytes;

  while (_Mid1 != _Last1 && _Mid2 != _Last2)
   if ((int)5 <= _Last2 - _Mid2)
    if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1,
     &_State, &_Cvt)) < 0)
     return (error);
    else
     ++_Mid1, _Mid2 += _Bytes;
   else
    {
    _Byte _Buf[5];
    _Statype _Stsave = _State;

    if ((_Bytes = _Wcrtomb(_Buf, *_Mid1,
     &_State, &_Cvt)) < 0)
     return (error);
    else if (_Last2 - _Mid2 < _Bytes)
     {
     _State = _Stsave;
     break;
     }
    else
     {
     :: memcpy(_Mid2, _Buf, _Bytes);
     ++_Mid1, _Mid2 += _Bytes;
     }
    }
  return (_Mid1 == _Last1 ? ok : partial);
  }

 virtual result do_unshift(_Statype& _State,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
                               ;
  _Mid2 = _First2;
  result _Ans = ok;
  int _Bytes;
  _Byte _Buf[5];
  _Statype _Stsave = _State;

  if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0)
   _Ans = error;
  else if (_Last2 - _Mid2 < --_Bytes)
   {
   _State = _Stsave;
   _Ans = partial;
   }
  else if (0 < _Bytes)
   {
   :: memcpy(_Mid2, _Buf, _Bytes);
   _Mid2 += _Bytes;
   }
  return (_Ans);
  }

 virtual int do_length(_Statype& _State, const _Byte *_First1,
  const _Byte *_Last1, size_t _Count) const
  {
                               ;
  int _Wchars;
  const _Byte *_Mid1;
  _Statype _Mystate = _State;

  for (_Wchars = 0, _Mid1 = _First1;
   (size_t)_Wchars < _Count && _Mid1 != _Last1; )
   {
   int _Bytes;
   _Elem _Ch;

   switch (_Bytes = _Mbrtowc(&_Ch, _Mid1, _Last1 - _Mid1,
    &_Mystate, &_Cvt))
    {
   case -2:
    return (_Wchars);

   case -1:
    return (_Wchars);

   case 0:
    if (_Ch == (_Elem)0)
     _Bytes = (int):: strlen(_Mid1) + 1;


   default:
    if (_Bytes == -3)
     _Bytes = 0;
    _Mid1 += _Bytes;
    ++_Wchars;
    }
   }
  return (_Wchars);
  }

 virtual bool do_always_noconv() const noexcept
  {
  return (false);
  }

 virtual int do_max_length() const noexcept
  {
  return (5);
  }

 virtual int do_encoding() const noexcept
  {
  return (0);
  }

private:
 _Locinfo::_Cvtvec _Cvt;
 };



template<>
 class codecvt<unsigned short, char, _Mbstatet>
 : public codecvt_base
 {
public:
 typedef unsigned short _Elem;
 typedef char _Byte;
 typedef _Mbstatet _Statype;
 typedef _Elem intern_type;
 typedef _Byte extern_type;
 typedef _Statype state_type;

 result in(_Statype& _State,
  const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
  _Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
  {
  return (do_in(_State,
   _First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
  }

 result out(_Statype& _State,
  const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
  return (do_out(_State,
   _First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
  }

 result unshift(_Statype& _State,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
  return (do_unshift(_State,
   _First2, _Last2, _Mid2));
  }

 int length(_Statype& _State, const _Byte *_First1,
  const _Byte *_Last1, size_t _Count) const
  {
  return (do_length(_State, _First1, _Last1, _Count));
  }

                         static locale::id id;

 explicit codecvt(size_t _Refs = 0)
  : codecvt_base(_Refs)
  {
  { _Locinfo _Lobj;
   _Init(_Lobj);
  }
  }

                    codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
  : codecvt_base(_Refs)
  {
  _Init(_Lobj);
  }

 static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
  const locale *_Ploc = 0)
  {
  if (_Ppf != 0 && *_Ppf == 0)
   *_Ppf = new codecvt<_Elem, _Byte, _Statype>(
    _Locinfo(_Ploc->c_str()));
  return (2);
  }

protected:
 virtual ~codecvt() noexcept
  {
  }

 void _Init(const _Locinfo& _Lobj)
  {
  _Cvt = _Lobj._Getcvt();
  }

 virtual result do_in(_Statype& _State,
  const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
   _Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
  {
                               ;
                               ;
  _Mid1 = _First1, _Mid2 = _First2;
  result _Ans = _Mid1 == _Last1 ? ok : partial;
  int _Bytes;

  while (_Mid1 != _Last1 && _Mid2 != _Last2)
   switch (_Bytes = _Mbrtowc((wchar_t *)_Mid2, _Mid1, _Last1 - _Mid1,
    &_State, &_Cvt))
   {
   case -2:
    _Mid1 = _Last1;
    return (_Ans);

   case -1:
    return (error);

   case 0:
    if (*_Mid2 == (_Elem)0)
     _Bytes = (int):: strlen(_Mid1) + 1;


   default:
    if (_Bytes == -3)
     _Bytes = 0;
    _Mid1 += _Bytes;
    ++_Mid2;
    _Ans = ok;
   }
  return (_Ans);
  }

 virtual result do_out(_Statype& _State,
  const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
   _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
                               ;
                               ;
  _Mid1 = _First1, _Mid2 = _First2;
  int _Bytes;

  while (_Mid1 != _Last1 && _Mid2 != _Last2)
   if ((int)5 <= _Last2 - _Mid2)
    if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1,
     &_State, &_Cvt)) < 0)
     return (error);
    else
     ++_Mid1, _Mid2 += _Bytes;
   else
    {
    _Byte _Buf[5];
    _Statype _Stsave = _State;

    if ((_Bytes = _Wcrtomb(_Buf, *_Mid1,
     &_State, &_Cvt)) < 0)
     return (error);
    else if (_Last2 - _Mid2 < _Bytes)
     {
     _State = _Stsave;
     break;
     }
    else
     {
     :: memcpy(_Mid2, _Buf, _Bytes);
     ++_Mid1, _Mid2 += _Bytes;
     }
    }
  return (_Mid1 == _Last1 ? ok : partial);
  }

 virtual result do_unshift(_Statype& _State,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
                               ;
  _Mid2 = _First2;
  result _Ans = ok;
  int _Bytes;
  _Byte _Buf[5];
  _Statype _Stsave = _State;

  if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0)
   _Ans = error;
  else if (_Last2 - _Mid2 < --_Bytes)
   {
   _State = _Stsave;
   _Ans = partial;
   }
  else if (0 < _Bytes)
   {
   :: memcpy(_Mid2, _Buf, _Bytes);
   _Mid2 += _Bytes;
   }
  return (_Ans);
  }

 virtual int do_length(_Statype& _State, const _Byte *_First1,
  const _Byte *_Last1, size_t _Count) const
  {
                               ;
  int _Wchars;
  const _Byte *_Mid1;
  _Statype _Mystate = _State;

  for (_Wchars = 0, _Mid1 = _First1;
   (size_t)_Wchars < _Count && _Mid1 != _Last1; )
   {
   int _Bytes;
   _Elem _Ch;

   switch (_Bytes = _Mbrtowc((wchar_t *)&_Ch, _Mid1, _Last1 - _Mid1,
    &_Mystate, &_Cvt))
    {
   case -2:
    return (_Wchars);

   case -1:
    return (_Wchars);

   case 0:
    if (_Ch == (_Elem)0)
     _Bytes = (int):: strlen(_Mid1) + 1;


   default:
    if (_Bytes == -3)
     _Bytes = 0;
    _Mid1 += _Bytes;
    ++_Wchars;
    }
   }
  return (_Wchars);
  }

 virtual bool do_always_noconv() const noexcept
  {
  return (false);
  }

 virtual int do_max_length() const noexcept
  {
  return (5);
  }

 virtual int do_encoding() const noexcept
  {
  return (0);
  }

private:
 _Locinfo::_Cvtvec _Cvt;
 };



template<class _Elem,
 class _Byte,
 class _Statype>
 class codecvt_byname
  : public codecvt<_Elem, _Byte, _Statype>
 {
public:
 explicit codecvt_byname(const char *_Locname, size_t _Refs = 0)
  : codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Locname), _Refs)
  {
  }

 explicit codecvt_byname(const string& _Str, size_t _Refs = 0)
  : codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Str.c_str()), _Refs)
  {
  }

protected:
 virtual ~codecvt_byname() noexcept
  {
  }
 };


#pragma warning(push)
#pragma warning(disable: 4275)

struct ctype_base
 : public locale::facet
 {
 enum
  {
  alnum = 0x04 | 0x02 | 0x01 | 0x100, alpha = 0x02 | 0x01 | 0x100,
  cntrl = 0x20, digit = 0x04, graph = 0x04 | 0x02 | 0x10 | 0x01 | 0x100,
  lower = 0x02, print = 0x04 | 0x02 | 0x10 | 0x40 | 0x01 | 0x100 | 0x80,
  punct = 0x10, space = 0x08 | 0x40 | 0x000, upper = 0x01,
  xdigit = 0x80, blank = 0x08 | 0x40 | 0x000 | 0x000};
 typedef short mask;

                    ctype_base(size_t _Refs = 0)
  : locale::facet(_Refs)
  {
  }

                    ~ctype_base() noexcept
  {
  }
 };

#pragma warning(pop)


template<class _Elem>
 class ctype
  : public ctype_base
 {
public:
 typedef _Elem char_type;

 bool is(mask _Maskval, _Elem _Ch) const
  {
  return (do_is(_Maskval, _Ch));
  }

 const _Elem * is(const _Elem *_First, const _Elem *_Last,
  mask *_Dest) const
  {
  return (do_is(_First, _Last, _Dest));
  }

 const _Elem * scan_is(mask _Maskval, const _Elem *_First,
  const _Elem *_Last) const
  {
  return (do_scan_is(_Maskval, _First, _Last));
  }

 const _Elem * scan_not(mask _Maskval, const _Elem *_First,
  const _Elem *_Last) const
  {
  return (do_scan_not(_Maskval, _First, _Last));
  }

 _Elem tolower(_Elem _Ch) const
  {
  return (do_tolower(_Ch));
  }

 const _Elem * tolower(_Elem *_First, const _Elem *_Last) const
  {
  return (do_tolower(_First, _Last));
  }

 _Elem toupper(_Elem _Ch) const
  {
  return (do_toupper(_Ch));
  }

 const _Elem * toupper(_Elem *_First, const _Elem *_Last) const
  {
  return (do_toupper(_First, _Last));
  }

 _Elem widen(char _Byte) const
  {
  return (do_widen(_Byte));
  }

 const char * widen(const char *_First, const char *_Last,
  _Elem *_Dest) const
  {
  return (do_widen(_First, _Last, _Dest));
  }

 char narrow(_Elem _Ch, char _Dflt = '\0') const
  {
  return (do_narrow(_Ch, _Dflt));
  }

 const _Elem * narrow(const _Elem *_First, const _Elem *_Last,
  char _Dflt, char *_Dest) const
  {
  return (do_narrow(_First, _Last, _Dflt, _Dest));
  }

                         static locale::id id;

 explicit ctype(size_t _Refs = 0)
  : ctype_base(_Refs)
  {
  { _Locinfo _Lobj;
   _Init(_Lobj);
  }
  }

                    ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
  : ctype_base(_Refs)
  {
  _Init(_Lobj);
  }

 static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
  const locale *_Ploc = 0)
  {
  if (_Ppf != 0 && *_Ppf == 0)
   *_Ppf = new ctype<_Elem>(
    _Locinfo(_Ploc->c_str()));
  return (2);
  }

protected:
 virtual ~ctype() noexcept
  {
  if (_Ctype._Delfl)
   :: free((void *)_Ctype._Table);

  :: free(_Ctype._LocaleName);
  }

 void _Init(const _Locinfo& _Lobj)
  {
  _Ctype = _Lobj._Getctype();
  _Cvt = _Lobj._Getcvt();
  }

 virtual bool do_is(mask _Maskval, _Elem _Ch) const
  {
  return ((_Ctype._Table[(unsigned char)narrow(_Ch)]
   & _Maskval) != 0);
  }

 virtual const _Elem * do_is(const _Elem *_First, const _Elem *_Last,
  mask *_Dest) const
  {
                                        ;
  for (; _First != _Last; ++_First, ++_Dest)
   *_Dest = _Ctype._Table[(unsigned char)narrow(*_First)];
  return (_First);
  }

 virtual const _Elem * do_scan_is(mask _Maskval,
  const _Elem *_First, const _Elem *_Last) const
  {
                             ;
  for (; _First != _Last && !is(_Maskval, *_First); ++_First)
   ;
  return (_First);
  }

 virtual const _Elem * do_scan_not(mask _Maskval,
  const _Elem *_First, const _Elem *_Last) const
  {
                             ;
  for (; _First != _Last && is(_Maskval, *_First); ++_First)
   ;
  return (_First);
  }

 virtual _Elem do_tolower(_Elem _Ch) const
  {
  unsigned char _Byte = (unsigned char)narrow(_Ch, '\0');
  if (_Byte == '\0')
   return (_Ch);
  else
   return (widen((char)_Tolower(_Byte, &_Ctype)));
  }

 virtual const _Elem * do_tolower(_Elem *_First,
  const _Elem *_Last) const
  {
                                            ;
  for (; _First != _Last; ++_First)
   {
   unsigned char _Byte = (unsigned char)narrow(*_First, '\0');
   if (_Byte != '\0')
    *_First = (widen((char)_Tolower(_Byte, &_Ctype)));
   }
  return ((const _Elem *)_First);
  }

 virtual _Elem do_toupper(_Elem _Ch) const
  {
  unsigned char _Byte = (unsigned char)narrow(_Ch, '\0');
  if (_Byte == '\0')
   return (_Ch);
  else
   return (widen((char)_Toupper(_Byte, &_Ctype)));
  }

 virtual const _Elem * do_toupper(_Elem *_First,
  const _Elem *_Last) const
  {
                                            ;
  for (; _First != _Last; ++_First)
   {
   unsigned char _Byte = (unsigned char)narrow(*_First, '\0');
   if (_Byte != '\0')
    *_First = (widen((char)_Toupper(_Byte, &_Ctype)));
   }
  return ((const _Elem *)_First);
  }

 virtual _Elem do_widen(char _Byte) const
  {
  return (_Maklocchr(_Byte, (_Elem *)0, _Cvt));
  }

 virtual const char * do_widen(const char *_First,
  const char *_Last, _Elem *_Dest) const
  {
                                        ;
  for (; _First != _Last; ++_First, ++_Dest)
   *_Dest = _Maklocchr(*_First, (_Elem *)0, _Cvt);
  return (_First);
  }

 char _Donarrow(_Elem _Ch, char _Dflt) const
  {
  char _Byte;
  if (_Ch == (_Elem)0)
   return ('\0');
  else if ((_Byte = _Maklocbyte((_Elem)_Ch, _Cvt)) == '\0')
   return (_Dflt);
  else
   return (_Byte);
  }

 virtual char do_narrow(_Elem _Ch, char _Dflt) const
  {
  return (_Donarrow(_Ch, _Dflt));
  }

 virtual const _Elem * do_narrow(const _Elem *_First,
  const _Elem *_Last, char _Dflt, char *_Dest) const
  {
                                        ;
  for (; _First != _Last; ++_First, ++_Dest)
   *_Dest = _Donarrow(*_First, _Dflt);
  return (_First);
  }

private:
 _Locinfo::_Ctypevec _Ctype;
 _Locinfo::_Cvtvec _Cvt;
 };


template<class _Elem>
 locale::id ctype<_Elem>::id;


template<>
 class ctype<char>
 : public ctype_base
 {
 typedef ctype<char> _Myt;

public:
 typedef char _Elem;
 typedef _Elem char_type;

 bool is(mask _Maskval, _Elem _Ch) const
  {
  return ((_Ctype._Table[(unsigned char)_Ch] & _Maskval) != 0);
  }

 const _Elem * is(const _Elem *_First,
  const _Elem *_Last, mask *_Dest) const
  {
                                        ;
  for (; _First != _Last; ++_First, ++_Dest)
   *_Dest = _Ctype._Table[(unsigned char)*_First];
  return (_First);
  }

 const _Elem * scan_is(mask _Maskval,
  const _Elem *_First, const _Elem *_Last) const
  {
                             ;
  for (; _First != _Last && !is(_Maskval, *_First); ++_First)
   ;
  return (_First);
  }

 const _Elem * scan_not(mask _Maskval,
  const _Elem *_First, const _Elem *_Last) const
  {
                             ;
  for (; _First != _Last && is(_Maskval, *_First); ++_First)
   ;
  return (_First);
  }

 _Elem tolower(_Elem _Ch) const
  {
  return (do_tolower(_Ch));
  }

 const _Elem * tolower(_Elem *_First, const _Elem *_Last) const
  {
  return (do_tolower(_First, _Last));
  }

 _Elem toupper(_Elem _Ch) const
  {
  return (do_toupper(_Ch));
  }

 const _Elem * toupper(_Elem *_First, const _Elem *_Last) const
  {
  return (do_toupper(_First, _Last));
  }

 _Elem widen(char _Byte) const
  {
  return (do_widen(_Byte));
  }

 const _Elem * widen(const char *_First, const char *_Last,
  _Elem *_Dest) const
  {
  return (do_widen(_First, _Last, _Dest));
  }

 _Elem narrow(_Elem _Ch, char _Dflt = '\0') const
  {
  return (do_narrow(_Ch, _Dflt));
  }

 const _Elem * narrow(const _Elem *_First, const _Elem *_Last,
  char _Dflt, char *_Dest) const
  {
  return (do_narrow(_First, _Last, _Dflt, _Dest));
  }

                         static locale::id id;

 explicit ctype(const mask *_Table = 0,
  bool _Deletetable = false,
  size_t _Refs = 0)
  : ctype_base(_Refs)
  {
  { _Locinfo _Lobj;
   _Init(_Lobj);
  }

  _Tidy();
  if (_Table != 0)
   {
   _Ctype._Table = _Table;
   _Ctype._Delfl = _Deletetable ? -1 : 0;
   }
  else
   {
   _Ctype._Table = classic_table();
   _Ctype._Delfl = 0;
   }
  }

                    ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
  : ctype_base(_Refs)
  {
  _Init(_Lobj);
  }

 static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
  const locale *_Ploc = 0)
  {
  if (_Ppf != 0 && *_Ppf == 0)
   *_Ppf = new ctype<_Elem>(
    _Locinfo(_Ploc->c_str()));
  return (2);
  }

 const mask * table() const noexcept
  {
  return (_Ctype._Table);
  }

 static const mask *__cdecl classic_table() noexcept
  {
  const _Myt& _Ctype_fac = use_facet< _Myt >(locale::classic());
  return (_Ctype_fac.table());
  }

          static const size_t table_size =
  1 << 8;

protected:
 virtual ~ctype() noexcept
  {
  _Tidy();
  }

 void _Init(const _Locinfo& _Lobj)
  {
  _Ctype = _Lobj._Getctype();
  }

 void _Tidy()
  {
  if (0 < _Ctype._Delfl)
   :: free((void *)_Ctype._Table);
  else if (_Ctype._Delfl < 0)
   delete[] _Ctype._Table;

  :: free(_Ctype._LocaleName);
  }

 virtual _Elem do_tolower(_Elem _Ch) const
  {
  return ((_Elem)_Tolower((unsigned char)_Ch, &_Ctype));
  }

 virtual const _Elem * do_tolower(_Elem *_First,
  const _Elem *_Last) const
  {
                                            ;
  for (; _First != _Last; ++_First)
   *_First = (_Elem)_Tolower((unsigned char)*_First, &_Ctype);
  return ((const _Elem *)_First);
  }

 virtual _Elem do_toupper(_Elem _Ch) const
  {
  return ((_Elem)_Toupper((unsigned char)_Ch, &_Ctype));
  }

 virtual const _Elem * do_toupper(_Elem *_First,
  const _Elem *_Last) const
  {
                                            ;
  for (; _First != _Last; ++_First)
   *_First = (_Elem)_Toupper((unsigned char)*_First, &_Ctype);
  return ((const _Elem *)_First);
  }

 virtual _Elem do_widen(char _Byte) const
  {
  return (_Byte);
  }

 virtual const _Elem * do_widen(const char *_First,
  const char *_Last, _Elem *_Dest) const
  {
                                        ;
  :: memcpy(_Dest, _First, _Last - _First);
  return (_Last);
  }

 virtual _Elem do_narrow(_Elem _Ch, char) const
  {
  return (_Ch);
  }

 virtual const _Elem * do_narrow(const _Elem *_First,
  const _Elem *_Last, char, char *_Dest) const
  {
                                        ;
  :: memcpy(_Dest, _First, _Last - _First);
  return (_Last);
  }

private:
 _Locinfo::_Ctypevec _Ctype;
 };


template<>
 class ctype<wchar_t>
 : public ctype_base
 {
 typedef ctype<wchar_t> _Myt;

public:
 typedef wchar_t _Elem;
 typedef _Elem char_type;

 bool is(mask _Maskval, _Elem _Ch) const
  {
  return (do_is(_Maskval, _Ch));
  }

 const _Elem * is(const _Elem *_First, const _Elem *_Last,
  mask *_Dest) const
  {
  return (do_is(_First, _Last, _Dest));
  }

 const _Elem * scan_is(mask _Maskval, const _Elem *_First,
  const _Elem *_Last) const
  {
  return (do_scan_is(_Maskval, _First, _Last));
  }

 const _Elem * scan_not(mask _Maskval, const _Elem *_First,
  const _Elem *_Last) const
  {
  return (do_scan_not(_Maskval, _First, _Last));
  }

 _Elem tolower(_Elem _Ch) const
  {
  return (do_tolower(_Ch));
  }

 const _Elem * tolower(_Elem *_First, const _Elem *_Last) const
  {
  return (do_tolower(_First, _Last));
  }

 _Elem toupper(_Elem _Ch) const
  {
  return (do_toupper(_Ch));
  }

 const _Elem * toupper(_Elem *_First, const _Elem *_Last) const
  {
  return (do_toupper(_First, _Last));
  }

 _Elem widen(char _Byte) const
  {
  return (do_widen(_Byte));
  }

 const char * widen(const char *_First, const char *_Last,
  _Elem *_Dest) const
  {
  return (do_widen(_First, _Last, _Dest));
  }

 char narrow(_Elem _Ch, char _Dflt = '\0') const
  {
  return (do_narrow(_Ch, _Dflt));
  }

 const _Elem * narrow(const _Elem *_First, const _Elem *_Last,
  char _Dflt, char *_Dest) const
  {
  return (do_narrow(_First, _Last, _Dflt, _Dest));
  }

                         static locale::id id;

 explicit ctype(size_t _Refs = 0)
  : ctype_base(_Refs)
  {
  { _Locinfo _Lobj;
   _Init(_Lobj);
  }
  }

                    ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
  : ctype_base(_Refs)
  {
  _Init(_Lobj);
  }

 static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
  const locale *_Ploc = 0)
  {
  if (_Ppf != 0 && *_Ppf == 0)
   *_Ppf = new ctype<_Elem>(
    _Locinfo(_Ploc->c_str()));
  return (2);
  }

protected:
 virtual ~ctype() noexcept
  {
  if (_Ctype._Delfl)
   :: free((void *)_Ctype._Table);

  :: free(_Ctype._LocaleName);
  }

 void _Init(const _Locinfo& _Lobj)
  {
  _Ctype = _Lobj._Getctype();
  _Cvt = _Lobj._Getcvt();
  }

 virtual bool do_is(mask _Maskval, _Elem _Ch) const
  {
  return ((:: _Getwctype(_Ch, &_Ctype) & _Maskval) != 0);
  }

 virtual const _Elem * do_is(const _Elem *_First,
  const _Elem *_Last, mask *_Dest) const
  {
                                        ;
  return (:: _Getwctypes(_First, _Last, _Dest, &_Ctype));
  }

 virtual const _Elem * do_scan_is(mask _Maskval,
  const _Elem *_First, const _Elem *_Last) const
  {
                             ;
  for (; _First != _Last && !is(_Maskval, *_First); ++_First)
   ;
  return (_First);
  }

 virtual const _Elem * do_scan_not(mask _Maskval,
  const _Elem *_First, const _Elem *_Last) const
  {
                             ;
  for (; _First != _Last && is(_Maskval, *_First); ++_First)
   ;
  return (_First);
  }

 virtual _Elem do_tolower(_Elem _Ch) const
  {
  return (_Towlower(_Ch, &_Ctype));
  }

 virtual const _Elem * do_tolower(_Elem *_First,
  const _Elem *_Last) const
  {
                                            ;
  for (; _First != _Last; ++_First)
   *_First = _Towlower(*_First, &_Ctype);
  return ((const _Elem *)_First);
  }

 virtual _Elem do_toupper(_Elem _Ch) const
  {
  return (_Towupper(_Ch, &_Ctype));
  }

 virtual const _Elem * do_toupper(_Elem *_First,
  const _Elem *_Last) const
  {
                                            ;
  for (; _First != _Last; ++_First)
   *_First = _Towupper(*_First, &_Ctype);
  return ((const _Elem *)_First);
  }

 _Elem _Dowiden(char _Byte) const
  {
  mbstate_t _Mbst = {};
  wchar_t _Wc;
  return (_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst, &_Cvt) < 0
   ? (wchar_t)((wint_t)(0xFFFF)) : _Wc);
  }

 virtual _Elem do_widen(char _Byte) const
  {
  return (_Dowiden(_Byte));
  }

 virtual const char * do_widen(const char *_First,
  const char *_Last, _Elem *_Dest) const
  {
                                        ;
  for (; _First != _Last; ++_First, ++_Dest)
   *_Dest = _Dowiden(*_First);
  return (_First);
  }

 char _Donarrow(_Elem _Ch, char _Dflt) const
  {
  char _Buf[5];
  mbstate_t _Mbst = {};
  return (_Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1
   ? _Dflt : _Buf[0]);
  }

 virtual char do_narrow(_Elem _Ch, char _Dflt) const
  {
  return (_Donarrow(_Ch, _Dflt));
  }

 virtual const _Elem * do_narrow(const _Elem *_First,
  const _Elem *_Last, char _Dflt, char *_Dest) const
  {
                                        ;
  for (; _First != _Last; ++_First, ++_Dest)
   *_Dest = _Donarrow(*_First, _Dflt);
  return (_First);
  }

private:
 _Locinfo::_Ctypevec _Ctype;
 _Locinfo::_Cvtvec _Cvt;
 };



template<>
 class ctype<unsigned short>
 : public ctype_base
 {
 typedef ctype<unsigned short> _Myt;

public:
 typedef unsigned short _Elem;
 typedef _Elem char_type;

 bool is(mask _Maskval, _Elem _Ch) const
  {
  return (do_is(_Maskval, _Ch));
  }

 const _Elem * is(const _Elem *_First, const _Elem *_Last,
  mask *_Dest) const
  {
  return (do_is(_First, _Last, _Dest));
  }

 const _Elem * scan_is(mask _Maskval, const _Elem *_First,
  const _Elem *_Last) const
  {
  return (do_scan_is(_Maskval, _First, _Last));
  }

 const _Elem * scan_not(mask _Maskval, const _Elem *_First,
  const _Elem *_Last) const
  {
  return (do_scan_not(_Maskval, _First, _Last));
  }

 _Elem tolower(_Elem _Ch) const
  {
  return (do_tolower(_Ch));
  }

 const _Elem * tolower(_Elem *_First, const _Elem *_Last) const
  {
  return (do_tolower(_First, _Last));
  }

 _Elem toupper(_Elem _Ch) const
  {
  return (do_toupper(_Ch));
  }

 const _Elem * toupper(_Elem *_First, const _Elem *_Last) const
  {
  return (do_toupper(_First, _Last));
  }

 _Elem widen(char _Byte) const
  {
  return (do_widen(_Byte));
  }

 const char * widen(const char *_First, const char *_Last,
  _Elem *_Dest) const
  {
  return (do_widen(_First, _Last, _Dest));
  }

 char narrow(_Elem _Ch, char _Dflt = '\0') const
  {
  return (do_narrow(_Ch, _Dflt));
  }

 const _Elem * narrow(const _Elem *_First, const _Elem *_Last,
  char _Dflt, char *_Dest) const
  {
  return (do_narrow(_First, _Last, _Dflt, _Dest));
  }

                         static locale::id id;

 explicit ctype(size_t _Refs = 0)
  : ctype_base(_Refs)
  {
  { _Locinfo _Lobj;
   _Init(_Lobj);
  }
  }

                    ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
  : ctype_base(_Refs)
  {
  _Init(_Lobj);
  }

 static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
  const locale *_Ploc = 0)
  {
  if (_Ppf != 0 && *_Ppf == 0)
   *_Ppf = new ctype<_Elem>(
    _Locinfo(_Ploc->c_str()));
  return (2);
  }

protected:
 virtual ~ctype() noexcept
  {
  if (_Ctype._Delfl)
   :: free((void *)_Ctype._Table);

  :: free(_Ctype._LocaleName);
  }

 void _Init(const _Locinfo& _Lobj)
  {
  _Ctype = _Lobj._Getctype();
  _Cvt = _Lobj._Getcvt();
  }

 virtual bool do_is(mask _Maskval, _Elem _Ch) const
  {
  return ((:: _Getwctype(_Ch, &_Ctype) & _Maskval) != 0);
  }

 virtual const _Elem * do_is(const _Elem *_First,
  const _Elem *_Last, mask *_Dest) const
  {
                                        ;
  return ((const _Elem *):: _Getwctypes((const wchar_t *)_First,
   (const wchar_t *)_Last, _Dest, &_Ctype));
  }

 virtual const _Elem * do_scan_is(mask _Maskval,
  const _Elem *_First, const _Elem *_Last) const
  {
                             ;
  for (; _First != _Last && !is(_Maskval, *_First); ++_First)
   ;
  return (_First);
  }

 virtual const _Elem * do_scan_not(mask _Maskval,
  const _Elem *_First, const _Elem *_Last) const
  {
                             ;
  for (; _First != _Last && is(_Maskval, *_First); ++_First)
   ;
  return (_First);
  }

 virtual _Elem do_tolower(_Elem _Ch) const
  {
  return (_Towlower(_Ch, &_Ctype));
  }

 virtual const _Elem * do_tolower(_Elem *_First,
  const _Elem *_Last) const
  {
                                            ;
  for (; _First != _Last; ++_First)
   *_First = _Towlower(*_First, &_Ctype);
  return ((const _Elem *)_First);
  }

 virtual _Elem do_toupper(_Elem _Ch) const
  {
  return (_Towupper(_Ch, &_Ctype));
  }

 virtual const _Elem * do_toupper(_Elem *_First,
  const _Elem *_Last) const
  {
                                            ;
  for (; _First != _Last; ++_First)
   *_First = _Towupper(*_First, &_Ctype);
  return ((const _Elem *)_First);
  }

 _Elem _Dowiden(char _Byte) const
  {
  mbstate_t _Mbst = {};
  unsigned short _Wc;
  return (_Mbrtowc((wchar_t *)&_Wc, &_Byte, 1, &_Mbst, &_Cvt) < 0
   ? (unsigned short)((wint_t)(0xFFFF)) : _Wc);
  }

 virtual _Elem do_widen(char _Byte) const
  {
  return (_Dowiden(_Byte));
  }

 virtual const char * do_widen(const char *_First,
  const char *_Last, _Elem *_Dest) const
  {
                                        ;
  for (; _First != _Last; ++_First, ++_Dest)
   *_Dest = _Dowiden(*_First);
  return (_First);
  }

 char _Donarrow(_Elem _Ch, char _Dflt) const
  {
  char _Buf[5];
  mbstate_t _Mbst = {};
  return (_Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1
   ? _Dflt : _Buf[0]);
  }

 virtual char do_narrow(_Elem _Ch, char _Dflt) const
  {
  return (_Donarrow(_Ch, _Dflt));
  }

 virtual const _Elem * do_narrow(const _Elem *_First,
  const _Elem *_Last, char _Dflt, char *_Dest) const
  {
                                        ;
  for (; _First != _Last; ++_First, ++_Dest)
   *_Dest = _Donarrow(*_First, _Dflt);
  return (_First);
  }

private:
 _Locinfo::_Ctypevec _Ctype;
 _Locinfo::_Cvtvec _Cvt;
 };



template<class _Elem>
 class ctype_byname
 : public ctype<_Elem>
 {
public:
 explicit ctype_byname(const char *_Locname, size_t _Refs = 0)
  : ctype<_Elem>(_Locinfo(_Locname), _Refs)
  {
  }

 explicit ctype_byname(const string& _Str, size_t _Refs = 0)
  : ctype<_Elem>(_Locinfo(_Str.c_str()), _Refs)
  {
  }

protected:
 virtual ~ctype_byname() noexcept
  {
  }
 };


template<>
 class ctype_byname<char>
 : public ctype<char>
 {
public:
 explicit ctype_byname(const char *_Locname, size_t _Refs = 0)
  : ctype<char>(_Locinfo(_Locname), _Refs)
  {
  }

 explicit ctype_byname(const string& _Str, size_t _Refs = 0)
  : ctype<char>(_Locinfo(_Str.c_str()), _Refs)
  {
  }

protected:
 virtual ~ctype_byname() noexcept
  {
  }
 };







}

#pragma warning(pop)
#pragma pack(pop)
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xiosbase" 2 3


# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\system_error" 1 3





# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\cerrno" 1 3
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\system_error" 2 3




#pragma pack(push,8)
#pragma warning(push, 3)
# 21 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\system_error" 3
namespace std {


enum class errc {
 address_family_not_supported = 102,
 address_in_use = 100,
 address_not_available = 101,
 already_connected = 113,
 argument_list_too_long = 7,
 argument_out_of_domain = 33,
 bad_address = 14,
 bad_file_descriptor = 9,
 bad_message = 104,
 broken_pipe = 32,
 connection_aborted = 106,
 connection_already_in_progress = 103,
 connection_refused = 107,
 connection_reset = 108,
 cross_device_link = 18,
 destination_address_required = 109,
 device_or_resource_busy = 16,
 directory_not_empty = 41,
 executable_format_error = 8,
 file_exists = 17,
 file_too_large = 27,
 filename_too_long = 38,
 function_not_supported = 40,
 host_unreachable = 110,
 identifier_removed = 111,
 illegal_byte_sequence = 42,
 inappropriate_io_control_operation = 25,
 interrupted = 4,
 invalid_argument = 22,
 invalid_seek = 29,
 io_error = 5,
 is_a_directory = 21,
 message_size = 115,
 network_down = 116,
 network_reset = 117,
 network_unreachable = 118,
 no_buffer_space = 119,
 no_child_process = 10,
 no_link = 121,
 no_lock_available = 39,
 no_message_available = 120,
 no_message = 122,
 no_protocol_option = 123,
 no_space_on_device = 28,
 no_stream_resources = 124,
 no_such_device_or_address = 6,
 no_such_device = 19,
 no_such_file_or_directory = 2,
 no_such_process = 3,
 not_a_directory = 20,
 not_a_socket = 128,
 not_a_stream = 125,
 not_connected = 126,
 not_enough_memory = 12,
 not_supported = 129,
 operation_canceled = 105,
 operation_in_progress = 112,
 operation_not_permitted = 1,
 operation_not_supported = 130,
 operation_would_block = 140,
 owner_dead = 133,
 permission_denied = 13,
 protocol_error = 134,
 protocol_not_supported = 135,
 read_only_file_system = 30,
 resource_deadlock_would_occur = 36,
 resource_unavailable_try_again = 11,
 result_out_of_range = 34,
 state_not_recoverable = 127,
 stream_timeout = 137,
 text_file_busy = 139,
 timed_out = 138,
 too_many_files_open_in_system = 23,
 too_many_files_open = 24,
 too_many_links = 31,
 too_many_symbolic_link_levels = 114,
 value_too_large = 132,
 wrong_protocol_type = 136
 };

typedef errc _Errc;



enum class io_errc {
 stream = 1
 };

typedef io_errc _Io_errc;


template<class _Enum>
 struct is_error_code_enum
  : public false_type
 {
 };

template<>
 struct is_error_code_enum<_Io_errc>
  : public true_type
 {
 };


template<class _Ty>
 constexpr bool is_error_code_enum_v = is_error_code_enum<_Ty>::value;



template<class _Enum>
 struct is_error_condition_enum
  : public false_type
 {
 };

template<>
 struct is_error_condition_enum<_Errc>
  : public true_type
 {
 };


template<class _Ty>
 constexpr bool is_error_condition_enum_v = is_error_condition_enum<_Ty>::value;


class error_code;
class error_condition;
error_code make_error_code(_Errc) noexcept;
error_code make_error_code(_Io_errc) noexcept;
error_condition make_error_condition(_Errc) noexcept;
error_condition make_error_condition(_Io_errc) noexcept;


class error_category;

const error_category& generic_category() noexcept;
const error_category& iostream_category() noexcept;
const error_category& system_category() noexcept;

class error_category
 {
public:
                 error_category() noexcept
  {
  _Addr = reinterpret_cast<uintptr_t>(this);
  }

 virtual ~error_category() noexcept
  {
  }

 virtual const char *name() const noexcept = 0;

 virtual string message(int _Errval) const = 0;

 virtual error_condition
  default_error_condition(int _Errval) const noexcept;

 virtual bool equivalent(int _Errval,
  const error_condition& _Cond) const noexcept;

 virtual bool equivalent(const error_code& _Code,
  int _Errval) const noexcept;

 bool operator==(const error_category& _Right) const noexcept
  {
  return (_Addr == _Right._Addr);
  }

 bool operator!=(const error_category& _Right) const noexcept
  {
  return (!(*this == _Right));
  }

 bool operator<(const error_category& _Right) const noexcept
  {
  return (_Addr < _Right._Addr);
  }

 error_category(const error_category&) = delete;
 error_category& operator=(const error_category&) = delete;

protected:
 uintptr_t _Addr;

 enum : uintptr_t
  {
  _Future_addr = 1,
  _Generic_addr = 3,
  _Iostream_addr = 5,
  _System_addr = 7
  };
 };


class error_code
 {
public:
 typedef error_code _Myt;

 error_code() noexcept
  : _Myval(0),
   _Mycat(&system_category())
  {
  }

 error_code(int _Val, const error_category& _Cat) noexcept
  : _Myval(_Val), _Mycat(&_Cat)
  {
  }

 template<class _Enum,
  class = typename enable_if<is_error_code_enum<_Enum>::value,
   void>::type>
  error_code(_Enum _Errcode) noexcept
  : _Myval(0), _Mycat(0)
  {
  *this = make_error_code(_Errcode);
  }

 void assign(int _Val, const error_category& _Cat) noexcept
  {
  _Myval = _Val;
  _Mycat = &_Cat;
  }

 template<class _Enum>
  typename enable_if<is_error_code_enum<_Enum>::value,
   error_code>::type& operator=(_Enum _Errcode) noexcept
  {
  *this = make_error_code(_Errcode);
  return (*this);
  }

 void clear() noexcept
  {
  _Myval = 0;
  _Mycat = &system_category();
  }

 int value() const noexcept
  {
  return (_Myval);
  }

 const error_category& category() const noexcept
  {
  return (*_Mycat);
  }

 error_condition default_error_condition() const noexcept;

 string message() const
  {
  return (category().message(value()));
  }

 explicit operator bool() const noexcept
  {
  return (value() != 0);
  }

private:
 int _Myval;
 const error_category *_Mycat;
 };


class error_condition
 {
public:
 typedef error_condition _Myt;

 error_condition() noexcept
  : _Myval(0),
   _Mycat(&generic_category())
  {
  }

 error_condition(int _Val, const error_category& _Cat) noexcept
  : _Myval(_Val), _Mycat(&_Cat)
  {
  }

 template<class _Enum,
  class = typename enable_if<is_error_condition_enum<_Enum>::value,
   void>::type>
  error_condition(_Enum _Errcode) noexcept
  : _Myval(0), _Mycat(0)
  {
  *this = make_error_condition(_Errcode);
  }

 void assign(int _Val, const error_category& _Cat) noexcept
  {
  _Myval = _Val;
  _Mycat = &_Cat;
  }

 template<class _Enum>
  typename enable_if<is_error_condition_enum<_Enum>::value,
   error_condition>::type& operator=(_Enum _Errcode) noexcept
  {
  *this = make_error_condition(_Errcode);
  return (*this);
  }

 void clear() noexcept
  {
  _Myval = 0;
  _Mycat = &generic_category();
  }

 int value() const noexcept
  {
  return (_Myval);
  }

 const error_category& category() const noexcept
  {
  return (*_Mycat);
  }

 string message() const
  {
  return (category().message(value()));
  }

 explicit operator bool() const noexcept
  {
  return (value() != 0);
  }

private:
 int _Myval;
 const error_category *_Mycat;
 };


inline bool operator==(
 const error_code& _Left,
 const error_code& _Right) noexcept
 {
 return (_Left.category() == _Right.category()
  && _Left.value() == _Right.value());
 }

inline bool operator==(
 const error_code& _Left,
 const error_condition& _Right) noexcept
 {
 return (_Left.category().equivalent(_Left.value(), _Right)
  || _Right.category().equivalent(_Left, _Right.value()));
 }

inline bool operator==(
 const error_condition& _Left,
 const error_code& _Right) noexcept
 {
 return (_Right.category().equivalent(_Right.value(), _Left)
  || _Left.category().equivalent(_Right, _Left.value()));
 }

inline bool operator==(
 const error_condition& _Left,
 const error_condition& _Right) noexcept
 {
 return (_Left.category() == _Right.category()
  && _Left.value() == _Right.value());
 }


inline bool operator!=(
 const error_code& _Left,
 const error_code& _Right) noexcept
 {
 return (!(_Left == _Right));
 }

inline bool operator!=(
 const error_code& _Left,
 const error_condition& _Right) noexcept
 {
 return (!(_Left == _Right));
 }

inline bool operator!=(
 const error_condition& _Left,
 const error_code& _Right) noexcept
 {
 return (!(_Left == _Right));
 }

inline bool operator!=(
 const error_condition& _Left,
 const error_condition& _Right) noexcept
 {
 return (!(_Left == _Right));
 }


inline bool operator<(
 const error_code& _Left,
 const error_code& _Right) noexcept
 {
 return (_Left.category() < _Right.category()
  || (_Left.category() == _Right.category()
   && _Left.value() < _Right.value()));
 }

inline bool operator<(
 const error_condition& _Left,
 const error_condition& _Right) noexcept
 {
 return (_Left.category() < _Right.category()
  || (_Left.category() == _Right.category()
   && _Left.value() < _Right.value()));
 }


inline error_condition
 error_category::default_error_condition(int _Errval) const noexcept
 {
 return (error_condition(_Errval, *this));
 }

inline bool
 error_category::equivalent(int _Errval,
  const error_condition& _Cond) const noexcept
 {
 return (default_error_condition(_Errval) == _Cond);
 }

inline bool
 error_category::equivalent(const error_code& _Code,
  int _Errval) const noexcept
 {
 return (*this == _Code.category() && _Code.value() == _Errval);
 }


inline error_condition error_code::default_error_condition() const noexcept
 {
 return (category().default_error_condition(value()));
 }


inline error_code make_error_code(_Errc _Errno) noexcept
 {
 return (error_code((int)_Errno, generic_category()));
 }

inline error_code make_error_code(_Io_errc _Errno) noexcept
 {
 return (error_code((int)_Errno, iostream_category()));
 }


inline error_condition make_error_condition(_Errc _Errno) noexcept
 {
 return (error_condition((int)_Errno, generic_category()));
 }

inline error_condition make_error_condition(_Io_errc _Errno) noexcept
 {
 return (error_condition((int)_Errno, iostream_category()));
 }


template<>
 struct hash<error_code>
 {
 typedef error_code argument_type;
 typedef size_t result_type;

 size_t operator()(const argument_type& _Keyval) const
  {
  return (hash<int>()(_Keyval.value()));
  }
 };


class _System_error
 : public runtime_error
 {
private:
 static string _Makestr(error_code _Errcode, string _Message)
  {
  if (!_Message.empty())
   _Message.append(": ");
  _Message.append(_Errcode.message());
  return (_Message);
  }

protected:
 _System_error(error_code _Errcode, const string& _Message)
  : runtime_error(_Makestr(_Errcode, _Message)), _Mycode(_Errcode)
  {
  }

 error_code _Mycode;
 };

class system_error
 : public _System_error
 {
private:
 typedef _System_error _Mybase;

public:
 system_error(error_code _Errcode)
  : _Mybase(_Errcode, "")
  {
  }

 system_error(error_code _Errcode, const string& _Message)
  : _Mybase(_Errcode, _Message)
  {
  }

 system_error(error_code _Errcode, const char *_Message)
  : _Mybase(_Errcode, _Message)
  {
  }

 system_error(int _Errval, const error_category& _Errcat)
  : _Mybase(error_code(_Errval, _Errcat), "")
  {
  }

 system_error(int _Errval, const error_category& _Errcat,
  const string& _Message)
  : _Mybase(error_code(_Errval, _Errcat), _Message)
  {
  }

 system_error(int _Errval, const error_category& _Errcat,
  const char *_Message)
  : _Mybase(error_code(_Errval, _Errcat), _Message)
  {
  }

 const error_code& code() const noexcept
  {
  return (_Mycode);
  }
# 582 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\system_error" 3
 };

              const char *__cdecl _Syserror_map(int);
              int __cdecl _Winerror_map(int);
              unsigned long __cdecl _Winerror_message(
 unsigned long _Message_id, char *_Narrow, unsigned long _Size);


class _Generic_error_category
 : public error_category
 {
public:
 _Generic_error_category() noexcept
  {
  _Addr = _Generic_addr;
  }

 virtual const char *name() const noexcept
  {
  return ("generic");
  }

 virtual string message(int _Errcode) const
  {
  return (_Syserror_map(_Errcode));
  }
 };


class _Iostream_error_category
 : public _Generic_error_category
 {
public:
 _Iostream_error_category() noexcept
  {
  _Addr = _Iostream_addr;
  }

 virtual const char *name() const noexcept
  {
  return ("iostream");
  }

 virtual string message(int _Errcode) const
  {
  if (_Errcode == (int)io_errc::stream)
   return ("iostream stream error");
  else
   return (_Generic_error_category::message(_Errcode));
  }
 };


class _System_error_category
 : public error_category
 {
public:
 _System_error_category() noexcept
  {
  _Addr = _System_addr;
  }

 virtual const char *name() const noexcept
  {
  return ("system");
  }

 virtual string message(int _Errcode) const
  {
  const unsigned long _Size = 32767;
  string _Narrow(_Size, '\0');

  const unsigned long _Val = _Winerror_message(
   static_cast<unsigned long>(_Errcode), &_Narrow[0], _Size);

  if (_Val == 0)
   return ("unknown error");

  _Narrow.resize(_Val);
  _Narrow.shrink_to_fit();
  return (_Narrow);
  }

 virtual error_condition
  default_error_condition(int _Errval) const noexcept
  {
  int _Posv = _Winerror_map(_Errval);

  if (_Posv != 0)
   return (error_condition(_Posv, generic_category()));
  else
   return (error_condition(_Errval, system_category()));
  }
 };

template<class _Ty>
 struct _Immortalizer
 {
 _Immortalizer()
  {
  ::new (static_cast<void *>(&_Storage)) _Ty();
  }

 ~_Immortalizer() noexcept
  {
  }

 _Immortalizer(const _Immortalizer&) = delete;
 _Immortalizer& operator=(const _Immortalizer&) = delete;

 typename aligned_union<1, _Ty>::type _Storage;
 };

template<class _Ty> inline
 _Ty& _Immortalize()
 {
             static _Immortalizer<_Ty> _Static;
 return (*reinterpret_cast<_Ty *>(&_Static._Storage));
 }

inline const error_category& generic_category() noexcept
 {
 return (_Immortalize<_Generic_error_category>());
 }

inline const error_category& iostream_category() noexcept
 {
 return (_Immortalize<_Iostream_error_category>());
 }

inline const error_category& system_category() noexcept
 {
 return (_Immortalize<_System_error_category>());
 }
}

#pragma warning(pop)
#pragma pack(pop)
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xiosbase" 2 3


# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\share.h" 1 3
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xiosbase" 2 3


#pragma pack(push,8)
#pragma warning(push, 3)



#pragma warning(disable: 4412)



namespace std {
# 47 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xiosbase" 3
template<class _Dummy>
 class _Iosb
 {
public:
 enum _Dummy_enum {_Dummy_enum_val = 1};
 enum _Fmtflags
  {
  _Fmtmask = 0xffff, _Fmtzero = 0};

 static constexpr _Fmtflags skipws = (_Fmtflags)0x0001;
 static constexpr _Fmtflags unitbuf = (_Fmtflags)0x0002;
 static constexpr _Fmtflags uppercase = (_Fmtflags)0x0004;
 static constexpr _Fmtflags showbase = (_Fmtflags)0x0008;
 static constexpr _Fmtflags showpoint = (_Fmtflags)0x0010;
 static constexpr _Fmtflags showpos = (_Fmtflags)0x0020;
 static constexpr _Fmtflags left = (_Fmtflags)0x0040;
 static constexpr _Fmtflags right = (_Fmtflags)0x0080;
 static constexpr _Fmtflags internal = (_Fmtflags)0x0100;
 static constexpr _Fmtflags dec = (_Fmtflags)0x0200;
 static constexpr _Fmtflags oct = (_Fmtflags)0x0400;
 static constexpr _Fmtflags hex = (_Fmtflags)0x0800;
 static constexpr _Fmtflags scientific = (_Fmtflags)0x1000;
 static constexpr _Fmtflags fixed = (_Fmtflags)0x2000;

 static constexpr _Fmtflags hexfloat =
  (_Fmtflags)0x3000;

 static constexpr _Fmtflags boolalpha = (_Fmtflags)0x4000;
 static constexpr _Fmtflags _Stdio = (_Fmtflags)0x8000;
 static constexpr _Fmtflags adjustfield = (_Fmtflags)(0x0040
  | 0x0080 | 0x0100);
 static constexpr _Fmtflags basefield = (_Fmtflags)(0x0200
  | 0x0400 | 0x0800);
 static constexpr _Fmtflags floatfield = (_Fmtflags)(0x1000
  | 0x2000);

 enum _Iostate
  {
  _Statmask = 0x17};

 static constexpr _Iostate goodbit = (_Iostate)0x0;
 static constexpr _Iostate eofbit = (_Iostate)0x1;
 static constexpr _Iostate failbit = (_Iostate)0x2;
 static constexpr _Iostate badbit = (_Iostate)0x4;

 enum _Openmode
  {
  _Openmask = 0xff};

 static constexpr _Openmode in = (_Openmode)0x01;
 static constexpr _Openmode out = (_Openmode)0x02;
 static constexpr _Openmode ate = (_Openmode)0x04;
 static constexpr _Openmode app = (_Openmode)0x08;
 static constexpr _Openmode trunc = (_Openmode)0x10;
 static constexpr _Openmode _Nocreate = (_Openmode)0x40;
 static constexpr _Openmode _Noreplace = (_Openmode)0x80;
 static constexpr _Openmode binary = (_Openmode)0x20;

 enum _Seekdir
  {
  _Seekbeg,
  _Seekcur,
  _Seekend
  };

 static constexpr _Seekdir beg = _Seekbeg;
 static constexpr _Seekdir cur = _Seekcur;
 static constexpr _Seekdir end = _Seekend;

 enum
  {
  _Openprot = 0x40};
 };

template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::skipws;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::unitbuf;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::uppercase;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showbase;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showpoint;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showpos;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::left;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::right;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::internal;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::dec;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::oct;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::hex;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::scientific;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::fixed;

template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags
  _Iosb<_Dummy>::hexfloat;

template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::boolalpha;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::_Stdio;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::adjustfield;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::basefield;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::floatfield;

template<class _Dummy>
 const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::goodbit;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::eofbit;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::failbit;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::badbit;

template<class _Dummy>
 const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::in;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::out;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::ate;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::app;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::trunc;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::_Nocreate;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::_Noreplace;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::binary;

template<class _Dummy>
 const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::beg;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::cur;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::end;


class ios_base
 : public _Iosb<int>
 {
public:
 typedef int fmtflags;
 typedef int iostate;
 typedef int openmode;
 typedef int seekdir;


 typedef ::std:: streamoff streamoff;
 typedef ::std:: streampos streampos;


 enum event
  {
  erase_event, imbue_event, copyfmt_event};

 typedef void (__cdecl *event_callback)(event, ios_base&, int);


 typedef unsigned int io_state, open_mode, seek_dir;



 class failure

  : public system_error
  {
 public:
  explicit failure(const string &_Message,
   const error_code& _Errcode = make_error_code(io_errc::stream))
   : system_error(_Errcode, _Message)
   {
   }

  explicit failure(const char *_Message,
   const error_code& _Errcode = make_error_code(io_errc::stream))
   : system_error(_Errcode, _Message)
   {
   }
# 251 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xiosbase" 3
  };


 class Init
  {
 public:
                     Init()
   {
   _Init_ctor(this);
   }

                     ~Init() noexcept
   {
   _Init_dtor(this);
   }

 private:
  static void __cdecl _Init_ctor(Init *);
  static void __cdecl _Init_dtor(Init *);

                          static int _Init_cnt;

  static int& __cdecl _Init_cnt_func();
  };

 explicit operator bool() const
  {
  return (!fail());
  }

 bool operator!() const
  {
  return (fail());
  }

 void clear(iostate _State, bool _Reraise)
  {
  _Mystate = (iostate)(_State & _Statmask);
  if ((_Mystate & _Except) == 0)
   ;
  else if (_Reraise)
   throw;
  else if (_Mystate & _Except & badbit)
   throw failure("ios_base::badbit set");
  else if (_Mystate & _Except & failbit)
   throw failure("ios_base::failbit set");
  else
   throw failure("ios_base::eofbit set");
  }

 void clear(iostate _State = goodbit)
  {
  clear(_State, false);
  }


 void clear(io_state _State)
  {
  clear((iostate)_State);
  }


 iostate rdstate() const
  {
  return (_Mystate);
  }

 void setstate(iostate _State, bool _Exreraise)
  {
  if (_State != goodbit)
   clear((iostate)((int)rdstate() | (int)_State), _Exreraise);
  }

 void setstate(iostate _State)
  {
  if (_State != goodbit)
   clear((iostate)((int)rdstate() | (int)_State), false);
  }


 void setstate(io_state _State)
  {
  setstate((iostate)_State);
  }


 bool good() const
  {
  return (rdstate() == goodbit);
  }

 bool eof() const
  {
  return ((int)rdstate() & (int)eofbit);
  }

 bool fail() const
  {
  return (((int)rdstate()
   & ((int)badbit | (int)failbit)) != 0);
  }

 bool bad() const
  {
  return (((int)rdstate() & (int)badbit) != 0);
  }

 iostate exceptions() const
  {
  return (_Except);
  }

 void exceptions(iostate _Newexcept)
  {
  _Except = (iostate)((int)_Newexcept & (int)_Statmask);
  clear(_Mystate);
  }


 void exceptions(io_state _State)
  {
  exceptions((iostate)_State);
  }


 fmtflags flags() const
  {
  return (_Fmtfl);
  }

 fmtflags flags(fmtflags _Newfmtflags)
  {
  fmtflags _Oldfmtflags = _Fmtfl;
  _Fmtfl = (fmtflags)((int)_Newfmtflags & (int)_Fmtmask);
  return (_Oldfmtflags);
  }

 fmtflags setf(fmtflags _Newfmtflags)
  {
  ios_base::fmtflags _Oldfmtflags = _Fmtfl;
  _Fmtfl = (fmtflags)((int)_Fmtfl
   | ((int)_Newfmtflags & (int)_Fmtmask));
  return (_Oldfmtflags);
  }

 fmtflags setf(fmtflags _Newfmtflags, fmtflags _Mask)
  {
  ios_base::fmtflags _Oldfmtflags = _Fmtfl;
  _Fmtfl = (fmtflags)(((int)_Fmtfl & (int)~_Mask)
   | ((int)_Newfmtflags & (int)_Mask & (int)_Fmtmask));
  return (_Oldfmtflags);
  }

 void unsetf(fmtflags _Mask)
  {
  _Fmtfl = (fmtflags)((int)_Fmtfl & (int)~_Mask);
  }

 streamsize precision() const
  {
  return (_Prec);
  }

 streamsize precision(streamsize _Newprecision)
  {
  streamsize _Oldprecision = _Prec;
  _Prec = _Newprecision;
  return (_Oldprecision);
  }

 streamsize width() const
  {
  return (_Wide);
  }

 streamsize width(streamsize _Newwidth)
  {
  streamsize _Oldwidth = _Wide;
  _Wide = _Newwidth;
  return (_Oldwidth);
  }

 locale getloc() const
  {
  return (*_Ploc);
  }

 locale imbue(const locale& _Loc)
  {
  locale _Oldlocale = *_Ploc;
  *_Ploc = _Loc;
  _Callfns(imbue_event);
  return (_Oldlocale);
  }

 static int __cdecl xalloc()
  {
  { ::std:: _Lockit _Lock(2);
   return (_Index++);
  }
  }

 long& iword(int _Idx)
  {
  return (_Findarr(_Idx)._Lo);
  }

 void *& pword(int _Idx)
  {
  return (_Findarr(_Idx)._Vp);
  }

 void register_callback(event_callback _Pfn,
  int _Idx)
  {
  _Calls = new _Fnarray(_Idx, _Pfn, _Calls);
  }

 ios_base& copyfmt(const ios_base& _Other)
  {
  if (this != &_Other)
   {
   _Tidy();
   *_Ploc = *_Other._Ploc;
   _Fmtfl = _Other._Fmtfl;
   _Prec = _Other._Prec;
   _Wide = _Other._Wide;
   _Iosarray *_Ptr = _Other._Arr;

   for (_Arr = 0; _Ptr != 0; _Ptr = _Ptr->_Next)
    if (_Ptr->_Lo != 0 || _Ptr->_Vp != 0)
     {
     iword(_Ptr->_Index) = _Ptr->_Lo;
     pword(_Ptr->_Index) = _Ptr->_Vp;
     }

   for (_Fnarray *_Pfa = _Other._Calls; _Pfa != 0;
    _Pfa = _Pfa->_Next)
    register_callback(_Pfa->_Pfn, _Pfa->_Index);

   _Callfns(copyfmt_event);
   exceptions(_Other._Except);
   }
  return (*this);
  }

 static bool __cdecl sync_with_stdio(bool _Newsync = true)
  {
  { ::std:: _Lockit _Lock(2);
   const bool _Oldsync = _Sync;
   _Sync = _Newsync;
   return (_Oldsync);
  }
  }

 void swap(ios_base& _Right)
  {
  if (this != &_Right)
   {
   ::std:: swap(_Mystate, _Right._Mystate);
   ::std:: swap(_Except, _Right._Except);
   ::std:: swap(_Fmtfl, _Right._Fmtfl);
   ::std:: swap(_Prec, _Right._Prec);
   ::std:: swap(_Wide, _Right._Wide);

   ::std:: swap(_Arr, _Right._Arr);
   ::std:: swap(_Calls, _Right._Calls);
   ::std:: swap(_Ploc, _Right._Ploc);
   }
  }

 virtual ~ios_base() noexcept
  {
  _Ios_base_dtor(this);
  }

 static void __cdecl
  _Addstd(ios_base *);

 size_t _Stdstr;

protected:
                    ios_base()
  {
  }

 void _Init()
  {
  _Ploc = 0;
  _Stdstr = 0;
  _Except = goodbit;
  _Fmtfl = (fmtflags)(skipws | dec);
  _Prec = 6;
  _Wide = 0;
  _Arr = 0;
  _Calls = 0;
  clear(goodbit);
  _Ploc = new locale;
  }

private:

 struct _Iosarray
  : public _Crt_new_delete
  {
 public:
                     _Iosarray(int _Idx, _Iosarray *_Link)
   : _Next(_Link), _Index(_Idx), _Lo(0), _Vp(0)
   {
   }

  _Iosarray *_Next;
  int _Index;
  long _Lo;
  void *_Vp;
  };


 struct _Fnarray
  : public _Crt_new_delete
  {
                     _Fnarray(int _Idx, event_callback _Pnew, _Fnarray *_Link)
   : _Next(_Link), _Index(_Idx), _Pfn(_Pnew)
   {
   }

  _Fnarray *_Next;
  int _Index;
  event_callback _Pfn;
  };

 void _Callfns(event _Ev)
  {
  for (_Fnarray *_Pfa = _Calls; _Pfa != 0; _Pfa = _Pfa->_Next)
   (*_Pfa->_Pfn)(_Ev, *this, _Pfa->_Index);
  }

 _Iosarray& _Findarr(int _Idx)
  {
  _Iosarray *_Ptr1, *_Ptr2;

  for (_Ptr1 = _Arr, _Ptr2 = 0; _Ptr1 != 0; _Ptr1 = _Ptr1->_Next)
   if (_Ptr1->_Index == _Idx)
    return (*_Ptr1);
   else if (_Ptr2 == 0 && _Ptr1->_Lo == 0 && _Ptr1->_Vp == 0)
    _Ptr2 = _Ptr1;

  if (_Ptr2 != 0)
   {
   _Ptr2->_Index = _Idx;
   return (*_Ptr2);
   }

  _Arr = new _Iosarray(_Idx, _Arr);
  return (*_Arr);
  }

 void _Tidy()
  {
  _Callfns(erase_event);
  _Iosarray *_Ptr1, *_Ptr2;

  for (_Ptr1 = _Arr; _Ptr1 != 0; _Ptr1 = _Ptr2)
   {
   _Ptr2 = _Ptr1->_Next;
   delete _Ptr1;
   }
  _Arr = 0;

  _Fnarray *_Pfa1, *_Pfa2;
  for (_Pfa1 = _Calls; _Pfa1 != 0; _Pfa1 = _Pfa2)
   {
   _Pfa2 = _Pfa1->_Next;
   delete _Pfa1;
   }
  _Calls = 0;
  }

 iostate _Mystate;
 iostate _Except;
 fmtflags _Fmtfl;
 streamsize _Prec;
 streamsize _Wide;
 _Iosarray *_Arr;
 _Fnarray *_Calls;
 locale *_Ploc;

                         static int _Index;
                         static bool _Sync;

 static void __cdecl
  _Ios_base_dtor(ios_base *);

public:
 ios_base(const ios_base&) = delete;
 ios_base& operator=(const ios_base&) = delete;
 };





}

#pragma warning(pop)
#pragma pack(pop)
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\streambuf" 2 3


#pragma pack(push,8)
#pragma warning(push, 3)



#pragma warning(disable: 4251)

namespace std {

template<class _Elem,
 class _Traits>
 class basic_streambuf
 {
 typedef basic_streambuf<_Elem, _Traits> _Myt;

protected:
                    basic_streambuf()
  : _Plocale(new locale)
  {
  _Init();
  }

                    basic_streambuf(_Uninitialized)
  {
  }

                    basic_streambuf(const _Myt& _Right)
  : _Plocale(new locale(_Right.getloc()))
  {
  _Init();
  setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
  setg(_Right.eback(), _Right.gptr(), _Right.egptr());
  }

 _Myt& operator=(const _Myt& _Right)
  {
  if (this != &_Right)
   {
   setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
   setg(_Right.eback(), _Right.gptr(), _Right.egptr());
   pubimbue(_Right.getloc());
   }
  return (*this);
  }

 void swap(_Myt& _Right)
  {
  if (this != &_Right)
   {
   _Elem *_Pfirst0 = pbase();
   _Elem *_Pnext0 = pptr();
   _Elem *_Pend = epptr();
   _Elem *_Gfirst0 = eback();
   _Elem *_Gnext0 = gptr();
   _Elem *_Gend = egptr();

   setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
   _Right.setp(_Pfirst0, _Pnext0, _Pend);

   setg(_Right.eback(), _Right.gptr(), _Right.egptr());
   _Right.setg(_Gfirst0, _Gnext0, _Gend);

   ::std:: swap(_Plocale, _Right._Plocale);
   }
  }

public:
 typedef _Elem char_type;
 typedef _Traits traits_type;

 virtual ~basic_streambuf() noexcept
  {
  delete _Plocale;
  }

 typedef typename _Traits::int_type int_type;
 typedef typename _Traits::pos_type pos_type;
 typedef typename _Traits::off_type off_type;

 pos_type pubseekoff(off_type _Off,
  ios_base::seekdir _Way,
  ios_base::openmode _Mode = ios_base::in | ios_base::out)
  {
  return (seekoff(_Off, _Way, _Mode));
  }


 pos_type pubseekoff(off_type _Off,
  ios_base::seek_dir _Way,
  ios_base::open_mode _Mode)
  {
  return (pubseekoff(_Off, (ios_base::seekdir)_Way,
   (ios_base::openmode)_Mode));
  }


 pos_type pubseekpos(pos_type _Pos,
  ios_base::openmode _Mode = ios_base::in | ios_base::out)
  {
  return (seekpos(_Pos, _Mode));
  }


 pos_type pubseekpos(pos_type _Pos,
  ios_base::open_mode _Mode)
  {
  return (seekpos(_Pos, (ios_base::openmode)_Mode));
  }


 _Myt * pubsetbuf(_Elem *_Buffer,
  streamsize _Count)
  {
  return (setbuf(_Buffer, _Count));
  }

 locale pubimbue(const locale &_Newlocale)
  {
  locale _Oldlocale = *_Plocale;
  imbue(_Newlocale);
  *_Plocale = _Newlocale;
  return (_Oldlocale);
  }

 locale getloc() const
  {
  return (*_Plocale);
  }

 streamsize in_avail()
  {
  streamsize _Res = _Gnavail();
  return (0 < _Res ? _Res : showmanyc());
  }

 int pubsync()
  {
  return (sync());
  }

 int_type sbumpc()
  {
  return (0 < _Gnavail()
   ? _Traits::to_int_type(*_Gninc()) : uflow());
  }

 int_type sgetc()
  {
  return (0 < _Gnavail()
   ? _Traits::to_int_type(*gptr()) : underflow());
  }

 streamsize sgetn(_Elem *_Ptr,
  streamsize _Count)
  {
  return (xsgetn(_Ptr, _Count));
  }

 int_type snextc()
  {
  return (1 < _Gnavail()
   ? _Traits::to_int_type(*_Gnpreinc())
   : _Traits::eq_int_type(_Traits::eof(), sbumpc())
    ? _Traits::eof() : sgetc());
  }

 int_type sputbackc(_Elem _Ch)
  {
  return (gptr() != 0 && eback() < gptr()
   && _Traits::eq(_Ch, gptr()[-1])
   ? _Traits::to_int_type(*_Gndec())
   : pbackfail(_Traits::to_int_type(_Ch)));
  }


 void stossc()
  {
  if (0 < _Gnavail())
   _Gninc();
  else
   uflow();
  }


 int_type sungetc()
  {
  return (gptr() != 0 && eback() < gptr()
   ? _Traits::to_int_type(*_Gndec()) : pbackfail());
  }

 int_type sputc(_Elem _Ch)
  {
  return (0 < _Pnavail()
   ? _Traits::to_int_type(*_Pninc() = _Ch)
   : overflow(_Traits::to_int_type(_Ch)));
  }

 streamsize sputn(const _Elem *_Ptr,
  streamsize _Count)
  {
  return (xsputn(_Ptr, _Count));
  }

 virtual void _Lock()
  {
  }

 virtual void _Unlock()
  {
  }

protected:
 _Elem * eback() const
  {
  return (*_IGfirst);
  }

 _Elem * gptr() const
  {
  return (*_IGnext);
  }

 _Elem * pbase() const
  {
  return (*_IPfirst);
  }

 _Elem * pptr() const
  {
  return (*_IPnext);
  }

 _Elem * egptr() const
  {
  return (*_IGnext + *_IGcount);
  }

 void gbump(int _Off)
  {
  *_IGcount -= _Off;
  *_IGnext += _Off;
  }

 void setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
  {
  *_IGfirst = _First;
  *_IGnext = _Next;
  *_IGcount = (int)(_Last - _Next);
  }

 _Elem * epptr() const
  {
  return (*_IPnext + *_IPcount);
  }

 _Elem * _Gndec()
  {
  ++*_IGcount;
  return (--*_IGnext);
  }

 _Elem * _Gninc()
  {
  --*_IGcount;
  return ((*_IGnext)++);
  }

 _Elem * _Gnpreinc()
  {
  --*_IGcount;
  return (++(*_IGnext));
  }

 streamsize _Gnavail() const
  {
  return (*_IGnext != 0 ? *_IGcount : 0);
  }

 void pbump(int _Off)
  {
  *_IPcount -= _Off;
  *_IPnext += _Off;
  }

 void setp(_Elem *_First, _Elem *_Last)
  {
  *_IPfirst = _First;
  *_IPnext = _First;
  *_IPcount = (int)(_Last - _First);
  }

 void setp(_Elem *_First, _Elem *_Next, _Elem *_Last)
  {
  *_IPfirst = _First;
  *_IPnext = _Next;
  *_IPcount = (int)(_Last - _Next);
  }

 _Elem * _Pninc()
  {
  --*_IPcount;
  return ((*_IPnext)++);
  }

 streamsize _Pnavail() const
  {
  return (*_IPnext != 0 ? *_IPcount : 0);
  }

 void _Init()
  {
  _IGfirst = &_Gfirst;
  _IPfirst = &_Pfirst;
  _IGnext = &_Gnext;
  _IPnext = &_Pnext;
  _IGcount = &_Gcount;
  _IPcount = &_Pcount;
  setp(0, 0);
  setg(0, 0, 0);
  }

 void _Init(_Elem **_Gf, _Elem **_Gn, int *_Gc,
  _Elem **_Pf, _Elem **_Pn, int *_Pc)
  {
  _IGfirst = _Gf;
  _IPfirst = _Pf;
  _IGnext = _Gn;
  _IPnext = _Pn;
  _IGcount = _Gc;
  _IPcount = _Pc;
  }

 virtual int_type overflow(int_type = _Traits::eof())
  {
  return (_Traits::eof());
  }

 virtual int_type pbackfail(int_type = _Traits::eof())
  {
  return (_Traits::eof());
  }

 virtual streamsize showmanyc()
  {
  return (0);
  }

 virtual int_type underflow()
  {
  return (_Traits::eof());
  }

 virtual int_type uflow()
  {
  return (_Traits::eq_int_type(_Traits::eof(), underflow())
   ? _Traits::eof() : _Traits::to_int_type(*_Gninc()));
  }

 virtual streamsize xsgetn(_Elem * _Ptr,
  streamsize _Count)
  {
  int_type _Meta;
  streamsize _Size, _Copied;

  for (_Copied = 0; 0 < _Count; )
   if (0 < (_Size = _Gnavail()))
    {
    if (_Count < _Size)
     _Size = _Count;
    _Traits::copy(_Ptr, gptr(), (size_t)_Size);
    _Ptr += _Size;
    _Copied += _Size;
    _Count -= _Size;
    gbump((int)_Size);
    }
   else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))
    break;
   else
    {
    *_Ptr++ = _Traits::to_char_type(_Meta);
    ++_Copied;
    --_Count;
    }

  return (_Copied);
  }

 virtual streamsize xsputn(const _Elem *_Ptr,
  streamsize _Count)
  {
  streamsize _Size, _Copied;

  for (_Copied = 0; 0 < _Count; )
   if (0 < (_Size = _Pnavail()))
    {
    if (_Count < _Size)
     _Size = _Count;
    _Traits::copy(pptr(), _Ptr, (size_t)_Size);
    _Ptr += _Size;
    _Copied += _Size;
    _Count -= _Size;
    pbump((int)_Size);
    }
   else if (_Traits::eq_int_type(_Traits::eof(),
    overflow(_Traits::to_int_type(*_Ptr))))
    break;
   else
    {
    ++_Ptr;
    ++_Copied;
    --_Count;
    }

  return (_Copied);
  }

 virtual pos_type seekoff(off_type,
  ios_base::seekdir,
  ios_base::openmode = ios_base::in | ios_base::out)
  {
  return (streampos(_BADOFF));
  }

 virtual pos_type seekpos(pos_type,
  ios_base::openmode = ios_base::in | ios_base::out)
  {
  return (streampos(_BADOFF));
  }

 virtual _Myt * setbuf(_Elem *, streamsize)
  {
  return (this);
  }

 virtual int sync()
  {
  return (0);
  }

 virtual void imbue(const locale&)
  {
  }

private:
 _Elem *_Gfirst;
 _Elem *_Pfirst;
 _Elem **_IGfirst;
 _Elem **_IPfirst;
 _Elem *_Gnext;
 _Elem *_Pnext;
 _Elem **_IGnext;
 _Elem **_IPnext;

 int _Gcount;
 int _Pcount;
 int *_IGcount;
 int *_IPcount;

protected:
 locale *_Plocale;
 };
# 484 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\streambuf" 3
template<class _Elem,
 class _Traits>
 class istreambuf_iterator
  : public iterator<input_iterator_tag,
   _Elem, typename _Traits::off_type, const _Elem *, _Elem>
 {
 typedef istreambuf_iterator<_Elem, _Traits> _Myt;
public:
 typedef _Elem char_type;
 typedef _Traits traits_type;
 typedef basic_streambuf<_Elem, _Traits> streambuf_type;
 typedef basic_istream<_Elem, _Traits> istream_type;

 typedef typename traits_type::int_type int_type;
 typedef const _Elem *pointer;

 constexpr istreambuf_iterator(streambuf_type *_Sb = 0) noexcept
  : _Strbuf(_Sb), _Got(_Sb == 0), _Val()
  {
  }

 istreambuf_iterator(istream_type& _Istr) noexcept
  : _Strbuf(_Istr.rdbuf()), _Got(_Istr.rdbuf() == 0)
  {
  }

 _Elem operator*() const
  {
  if (!_Got)
   _Peek();






  return (_Val);
  }

 const _Elem *operator->() const
  {
  return (pointer_traits<pointer>::pointer_to(**this));
  }

 _Myt& operator++()
  {





  _Inc();
  return (*this);
  }

 _Myt operator++(int)
  {
  if (!_Got)
   _Peek();
  _Myt _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 bool equal(const _Myt& _Right) const
  {
  if (!_Got)
   _Peek();
  if (!_Right._Got)
   _Right._Peek();
  return ((_Strbuf == 0 && _Right._Strbuf == 0)
   || (_Strbuf != 0 && _Right._Strbuf != 0));
  }

private:
 void _Inc()
  {
  if (_Strbuf == 0
   || traits_type::eq_int_type(traits_type::eof(),
    _Strbuf->sbumpc()))
   _Strbuf = 0, _Got = true;
  else
   _Got = false;
  }

 _Elem _Peek() const
  {
  int_type _Meta;
  if (_Strbuf == 0
   || traits_type::eq_int_type(traits_type::eof(),
    _Meta = _Strbuf->sgetc()))
   _Strbuf = 0;
  else
   _Val = traits_type::to_char_type(_Meta);
  _Got = true;
  return (_Val);
  }

 mutable streambuf_type *_Strbuf;
 mutable bool _Got;
 mutable _Elem _Val;
 };

template<class _Elem,
 class _Traits>
 struct _Is_checked_helper<istreambuf_iterator<_Elem, _Traits> >
  : public true_type
 {
 };


template<class _Elem,
 class _Traits> inline
 bool operator==(
  const istreambuf_iterator<_Elem, _Traits>& _Left,
  const istreambuf_iterator<_Elem, _Traits>& _Right)
 {
 return (_Left.equal(_Right));
 }

template<class _Elem,
 class _Traits> inline
 bool operator!=(
  const istreambuf_iterator<_Elem, _Traits>& _Left,
  const istreambuf_iterator<_Elem, _Traits>& _Right)
 {
 return (!(_Left == _Right));
 }


template<class _Elem,
 class _Traits>
 class ostreambuf_iterator
  : public _Outit
 {
 typedef ostreambuf_iterator<_Elem, _Traits> _Myt;
public:
 typedef _Elem char_type;
 typedef _Traits traits_type;
 typedef basic_streambuf<_Elem, _Traits> streambuf_type;
 typedef basic_ostream<_Elem, _Traits> ostream_type;

 ostreambuf_iterator(streambuf_type *_Sb) noexcept
  : _Failed(false), _Strbuf(_Sb)
  {
  }

 ostreambuf_iterator(ostream_type& _Ostr) noexcept
  : _Failed(false), _Strbuf(_Ostr.rdbuf())
  {
  }

 _Myt& operator=(_Elem _Right)
  {
  if (_Strbuf == 0
   || traits_type::eq_int_type(_Traits::eof(),
    _Strbuf->sputc(_Right)))
   _Failed = true;
  return (*this);
  }

 _Myt& operator*()
  {
  return (*this);
  }

 _Myt& operator++()
  {
  return (*this);
  }

 _Myt& operator++(int)
  {
  return (*this);
  }

 bool failed() const noexcept
  {
  return (_Failed);
  }

private:
 bool _Failed;
 streambuf_type *_Strbuf;
 };

template<class _Elem,
 class _Traits>
 struct _Is_checked_helper<ostreambuf_iterator<_Elem, _Traits> >
  : public true_type
 {
 };
}


#pragma warning(pop)
#pragma pack(pop)
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xlocnum" 2 3


#pragma pack(push,8)
#pragma warning(push, 3)



#pragma warning(disable: 4189 4275)




extern "C" {


extern float __cdecl _Stofx(const char *,
                                  char **,
 long, int *);
extern double __cdecl _Stodx(const char *,
                                  char **,
 long, int *);
extern long double __cdecl _Stoldx(const char *,
                                  char **,
 long, int *);
extern long __cdecl _Stolx(const char *,
                                  char **,
 int, int *);
extern unsigned long __cdecl _Stoulx(const char *,
                                  char **,
 int, int *);
extern long long __cdecl _Stollx(const char *,
                                  char **,
 int, int *);
extern unsigned long long __cdecl _Stoullx(const char *,
                                  char **,
 int, int *);


}


namespace std {


inline double _Stodx_v2(const char *_Str, char **_Endptr, int _Pten, int *_Perr)
 {
 int& _Errno_ref = (*_errno());
 const int _Orig = _Errno_ref;

 _Errno_ref = 0;
 double _Val = :: strtod(_Str, _Endptr);
 *_Perr = _Errno_ref;
 _Errno_ref = _Orig;

 if (_Pten != 0)
  _Val *= :: pow(10.0, static_cast<double>(_Pten));

 return (_Val);
 }


inline float _Stofx_v2(const char *_Str, char **_Endptr, int _Pten, int *_Perr)
 {
 int& _Errno_ref = (*_errno());
 const int _Orig = _Errno_ref;

 _Errno_ref = 0;
 float _Val = :: strtof(_Str, _Endptr);
 *_Perr = _Errno_ref;
 _Errno_ref = _Orig;

 if (_Pten != 0)
  _Val *= :: powf(10.0f, static_cast<float>(_Pten));

 return (_Val);
 }


template<class _Elem> inline
 size_t _Find_elem(_Elem *_Base, _Elem _Ch)
 {
 _Elem *_Ptr = _Base;
 for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)
  ;
 return ((size_t)(_Ptr - _Base));
 }

inline wchar_t *_Maklocwcs(const wchar_t *_Ptr)
 {
 size_t _Count = :: wcslen(_Ptr) + 1;

 wchar_t *_Ptrdest = (wchar_t *)calloc(_Count, sizeof (wchar_t));


 if (!_Ptrdest)
  _Xbad_alloc();
 :: wmemcpy(_Ptrdest, _Ptr, _Count);
 return (_Ptrdest);
 }


template<class _Elem>
 class numpunct
  : public locale::facet
 {
public:
 typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
  string_type;
 typedef _Elem char_type;

                                       static locale::id id;

 _Elem decimal_point() const
  {
  return (do_decimal_point());
  }

 _Elem thousands_sep() const
  {
  return (do_thousands_sep());
  }

 string grouping() const
  {
  return (do_grouping());
  }

 string_type falsename() const
  {
  return (do_falsename());
  }

 string_type truename() const
  {
  return (do_truename());
  }

 explicit numpunct(size_t _Refs = 0)
  : locale::facet(_Refs)
  {
  { _Locinfo _Lobj;
   _Init(_Lobj);
   if (_Kseparator == 0)
    _Kseparator =
     _Maklocchr(',', (_Elem *)0, _Lobj._Getcvt());
  }
  }

 numpunct(const _Locinfo& _Lobj, size_t _Refs = 0, bool _Isdef = false)
  : locale::facet(_Refs)
  {
  _Init(_Lobj, _Isdef);
  }

 static size_t _Getcat(const locale::facet **_Ppf = 0,
  const locale *_Ploc = 0)
  {
  if (_Ppf != 0 && *_Ppf == 0)
   *_Ppf = new numpunct<_Elem>(
    _Locinfo(_Ploc->c_str()), 0, true);
  return (4);
  }

protected:
 virtual ~numpunct() noexcept
  {
  _Tidy();
  }

 numpunct(const char *_Locname, size_t _Refs = 0, bool _Isdef = false)
  : locale::facet(_Refs)
  {
  { _Locinfo _Lobj(_Locname);
   _Init(_Lobj, _Isdef);
  }
  }

 template<class _Elem2>
  void _Getvals(_Elem2, const lconv *_Ptr, _Locinfo::_Cvtvec _Cvt)
  {
  _Dp = _Maklocchr(_Ptr->decimal_point[0], (_Elem2 *)0, _Cvt);
  _Kseparator = _Maklocchr(_Ptr->thousands_sep[0], (_Elem2 *)0, _Cvt);
  }

 template<>
  void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)
  {
  _Dp = (_Elem)_Ptr->_W_decimal_point[0];
  _Kseparator = (_Elem)_Ptr->_W_thousands_sep[0];
  }

 void _Init(const _Locinfo& _Lobj, bool _Isdef = false)
  {
  const lconv *_Ptr = _Lobj._Getlconv();
  _Locinfo::_Cvtvec _Cvt = _Lobj._Getcvt();

  _Grouping = 0;
  _Falsename = 0;
  _Truename = 0;

  try {
  _Grouping = _Maklocstr(_Isdef ? "" : _Ptr->grouping, (char *)0, _Lobj._Getcvt());

  _Falsename = _Maklocstr(_Lobj._Getfalse(), (_Elem *)0, _Cvt);
  _Truename = _Maklocstr(_Lobj._Gettrue(), (_Elem *)0, _Cvt);
  } catch (...) {
  _Tidy();
  throw;
  }

  if (_Isdef)
   {

   _Dp = _Maklocchr('.', (_Elem *)0, _Cvt);
   _Kseparator = _Maklocchr(',', (_Elem *)0, _Cvt);
   }
  else
   _Getvals((_Elem)0, _Ptr, _Cvt);
  }

 virtual _Elem do_decimal_point() const
  {
  return (_Dp);
  }

 virtual _Elem do_thousands_sep() const
  {
  return (_Kseparator);
  }

 virtual string do_grouping() const
  {
  return (string(_Grouping));
  }

 virtual string_type do_falsename() const
  {
  return (string_type(_Falsename));
  }

 virtual string_type do_truename() const
  {
  return (string_type(_Truename));
  }

private:
 void _Tidy()
  {
  :: free((void *)_Grouping);
  :: free((void *)_Falsename);
  :: free((void *)_Truename);
  }

 const char *_Grouping;
 _Elem _Dp;
 _Elem _Kseparator;
 const _Elem *_Falsename;
 const _Elem *_Truename;
 };


template<class _Elem>
 class numpunct_byname
  : public numpunct<_Elem>
 {
public:
 explicit numpunct_byname(const char *_Locname, size_t _Refs = 0)
  : numpunct<_Elem>(_Locname, _Refs)
  {
  }

 explicit numpunct_byname(const string& _Str, size_t _Refs = 0)
  : numpunct<_Elem>(_Str.c_str(), _Refs)
  {
  }

protected:
 virtual ~numpunct_byname() noexcept
  {
  }
 };


template<class _Elem>
                         locale::id numpunct<_Elem>::id;


template<class _Elem,
 class _InIt = istreambuf_iterator<_Elem, char_traits<_Elem> > >
 class num_get
  : public locale::facet
 {
public:
 typedef numpunct<_Elem> _Mypunct;
 typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
  _Mystr;

 static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
  const locale *_Ploc = 0)
  {
  if (_Ppf != 0 && *_Ppf == 0)
   *_Ppf = new num_get<_Elem, _InIt>(
    _Locinfo(_Ploc->c_str()));
  return (4);
  }

                         static locale::id id;

protected:
 virtual ~num_get() noexcept
  {
  }

 void _Init(const _Locinfo&)
  {
  }

public:
 explicit num_get(size_t _Refs = 0)
  : locale::facet(_Refs)
  {
  { _Locinfo _Lobj;
   _Init(_Lobj);
  }
  }

                    num_get(const _Locinfo& _Lobj, size_t _Refs = 0)
  : locale::facet(_Refs)
  {
  _Init(_Lobj);
  }

 typedef _Elem char_type;
 typedef _InIt iter_type;

 _InIt get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   bool& _Val) const
  {
  return (do_get(_First, _Last, _Iosbase, _State, _Val));
  }

 _InIt get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   unsigned short& _Val) const
  {
  return (do_get(_First, _Last, _Iosbase, _State, _Val));
  }

 _InIt get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   unsigned int& _Val) const
  {
  return (do_get(_First, _Last, _Iosbase, _State, _Val));
  }

 _InIt get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   long& _Val) const
  {
  return (do_get(_First, _Last, _Iosbase, _State, _Val));
  }

 _InIt get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   unsigned long& _Val) const
  {
  return (do_get(_First, _Last, _Iosbase, _State, _Val));
  }

 _InIt get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   long long& _Val) const
  {
  return (do_get(_First, _Last, _Iosbase, _State, _Val));
  }

 _InIt get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   unsigned long long& _Val) const
  {
  return (do_get(_First, _Last, _Iosbase, _State, _Val));
  }

 _InIt get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   float& _Val) const
  {
  return (do_get(_First, _Last, _Iosbase, _State, _Val));
  }

 _InIt get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   double& _Val) const
  {
  return (do_get(_First, _Last, _Iosbase, _State, _Val));
  }

 _InIt get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   long double& _Val) const
  {
  return (do_get(_First, _Last, _Iosbase, _State, _Val));
  }

 _InIt get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   void *& _Val) const
  {
  return (do_get(_First, _Last, _Iosbase, _State, _Val));
  }

protected:
 virtual _InIt do_get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   bool& _Val) const
  {
                             ;
  int _Ans = -1;

  if (_Iosbase.flags() & ios_base::boolalpha)
   {
   typedef typename _Mystr::size_type _Mystrsize;
   const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
   _Mystr _Str((_Mystrsize)1, (char_type)0);
   _Str += _Punct_fac.falsename();
   _Str += (char_type)0;
   _Str += _Punct_fac.truename();
   _Ans = _Getloctxt(_First, _Last, (size_t)2, _Str.c_str());
   }
  else
   {
   char _Ac[32], *_Ep;
   int _Errno = 0;
   const unsigned long _Ulo = :: _Stoulx(_Ac, &_Ep,
    _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
     _Iosbase.getloc()), &_Errno);
   if (_Ep != _Ac && _Errno == 0 && _Ulo <= 1)
    _Ans = _Ulo;
   }

  if (_First == _Last)
   _State |= ios_base::eofbit;
  if (_Ans < 0)
   _State |= ios_base::failbit;
  else
   _Val = _Ans != 0;
  return (_First);
  }

 virtual _InIt do_get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   unsigned short& _Val) const
  {
                             ;
  char _Ac[32], *_Ep;
  int _Errno = 0;
  int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
   _Iosbase.getloc());
  char *_Ptr = _Ac[0] == '-' ? _Ac + 1 : _Ac;
  const unsigned long _Ans =
   :: _Stoulx(_Ptr, &_Ep, _Base, &_Errno);

  if (_First == _Last)
   _State |= ios_base::eofbit;
  if (_Ep == _Ptr || _Errno != 0 || 0xffff < _Ans)
   _State |= ios_base::failbit;
  else
   _Val = (unsigned short)(_Ac[0] == '-'
    ? 0 -_Ans : _Ans);
  return (_First);
  }

 virtual _InIt do_get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   unsigned int& _Val) const
  {
                             ;
  char _Ac[32], *_Ep;
  int _Errno = 0;
  int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
   _Iosbase.getloc());
  char *_Ptr = _Ac[0] == '-' ? _Ac + 1 : _Ac;
  const unsigned long _Ans =
   :: _Stoulx(_Ptr, &_Ep, _Base, &_Errno);

  if (_First == _Last)
   _State |= ios_base::eofbit;
  if (_Ep == _Ptr || _Errno != 0 || 0xffffffff < _Ans)
   _State |= ios_base::failbit;
  else
   _Val = _Ac[0] == '-' ? 0 -_Ans : _Ans;
  return (_First);
  }

 virtual _InIt do_get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   long& _Val) const
  {
                             ;
  char _Ac[32], *_Ep;
  int _Errno = 0;
  const long _Ans = :: _Stolx(_Ac, &_Ep,
   _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
    _Iosbase.getloc()), &_Errno);

  if (_First == _Last)
   _State |= ios_base::eofbit;
  if (_Ep == _Ac || _Errno != 0)
   _State |= ios_base::failbit;
  else
   _Val = _Ans;
  return (_First);
  }

 virtual _InIt do_get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   unsigned long& _Val) const
  {
                             ;
  char _Ac[32], *_Ep;
  int _Errno = 0;
  const unsigned long _Ans = :: _Stoulx(_Ac, &_Ep,
   _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
    _Iosbase.getloc()), &_Errno);

  if (_First == _Last)
   _State |= ios_base::eofbit;
  if (_Ep == _Ac || _Errno != 0)
   _State |= ios_base::failbit;
  else
   _Val = _Ans;
  return (_First);
  }

 virtual _InIt do_get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   long long& _Val) const
  {
                             ;
  char _Ac[32], *_Ep;
  int _Errno = 0;
  const long long _Ans = :: _Stollx(_Ac, &_Ep,
   _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
    _Iosbase.getloc()), &_Errno);

  if (_First == _Last)
   _State |= ios_base::eofbit;
  if (_Ep == _Ac || _Errno != 0)
   _State |= ios_base::failbit;
  else
   _Val = _Ans;
  return (_First);
  }

 virtual _InIt do_get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   unsigned long long& _Val) const
  {
                             ;
  char _Ac[32], *_Ep;
  int _Errno = 0;
  const unsigned long long _Ans = :: _Stoullx(_Ac, &_Ep,
   _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
    _Iosbase.getloc()), &_Errno);

  if (_First == _Last)
   _State |= ios_base::eofbit;
  if (_Ep == _Ac || _Errno != 0)
   _State |= ios_base::failbit;
  else
   _Val = _Ans;
  return (_First);
  }







 virtual _InIt do_get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   float& _Val) const
  {
                             ;
  char _Ac[(8 + 768 + 16)], *_Ep;
  int _Errno = 0;
  int _Hexexp = 1000000000;
  float _Ans = _Stofx_v2(_Ac, &_Ep,
   _Getffld(_Ac, _First, _Last,
    _Iosbase, &_Hexexp), &_Errno);

  if (_Hexexp != 1000000000 && _Hexexp != 0)
   _Ans = :: ldexpf(_Ans, 4 * _Hexexp);

  if (_First == _Last)
   _State |= ios_base::eofbit;
  if (_Ep == _Ac || _Errno != 0)
   _State |= ios_base::failbit;
  else
   _Val = _Ans;
  return (_First);
  }

 virtual _InIt do_get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   double& _Val) const
  {
                             ;
  char _Ac[(8 + 768 + 16)], *_Ep;
  int _Errno = 0;
  int _Hexexp = 1000000000;
  double _Ans = _Stodx_v2(_Ac, &_Ep,
   _Getffld(_Ac, _First, _Last,
    _Iosbase, &_Hexexp), &_Errno);

  if (_Hexexp != 1000000000 && _Hexexp != 0)
   _Ans = :: ldexp(_Ans, 4 * _Hexexp);

  if (_First == _Last)
   _State |= ios_base::eofbit;
  if (_Ep == _Ac || _Errno != 0)
   _State |= ios_base::failbit;
  else
   _Val = _Ans;
  return (_First);
  }

 virtual _InIt do_get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   long double& _Val) const
  {
                             ;
  char _Ac[(8 + 768 + 16)], *_Ep;
  int _Errno = 0;
  int _Hexexp = 1000000000;
  long double _Ans = _Stodx_v2(_Ac, &_Ep,
   _Getffld(_Ac, _First, _Last,
    _Iosbase, &_Hexexp), &_Errno);

  if (_Hexexp != 1000000000 && _Hexexp != 0)
   _Ans = :: ldexpl(_Ans, 4 * _Hexexp);

  if (_First == _Last)
   _State |= ios_base::eofbit;
  if (_Ep == _Ac || _Errno != 0)
   _State |= ios_base::failbit;
  else
   _Val = _Ans;
  return (_First);
  }



 virtual _InIt do_get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   void *& _Val) const
  {
                             ;
  char _Ac[32], *_Ep;
  int _Errno = 0;

  int _Base = _Getifld(_Ac, _First, _Last, ios_base::hex,
   _Iosbase.getloc());
  const unsigned long long _Ans =
   (sizeof (void *) == sizeof (unsigned long))
    ? (unsigned long long):: _Stoulx(_Ac, &_Ep, _Base, &_Errno)
    : :: _Stoullx(_Ac, &_Ep, _Base, &_Errno);

  if (_First == _Last)
   _State |= ios_base::eofbit;
  if (_Ep == _Ac || _Errno != 0)
   _State |= ios_base::failbit;
  else
   _Val = (void *)((char *)0 + _Ans);
  return (_First);
  }

private:
 int __cdecl _Getifld(char *_Ac,
  _InIt& _First, _InIt& _Last, ios_base::fmtflags _Basefield,
   const locale& _Loc) const
  {
  const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Loc);
  const string _Grouping = _Punct_fac.grouping();
  const _Elem _Kseparator = _Grouping.size() == 0
   ? (_Elem)0 : _Punct_fac.thousands_sep();

  enum {
   _NUMGET_SIGNOFF = 22,
   _NUMGET_XOFF = 24};
  static const char _Src[] = {"0123456789ABCDEFabcdef-+Xx"};
  _Elem _Atoms[sizeof (_Src)];
  const ctype<_Elem>& _Ctype_fac =
   use_facet< ctype<_Elem> >(_Loc);
  _Ctype_fac.widen(&_Src[0], &_Src[sizeof (_Src)], _Atoms);

  char *_Ptr = _Ac;

  if (_First == _Last)
   ;
  else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
   *_Ptr++ = '+', ++_First;
  else if (*_First == _Atoms[_NUMGET_SIGNOFF])
   *_Ptr++ = '-', ++_First;

  _Basefield &= ios_base::basefield;
  int _Base = _Basefield == ios_base::oct ? 8
   : _Basefield == ios_base::hex ? 16
   : _Basefield == ios_base::_Fmtzero ? 0 : 10;

  bool _Seendigit = false;
  bool _Nonzero = false;

  if (_First != _Last && *_First == _Atoms[0])
   {
   _Seendigit = true, ++_First;
   if (_First != _Last && (*_First == _Atoms[_NUMGET_XOFF + 1]
     || *_First == _Atoms[_NUMGET_XOFF])
    && (_Base == 0 || _Base == 16))
    _Base = 16, _Seendigit = false, ++_First;
   else if (_Base == 0)
    _Base = 8;
   }

  size_t _Dlen = _Base == 0 || _Base == 10 ? 10
   : _Base == 8 ? 8 : 16 + 6;
  string _Groups((size_t)1, (char)_Seendigit);
  size_t _Group = 0;

  for (char *const _Pe = &_Ac[32 - 1];
   _First != _Last; ++_First)
   {
   size_t _Idx = _Find_elem(_Atoms, *_First);
   if (_Idx < _Dlen)
    {
    *_Ptr = _Src[_Idx];
    if ((_Nonzero || *_Ptr != '0') && _Ptr < _Pe)
     ++_Ptr, _Nonzero = true;
    _Seendigit = true;
    if (_Groups[_Group] != 127)
     ++_Groups[_Group];
    }
   else if (_Groups[_Group] == '\0'
    || _Kseparator == (_Elem)0
    || *_First != _Kseparator)
    break;
   else
    {
    _Groups.append((string::size_type)1, '\0');
    ++_Group;
    }
   }

  if (_Group == 0)
   ;
  else if ('\0' < _Groups[_Group])
   ++_Group;
  else
   _Seendigit = false;

  for (const char *_Pg = &_Grouping[0]; _Seendigit && 0 < _Group; )
   if (*_Pg == 127)
    break;
   else if ((0 < --_Group && *_Pg != _Groups[_Group])
    || (0 == _Group && *_Pg < _Groups[_Group]))
    _Seendigit = false;
   else if ('\0' < _Pg[1])
    ++_Pg;

  if (_Seendigit && !_Nonzero)
   *_Ptr++ = '0';
  else if (!_Seendigit)
   _Ptr = _Ac;
  *_Ptr = '\0';
  return (_Base);
  }

 int __cdecl _Getffld(char *_Ac,
  _InIt& _First, _InIt &_Last,
  ios_base& _Iosbase, int *_Phexexp) const
  {
  if ((_Iosbase.flags() & ios_base::floatfield) == ios_base::hexfloat)
   return (_Getffldx(_Ac, _First, _Last,
    _Iosbase, _Phexexp));

  const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
  const string _Grouping = _Punct_fac.grouping();
  char *_Ptr = _Ac;
  bool _Bad = false;
  bool _Sticky = false;

  enum {
   _NUMGET_SIGNOFF = 10,
   _NUMGET_EOFF = 12};
  static const char _Src[] = {"0123456789-+Ee"};
  _Elem _Atoms[sizeof (_Src)];
  const ctype<_Elem>& _Ctype_fac =
   use_facet< ctype<_Elem> >(_Iosbase.getloc());
  _Ctype_fac.widen(&_Src[0], &_Src[sizeof (_Src)], _Atoms);

  if (_First == _Last)
   ;
  else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
   *_Ptr++ = '+', ++_First;
  else if (*_First == _Atoms[_NUMGET_SIGNOFF])
   *_Ptr++ = '-', ++_First;

  char *_Leading = _Ptr;
  *_Ptr++ = '0';

  bool _Seendigit = false;
  int _Significant = 0;
  int _Pten = 0;
  size_t _Idx;

  const int _Max_sig_dig = (*_Phexexp == 1000000000 ? 768 : 36);

  const char *_Pg = &_Grouping[0];
  if (*_Pg == 127 || *_Pg <= '\0')
   for (; _First != _Last
    && (_Idx = _Find_elem(_Atoms, *_First)) < 10;
     _Seendigit = true, ++_First)
    if (_Max_sig_dig <= _Significant)
     {
     ++_Pten;
     if (0 < _Idx)
      _Sticky = true;
     }
    else if (_Idx == 0 && _Significant == 0)
     ;
    else
     {
     *_Ptr++ = _Src[_Idx];
     ++_Significant;
     }
  else
   {
   const _Elem _Kseparator = _Grouping.size() == 0
    ? (_Elem)0 : _Punct_fac.thousands_sep();
   string _Groups((size_t)1, '\0');
   size_t _Group = 0;

   for (; _First != _Last; ++_First)
    if ((_Idx = _Find_elem(_Atoms, *_First)) < 10)
     {
     _Seendigit = true;
     if (_Max_sig_dig <= _Significant)
      {
      ++_Pten;
      if (0 < _Idx)
       _Sticky = true;
      }
     else if (_Idx == 0 && _Significant == 0)
      ;
     else
      {
      *_Ptr++ = _Src[_Idx];
      ++_Significant;
      }
     if (_Groups[_Group] != 127)
      ++_Groups[_Group];
     }
    else if (_Groups[_Group] == '\0'
     || _Kseparator == (_Elem)0
     || *_First != _Kseparator)
     break;
    else
     {
     _Groups.append((size_t)1, '\0');
     ++_Group;
     }
   if (_Group == 0)
    ;
   else if ('\0' < _Groups[_Group])
    ++_Group;
   else
    _Bad = true;

   while (!_Bad && 0 < _Group)
    if (*_Pg == 127)
     break;
    else if ((0 < --_Group && *_Pg != _Groups[_Group])
     || (0 == _Group && *_Pg < _Groups[_Group]))
     _Bad = true;
    else if ('\0' < _Pg[1])
     ++_Pg;
   }

  if (_First != _Last && *_First == _Punct_fac.decimal_point())
   *_Ptr++ = localeconv()->decimal_point[0], ++_First;

  if (*_Phexexp != 1000000000 && _Significant == 0)
   {
   for (; _First != _Last && *_First == _Atoms[0];
    _Seendigit = true, ++_First)
    --_Pten;
   if (_Pten < 0)
    *_Ptr++ = '0', ++_Pten;
   }

  for (; _First != _Last
    && (_Idx = _Find_elem(_Atoms, *_First)) < 10;
    _Seendigit = true, ++_First)
   if (_Significant < _Max_sig_dig)
    {
    *_Ptr++ = _Src[_Idx];
    ++_Significant;
    }
   else if (0 < _Idx)
    _Sticky = true;

  if (_Sticky)
   {
   char *_Px = _Ptr;
   for (; --_Px != _Leading; )
    {
    if (*_Px == localeconv()->decimal_point[0])
     ;
    else if (*_Px != '9')
     {
     ++*_Px;
     break;
     }
    else
     *_Px = '0';
    }

   if (_Px == _Leading)
    {
    *_Px = '1';
    ++_Pten;
    }
   }

  if (_Seendigit && _First != _Last
   && (*_First == _Atoms[_NUMGET_EOFF + 1]
    || *_First == _Atoms[_NUMGET_EOFF]))
   {
   *_Ptr++ = 'e', ++_First;
   _Seendigit = false, _Significant = 0;

   if (_First == _Last)
    ;
   else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
    *_Ptr++ = '+', ++_First;
   else if (*_First == _Atoms[_NUMGET_SIGNOFF])
    *_Ptr++ = '-', ++_First;
   for (; _First != _Last && *_First == _Atoms[0]; )
    _Seendigit = true, ++_First;
   if (_Seendigit)
    *_Ptr++ = '0';
   for (; _First != _Last
    && (_Idx = _Find_elem(_Atoms, *_First)) < 10;
    _Seendigit = true, ++_First)
    if (_Significant < 8)
     {
     *_Ptr++ = _Src[_Idx];
     ++_Significant;
     }
   }

  if (_Bad || !_Seendigit)
   _Ptr = _Ac;
  *_Ptr = '\0';
  return (_Pten);
  }

 int __cdecl _Getffldx(char *_Ac,
  _InIt& _First, _InIt &_Last,
  ios_base& _Iosbase, int *_Phexexp) const
  {
  const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
  const string _Grouping = _Punct_fac.grouping();

  enum {
   _NUMGET_SIGNOFF = 22,
   _NUMGET_XOFF = 24,
   _NUMGET_POFF = 26};
  static const char _Src[] = {"0123456789ABCDEFabcdef-+XxPp"};
  _Elem _Atoms[sizeof (_Src)];
  const ctype<_Elem>& _Ctype_fac =
   use_facet< ctype<_Elem> >(_Iosbase.getloc());
  _Ctype_fac.widen(&_Src[0], &_Src[sizeof (_Src)], _Atoms);

  char *_Ptr = _Ac;
  bool _Bad = false;
  size_t _Idx;

  if (_First == _Last)
   ;
  else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
   *_Ptr++ = '+', ++_First;
  else if (*_First == _Atoms[_NUMGET_SIGNOFF])
   *_Ptr++ = '-', ++_First;

  *_Ptr++ = '0';
  *_Ptr++ = 'x';

  bool _Seendigit = false;
  int _Significant = 0;
  int _Phex = 0;

  if (_First == _Last || *_First != _Atoms[0])
   ;
  else if (++_First != _Last
   && (*_First == _Atoms[_NUMGET_XOFF + 1]
    || *_First == _Atoms[_NUMGET_XOFF]))
   ++_First;
  else
   _Seendigit = true;

  const int _Max_sig_dig = (*_Phexexp == 1000000000 ? 768 : 36);

  const char *_Pg = &_Grouping[0];
  if (*_Pg == 127 || *_Pg <= '\0')
   for (; _First != _Last
    && (_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF;
     _Seendigit = true, ++_First)
    if (_Max_sig_dig <= _Significant)
     ++_Phex;
    else if (_Idx == 0 && _Significant == 0)
     ;
    else
     {
     *_Ptr++ = _Src[_Idx];
     ++_Significant;
     }
  else
   {
   const _Elem _Kseparator = _Grouping.size() == 0
    ? (_Elem)0 : _Punct_fac.thousands_sep();
   string _Groups((size_t)1, '\0');
   size_t _Group = 0;

   for (; _First != _Last; ++_First)
    if ((_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF)
     {
     _Seendigit = true;
     if (_Max_sig_dig <= _Significant)
      ++_Phex;
     else if (_Idx == 0 && _Significant == 0)
      ;
     else
      {
      *_Ptr++ = _Src[_Idx];
      ++_Significant;
      }
     if (_Groups[_Group] != 127)
      ++_Groups[_Group];
     }
    else if (_Groups[_Group] == '\0'
     || _Kseparator == (_Elem)0
     || *_First != _Kseparator)
     break;
    else
     {
     _Groups.append((size_t)1, '\0');
     ++_Group;
     }
   if (_Group == 0)
    ;
   else if ('\0' < _Groups[_Group])
    ++_Group;
   else
    _Bad = true;

   while (!_Bad && 0 < _Group)
    if (*_Pg == 127)
     break;
    else if ((0 < --_Group && *_Pg != _Groups[_Group])
     || (0 == _Group && *_Pg < _Groups[_Group]))
     _Bad = true;
    else if ('\0' < _Pg[1])
     ++_Pg;
   }

  if (_Seendigit && _Significant == 0)
   *_Ptr++ = '0';

  if (_First != _Last && *_First == _Punct_fac.decimal_point())
   *_Ptr++ = localeconv()->decimal_point[0], ++_First;

  if (_Significant == 0)
   {
   for (; _First != _Last && *_First == _Atoms[0];
    _Seendigit = true, ++_First)
    --_Phex;
   if (_Phex < 0)
    *_Ptr++ = '0', ++_Phex;
   }

  for (; _First != _Last
    && (_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF;
    _Seendigit = true, ++_First)
   if (_Significant < _Max_sig_dig)
    {
    *_Ptr++ = _Src[_Idx];
    ++_Significant;
    }

  if (_Seendigit && _First != _Last
   && (*_First == _Atoms[_NUMGET_POFF + 1]
    || *_First == _Atoms[_NUMGET_POFF]))
   {
   *_Ptr++ = 'p', ++_First;
   _Seendigit = false, _Significant = 0;

   if (_First == _Last)
    ;
   else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
    *_Ptr++ = '+', ++_First;
   else if (*_First == _Atoms[_NUMGET_SIGNOFF])
    *_Ptr++ = '-', ++_First;
   for (; _First != _Last && *_First == _Atoms[0]; )
    _Seendigit = true, ++_First;
   if (_Seendigit)
    *_Ptr++ = '0';
   for (; _First != _Last
    && (_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF;
    _Seendigit = true, ++_First)
    if (_Significant < 8)
     {
     *_Ptr++ = _Src[_Idx];
     ++_Significant;
     }
   }

  if (_Bad || !_Seendigit)
   _Ptr = _Ac;
  *_Ptr = '\0';
  *_Phexexp = _Phex;
  return (0);
  }



 };


template<class _Elem,
 class _InIt>
                         locale::id num_get<_Elem, _InIt>::id;


template<class _Elem,
 class _OutIt = ostreambuf_iterator<_Elem, char_traits<_Elem> > >
 class num_put
  : public locale::facet
 {
public:
 typedef numpunct<_Elem> _Mypunct;
 typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
  _Mystr;

 static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
  const locale *_Ploc = 0)
  {
  if (_Ppf != 0 && *_Ppf == 0)
   *_Ppf = new num_put<_Elem, _OutIt>(
    _Locinfo(_Ploc->c_str()));
  return (4);
  }

                         static locale::id id;

protected:
 virtual ~num_put() noexcept
  {
  }

 void _Init(const _Locinfo&)
  {
  }

public:
 explicit num_put(size_t _Refs = 0)
  : locale::facet(_Refs)
  {
  { _Locinfo _Lobj;
   _Init(_Lobj);
  }
  }

                    num_put(const _Locinfo& _Lobj, size_t _Refs = 0)
  : locale::facet(_Refs)
  {
  _Init(_Lobj);
  }

 typedef _Elem char_type;
 typedef _OutIt iter_type;

 _OutIt put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, bool _Val) const
  {
  return (do_put(_Dest, _Iosbase, _Fill, _Val));
  }

 _OutIt put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, long _Val) const
  {
  return (do_put(_Dest, _Iosbase, _Fill, _Val));
  }

 _OutIt put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, unsigned long _Val) const
  {
  return (do_put(_Dest, _Iosbase, _Fill, _Val));
  }

 _OutIt put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, long long _Val) const
  {
  return (do_put(_Dest, _Iosbase, _Fill, _Val));
  }

 _OutIt put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, unsigned long long _Val) const
  {
  return (do_put(_Dest, _Iosbase, _Fill, _Val));
  }

 _OutIt put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, double _Val) const
  {
  return (do_put(_Dest, _Iosbase, _Fill, _Val));
  }

 _OutIt put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, long double _Val) const
  {
  return (do_put(_Dest, _Iosbase, _Fill, _Val));
  }

 _OutIt put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, const void *_Val) const
  {
  return (do_put(_Dest, _Iosbase, _Fill, _Val));
  }

protected:
 virtual _OutIt do_put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, bool _Val) const
  {
                       ;
  if (!(_Iosbase.flags() & ios_base::boolalpha))
   return (do_put(_Dest, _Iosbase, _Fill, (long)_Val));
  else
   {
   const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
   _Mystr _Str;
   if (_Val)
    _Str.assign(_Punct_fac.truename());
   else
    _Str.assign(_Punct_fac.falsename());

   size_t _Fillcount = _Iosbase.width() <= 0
    || (size_t)_Iosbase.width() <= _Str.size()
     ? 0 : (size_t)_Iosbase.width() - _Str.size();

   if ((_Iosbase.flags() & ios_base::adjustfield) != ios_base::left)
    {
    _Dest = _Rep(_Dest, _Fill, _Fillcount);
    _Fillcount = 0;
    }
   _Dest = _Put(_Dest, _Str.c_str(), _Str.size());
   _Iosbase.width(0);
   return (_Rep(_Dest, _Fill, _Fillcount));
   }
  }

 virtual _OutIt do_put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, long _Val) const
  {
  char _Buf[2 * 32], _Fmt[6];

  return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
   :: sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "ld",
    _Iosbase.flags()), _Val)));
  }

 virtual _OutIt do_put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, unsigned long _Val) const
  {
  char _Buf[2 * 32], _Fmt[6];

  return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
   :: sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "lu",
    _Iosbase.flags()), _Val)));
  }

 virtual _OutIt do_put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, long long _Val) const
  {
  char _Buf[2 * 32], _Fmt[8];

  return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
   :: sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "Ld",
    _Iosbase.flags()), _Val)));
  }

 virtual _OutIt do_put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, unsigned long long _Val) const
  {
  char _Buf[2 * 32], _Fmt[8];

  return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
   :: sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "Lu",
    _Iosbase.flags()), _Val)));
  }

 virtual _OutIt do_put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, double _Val) const
  {
  string _Buf;
  char _Fmt[8];
  bool _Isfixed = (_Iosbase.flags() & ios_base::floatfield)
   == ios_base::fixed;
  streamsize _Precision = _Iosbase.precision() <= 0 && !_Isfixed
   ? 6 : _Iosbase.precision();
  size_t _Bufsize = (size_t)_Precision;
  if (_Isfixed && 1e10 < :: fabs(_Val))
   {
   int _Ptwo;
   (void):: frexp(_Val, &_Ptwo);
   _Bufsize += :: abs(_Ptwo) * 30103L / 100000L;
   }
  _Buf.resize(_Bufsize + 50);

  int _Ngen = :: sprintf_s((char *)_Buf.c_str(), _Buf.size(),
   _Ffmt(_Fmt, 0, _Iosbase.flags()), (int)_Precision, _Val);

  return (_Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen));
  }

 virtual _OutIt do_put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, long double _Val) const
  {
  string _Buf;
  char _Fmt[8];
  bool _Isfixed = (_Iosbase.flags() & ios_base::floatfield)
   == ios_base::fixed;
  streamsize _Precision = _Iosbase.precision() <= 0 && !_Isfixed
   ? 6 : _Iosbase.precision();
  size_t _Bufsize = (size_t)_Precision;
  if (_Isfixed && 1e10 < :: fabsl(_Val))
   {
   int _Ptwo;
   (void):: frexpl(_Val, &_Ptwo);
   _Bufsize += :: abs(_Ptwo) * 30103L / 100000L;
   }
  _Buf.resize(_Bufsize + 50);

  int _Ngen = :: sprintf_s((char *)_Buf.c_str(), _Buf.size(),
   _Ffmt(_Fmt, 'L', _Iosbase.flags()), (int)_Precision, _Val);

  return (_Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen));
  }

 virtual _OutIt do_put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, const void *_Val) const
  {
  char _Buf[2 * 32];

  return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
   :: sprintf_s(_Buf, sizeof (_Buf), "%p", _Val)));
  }

private:
 char *__cdecl _Ffmt(char *_Fmt,
  char _Spec, ios_base::fmtflags _Flags) const
  {
  char *_Ptr = _Fmt;
  *_Ptr++ = '%';

  if (_Flags & ios_base::showpos)
   *_Ptr++ = '+';
  if (_Flags & ios_base::showpoint)
   *_Ptr++ = '#';
  *_Ptr++ = '.';
  *_Ptr++ = '*';
  if (_Spec != '\0')
   *_Ptr++ = _Spec;

  ios_base::fmtflags _Ffl = _Flags & ios_base::floatfield;
  if (_Flags & ios_base::uppercase)
   *_Ptr++ = _Ffl == ios_base::fixed ? 'f'
    : _Ffl == ios_base::hexfloat ? 'A'
    : _Ffl == ios_base::scientific ? 'E' : 'G';
  else
   *_Ptr++ = _Ffl == ios_base::fixed ? 'f'
    : _Ffl == ios_base::hexfloat ? 'a'
    : _Ffl == ios_base::scientific ? 'e' : 'g';

  *_Ptr = '\0';
  return (_Fmt);
  }

 _OutIt __cdecl _Fput(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, const char *_Buf,
   size_t _Count) const
  {
                       ;
  size_t _Prefix = 0 < _Count && (*_Buf == '+' || *_Buf == '-')
   ? 1 : 0;

  const char *_Exps;
  if ((_Iosbase.flags() & ios_base::floatfield) != ios_base::hexfloat)
   _Exps = "eE";
  else
   {
   _Exps = "pP";
   if (_Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
    && (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X'))
    _Prefix += 2;
   }
  const size_t _Eoff =
   :: strcspn(&_Buf[0], _Exps);
  char _Dp[2] = {"."};
  _Dp[0] = :: localeconv()->decimal_point[0];
  const size_t _Poff =
   :: strcspn(&_Buf[0], &_Dp[0]);

  const ctype<_Elem>& _Ctype_fac =
   use_facet< ctype<_Elem> >(_Iosbase.getloc());
  _Mystr _Groupstring(_Count, _Elem(0));
  _Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

  const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
  const string _Grouping = _Punct_fac.grouping();
  const _Elem _Kseparator = _Punct_fac.thousands_sep();

  if (_Poff != _Count)
   _Groupstring[_Poff] = _Punct_fac.decimal_point();

  size_t _Off = _Poff == _Count ? _Eoff : _Poff;
  const char *_Pg = &_Grouping[0];
  while (*_Pg != 127 && '\0' < *_Pg
   && (size_t)*_Pg < _Off - _Prefix)
   {
   _Groupstring.insert(_Off -= *_Pg, (size_t)1, _Kseparator);
   if ('\0' < _Pg[1])
    ++_Pg;
   }

  _Count = _Groupstring.size();
  size_t _Fillcount = _Iosbase.width() <= 0
   || (size_t)_Iosbase.width() <= _Count
    ? 0 : (size_t)_Iosbase.width() - _Count;

  ios_base::fmtflags _Adjustfield =
   _Iosbase.flags() & ios_base::adjustfield;
  if (_Adjustfield != ios_base::left
   && _Adjustfield != ios_base::internal)
   {
   _Dest = _Rep(_Dest, _Fill, _Fillcount);
   _Fillcount = 0;
   _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
   }
  else if (_Adjustfield == ios_base::internal)
   {
   _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
   _Dest = _Rep(_Dest, _Fill, _Fillcount);
   _Fillcount = 0;
   }
  else
   _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

  _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);
  _Iosbase.width(0);
  return (_Rep(_Dest, _Fill, _Fillcount));
  }

 char *__cdecl _Ifmt(char *_Fmt,
  const char *_Spec, ios_base::fmtflags _Flags) const
  {
  char *_Ptr = _Fmt;
  *_Ptr++ = '%';

  if (_Flags & ios_base::showpos)
   *_Ptr++ = '+';
  if (_Flags & ios_base::showbase)
   *_Ptr++ = '#';
  if (_Spec[0] != 'L')
   *_Ptr++ = _Spec[0];
  else

   {
   *_Ptr++ = 'I';
   *_Ptr++ = '6';
   *_Ptr++ = '4';
   }

  ios_base::fmtflags _Basefield = _Flags & ios_base::basefield;
  *_Ptr++ = _Basefield == ios_base::oct ? 'o'
   : _Basefield != ios_base::hex ? _Spec[1]
   : _Flags & ios_base::uppercase ? 'X' : 'x';
  *_Ptr = '\0';
  return (_Fmt);
  }

 _OutIt __cdecl _Iput(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, char *_Buf, size_t _Count) const
  {
                       ;
  size_t _Prefix = 0 < _Count && (*_Buf == '+' || *_Buf == '-')
   ? 1 : 0;
  if ((_Iosbase.flags() & ios_base::basefield) == ios_base::hex
   && _Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
   && (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X'))
   _Prefix += 2;

  const ctype<_Elem>& _Ctype_fac =
   use_facet< ctype<_Elem> >(_Iosbase.getloc());
  _Mystr _Groupstring(_Count, _Elem(0));
  _Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

  const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
  const string _Grouping = _Punct_fac.grouping();
  const char *_Pg = &_Grouping[0];
  if (*_Pg != 127 && '\0' < *_Pg)
   {
   const _Elem _Kseparator = _Punct_fac.thousands_sep();
   while (*_Pg != 127 && '\0' < *_Pg
    && (size_t)*_Pg < _Count - _Prefix)
    {
    _Count -= *_Pg;
    _Groupstring.insert(_Count, 1, _Kseparator);
    if ('\0' < _Pg[1])
     ++_Pg;
    }
   }

  _Count = _Groupstring.size();
  size_t _Fillcount = _Iosbase.width() <= 0
   || (size_t)_Iosbase.width() <= _Count
    ? 0 : (size_t)_Iosbase.width() - _Count;

  ios_base::fmtflags _Adjustfield =
   _Iosbase.flags() & ios_base::adjustfield;
  if (_Adjustfield != ios_base::left
   && _Adjustfield != ios_base::internal)
   {
   _Dest = _Rep(_Dest, _Fill, _Fillcount);
   _Fillcount = 0;
   _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
   }
  else if (_Adjustfield == ios_base::internal)
   {
   _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
   _Dest = _Rep(_Dest, _Fill, _Fillcount);
   _Fillcount = 0;
   }
  else
   _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

  _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);
  _Iosbase.width(0);
  return (_Rep(_Dest, _Fill, _Fillcount));
  }

 _OutIt __cdecl _Put(_OutIt _Dest,
  const _Elem *_Ptr, size_t _Count) const
  {
  for (; 0 < _Count; --_Count, (void)++_Dest, ++_Ptr)
   *_Dest = *_Ptr;
  return (_Dest);
  }

 _OutIt __cdecl _Rep(_OutIt _Dest,
  _Elem _Ch, size_t _Count) const
  {
  for (; 0 < _Count; --_Count, (void)++_Dest)
   *_Dest = _Ch;
  return (_Dest);
  }
 };


template<class _Elem,
 class _OutIt>
                         locale::id num_put<_Elem, _OutIt>::id;
# 1619 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xlocnum" 3
}

#pragma warning(pop)
#pragma pack(pop)
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\ios" 2 3


#pragma pack(push,8)
#pragma warning(push, 3)



#pragma warning(disable: 4189)

namespace std {

template<class _Elem,
 class _Traits>
 class basic_ios
  : public ios_base
 {
public:
 typedef basic_ios<_Elem, _Traits> _Myt;
 typedef basic_ostream<_Elem, _Traits> _Myos;
 typedef basic_streambuf<_Elem, _Traits> _Mysb;
 typedef ctype<_Elem> _Ctype;
 typedef _Elem char_type;
 typedef _Traits traits_type;
 typedef typename _Traits::int_type int_type;
 typedef typename _Traits::pos_type pos_type;
 typedef typename _Traits::off_type off_type;

 explicit basic_ios(_Mysb *_Strbuf)
  {
  init(_Strbuf);
  }

 virtual ~basic_ios() noexcept
  {
  }

 void clear(iostate _State = goodbit,
  bool _Reraise = false)
  {
  ios_base::clear((iostate)(_Mystrbuf == 0
   ? (int)_State | (int)badbit : (int)_State), _Reraise);
  }


 void clear(io_state _State)
  {
  clear((iostate)_State);
  }


 void setstate(iostate _State,
  bool _Reraise = false)
  {
  if (_State != goodbit)
   clear((iostate)((int)rdstate() | (int)_State), _Reraise);
  }


 void setstate(io_state _State)
  {
  setstate((iostate)_State);
  }


 _Myt& copyfmt(const _Myt& _Right)
  {
  _Tiestr = _Right.tie();
  _Fillch = _Right.fill();
  ios_base::copyfmt(_Right);
  return (*this);
  }

 _Myos * tie() const
  {
  return (_Tiestr);
  }

 _Myos * tie(_Myos *_Newtie)
  {
  _Myos *_Oldtie = _Tiestr;
  _Tiestr = _Newtie;
  return (_Oldtie);
  }

 _Mysb * rdbuf() const
  {
  return (_Mystrbuf);
  }

 _Mysb * rdbuf(_Mysb *_Strbuf)
  {
  _Mysb *_Oldstrbuf = _Mystrbuf;
  _Mystrbuf = _Strbuf;
  clear();
  return (_Oldstrbuf);
  }

 locale imbue(const locale& _Loc)
  {
  locale _Oldlocale = ios_base::imbue(_Loc);
  if (rdbuf() != 0)
   rdbuf()->pubimbue(_Loc);
  return (_Oldlocale);
  }

 _Elem fill() const
  {
  return (_Fillch);
  }

 _Elem fill(_Elem _Newfill)
  {
  _Elem _Oldfill = _Fillch;
  _Fillch = _Newfill;
  return (_Oldfill);
  }

 char narrow(_Elem _Ch, char _Dflt = '\0') const
  {
  const _Ctype& _Ctype_fac = use_facet< _Ctype >(getloc());
  return (_Ctype_fac.narrow(_Ch, _Dflt));
  }

 _Elem widen(char _Byte) const
  {
  const _Ctype& _Ctype_fac = use_facet< _Ctype >(getloc());
  return (_Ctype_fac.widen(_Byte));
  }

 void move(_Myt& _Right)
  {
  if (this != &_Right)
   {
   _Mystrbuf = 0;
   _Tiestr = 0;
   this->swap(_Right);
   }
  }

 void move(_Myt&& _Right)
  {
  if (this != &_Right)
   {
   _Mystrbuf = 0;
   _Tiestr = 0;
   this->swap(_Right);
   }
  }

 void swap(_Myt& _Right) noexcept
  {
  ios_base::swap(_Right);
  ::std:: swap(_Fillch, _Right._Fillch);
  ::std:: swap(_Tiestr, _Right._Tiestr);
  }

 void set_rdbuf(_Mysb *_Strbuf)
  {
  _Mystrbuf = _Strbuf;
  }

protected:
 void init(_Mysb *_Strbuf = 0,
  bool _Isstd = false)
  {
  _Init();
  _Mystrbuf = _Strbuf;
  _Tiestr = 0;
  _Fillch = widen(' ');

  if (_Mystrbuf == 0)
   setstate(badbit);

  if (_Isstd)
   _Addstd(this);
  }

                    basic_ios()
  {
  }

private:
 _Mysb *_Mystrbuf;
 _Myos *_Tiestr;
 _Elem _Fillch;

public:
                    basic_ios(const _Myt&) = delete;
 _Myt& operator=(const _Myt&) = delete;
 };
# 213 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\ios" 3
inline ios_base& __cdecl boolalpha(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::boolalpha);
 return (_Iosbase);
 }

inline ios_base& __cdecl dec(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::dec, ios_base::basefield);
 return (_Iosbase);
 }

inline ios_base& __cdecl defaultfloat(ios_base& _Iosbase)
 {
 _Iosbase.unsetf(ios_base::floatfield);
 return (_Iosbase);
 }

inline ios_base& __cdecl fixed(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::fixed, ios_base::floatfield);
 return (_Iosbase);
 }

inline ios_base& __cdecl hex(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::hex, ios_base::basefield);
 return (_Iosbase);
 }

inline ios_base& __cdecl hexfloat(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::hexfloat, ios_base::floatfield);
 return (_Iosbase);
 }


namespace tr1 {
using ::std:: hexfloat;
}


inline ios_base& __cdecl internal(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::internal, ios_base::adjustfield);
 return (_Iosbase);
 }

inline ios_base& __cdecl left(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::left, ios_base::adjustfield);
 return (_Iosbase);
 }

inline ios_base& __cdecl noboolalpha(ios_base& _Iosbase)
 {
 _Iosbase.unsetf(ios_base::boolalpha);
 return (_Iosbase);
 }

inline ios_base& __cdecl noshowbase(ios_base& _Iosbase)
 {
 _Iosbase.unsetf(ios_base::showbase);
 return (_Iosbase);
 }

inline ios_base& __cdecl noshowpoint(ios_base& _Iosbase)
 {
 _Iosbase.unsetf(ios_base::showpoint);
 return (_Iosbase);
 }

inline ios_base& __cdecl noshowpos(ios_base& _Iosbase)
 {
 _Iosbase.unsetf(ios_base::showpos);
 return (_Iosbase);
 }

inline ios_base& __cdecl noskipws(ios_base& _Iosbase)
 {
 _Iosbase.unsetf(ios_base::skipws);
 return (_Iosbase);
 }

inline ios_base& __cdecl nounitbuf(ios_base& _Iosbase)
 {
 _Iosbase.unsetf(ios_base::unitbuf);
 return (_Iosbase);
 }

inline ios_base& __cdecl nouppercase(ios_base& _Iosbase)
 {
 _Iosbase.unsetf(ios_base::uppercase);
 return (_Iosbase);
 }

inline ios_base& __cdecl oct(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::oct, ios_base::basefield);
 return (_Iosbase);
 }

inline ios_base& __cdecl right(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::right, ios_base::adjustfield);
 return (_Iosbase);
 }

inline ios_base& __cdecl scientific(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::scientific, ios_base::floatfield);
 return (_Iosbase);
 }

inline ios_base& __cdecl showbase(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::showbase);
 return (_Iosbase);
 }

inline ios_base& __cdecl showpoint(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::showpoint);
 return (_Iosbase);
 }

inline ios_base& __cdecl showpos(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::showpos);
 return (_Iosbase);
 }

inline ios_base& __cdecl skipws(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::skipws);
 return (_Iosbase);
 }

inline ios_base& __cdecl unitbuf(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::unitbuf);
 return (_Iosbase);
 }

inline ios_base& __cdecl uppercase(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::uppercase);
 return (_Iosbase);
 }
}


#pragma warning(pop)
#pragma pack(pop)
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\ostream" 2 3


#pragma pack(push,8)
#pragma warning(push, 3)



#pragma warning(disable: 4189 4390)

namespace std {
# 35 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\ostream" 3
#pragma vtordisp(push, 2)


template<class _Elem,
 class _Traits>
 class basic_ostream
  : virtual public basic_ios<_Elem, _Traits>
 {
public:
 typedef basic_ostream<_Elem, _Traits> _Myt;
 typedef basic_ios<_Elem, _Traits> _Myios;
 typedef basic_streambuf<_Elem, _Traits> _Mysb;
 typedef ostreambuf_iterator<_Elem, _Traits> _Iter;
 typedef num_put<_Elem, _Iter> _Nput;

 explicit basic_ostream(
  basic_streambuf<_Elem, _Traits> *_Strbuf,

  bool _Isstd = false)
  {
  _Myios::init(_Strbuf, _Isstd);
  }

                    basic_ostream(_Uninitialized, bool _Addit = true)
  {
  if (_Addit)
   this->_Addstd(this);
  }

protected:
                    basic_ostream(_Myt&& _Right)
  {
  _Myios::init();
  _Myios::move(::std:: move(_Right));
  }

 _Myt& operator=(_Myt&& _Right)
  {
  this->swap(_Right);
  return (*this);
  }

 void swap(_Myt& _Right)
  {
  if (this != &_Right)
   _Myios::swap(_Right);
  }

public:
                    basic_ostream(const _Myt&) = delete;
 _Myt& operator=(const _Myt&) = delete;

 virtual ~basic_ostream() noexcept
  {
  }

 typedef typename _Traits::int_type int_type;
 typedef typename _Traits::pos_type pos_type;
 typedef typename _Traits::off_type off_type;

 class _Sentry_base
  {
 public:
                     _Sentry_base(_Myt& _Ostr)
   : _Myostr(_Ostr)
   {
   if (_Myostr.rdbuf() != 0)
    _Myostr.rdbuf()->_Lock();
   }

                     ~_Sentry_base() noexcept
   {
   if (_Myostr.rdbuf() != 0)
    _Myostr.rdbuf()->_Unlock();
   }

  _Myt& _Myostr;

 private:
  _Sentry_base& operator=(const _Sentry_base&);
  };

 class sentry
  : public _Sentry_base
  {
 public:
  explicit sentry(_Myt& _Ostr)
   : _Sentry_base(_Ostr)
   {
   if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)
    _Ostr.tie()->flush();
   _Ok = _Ostr.good();
   }

                     ~sentry() noexcept
   {

   if (!::std:: uncaught_exception())
    this->_Myostr._Osfx();




   }

  explicit operator bool() const
   {
   return (_Ok);
   }

                     sentry(const sentry&) = delete;
  sentry& operator=(const sentry&) = delete;

 private:
  bool _Ok;
  };

 bool opfx()
  {
  if (this->good() && _Myios::tie() != 0 && _Myios::tie() != this)
   _Myios::tie()->flush();
  return (this->good());
  }

 void osfx()
  {
  _Osfx();
  }

 void _Osfx()
  {
  try {
  if (this->good() && this->flags() & ios_base::unitbuf)
   if (_Myios::rdbuf()->pubsync() == -1)
    _Myios::setstate(ios_base::badbit);
  } catch (...) {
  }
  }
# 196 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\ostream" 3
 _Myt& operator<<(_Myt& (__cdecl *_Pfn)(_Myt&))
  {
                      ;
  return ((*_Pfn)(*this));
  }

 _Myt& operator<<(_Myios& (__cdecl *_Pfn)(_Myios&))
  {
                      ;
  (*_Pfn)(*(_Myios *)this);
  return (*this);
  }

 _Myt& operator<<(ios_base& (__cdecl *_Pfn)(ios_base&))
  {
                      ;
  (*_Pfn)(*(ios_base *)this);
  return (*this);
  }

 _Myt& operator<<(bool _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

   try {
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), _Val).failed())
    _State |= ios_base::badbit;
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& operator<<(short _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());
   ios_base::fmtflags _Bfl =
    this->flags() & ios_base::basefield;
   long _Tmp = (_Bfl == ios_base::oct
    || _Bfl == ios_base::hex)
    ? (long)(unsigned short)_Val : (long)_Val;

   try {
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), _Tmp).failed())
    _State |= ios_base::badbit;
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }
# 270 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\ostream" 3
 _Myt& operator<<(unsigned short _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

   try {
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), (unsigned long)_Val).failed())
    _State |= ios_base::badbit;
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& operator<<(int _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());
   ios_base::fmtflags _Bfl =
    this->flags() & ios_base::basefield;
   long _Tmp = (_Bfl == ios_base::oct
    || _Bfl == ios_base::hex)
    ? (long)(unsigned int)_Val : (long)_Val;

   try {
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), _Tmp).failed())
    _State |= ios_base::badbit;
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& operator<<(unsigned int _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

   try {
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), (unsigned long)_Val).failed())
    _State |= ios_base::badbit;
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& operator<<(long _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

   try {
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), _Val).failed())
    _State |= ios_base::badbit;
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& operator<<(unsigned long _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

   try {
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), _Val).failed())
    _State |= ios_base::badbit;
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& operator<<(long long _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

   try {
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), _Val).failed())
    _State |= ios_base::badbit;
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& operator<<(unsigned long long _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

   try {
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), _Val).failed())
    _State |= ios_base::badbit;
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& operator<<(float _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

   try {
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), (double)_Val).failed())
    _State |= ios_base::badbit;
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& operator<<(double _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

   try {
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), _Val).failed())
    _State |= ios_base::badbit;
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& operator<<(long double _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

   try {
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), _Val).failed())
    _State |= ios_base::badbit;
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& operator<<(const void *_Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

   try {
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), _Val).failed())
    _State |= ios_base::badbit;
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& operator<<(_Mysb *_Strbuf)
  {
  ios_base::iostate _State = ios_base::goodbit;
  bool _Copied = false;
  const sentry _Ok(*this);

  if (_Ok && _Strbuf != 0)
   for (int_type _Meta = _Traits::eof(); ; _Copied = true)
    {
    try {
    _Meta = _Traits::eq_int_type(_Traits::eof(), _Meta)
     ? _Strbuf->sgetc() : _Strbuf->snextc();
    } catch (...) {
     _Myios::setstate(ios_base::failbit);
     throw;
    }

    if (_Traits::eq_int_type(_Traits::eof(), _Meta))
     break;

    try {
     if (_Traits::eq_int_type(_Traits::eof(),
      _Myios::rdbuf()->sputc(
       _Traits::to_char_type(_Meta))))
      {
      _State |= ios_base::badbit;
      break;
      }
    } catch (...) { _Myios::setstate(ios_base::badbit, true); }
    }

  this->width(0);
  _Myios::setstate(_Strbuf == 0 ? ios_base::badbit
   : !_Copied ? _State | ios_base::failbit : _State);
  return (*this);
  }

 _Myt& put(_Elem _Ch)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (!_Ok)
   _State |= ios_base::badbit;
  else
   {
   try {
   if (_Traits::eq_int_type(_Traits::eof(),
    _Myios::rdbuf()->sputc(_Ch)))
    _State |= ios_base::badbit;
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& write(const _Elem *_Str,
  streamsize _Count)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (!_Ok)
   _State |= ios_base::badbit;
  else if (0 < _Count)
   {
                       ;
   try {
   if (_Myios::rdbuf()->sputn(_Str, _Count) != _Count)
    _State |= ios_base::badbit;
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& flush()
  {
  if (_Myios::rdbuf() != 0)
   {
   const sentry _Ok(*this);

   if (_Ok && _Myios::rdbuf()->pubsync() == -1)
    _Myios::setstate(ios_base::badbit);
   }
  return (*this);
  }

 _Myt& seekp(pos_type _Pos)
  {
  const sentry _Ok(*this);

  if (!this->fail()
   && (off_type)_Myios::rdbuf()->pubseekpos(_Pos,
    ios_base::out) == _BADOFF)
   _Myios::setstate(ios_base::failbit);
  return (*this);
  }

 _Myt& seekp(off_type _Off, ios_base::seekdir _Way)
  {
  const sentry _Ok(*this);

  if (!this->fail()
   && (off_type)_Myios::rdbuf()->pubseekoff(_Off, _Way,
    ios_base::out) == _BADOFF)
   _Myios::setstate(ios_base::failbit);
  return (*this);
  }

 pos_type tellp()
  {
  const sentry _Ok(*this);

  if (!this->fail())
   return (_Myios::rdbuf()->pubseekoff(0,
    ios_base::cur, ios_base::out));
  else
   return (pos_type(_BADOFF));
  }
 };

#pragma vtordisp(pop)
# 690 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\ostream" 3
template<class _Elem,
 class _Traits> inline
 basic_ostream<_Elem, _Traits>& operator<<(
  basic_ostream<_Elem, _Traits>& _Ostr, const char *_Val)
 {
 ios_base::iostate _State = ios_base::goodbit;
 streamsize _Count = (streamsize):: strlen(_Val);
 streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
  ? 0 : _Ostr.width() - _Count;
 const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

 if (!_Ok)
  _State |= ios_base::badbit;
 else
  {
  try {
  const ctype<_Elem>& _Ctype_fac = use_facet< ctype<_Elem> >(_Ostr.getloc());
  if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
   for (; 0 < _Pad; --_Pad)
    if (_Traits::eq_int_type(_Traits::eof(),
     _Ostr.rdbuf()->sputc(_Ostr.fill())))
     {
     _State |= ios_base::badbit;
     break;
     }

  for (; _State == ios_base::goodbit && 0 < _Count; --_Count, ++_Val)
   if (_Traits::eq_int_type(_Traits::eof(),
    _Ostr.rdbuf()->sputc(_Ctype_fac.widen(*_Val))))
     _State |= ios_base::badbit;

  if (_State == ios_base::goodbit)
   for (; 0 < _Pad; --_Pad)
    if (_Traits::eq_int_type(_Traits::eof(),
     _Ostr.rdbuf()->sputc(_Ostr.fill())))
     {
     _State |= ios_base::badbit;
     break;
     }
  _Ostr.width(0);
  } catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
  }

 _Ostr.setstate(_State);
 return (_Ostr);
 }

template<class _Elem,
 class _Traits> inline
 basic_ostream<_Elem, _Traits>& operator<<(
  basic_ostream<_Elem, _Traits>& _Ostr, char _Ch)
 {
 ios_base::iostate _State = ios_base::goodbit;
 const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

 if (_Ok)
  {
  const ctype<_Elem>& _Ctype_fac = use_facet< ctype<_Elem> >(_Ostr.getloc());
  streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

  try {
  if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
   for (; _State == ios_base::goodbit && 0 < _Pad;
    --_Pad)
    if (_Traits::eq_int_type(_Traits::eof(),
     _Ostr.rdbuf()->sputc(_Ostr.fill())))
     _State |= ios_base::badbit;

  if (_State == ios_base::goodbit
   && _Traits::eq_int_type(_Traits::eof(),
    _Ostr.rdbuf()->sputc(_Ctype_fac.widen(_Ch))))
   _State |= ios_base::badbit;

  for (; _State == ios_base::goodbit && 0 < _Pad;
   --_Pad)
   if (_Traits::eq_int_type(_Traits::eof(),
    _Ostr.rdbuf()->sputc(_Ostr.fill())))
    _State |= ios_base::badbit;
  } catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
  }

 _Ostr.width(0);
 _Ostr.setstate(_State);
 return (_Ostr);
 }

template<class _Traits> inline
 basic_ostream<char, _Traits>& operator<<(
  basic_ostream<char, _Traits>& _Ostr,
  const char *_Val)
 {
 typedef char _Elem;
 typedef basic_ostream<_Elem, _Traits> _Myos;
 ios_base::iostate _State = ios_base::goodbit;
 streamsize _Count = (streamsize)_Traits::length(_Val);
 streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
  ? 0 : _Ostr.width() - _Count;
 const typename _Myos::sentry _Ok(_Ostr);

 if (!_Ok)
  _State |= ios_base::badbit;
 else
  {
  try {
  if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
   for (; 0 < _Pad; --_Pad)
    if (_Traits::eq_int_type(_Traits::eof(),
     _Ostr.rdbuf()->sputc(_Ostr.fill())))
     {
     _State |= ios_base::badbit;
     break;
     }

  if (_State == ios_base::goodbit
   && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)
   _State |= ios_base::badbit;

  if (_State == ios_base::goodbit)
   for (; 0 < _Pad; --_Pad)
    if (_Traits::eq_int_type(_Traits::eof(),
     _Ostr.rdbuf()->sputc(_Ostr.fill())))
     {
     _State |= ios_base::badbit;
     break;
     }
  _Ostr.width(0);
  } catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
  }

 _Ostr.setstate(_State);
 return (_Ostr);
 }

template<class _Traits> inline
 basic_ostream<char, _Traits>& operator<<(
  basic_ostream<char, _Traits>& _Ostr, char _Ch)
 {
 typedef char _Elem;
 typedef basic_ostream<_Elem, _Traits> _Myos;
 ios_base::iostate _State = ios_base::goodbit;
 const typename _Myos::sentry _Ok(_Ostr);

 if (_Ok)
  {
  streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

  try {
  if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
   for (; _State == ios_base::goodbit && 0 < _Pad;
    --_Pad)
    if (_Traits::eq_int_type(_Traits::eof(),
     _Ostr.rdbuf()->sputc(_Ostr.fill())))
     _State |= ios_base::badbit;

  if (_State == ios_base::goodbit
   && _Traits::eq_int_type(_Traits::eof(),
    _Ostr.rdbuf()->sputc(_Ch)))
   _State |= ios_base::badbit;

  for (; _State == ios_base::goodbit && 0 < _Pad;
   --_Pad)
   if (_Traits::eq_int_type(_Traits::eof(),
    _Ostr.rdbuf()->sputc(_Ostr.fill())))
    _State |= ios_base::badbit;
  } catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
  }

 _Ostr.width(0);
 _Ostr.setstate(_State);
 return (_Ostr);
 }

template<class _Elem,
 class _Traits> inline
 basic_ostream<_Elem, _Traits>& operator<<(
  basic_ostream<_Elem, _Traits>& _Ostr, const _Elem *_Val)
 {
 typedef basic_ostream<_Elem, _Traits> _Myos;

 ios_base::iostate _State = ios_base::goodbit;
 streamsize _Count = (streamsize)_Traits::length(_Val);
 streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
  ? 0 : _Ostr.width() - _Count;
 const typename _Myos::sentry _Ok(_Ostr);

 if (!_Ok)
  _State |= ios_base::badbit;
 else
  {
  try {
  if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
   for (; 0 < _Pad; --_Pad)
    if (_Traits::eq_int_type(_Traits::eof(),
     _Ostr.rdbuf()->sputc(_Ostr.fill())))
     {
     _State |= ios_base::badbit;
     break;
     }

  if (_State == ios_base::goodbit
   && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)
   _State |= ios_base::badbit;

  if (_State == ios_base::goodbit)
   for (; 0 < _Pad; --_Pad)
    if (_Traits::eq_int_type(_Traits::eof(),
     _Ostr.rdbuf()->sputc(_Ostr.fill())))
     {
     _State |= ios_base::badbit;
     break;
     }
  _Ostr.width(0);
  } catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
  }

 _Ostr.setstate(_State);
 return (_Ostr);
 }

template<class _Elem,
 class _Traits> inline
 basic_ostream<_Elem, _Traits>& operator<<(
  basic_ostream<_Elem, _Traits>& _Ostr, _Elem _Ch)
 {
 typedef basic_ostream<_Elem, _Traits> _Myos;

 ios_base::iostate _State = ios_base::goodbit;
 const typename _Myos::sentry _Ok(_Ostr);

 if (_Ok)
  {
  streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

  try {
  if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
   for (; _State == ios_base::goodbit && 0 < _Pad;
    --_Pad)
    if (_Traits::eq_int_type(_Traits::eof(),
     _Ostr.rdbuf()->sputc(_Ostr.fill())))
     _State |= ios_base::badbit;

  if (_State == ios_base::goodbit
   && _Traits::eq_int_type(_Traits::eof(),
    _Ostr.rdbuf()->sputc(_Ch)))
   _State |= ios_base::badbit;

  for (; _State == ios_base::goodbit && 0 < _Pad;
   --_Pad)
   if (_Traits::eq_int_type(_Traits::eof(),
    _Ostr.rdbuf()->sputc(_Ostr.fill())))
    _State |= ios_base::badbit;
  } catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
  }

 _Ostr.width(0);
 _Ostr.setstate(_State);
 return (_Ostr);
 }

template<class _Traits> inline
 basic_ostream<char, _Traits>& operator<<(
  basic_ostream<char, _Traits>& _Ostr, const signed char *_Val)
 {
 return (_Ostr << (const char *)_Val);
 }

template<class _Traits> inline
 basic_ostream<char, _Traits>& operator<<(
  basic_ostream<char, _Traits>& _Ostr, signed char _Ch)
 {
 return (_Ostr << (char)_Ch);
 }

template<class _Traits> inline
 basic_ostream<char, _Traits>& operator<<(
  basic_ostream<char, _Traits>& _Ostr, const unsigned char *_Val)
 {
 return (_Ostr << (const char *)_Val);
 }

template<class _Traits> inline
 basic_ostream<char, _Traits>& operator<<(
  basic_ostream<char, _Traits>& _Ostr, unsigned char _Ch)
 {
 return (_Ostr << (char)_Ch);
 }

template<class _Elem,
 class _Traits,
 class _Ty> inline
 basic_ostream<_Elem, _Traits>&
  operator<<(basic_ostream<_Elem, _Traits>&& _Ostr, const _Ty& _Val)
 {
 return (_Ostr << _Val);
 }


template<class _Elem,
 class _Traits> inline
 basic_ostream<_Elem, _Traits>&
  __cdecl endl(basic_ostream<_Elem, _Traits>& _Ostr)
 {
 _Ostr.put(_Ostr.widen('\n'));
 _Ostr.flush();
 return (_Ostr);
 }

template<class _Elem,
 class _Traits> inline
 basic_ostream<_Elem, _Traits>&
  __cdecl ends(basic_ostream<_Elem, _Traits>& _Ostr)
 {
 _Ostr.put(_Elem());
 return (_Ostr);
 }

template<class _Elem,
 class _Traits> inline
 basic_ostream<_Elem, _Traits>&
  __cdecl flush(basic_ostream<_Elem, _Traits>& _Ostr)
 {
 _Ostr.flush();
 return (_Ostr);
 }


template<class _Elem,
 class _Traits> inline
 basic_ostream<_Elem, _Traits>&
  operator<<(basic_ostream<_Elem, _Traits>& _Ostr,
   const error_code& _Errcode)
 {
 return (_Ostr << _Errcode.category().name() << ':' << _Errcode.value());
 }
}


#pragma warning(pop)
#pragma pack(pop)
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\istream" 2 3


#pragma pack(push,8)
#pragma warning(push, 3)



#pragma warning(disable: 4189)

namespace std {
#pragma vtordisp(push, 2)


template<class _Elem,
 class _Traits>
 class basic_istream
  : virtual public basic_ios<_Elem, _Traits>
 {
public:
 typedef basic_istream<_Elem, _Traits> _Myt;
 typedef basic_ios<_Elem, _Traits> _Myios;
 typedef basic_streambuf<_Elem, _Traits> _Mysb;
 typedef istreambuf_iterator<_Elem, _Traits> _Iter;
 typedef ctype<_Elem> _Ctype;
 typedef num_get<_Elem, _Iter> _Nget;
# 42 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\istream" 3
 explicit basic_istream(_Mysb *_Strbuf,
  bool _Isstd = false)

  : _Chcount(0)
  {
  _Myios::init(_Strbuf, _Isstd);
  }

                    basic_istream(_Uninitialized)
  {
  this->_Addstd(this);
  }

protected:
                    basic_istream(_Myt&& _Right)
  : _Chcount(_Right._Chcount)
  {
  _Myios::init();
  _Myios::move(::std:: move(_Right));
  _Right._Chcount = 0;
  }

 _Myt& operator=(_Myt&& _Right)
  {
  this->swap(_Right);
  return (*this);
  }

 void swap(_Myt& _Right)
  {
  _Myios::swap(_Right);
  ::std:: swap(_Chcount, _Right._Chcount);
  }

public:
                    basic_istream(const _Myt&) = delete;
 _Myt& operator=(const _Myt&) = delete;

 virtual ~basic_istream() noexcept
  {
  }

 typedef typename _Traits::int_type int_type;
 typedef typename _Traits::pos_type pos_type;
 typedef typename _Traits::off_type off_type;


 class _Sentry_base
  {
 public:
                     _Sentry_base(_Myt& _Istr)
   : _Myistr(_Istr)
   {
   if (_Myistr.rdbuf() != 0)
    _Myistr.rdbuf()->_Lock();
   }

                     ~_Sentry_base() noexcept
   {
   if (_Myistr.rdbuf() != 0)
    _Myistr.rdbuf()->_Unlock();
   }

  _Myt& _Myistr;

 private:
  _Sentry_base& operator=(const _Sentry_base&);
  };

 class sentry
  : public _Sentry_base
  {
 public:
  explicit sentry(_Myt& _Istr, bool _Noskip = false)
   : _Sentry_base(_Istr)
   {
   _Ok = this->_Myistr._Ipfx(_Noskip);
   }

  explicit operator bool() const
   {
   return (_Ok);
   }

                     sentry(const sentry&) = delete;
  sentry& operator=(const sentry&) = delete;

 private:
  bool _Ok;
  };

 bool _Ipfx(bool _Noskip = false)
  {
  if (this->good())
   {
   if (_Myios::tie() != 0)
    _Myios::tie()->flush();

   if (!_Noskip && this->flags() & ios_base::skipws)
    {
    const _Ctype& _Ctype_fac = use_facet< _Ctype >(this->getloc());

    try {
    int_type _Meta = _Myios::rdbuf()->sgetc();

    for (; ; _Meta = _Myios::rdbuf()->snextc())
     if (_Traits::eq_int_type(_Traits::eof(), _Meta))
      {
      _Myios::setstate(ios_base::eofbit);
      break;
      }
     else if (!_Ctype_fac.is(_Ctype::space,
      _Traits::to_char_type(_Meta)))
      break;
    } catch (...) { _Myios::setstate(ios_base::badbit, true); }
    }

   if (this->good())
    return (true);
   }
  _Myios::setstate(ios_base::failbit);
  return (false);
  }

 bool ipfx(bool _Noskip = false)
  {
  return (_Ipfx(_Noskip));
  }

 void isfx()
  {
  }
# 197 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\istream" 3
 _Myt& operator>>(_Myt& (__cdecl *_Pfn)(_Myt&))
  {
                      ;
  return ((*_Pfn)(*this));
  }

 _Myt& operator>>(_Myios& (__cdecl *_Pfn)(_Myios&))
  {
                      ;
  (*_Pfn)(*(_Myios *)this);
  return (*this);
  }

 _Myt& operator>>(ios_base& (__cdecl *_Pfn)(ios_base&))
  {
                      ;
  (*_Pfn)(*(ios_base *)this);
  return (*this);
  }

 _Myt& operator>>(bool& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

   try {
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Val);
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& operator>>(short& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   long _Tmp = 0;
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

   try {
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Tmp);
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }

   if (_State & ios_base::failbit
    || _Tmp < (-32768) || 32767 < _Tmp)
    _State |= ios_base::failbit;
   else
    _Val = (short)_Tmp;
   }

  _Myios::setstate(_State);
  return (*this);
  }
# 271 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\istream" 3
 _Myt& operator>>(unsigned short& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

   try {
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Val);
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& operator>>(int& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   long _Tmp = 0;
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

   try {
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Tmp);
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }

   if (_State & ios_base::failbit
    || _Tmp < (-2147483647 - 1) || 2147483647 < _Tmp)
    _State |= ios_base::failbit;
   else
    _Val = _Tmp;
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& operator>>(unsigned int& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);
  if (_Ok)
   {
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

   try {
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Val);
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& operator>>(long& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());
   try {
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Val);
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& operator>>(unsigned long& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

   try {
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Val);
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& operator>>(long long& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

   try {
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Val);
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& operator>>(unsigned long long& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);
  if (_Ok)
   {
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

   try {
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Val);
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& operator>>(float& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

   try {
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Val);
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& operator>>(double& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);
  if (_Ok)
   {
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

   try {
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Val);
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& operator>>(long double& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());
   try {
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Val);
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& operator>>(void *& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

   try {
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Val);
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& operator>>(_Mysb *_Strbuf)
  {
  ios_base::iostate _State = ios_base::goodbit;
  bool _Copied = false;
  const sentry _Ok(*this);

  if (_Ok && _Strbuf != 0)
   {
   try {
   int_type _Meta = _Myios::rdbuf()->sgetc();

   for (; ; _Meta = _Myios::rdbuf()->snextc())
    if (_Traits::eq_int_type(_Traits::eof(), _Meta))
     {
     _State |= ios_base::eofbit;
     break;
     }
    else
     {
     try {
      if (_Traits::eq_int_type(_Traits::eof(),
       _Strbuf->sputc(_Traits::to_char_type(_Meta))))
       break;
     } catch (...) {
      break;
     }
     _Copied = true;
     }
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(!_Copied ? _State | ios_base::failbit : _State);
  return (*this);
  }

 int_type get()
  {
  int_type _Meta = 0;
  ios_base::iostate _State = ios_base::goodbit;
  _Chcount = 0;
  const sentry _Ok(*this, true);

  if (!_Ok)
   _Meta = _Traits::eof();
  else
   {
   try {
   _Meta = _Myios::rdbuf()->sgetc();

   if (_Traits::eq_int_type(_Traits::eof(), _Meta))
    _State |= ios_base::eofbit | ios_base::failbit;
   else
    {
    _Myios::rdbuf()->sbumpc();
    ++_Chcount;
    }
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (_Meta);
  }

 _Myt& get(_Elem *_Str, streamsize _Count)
  {
  return (get(_Str, _Count, _Myios::widen('\n')));
  }

 _Myt& get(_Elem *_Str,
  streamsize _Count, _Elem _Delim)
  {
  ios_base::iostate _State = ios_base::goodbit;
  _Chcount = 0;
  const sentry _Ok(*this, true);

  if (_Ok && 0 < _Count)
   {
   try {
   int_type _Meta = _Myios::rdbuf()->sgetc();

   for (; 0 < --_Count; _Meta = _Myios::rdbuf()->snextc())
    if (_Traits::eq_int_type(_Traits::eof(), _Meta))
     {
     _State |= ios_base::eofbit;
     break;
     }
    else if (_Traits::to_char_type(_Meta) == _Delim)
     break;
    else
     {
                         ;
     *_Str++ = _Traits::to_char_type(_Meta);
     ++_Chcount;
     }
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_Chcount == 0
   ? _State | ios_base::failbit : _State);
  *_Str = _Elem();
  return (*this);
  }

 _Myt& get(_Elem& _Ch)
  {
  int_type _Meta = get();
  if (!_Traits::eq_int_type(_Traits::eof(), _Meta))
   _Ch = _Traits::to_char_type(_Meta);
  return (*this);
  }

 _Myt& get(_Mysb& _Strbuf)
  {
  return (get(_Strbuf, _Myios::widen('\n')));
  }

 _Myt& get(_Mysb& _Strbuf, _Elem _Delim)
  {
  ios_base::iostate _State = ios_base::goodbit;
  _Chcount = 0;
  const sentry _Ok(*this, true);

  if (_Ok)
   {
   try {
   int_type _Meta = _Myios::rdbuf()->sgetc();

   for (; ; _Meta = _Myios::rdbuf()->snextc())
    if (_Traits::eq_int_type(_Traits::eof(), _Meta))
     {
     _State |= ios_base::eofbit;
     break;
     }
    else
     {
     try {
      _Elem _Ch = _Traits::to_char_type(_Meta);
      if (_Ch == _Delim
       || _Traits::eq_int_type(_Traits::eof(),
        _Strbuf.sputc(_Ch)))
       break;
     } catch (...) {
      break;
     }
     ++_Chcount;
     }
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  if (_Chcount == 0)
   _State |= ios_base::failbit;
  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& getline(_Elem *_Str, streamsize _Count)
  {
  return (getline(_Str, _Count, _Myios::widen('\n')));
  }

 _Myt& getline(_Elem *_Str,
  streamsize _Count, _Elem _Delim)
  {
  ios_base::iostate _State = ios_base::goodbit;
  _Chcount = 0;
  const sentry _Ok(*this, true);

  if (_Ok && 0 < _Count)
   {
   int_type _Metadelim = _Traits::to_int_type(_Delim);

   try {
   int_type _Meta = _Myios::rdbuf()->sgetc();

   for (; ; _Meta = _Myios::rdbuf()->snextc())
    if (_Traits::eq_int_type(_Traits::eof(), _Meta))
     {
     _State |= ios_base::eofbit;
     break;
     }
    else if (_Meta == _Metadelim)
     {
     ++_Chcount;
     _Myios::rdbuf()->sbumpc();
     break;
     }
    else if (--_Count <= 0)
     {
     _State |= ios_base::failbit;
     break;
     }
    else
     {
                         ;
     *_Str++ = _Traits::to_char_type(_Meta);
     ++_Chcount;
     }
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  *_Str = _Elem();
  _Myios::setstate(_Chcount == 0 ? _State | ios_base::failbit : _State);
  return (*this);
  }

 _Myt& ignore(streamsize _Count = 1,
  int_type _Metadelim = _Traits::eof())
  {
  ios_base::iostate _State = ios_base::goodbit;
  _Chcount = 0;
  const sentry _Ok(*this, true);

  if (_Ok && 0 < _Count)
   {
   try {
   for (; ; )
    {
    int_type _Meta;
    if (_Count != (numeric_limits<streamsize>::max)()
     && --_Count < 0)
     break;
    else if (_Traits::eq_int_type(_Traits::eof(),
     _Meta = _Myios::rdbuf()->sbumpc()))
     {
     _State |= ios_base::eofbit;
     break;
     }
    else
     {
     ++_Chcount;
     if (_Meta == _Metadelim)
      break;
     }
    }
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& read(_Elem *_Str, streamsize _Count)
  {
  ios_base::iostate _State = ios_base::goodbit;
  _Chcount = 0;
  const sentry _Ok(*this, true);

  if (_Ok && 0 < _Count)
   {
   try {
                       ;
   const streamsize _Num = _Myios::rdbuf()->sgetn(_Str, _Count);
   _Chcount += _Num;
   if (_Num != _Count)
    _State |= ios_base::eofbit | ios_base::failbit;
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 streamsize readsome(_Elem *_Str,
  streamsize _Count)
  {
  ios_base::iostate _State = ios_base::goodbit;
  _Chcount = 0;
  const sentry _Ok(*this, true);
  streamsize _Num;

  if (!_Ok)
   _State |= ios_base::failbit;
  else if ((_Num = _Myios::rdbuf()->in_avail()) < 0)
   _State |= ios_base::eofbit;
  else if (0 < _Count && 0 < _Num)
   {
                       ;
   read(_Str, _Num < _Count ? _Num : _Count);
   }

  _Myios::setstate(_State);
  return (gcount());
  }

 int_type peek()
  {
  ios_base::iostate _State = ios_base::goodbit;
  _Chcount = 0;
  int_type _Meta = 0;
  const sentry _Ok(*this, true);

  if (!_Ok)
   _Meta = _Traits::eof();
  else
   {
   try {
   if (_Traits::eq_int_type(_Traits::eof(),
    _Meta = _Myios::rdbuf()->sgetc()))
    _State |= ios_base::eofbit;
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (_Meta);
  }

 _Myt& putback(_Elem _Ch)
  {
  _Chcount = 0;
  ios_base::iostate _State = ios_base::goodbit;
  ios_base::iostate _Oldstate = _Myios::rdstate();
  _Myios::clear(_Oldstate & ~ios_base::eofbit);
  const sentry _Ok(*this, true);

  if (_Ok)
   {
   try {
   if (_Traits::eq_int_type(_Traits::eof(),
    _Myios::rdbuf()->sputbackc(_Ch)))
    _State |= ios_base::badbit | _Oldstate;
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& unget()
  {
  _Chcount = 0;
  ios_base::iostate _State = ios_base::goodbit;
  ios_base::iostate _Oldstate = _Myios::rdstate();
  _Myios::clear(_Oldstate & ~ios_base::eofbit);
  const sentry _Ok(*this, true);

  if (_Ok)
   {
   try {
   if (_Traits::eq_int_type(_Traits::eof(),
    _Myios::rdbuf()->sungetc()))
    _State |= ios_base::badbit | _Oldstate;
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 streamsize gcount() const
  {
  return (_Chcount);
  }

 int sync()
  {
  const sentry _Ok(*this, true);

  if (_Myios::rdbuf() == 0)
   return (-1);
  else if (_Myios::rdbuf()->pubsync() == -1)
   {
   _Myios::setstate(ios_base::badbit);
   return (-1);
   }
  else
   return (0);
  }

 _Myt& seekg(pos_type _Pos)
  {
  ios_base::iostate _State = ios_base::goodbit;
  ios_base::iostate _Oldstate = _Myios::rdstate();
  _Myios::clear(_Oldstate & ~ios_base::eofbit);
  const sentry _Ok(*this, true);

  if (!this->fail()
   && (off_type)_Myios::rdbuf()->pubseekpos(_Pos,
    ios_base::in) == _BADOFF)
   _Myios::setstate(_State | ios_base::failbit);
  return (*this);
  }

 _Myt& seekg(off_type _Off, ios_base::seekdir _Way)
  {
  ios_base::iostate _State = ios_base::goodbit;
  ios_base::iostate _Oldstate = _Myios::rdstate();
  _Myios::clear(_Oldstate & ~ios_base::eofbit);
  const sentry _Ok(*this, true);

  if (!this->fail()
   && (off_type)_Myios::rdbuf()->pubseekoff(_Off, _Way,
    ios_base::in) == _BADOFF)
   _Myios::setstate(_State | ios_base::failbit);
  return (*this);
  }

 pos_type tellg()
  {
  const sentry _Ok(*this, true);

  if (!this->fail())
   return (_Myios::rdbuf()->pubseekoff(0,
    ios_base::cur, ios_base::in));
  else
   return (pos_type(_BADOFF));
  }

private:
 streamsize _Chcount;
 };



#pragma vtordisp(pop)
# 934 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\istream" 3
template<class _Elem,
 class _Traits>
 class basic_iostream
 : public basic_istream<_Elem, _Traits>,
  public basic_ostream<_Elem, _Traits>
 {
public:
 typedef basic_iostream<_Elem, _Traits> _Myt;
 typedef basic_istream<_Elem, _Traits> _Myis;
 typedef basic_ostream<_Elem, _Traits> _Myos;
 typedef basic_ios<_Elem, _Traits> _Myios;
 typedef _Elem char_type;
 typedef _Traits traits_type;
 typedef typename _Traits::int_type int_type;
 typedef typename _Traits::pos_type pos_type;
 typedef typename _Traits::off_type off_type;

 explicit basic_iostream(basic_streambuf<_Elem, _Traits> *_Strbuf)
  : _Myis(_Strbuf, false),
   _Myos(_Noinit, false)
  {
  }

protected:
                    basic_iostream(_Myt&& _Right)
  : _Myis(_Right.rdbuf(), false),
   _Myos(_Noinit, false)
  {
  _Myios::init();
  _Myios::move(::std:: forward<_Myt>(_Right));
  }

 _Myt& operator=(_Myt&& _Right)
  {
  this->swap(_Right);
  return (*this);
  }

 void swap(_Myt& _Right)
  {
  if (this != &_Right)
   _Myios::swap(_Right);
  }

public:
                    basic_iostream(const _Myt&) = delete;
 _Myt& operator=(const _Myt&) = delete;

 virtual ~basic_iostream() noexcept
  {
  }
 };
# 1004 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\istream" 3
template<class _Elem,
 class _Traits> inline
 basic_istream<_Elem, _Traits>& operator>>(
  basic_istream<_Elem, _Traits>& _Istr, _Elem *_Str)
 {
                     ;
 typedef basic_istream<_Elem, _Traits> _Myis;
 typedef ctype<_Elem> _Ctype;
 ios_base::iostate _State = ios_base::goodbit;
 _Elem *_Str0 = _Str;
 const typename _Myis::sentry _Ok(_Istr);

 if (_Ok)
  {
  const _Ctype& _Ctype_fac = use_facet< _Ctype >(_Istr.getloc());

  try {
  streamsize _Count = 0 < _Istr.width() ? _Istr.width()
   : (numeric_limits<streamsize>::max)();
  typename _Myis::int_type _Meta = _Istr.rdbuf()->sgetc();
  _Elem _Ch;
  for (; 0 < --_Count; _Meta = _Istr.rdbuf()->snextc())
   if (_Traits::eq_int_type(_Traits::eof(), _Meta))
    {
    _State |= ios_base::eofbit;
    break;
    }
   else if (_Ctype_fac.is(_Ctype::space,
    _Ch = _Traits::to_char_type(_Meta))
     || _Ch == _Elem())
    break;
   else
    *_Str++ = _Traits::to_char_type(_Meta);
  } catch (...) { (_Istr).setstate(ios_base::badbit, true); }
  }

 *_Str = _Elem();
 _Istr.width(0);
 _Istr.setstate(_Str == _Str0 ? _State | ios_base::failbit : _State);
 return (_Istr);
 }

template<class _Elem,
 class _Traits> inline
 basic_istream<_Elem, _Traits>& operator>>(
  basic_istream<_Elem, _Traits>& _Istr, _Elem& _Ch)
 {
 typedef basic_istream<_Elem, _Traits> _Myis;

 typename _Myis::int_type _Meta;
 ios_base::iostate _State = ios_base::goodbit;
 const typename _Myis::sentry _Ok(_Istr);

 if (_Ok)
  {
  try {
  _Meta = _Istr.rdbuf()->sbumpc();
  if (_Traits::eq_int_type(_Traits::eof(), _Meta))
   _State |= ios_base::eofbit | ios_base::failbit;
  else
   _Ch = _Traits::to_char_type(_Meta);
  } catch (...) { (_Istr).setstate(ios_base::badbit, true); }
  }

 _Istr.setstate(_State);
 return (_Istr);
 }

template<class _Traits> inline
 basic_istream<char, _Traits>& operator>>(
  basic_istream<char, _Traits>& _Istr, signed char *_Str)
 {
 return (_Istr >> (char *)_Str);
 }

template<class _Traits> inline
 basic_istream<char, _Traits>& operator>>(
  basic_istream<char, _Traits>& _Istr, signed char& _Ch)
 {
 return (_Istr >> (char&)_Ch);
 }

template<class _Traits> inline
 basic_istream<char, _Traits>& operator>>(
  basic_istream<char, _Traits>& _Istr, unsigned char *_Str)
 {
 return (_Istr >> (char *)_Str);
 }

template<class _Traits> inline
 basic_istream<char, _Traits>& operator>>(
  basic_istream<char, _Traits>& _Istr, unsigned char& _Ch)
 {
 return (_Istr >> (char&)_Ch);
 }

template<class _Elem,
 class _Traits,
 class _Ty> inline
 basic_istream<_Elem, _Traits>&
  operator>>(basic_istream<_Elem, _Traits>&& _Istr, _Ty& _Val)
 {
 return (_Istr >> _Val);
 }


template<class _Elem,
 class _Traits> inline
 basic_istream<_Elem, _Traits>&
  __cdecl ws(basic_istream<_Elem, _Traits>& _Istr)
 {
 typedef basic_istream<_Elem, _Traits> _Myis;
 typedef ctype<_Elem> _Ctype;

 if (!_Istr.eof())
  {
  ios_base::iostate _State = ios_base::goodbit;
  const typename _Myis::sentry _Ok(_Istr, true);

  if (_Ok)
   {
   const _Ctype& _Ctype_fac = use_facet< _Ctype >(_Istr.getloc());

   try {
   for (typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc(); ;
    _Meta = _Istr.rdbuf()->snextc())
    if (_Traits::eq_int_type(_Traits::eof(), _Meta))
     {
     _State |= ios_base::eofbit;
     break;
     }
    else if (!_Ctype_fac.is(_Ctype::space,
     _Traits::to_char_type(_Meta)))
     break;
   } catch (...) { (_Istr).setstate(ios_base::badbit, true); }
   }

  _Istr.setstate(_State);
  }
 return (_Istr);
 }
}


#pragma warning(pop)
#pragma pack(pop)
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\iostream" 2 3


#pragma pack(push,8)
#pragma warning(push, 3)


namespace std {
# 26 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\iostream" 3
                        extern istream cin, *_Ptr_cin;
                        extern ostream cout, *_Ptr_cout;
                        extern ostream cerr, *_Ptr_cerr;
                        extern ostream clog, *_Ptr_clog;

                        extern wistream wcin, *_Ptr_wcin;
                        extern wostream wcout, *_Ptr_wcout;
                        extern wostream wcerr, *_Ptr_wcerr;
                        extern wostream wclog, *_Ptr_wclog;


class _Winit {
public:
 __thiscall _Winit();
 __thiscall ~_Winit() noexcept;
private:
                         static int _Init_cnt;
 };

}

#pragma warning(pop)
#pragma pack(pop)
# 58 "..\\..\\..\\JUCE\\modules\\juce_core/system/juce_StandardHeader.h" 2

# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\functional" 1 3





# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xfunctional" 1 3
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xfunctional" 3
#pragma pack(push,8)
#pragma warning(push, 3)



#pragma warning(disable: 4100 4180 4244)





namespace std {
# 32 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xfunctional" 3
template<class _Ty = void>
 struct divides
 {
 typedef _Ty first_argument_type;
 typedef _Ty second_argument_type;
 typedef _Ty result_type;

 constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left / _Right);
  }
 };


template<class _Ty = void>
 struct modulus
 {
 typedef _Ty first_argument_type;
 typedef _Ty second_argument_type;
 typedef _Ty result_type;

 constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left % _Right);
  }
 };


template<class _Ty = void>
 struct negate
 {
 typedef _Ty argument_type;
 typedef _Ty result_type;

 constexpr _Ty operator()(const _Ty& _Left) const
  {
  return (-_Left);
  }
 };





template<class _Ty = void>
 struct not_equal_to
 {
 typedef _Ty first_argument_type;
 typedef _Ty second_argument_type;
 typedef bool result_type;

 constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left != _Right);
  }
 };


template<class _Ty = void>
 struct greater
 {
 typedef _Ty first_argument_type;
 typedef _Ty second_argument_type;
 typedef bool result_type;

 constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left > _Right);
  }
 };





template<class _Ty = void>
 struct greater_equal
 {
 typedef _Ty first_argument_type;
 typedef _Ty second_argument_type;
 typedef bool result_type;

 constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left >= _Right);
  }
 };


template<class _Ty = void>
 struct less_equal
 {
 typedef _Ty first_argument_type;
 typedef _Ty second_argument_type;
 typedef bool result_type;

 constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left <= _Right);
  }
 };


template<class _Ty = void>
 struct logical_and
 {
 typedef _Ty first_argument_type;
 typedef _Ty second_argument_type;
 typedef bool result_type;

 constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left && _Right);
  }
 };


template<class _Ty = void>
 struct logical_or
 {
 typedef _Ty first_argument_type;
 typedef _Ty second_argument_type;
 typedef bool result_type;

 constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left || _Right);
  }
 };


template<class _Ty = void>
 struct logical_not
 {
 typedef _Ty argument_type;
 typedef bool result_type;

 constexpr bool operator()(const _Ty& _Left) const
  {
  return (!_Left);
  }
 };


template<class _Ty = void>
 struct bit_and
 {
 typedef _Ty first_argument_type;
 typedef _Ty second_argument_type;
 typedef _Ty result_type;

 constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left & _Right);
  }
 };


template<class _Ty = void>
 struct bit_or
 {
 typedef _Ty first_argument_type;
 typedef _Ty second_argument_type;
 typedef _Ty result_type;

 constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left | _Right);
  }
 };


template<class _Ty = void>
 struct bit_xor
 {
 typedef _Ty first_argument_type;
 typedef _Ty second_argument_type;
 typedef _Ty result_type;

 constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left ^ _Right);
  }
 };


template<class _Ty = void>
 struct bit_not
 {
 typedef _Ty argument_type;
 typedef _Ty result_type;

 constexpr _Ty operator()(const _Ty& _Left) const
  {
  return (~_Left);
  }
 };
# 240 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xfunctional" 3
template<>
 struct divides<void>
 {
 typedef int is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(::std:: forward<_Ty1>(_Left) / ::std:: forward<_Ty2>(_Right))
  {
  return (::std:: forward<_Ty1>(_Left) / ::std:: forward<_Ty2>(_Right));
  }
 };


template<>
 struct modulus<void>
 {
 typedef int is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(::std:: forward<_Ty1>(_Left) % ::std:: forward<_Ty2>(_Right))
  {
  return (::std:: forward<_Ty1>(_Left) % ::std:: forward<_Ty2>(_Right));
  }
 };


template<>
 struct negate<void>
 {
 typedef int is_transparent;

 template<class _Ty>
  constexpr auto operator()(_Ty&& _Left) const
  -> decltype(-::std:: forward<_Ty>(_Left))
  {
  return (-::std:: forward<_Ty>(_Left));
  }
 };





template<>
 struct not_equal_to<void>
 {
 typedef int is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(::std:: forward<_Ty1>(_Left) != ::std:: forward<_Ty2>(_Right))
  {
  return (::std:: forward<_Ty1>(_Left) != ::std:: forward<_Ty2>(_Right));
  }
 };


template<>
 struct greater<void>
 {
 typedef int is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(::std:: forward<_Ty1>(_Left) > ::std:: forward<_Ty2>(_Right))
  {
  return (::std:: forward<_Ty1>(_Left) > ::std:: forward<_Ty2>(_Right));
  }
 };

template<class _Obj1,
 class _Obj2,
 class _FTy> inline
 _Lex_compare_check_element_types<greater<int>, _Obj1, _Obj2, _FTy>
  _Lex_compare_memcmp_classify(_Obj1 * const&, _Obj2 * const&, const greater<_FTy>&)
 {
 return {};
 }





template<>
 struct greater_equal<void>
 {
 typedef int is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(::std:: forward<_Ty1>(_Left) >= ::std:: forward<_Ty2>(_Right))
  {
  return (::std:: forward<_Ty1>(_Left) >= ::std:: forward<_Ty2>(_Right));
  }
 };


template<>
 struct less_equal<void>
 {
 typedef int is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(::std:: forward<_Ty1>(_Left) <= ::std:: forward<_Ty2>(_Right))
  {
  return (::std:: forward<_Ty1>(_Left) <= ::std:: forward<_Ty2>(_Right));
  }
 };


template<>
 struct logical_and<void>
 {
 typedef int is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(::std:: forward<_Ty1>(_Left) && ::std:: forward<_Ty2>(_Right))
  {
  return (::std:: forward<_Ty1>(_Left) && ::std:: forward<_Ty2>(_Right));
  }
 };


template<>
 struct logical_or<void>
 {
 typedef int is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(::std:: forward<_Ty1>(_Left) || ::std:: forward<_Ty2>(_Right))
  {
  return (::std:: forward<_Ty1>(_Left) || ::std:: forward<_Ty2>(_Right));
  }
 };


template<>
 struct logical_not<void>
 {
 typedef int is_transparent;

 template<class _Ty>
  constexpr auto operator()(_Ty&& _Left) const
  -> decltype(!::std:: forward<_Ty>(_Left))
  {
  return (!::std:: forward<_Ty>(_Left));
  }
 };


template<>
 struct bit_and<void>
 {
 typedef int is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(::std:: forward<_Ty1>(_Left) & ::std:: forward<_Ty2>(_Right))
  {
  return (::std:: forward<_Ty1>(_Left) & ::std:: forward<_Ty2>(_Right));
  }
 };


template<>
 struct bit_or<void>
 {
 typedef int is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(::std:: forward<_Ty1>(_Left) | ::std:: forward<_Ty2>(_Right))
  {
  return (::std:: forward<_Ty1>(_Left) | ::std:: forward<_Ty2>(_Right));
  }
 };


template<>
 struct bit_xor<void>
 {
 typedef int is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(::std:: forward<_Ty1>(_Left) ^ ::std:: forward<_Ty2>(_Right))
  {
  return (::std:: forward<_Ty1>(_Left) ^ ::std:: forward<_Ty2>(_Right));
  }
 };


template<>
 struct bit_not<void>
 {
 typedef int is_transparent;

 template<class _Ty>
  constexpr auto operator()(_Ty&& _Left) const
  -> decltype(~::std:: forward<_Ty>(_Left))
  {
  return (~::std:: forward<_Ty>(_Left));
  }
 };


template<class _Fn1>
 class unary_negate
 {
public:
 typedef typename _Fn1::argument_type argument_type;
 typedef bool result_type;

 constexpr explicit unary_negate(const _Fn1& _Func)
  : _Functor(_Func)
  {
  }

 constexpr bool operator()(const argument_type& _Left) const
  {
  return (!_Functor(_Left));
  }

private:
 _Fn1 _Functor;
 };


template<class _Fn1> inline
 constexpr unary_negate<_Fn1> not1(const _Fn1& _Func)
 {
 return (unary_negate<_Fn1>(_Func));
 }


template<class _Fn2>
 class binary_negate
 {
public:
 typedef typename _Fn2::first_argument_type first_argument_type;
 typedef typename _Fn2::second_argument_type second_argument_type;
 typedef bool result_type;

 constexpr explicit binary_negate(const _Fn2& _Func)
  : _Functor(_Func)
  {
  }

 constexpr bool operator()(const first_argument_type& _Left,
  const second_argument_type& _Right) const
  {
  return (!_Functor(_Left, _Right));
  }

private:
 _Fn2 _Functor;
 };


template<class _Fn2> inline
 constexpr binary_negate<_Fn2> not2(const _Fn2& _Func)
 {
 return (binary_negate<_Fn2>(_Func));
 }



template<class _Fn2>
 class binder1st
  : public unary_function<typename _Fn2::second_argument_type,
   typename _Fn2::result_type>
 {
public:
 typedef unary_function<typename _Fn2::second_argument_type,
  typename _Fn2::result_type> _Base;
 typedef typename _Base::argument_type argument_type;
 typedef typename _Base::result_type result_type;

 binder1st(const _Fn2& _Func,
  const typename _Fn2::first_argument_type& _Left)
  : op(_Func), value(_Left)
  {
  }

 result_type operator()(const argument_type& _Right) const
  {
  return (op(value, _Right));
  }

 result_type operator()(argument_type& _Right) const
  {
  return (op(value, _Right));
  }

protected:
 _Fn2 op;
 typename _Fn2::first_argument_type value;
 };


template<class _Fn2,
 class _Ty> inline
 binder1st<_Fn2> bind1st(const _Fn2& _Func, const _Ty& _Left)
 {
 typename _Fn2::first_argument_type _Val(_Left);
 return (binder1st<_Fn2>(_Func, _Val));
 }


template<class _Fn2>
 class binder2nd
  : public unary_function<typename _Fn2::first_argument_type,
   typename _Fn2::result_type>
 {
public:
 typedef unary_function<typename _Fn2::first_argument_type,
  typename _Fn2::result_type> _Base;
 typedef typename _Base::argument_type argument_type;
 typedef typename _Base::result_type result_type;

 binder2nd(const _Fn2& _Func,
  const typename _Fn2::second_argument_type& _Right)
  : op(_Func), value(_Right)
  {
  }

 result_type operator()(const argument_type& _Left) const
  {
  return (op(_Left, value));
  }

 result_type operator()(argument_type& _Left) const
  {
  return (op(_Left, value));
  }

protected:
 _Fn2 op;
 typename _Fn2::second_argument_type value;
 };


template<class _Fn2,
 class _Ty> inline
 binder2nd<_Fn2> bind2nd(const _Fn2& _Func, const _Ty& _Right)
 {
 typename _Fn2::second_argument_type _Val(_Right);
 return (binder2nd<_Fn2>(_Func, _Val));
 }


template<class _Arg,
 class _Result,
 class _Fn = _Result (*)(_Arg)>
 class pointer_to_unary_function
  : public unary_function<_Arg, _Result>
 {
public:
 explicit pointer_to_unary_function(_Fn _Left)
  : _Pfun(_Left)
  {
  }

 _Result operator()(_Arg _Left) const
  {
  return (_Pfun(_Left));
  }

protected:
 _Fn _Pfun;
 };


template<class _Arg1,
 class _Arg2,
 class _Result,
 class _Fn = _Result (*)(_Arg1, _Arg2)>
 class pointer_to_binary_function
  : public binary_function<_Arg1, _Arg2, _Result>
 {
public:
 explicit pointer_to_binary_function(_Fn _Left)
  : _Pfun(_Left)
  {
  }

 _Result operator()(_Arg1 _Left, _Arg2 _Right) const
  {
  return (_Pfun(_Left, _Right));
  }

protected:
 _Fn _Pfun;
 };


template<class _Arg,
 class _Result> inline
 pointer_to_unary_function<_Arg, _Result,
  _Result (__cdecl *)(_Arg)>
  ptr_fun(_Result (__cdecl *_Left)(_Arg))
 {
 return (pointer_to_unary_function<_Arg, _Result,
  _Result (__cdecl *)(_Arg)>(_Left));
 }


template<class _Arg,
 class _Result> inline
 pointer_to_unary_function<_Arg, _Result,
  _Result (__stdcall *)(_Arg)>
   ptr_fun(_Result (__stdcall *_Left)(_Arg))
 {
 return (pointer_to_unary_function<_Arg, _Result,
  _Result (__stdcall *)(_Arg)>(_Left));
 }


template<class _Arg,
 class _Result> inline
 pointer_to_unary_function<_Arg, _Result,
  _Result (__fastcall *)(_Arg)>
   ptr_fun(_Result (__fastcall *_Left)(_Arg))
 {
 return (pointer_to_unary_function<_Arg, _Result,
  _Result (__fastcall *)(_Arg)>(_Left));
 }
# 698 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xfunctional" 3
template<class _Arg1,
 class _Arg2,
 class _Result> inline
 pointer_to_binary_function<_Arg1, _Arg2, _Result,
  _Result (__cdecl *)(_Arg1, _Arg2)>
  ptr_fun(_Result (__cdecl *_Left)(_Arg1, _Arg2))
 {
 return (pointer_to_binary_function<_Arg1, _Arg2, _Result,
  _Result (__cdecl *)(_Arg1, _Arg2)>(_Left));
 }


template<class _Arg1,
 class _Arg2,
 class _Result> inline
 pointer_to_binary_function<_Arg1, _Arg2, _Result,
  _Result(__stdcall *)(_Arg1, _Arg2)>
   ptr_fun(_Result (__stdcall *_Left)(_Arg1, _Arg2))
 {
 return (pointer_to_binary_function<_Arg1, _Arg2, _Result,
  _Result (__stdcall *)(_Arg1, _Arg2)>(_Left));
 }


template<class _Arg1,
 class _Arg2,
 class _Result> inline
 pointer_to_binary_function<_Arg1, _Arg2, _Result,
  _Result(__fastcall *)(_Arg1, _Arg2)>
   ptr_fun(_Result (__fastcall *_Left)(_Arg1, _Arg2))
 {
 return (pointer_to_binary_function<_Arg1, _Arg2, _Result,
  _Result (__fastcall *)(_Arg1, _Arg2)>(_Left));
 }
# 749 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xfunctional" 3
template<class _Result,
 class _Ty>
 class mem_fun_t
  : public unary_function<_Ty *, _Result>
 {
public:
 explicit mem_fun_t(_Result (_Ty::*_Pm)())
  : _Pmemfun(_Pm)
  {
  }

 _Result operator()(_Ty *_Pleft) const
  {
  return ((_Pleft->*_Pmemfun)());
  }

private:
 _Result (_Ty::*_Pmemfun)();
 };


template<class _Result,
 class _Ty,
 class _Arg>
 class mem_fun1_t
  : public binary_function<_Ty *, _Arg, _Result>
 {
public:
 explicit mem_fun1_t(_Result (_Ty::*_Pm)(_Arg))
  : _Pmemfun(_Pm)
  {
  }

 _Result operator()(_Ty *_Pleft, _Arg _Right) const
  {
  return ((_Pleft->*_Pmemfun)(_Right));
  }

private:
 _Result (_Ty::*_Pmemfun)(_Arg);
 };


template<class _Result,
 class _Ty>
 class const_mem_fun_t
  : public unary_function<const _Ty *, _Result>
 {
public:
 explicit const_mem_fun_t(_Result (_Ty::*_Pm)() const)
  : _Pmemfun(_Pm)
  {
  }

 _Result operator()(const _Ty *_Pleft) const
  {
  return ((_Pleft->*_Pmemfun)());
  }

private:
 _Result (_Ty::*_Pmemfun)() const;
 };


template<class _Result,
 class _Ty,
 class _Arg>
 class const_mem_fun1_t
  : public binary_function<const _Ty *, _Arg, _Result>
 {
public:
 explicit const_mem_fun1_t(_Result (_Ty::*_Pm)(_Arg) const)
  : _Pmemfun(_Pm)
  {
  }

 _Result operator()(const _Ty *_Pleft, _Arg _Right) const
  {
  return ((_Pleft->*_Pmemfun)(_Right));
  }

private:
 _Result (_Ty::*_Pmemfun)(_Arg) const;
 };


template<class _Result,
 class _Ty> inline
 mem_fun_t<_Result, _Ty> mem_fun(_Result (_Ty::*_Pm)())
 {
 return (mem_fun_t<_Result, _Ty>(_Pm));
 }

template<class _Result,
 class _Ty,
 class _Arg> inline
 mem_fun1_t<_Result, _Ty, _Arg> mem_fun(_Result (_Ty::*_Pm)(_Arg))
 {
 return (mem_fun1_t<_Result, _Ty, _Arg>(_Pm));
 }

template<class _Result,
 class _Ty> inline
 const_mem_fun_t<_Result, _Ty>
  mem_fun(_Result (_Ty::*_Pm)() const)
 {
 return (const_mem_fun_t<_Result, _Ty>(_Pm));
 }

template<class _Result,
 class _Ty,
 class _Arg> inline
 const_mem_fun1_t<_Result, _Ty, _Arg>
  mem_fun(_Result (_Ty::*_Pm)(_Arg) const)
 {
 return (const_mem_fun1_t<_Result, _Ty, _Arg>(_Pm));
 }


template<class _Result,
 class _Ty>
 class mem_fun_ref_t
  : public unary_function<_Ty, _Result>
 {
public:
 explicit mem_fun_ref_t(_Result (_Ty::*_Pm)())
  : _Pmemfun(_Pm)
  {
  }

 _Result operator()(_Ty& _Left) const
  {
  return ((_Left.*_Pmemfun)());
  }

private:
 _Result (_Ty::*_Pmemfun)();
 };


template<class _Result,
 class _Ty,
 class _Arg>
 class mem_fun1_ref_t
  : public binary_function<_Ty, _Arg, _Result>
 {
public:
 explicit mem_fun1_ref_t(_Result (_Ty::*_Pm)(_Arg))
  : _Pmemfun(_Pm)
  {
  }

 _Result operator()(_Ty& _Left, _Arg _Right) const
  {
  return ((_Left.*_Pmemfun)(_Right));
  }

private:
 _Result (_Ty::*_Pmemfun)(_Arg);
 };


template<class _Result,
 class _Ty>
 class const_mem_fun_ref_t
  : public unary_function<_Ty, _Result>
 {
public:
 explicit const_mem_fun_ref_t(_Result (_Ty::*_Pm)() const)
  : _Pmemfun(_Pm)
  {
  }

 _Result operator()(const _Ty& _Left) const
  {
  return ((_Left.*_Pmemfun)());
  }

private:
 _Result (_Ty::*_Pmemfun)() const;
 };


template<class _Result,
 class _Ty,
 class _Arg>
 class const_mem_fun1_ref_t
  : public binary_function<_Ty, _Arg, _Result>
 {
public:
 explicit const_mem_fun1_ref_t(_Result (_Ty::*_Pm)(_Arg) const)
  : _Pmemfun(_Pm)
  {
  }

 _Result operator()(const _Ty& _Left, _Arg _Right) const
  {
  return ((_Left.*_Pmemfun)(_Right));
  }

private:
 _Result (_Ty::*_Pmemfun)(_Arg) const;
 };


template<class _Result,
 class _Ty> inline
 mem_fun_ref_t<_Result, _Ty> mem_fun_ref(_Result (_Ty::*_Pm)())
 {
 return (mem_fun_ref_t<_Result, _Ty>(_Pm));
 }

template<class _Result,
 class _Ty,
 class _Arg> inline
 mem_fun1_ref_t<_Result, _Ty, _Arg>
  mem_fun_ref(_Result (_Ty::*_Pm)(_Arg))
 {
 return (mem_fun1_ref_t<_Result, _Ty, _Arg>(_Pm));
 }

template<class _Result,
 class _Ty> inline
 const_mem_fun_ref_t<_Result, _Ty>
  mem_fun_ref(_Result (_Ty::*_Pm)() const)
 {
 return (const_mem_fun_ref_t<_Result, _Ty>(_Pm));
 }

template<class _Result,
 class _Ty,
 class _Arg> inline
 const_mem_fun1_ref_t<_Result, _Ty, _Arg>
  mem_fun_ref(_Result (_Ty::*_Pm)(_Arg) const)
 {
 return (const_mem_fun1_ref_t<_Result, _Ty, _Arg>(_Pm));
 }

}


#pragma warning(pop)
#pragma pack(pop)
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\functional" 2 3



# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\tuple" 1 3
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\tuple" 3
#pragma pack(push,8)
#pragma warning(push, 3)



namespace std {

template<bool _Same,
 class _Dest,
 class... _Srcs>
 struct _Tuple_implicit_val0
  : false_type
 {
 };

template<class... _Dests,
 class... _Srcs>
 struct _Tuple_implicit_val0<true, tuple<_Dests...>, _Srcs...>
  : conjunction<
   is_constructible<_Dests, _Srcs>...,
   is_convertible<_Srcs, _Dests>...
  >::type
 {
 };

template<class _Dest,
 class... _Srcs>
 struct _Tuple_implicit_val
  : _Tuple_implicit_val0<tuple_size<_Dest>::value == sizeof...(_Srcs), _Dest, _Srcs...>::type
 {
 };

template<class _Dest,
 class... _Srcs>
 using _Tuple_implicit_t = enable_if_t<_Tuple_implicit_val<_Dest, _Srcs...>::value, int>;


template<bool _Same,
 class _Dest,
 class... _Srcs>
 struct _Tuple_explicit_val0
  : false_type
 {
 };

template<class... _Dests,
 class... _Srcs>
 struct _Tuple_explicit_val0<true, tuple<_Dests...>, _Srcs...>
  : conjunction<
   is_constructible<_Dests, _Srcs>...,
   negation<conjunction<is_convertible<_Srcs, _Dests>...>>
  >::type
 {
 };

template<class _Dest,
 class... _Srcs>
 struct _Tuple_explicit_val
  : _Tuple_explicit_val0<tuple_size<_Dest>::value == sizeof...(_Srcs), _Dest, _Srcs...>::type
 {
 };

template<class _Dest,
 class... _Srcs>
 using _Tuple_explicit_t = enable_if_t<_Tuple_explicit_val<_Dest, _Srcs...>::value, int>;


template<class _Myt,
 class... _Other>
 struct _Tuple_convert_copy
 {
 typedef int type;
 };

template<class _This,
 class _Uty>
 struct _Tuple_convert_copy<tuple<_This>, _Uty>
  : enable_if<!is_same<_This, _Uty>::value
   && !is_constructible<_This, const tuple<_Uty>&>::value
   && !is_convertible<const tuple<_Uty>&, _This>::value, int>
 {
 };

template<class _Myt,
 class... _Other>
 using _Tuple_convert_copy_t = typename _Tuple_convert_copy<_Myt, _Other...>::type;


template<class _Myt,
 class... _Other>
 struct _Tuple_convert_move
 {
 typedef int type;
 };

template<class _This,
 class _Uty>
 struct _Tuple_convert_move<tuple<_This>, _Uty>
  : enable_if<!is_same<_This, _Uty>::value
   && !is_constructible<_This, tuple<_Uty> >::value
   && !is_convertible<tuple<_Uty>, _This>::value, int>
 {
 };

template<class _Myt,
 class... _Other>
 using _Tuple_convert_move_t = typename _Tuple_convert_move<_Myt, _Other...>::type;


template<class _Myt,
 class _This2,
 class... _Rest2>
 struct _Tuple_perfect_val
  : true_type
 {
 };

template<class _Myt,
 class _This2>
 struct _Tuple_perfect_val<_Myt, _This2>
  : negation<is_same<_Myt, remove_const_t<remove_reference_t<_This2>>>>::type
 {
 };


struct _Ignore
 {
 template<class _Ty>
  void operator=(const _Ty&) const
  {
  }
 };

constexpr _Ignore ignore{};


struct _Tuple_alloc_t
 {
 };

constexpr _Tuple_alloc_t _Tuple_alloc{};


template<class _Ty>
 struct _Tuple_val
 {
 constexpr _Tuple_val()
  : _Val()
  {
  }

 template<class _Other>
  constexpr _Tuple_val(_Other&& _Arg)
  : _Val(::std:: forward<_Other>(_Arg))
  {
  }

 template<class _Other>
  _Tuple_val& operator=(_Other&& _Right)
  {
  _Val = ::std:: forward<_Other>(_Right);
  return (*this);
  }

 template<class _Alloc,
  class... _Other>
  _Tuple_val(const _Alloc&,
   typename enable_if<!uses_allocator<_Ty, _Alloc>::value,
    _Tuple_alloc_t>::type, _Other&&... _Arg)
  : _Val(::std:: forward<_Other>(_Arg)...)
  {
  }

 template<class _Alloc,
  class... _Other>
  _Tuple_val(const _Alloc& _Al,
   typename enable_if<uses_allocator<_Ty, _Alloc>::value
    && is_constructible<_Ty,
     allocator_arg_t, _Alloc>::value,
    _Tuple_alloc_t>::type, _Other&&... _Arg)
  : _Val(allocator_arg, _Al, ::std:: forward<_Other>(_Arg)...)
  {
  }

 template<class _Alloc,
  class... _Other>
  _Tuple_val(const _Alloc& _Al,
   typename enable_if<uses_allocator<_Ty, _Alloc>::value
    && !is_constructible<_Ty,
     allocator_arg_t, _Alloc>::value,
    _Tuple_alloc_t>::type, _Other&&... _Arg)
  : _Val(::std:: forward<_Other>(_Arg)..., _Al)
  {
  }

 _Ty _Val;
 };


struct _Exact_args_t
 {
 };

struct _Unpack_tuple_t
 {
 };

struct _Alloc_exact_args_t
 {
 };

struct _Alloc_unpack_tuple_t
 {
 };

template<class... _Types>
 class tuple;

template<>
 class tuple<>
 {
public:
 typedef tuple<> _Myt;

 constexpr tuple() noexcept
  {
  }

 template<class _Alloc>
  tuple(allocator_arg_t, const _Alloc&) noexcept
  {
  }

 constexpr tuple(const tuple&) noexcept
  {
  }

 template<class _Alloc>
  tuple(allocator_arg_t, const _Alloc&, const _Myt&) noexcept
  {
  }

 template<class _Tag,
  enable_if_t<is_same<_Tag, _Exact_args_t>::value, int> = 0>
  constexpr tuple(_Tag) noexcept
  {
  }

 template<class _Tag,
  enable_if_t<is_same<_Tag, _Unpack_tuple_t>::value, int> = 0>
  constexpr tuple(_Tag, const _Myt&) noexcept
  {
  }

 template<class _Tag,
  class _Alloc,
  enable_if_t<is_same<_Tag, _Alloc_exact_args_t>::value, int> = 0>
  tuple(_Tag, const _Alloc&) noexcept
  {
  }

 void swap(_Myt&) noexcept
  {
  }

 constexpr bool _Equals(const _Myt&) const noexcept
  {
  return (true);
  }

 constexpr bool _Less(const _Myt&) const noexcept
  {
  return (false);
  }
 };

template<class _This,
 class... _Rest>
 class tuple<_This, _Rest...>
  : private tuple<_Rest...>
 {
public:
 typedef _This _This_type;
 typedef tuple<_This, _Rest...> _Myt;
 typedef tuple<_Rest...> _Mybase;
 static constexpr size_t _Mysize = 1 + sizeof...(_Rest);

 template<class _Tag,
  class _This2,
  class... _Rest2,
  enable_if_t<is_same<_Tag, _Exact_args_t>::value, int> = 0>
  constexpr tuple(_Tag, _This2&& _This_arg, _Rest2&&... _Rest_arg)
  : _Mybase(_Exact_args_t{}, ::std:: forward<_Rest2>(_Rest_arg)...),
   _Myfirst(::std:: forward<_This2>(_This_arg))
  {
  }
# 326 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\tuple" 3
 template<class _Tag,
  class... _Other,
  enable_if_t<is_same<_Tag, _Unpack_tuple_t>::value, int> = 0>
  constexpr tuple(_Tag, const tuple<_Other...>& _Right)
  : _Mybase(_Unpack_tuple_t{}, _Right._Get_rest()),
   _Myfirst(_Right._Myfirst._Val)
  {
  }

 template<class _Tag,
  class... _Other,
  enable_if_t<is_same<_Tag, _Unpack_tuple_t>::value, int> = 0>
  constexpr tuple(_Tag, tuple<_Other...>&& _Right)
  : _Mybase(_Unpack_tuple_t{}, (typename tuple<_Other...>::_Mybase&&) _Right),
   _Myfirst(::std:: forward<typename tuple<_Other...>::_This_type>(_Right._Myfirst._Val))
  {
  }

 template<class _Tag,
  class _Alloc,
  class _This2,
  class... _Rest2,
  enable_if_t<is_same<_Tag, _Alloc_exact_args_t>::value, int> = 0>
  tuple(_Tag, const _Alloc& _Al, _This2&& _This_arg, _Rest2&&... _Rest_arg)
  : _Mybase(_Alloc_exact_args_t{}, _Al, ::std:: forward<_Rest2>(_Rest_arg)...),
   _Myfirst(_Al, _Tuple_alloc, ::std:: forward<_This2>(_This_arg))
  {
  }

 template<class _Tag,
  class _Alloc,
  class _Tpl,
  size_t... _Indices,
  enable_if_t<is_same<_Tag, _Alloc_unpack_tuple_t>::value, int> = 0> inline
  tuple(_Tag, const _Alloc& _Al, _Tpl&& _Right, integer_sequence<size_t, _Indices...>);

 template<class _Tag,
  class _Alloc,
  class _Tpl,
  enable_if_t<is_same<_Tag, _Alloc_unpack_tuple_t>::value, int> = 0>
  tuple(_Tag, const _Alloc& _Al, _Tpl&& _Right)
  : tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: forward<_Tpl>(_Right),
   make_integer_sequence<size_t, tuple_size<remove_reference_t<_Tpl>>::value>{})
  {
  }

 template<class _This2 = _This,
  class = enable_if_t<conjunction<is_default_constructible<_This2>,
          is_default_constructible<_Rest>...>::value> >
  constexpr tuple()
  : _Mybase(), _Myfirst()
  {
  }

 template<class... _Other,
  _Tuple_implicit_t<_Myt, const _Other&...> = 0,
  _Tuple_convert_copy_t<_Myt, _Other...> = 0>
  constexpr tuple(const tuple<_Other...>& _Right)


  : _Mybase(_Unpack_tuple_t{}, _Right._Get_rest()),
   _Myfirst(_Right._Myfirst._Val)
  {
  }

 template<class... _Other,
  _Tuple_explicit_t<_Myt, const _Other&...> = 0,
  _Tuple_convert_copy_t<_Myt, _Other...> = 0>
  constexpr explicit tuple(const tuple<_Other...>& _Right)


  : _Mybase(_Unpack_tuple_t{}, _Right._Get_rest()),
   _Myfirst(_Right._Myfirst._Val)
  {
  }

 template<class _Alloc,
  class... _Other,
  _Tuple_implicit_t<_Myt, const _Other&...> = 0,
  _Tuple_convert_copy_t<_Myt, _Other...> = 0>
  tuple(allocator_arg_t, const _Alloc& _Al,
   const tuple<_Other...>& _Right)
  : tuple(_Alloc_unpack_tuple_t{}, _Al, _Right)
  {
  }

 template<class _Alloc,
  class... _Other,
  _Tuple_explicit_t<_Myt, const _Other&...> = 0,
  _Tuple_convert_copy_t<_Myt, _Other...> = 0>
  explicit tuple(allocator_arg_t, const _Alloc& _Al,
   const tuple<_Other...>& _Right)
  : tuple(_Alloc_unpack_tuple_t{}, _Al, _Right)
  {
  }

 template<class _This2 = _This,
  _Tuple_implicit_t<_Myt, const _This2&, const _Rest&...> = 0>
  constexpr tuple(const _This& _This_arg, const _Rest&... _Rest_arg)


  : _Mybase(_Exact_args_t{}, _Rest_arg...), _Myfirst(_This_arg)
  {
  }

 template<class _This2 = _This,
  _Tuple_explicit_t<_Myt, const _This2&, const _Rest&...> = 0>
  constexpr explicit tuple(const _This& _This_arg, const _Rest&... _Rest_arg)


  : _Mybase(_Exact_args_t{}, _Rest_arg...), _Myfirst(_This_arg)
  {
  }

 template<class _Alloc,
  class _This2 = _This,
  _Tuple_implicit_t<_Myt, const _This2&, const _Rest&...> = 0>
  tuple(allocator_arg_t, const _Alloc& _Al,
   const _This& _This_arg, const _Rest&... _Rest_arg)
  : tuple(_Alloc_exact_args_t{}, _Al, _This_arg, _Rest_arg...)
  {
  }

 template<class _Alloc,
  class _This2 = _This,
  _Tuple_explicit_t<_Myt, const _This2&, const _Rest&...> = 0>
  explicit tuple(allocator_arg_t, const _Alloc& _Al,
   const _This& _This_arg, const _Rest&... _Rest_arg)
  : tuple(_Alloc_exact_args_t{}, _Al, _This_arg, _Rest_arg...)
  {
  }

 template<class _This2,
  class... _Rest2,
  enable_if_t<conjunction<
   _Tuple_perfect_val<_Myt, _This2, _Rest2...>,
   _Tuple_implicit_val<_Myt, _This2, _Rest2...>
  >::value, int> = 0>
  constexpr tuple(_This2&& _This_arg, _Rest2&&... _Rest_arg)


  : _Mybase(_Exact_args_t{}, ::std:: forward<_Rest2>(_Rest_arg)...),
   _Myfirst(::std:: forward<_This2>(_This_arg))
  {
  }

 template<class _This2,
  class... _Rest2,
  enable_if_t<conjunction<
   _Tuple_perfect_val<_Myt, _This2, _Rest2...>,
   _Tuple_explicit_val<_Myt, _This2, _Rest2...>
  >::value, int> = 0>
  constexpr explicit tuple(_This2&& _This_arg, _Rest2&&... _Rest_arg)


  : _Mybase(_Exact_args_t{}, ::std:: forward<_Rest2>(_Rest_arg)...),
   _Myfirst(::std:: forward<_This2>(_This_arg))
  {
  }

 template<class _Alloc,
  class _This2,
  class... _Rest2,
  enable_if_t<conjunction<
   _Tuple_perfect_val<_Myt, _This2, _Rest2...>,
   _Tuple_implicit_val<_Myt, _This2, _Rest2...>
  >::value, int> = 0>
  tuple(allocator_arg_t, const _Alloc& _Al,
   _This2&& _This_arg, _Rest2&&... _Rest_arg)
  : tuple(_Alloc_exact_args_t{}, _Al, ::std:: forward<_This2>(_This_arg), ::std:: forward<_Rest2>(_Rest_arg)...)
  {
  }

 template<class _Alloc,
  class _This2,
  class... _Rest2,
  enable_if_t<conjunction<
   _Tuple_perfect_val<_Myt, _This2, _Rest2...>,
   _Tuple_explicit_val<_Myt, _This2, _Rest2...>
  >::value, int> = 0>
  explicit tuple(allocator_arg_t, const _Alloc& _Al,
   _This2&& _This_arg, _Rest2&&... _Rest_arg)
  : tuple(_Alloc_exact_args_t{}, _Al, ::std:: forward<_This2>(_This_arg), ::std:: forward<_Rest2>(_Rest_arg)...)
  {
  }

 template<class... _Other,
  _Tuple_implicit_t<_Myt, _Other...> = 0,
  _Tuple_convert_move_t<_Myt, _Other...> = 0>
  constexpr tuple(tuple<_Other...>&& _Right)


  : _Mybase(_Unpack_tuple_t{}, (typename tuple<_Other...>::_Mybase&&) _Right),
   _Myfirst(::std:: forward<typename tuple<_Other...>::_This_type>(_Right._Myfirst._Val))
  {
  }

 template<class... _Other,
  _Tuple_explicit_t<_Myt, _Other...> = 0,
  _Tuple_convert_move_t<_Myt, _Other...> = 0>
  constexpr explicit tuple(tuple<_Other...>&& _Right)


  : _Mybase(_Unpack_tuple_t{}, (typename tuple<_Other...>::_Mybase&&) _Right),
   _Myfirst(::std:: forward<typename tuple<_Other...>::_This_type>(_Right._Myfirst._Val))
  {
  }

 template<class _Alloc,
  class... _Other,
  _Tuple_implicit_t<_Myt, _Other...> = 0,
  _Tuple_convert_move_t<_Myt, _Other...> = 0>
  tuple(allocator_arg_t, const _Alloc& _Al,
   tuple<_Other...>&& _Right)
  : tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: move(_Right))
  {
  }

 template<class _Alloc,
  class... _Other,
  _Tuple_explicit_t<_Myt, _Other...> = 0,
  _Tuple_convert_move_t<_Myt, _Other...> = 0>
  explicit tuple(allocator_arg_t, const _Alloc& _Al,
   tuple<_Other...>&& _Right)
  : tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: move(_Right))
  {
  }

 template<class... _Other>
  _Myt& operator=(const tuple<_Other...>& _Right)
  {
  _Myfirst._Val = _Right._Myfirst._Val;
  _Get_rest() = _Right._Get_rest();
  return (*this);
  }

 template<class... _Other>
  _Myt& operator=(tuple<_Other...>&& _Right)
  {
  _Myfirst._Val = ::std:: forward<typename tuple<_Other...>::_This_type>
   (_Right._Myfirst._Val);
  _Get_rest() = ::std:: forward<typename tuple<_Other...>::_Mybase>
   (_Right._Get_rest());
  return (*this);
  }

 template<class... _Other>
  constexpr bool _Equals(const tuple<_Other...>& _Right) const
  {
  static_assert(_Mysize == sizeof...(_Other),
   "comparing tuple to object with different size");
  return (_Myfirst._Val == _Right._Myfirst._Val
   && _Mybase::_Equals(_Right._Get_rest()));
  }

 template<class... _Other>
  constexpr bool _Less(const tuple<_Other...>& _Right) const
  {
  static_assert(_Mysize == sizeof...(_Other),
   "comparing tuple to object with different size");
  return (_Myfirst._Val < _Right._Myfirst._Val
   || (!(_Right._Myfirst._Val < _Myfirst._Val)
    && _Mybase::_Less(_Right._Get_rest())));
  }

 template<class _Alloc,
  class _This2 = _This,
  class = enable_if_t<conjunction<is_default_constructible<_This2>,
          is_default_constructible<_Rest>...>::value> >
  tuple(allocator_arg_t, const _Alloc& _Al)
  : _Mybase(allocator_arg, _Al), _Myfirst(_Al, _Tuple_alloc)
  {
  }

 template<class _Alloc>
  tuple(allocator_arg_t, const _Alloc& _Al,
   const _Myt& _Right)
  : tuple(_Alloc_unpack_tuple_t{}, _Al, _Right)
  {
  }

 tuple(const _Myt&) = default;
 tuple(_Myt&&) = default;

 template<class _First,
  class _Second,
  _Tuple_implicit_t<_Myt, const _First&, const _Second&> = 0>
  constexpr tuple(const pair<_First, _Second>& _Right)


  : _Mybase(_Exact_args_t{}, _Right.second), _Myfirst(_Right.first)
  {
  }

 template<class _First,
  class _Second,
  _Tuple_explicit_t<_Myt, const _First&, const _Second&> = 0>
  constexpr explicit tuple(const pair<_First, _Second>& _Right)


  : _Mybase(_Exact_args_t{}, _Right.second), _Myfirst(_Right.first)
  {
  }

 template<class _Alloc,
  class _First,
  class _Second,
  _Tuple_implicit_t<_Myt, const _First&, const _Second&> = 0>
  tuple(allocator_arg_t, const _Alloc& _Al,
   const pair<_First, _Second>& _Right)
  : tuple(_Alloc_unpack_tuple_t{}, _Al, _Right)
  {
  }

 template<class _Alloc,
  class _First,
  class _Second,
  _Tuple_explicit_t<_Myt, const _First&, const _Second&> = 0>
  explicit tuple(allocator_arg_t, const _Alloc& _Al,
   const pair<_First, _Second>& _Right)
  : tuple(_Alloc_unpack_tuple_t{}, _Al, _Right)
  {
  }

 _Myt& operator=(const _Myt& _Right)
  {
  _Myfirst._Val = _Right._Myfirst._Val;
  _Get_rest() = _Right._Get_rest();
  return (*this);
  }

 template<class _First,
  class _Second>
  _Myt& operator=(const pair<_First, _Second>& _Right)
  {
  static_assert(_Mysize == 2,
   "assigning to tuple from object with different size");
  _Myfirst._Val = _Right.first;
  _Get_rest()._Myfirst._Val = _Right.second;
  return (*this);
  }

 template<class _Alloc>
  tuple(allocator_arg_t, const _Alloc& _Al,
   _Myt&& _Right)
  : tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: move(_Right))
  {
  }

 template<class _First,
  class _Second,
  _Tuple_implicit_t<_Myt, _First, _Second> = 0>
  constexpr tuple(pair<_First, _Second>&& _Right)


  : _Mybase(_Exact_args_t{}, ::std:: forward<_Second>(_Right.second)),
   _Myfirst(::std:: forward<_First>(_Right.first))
  {
  }

 template<class _First,
  class _Second,
  _Tuple_explicit_t<_Myt, _First, _Second> = 0>
  constexpr explicit tuple(pair<_First, _Second>&& _Right)


  : _Mybase(_Exact_args_t{}, ::std:: forward<_Second>(_Right.second)),
   _Myfirst(::std:: forward<_First>(_Right.first))
  {
  }

 template<class _Alloc,
  class _First,
  class _Second,
  _Tuple_implicit_t<_Myt, _First, _Second> = 0>
  tuple(allocator_arg_t, const _Alloc& _Al,
   pair<_First, _Second>&& _Right)
  : tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: move(_Right))
  {
  }

 template<class _Alloc,
  class _First,
  class _Second,
  _Tuple_explicit_t<_Myt, _First, _Second> = 0>
  explicit tuple(allocator_arg_t, const _Alloc& _Al,
   pair<_First, _Second>&& _Right)
  : tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: move(_Right))
  {
  }

 _Myt& operator=(_Myt&& _Right)
  noexcept(is_nothrow_move_assignable<_This>::value && is_nothrow_move_assignable<_Mybase>::value)

  {
  _Myfirst._Val = ::std:: forward<_This>(_Right._Myfirst._Val);
  _Get_rest() = ::std:: forward<_Mybase>(_Right._Get_rest());
  return (*this);
  }

 template<class _First,
  class _Second>
  _Myt& operator=(pair<_First, _Second>&& _Right)
  {
  static_assert(_Mysize == 2,
   "assigning to tuple from object with different size");
  _Myfirst._Val = ::std:: forward<_First>(_Right.first);
  _Get_rest()._Myfirst._Val = ::std:: forward<_Second>(_Right.second);
  return (*this);
  }

 _Mybase& _Get_rest() noexcept
  {
  return (*this);
  }

 constexpr const _Mybase& _Get_rest() const noexcept
  {
  return (*this);
  }

 _Tuple_val<_This> _Myfirst;

 void swap(tuple& _Right)
  noexcept((conjunction<_Is_nothrow_swappable<_This>, _Is_nothrow_swappable<_Rest>...>::value))

  {
  _Swap_adl(_Myfirst._Val, _Right._Myfirst._Val);
  _Mybase::swap(_Right._Get_rest());
  }
 };




template<class... _Types1,
 class... _Types2> inline
 constexpr bool operator==(const tuple<_Types1...>& _Left,
  const tuple<_Types2...>& _Right)
 {
 return (_Left._Equals(_Right));
 }

template<class... _Types1,
 class... _Types2> inline
 constexpr bool operator!=(const tuple<_Types1...>& _Left,
  const tuple<_Types2...>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class... _Types1,
 class... _Types2> inline
 constexpr bool operator<(const tuple<_Types1...>& _Left,
  const tuple<_Types2...>& _Right)
 {
 return (_Left._Less(_Right));
 }

template<class... _Types1,
 class... _Types2> inline
 constexpr bool operator>=(const tuple<_Types1...>& _Left,
  const tuple<_Types2...>& _Right)
 {
 return (!(_Left < _Right));
 }

template<class... _Types1,
 class... _Types2> inline
 constexpr bool operator>(const tuple<_Types1...>& _Left,
  const tuple<_Types2...>& _Right)
 {
 return (_Right < _Left);
 }

template<class... _Types1,
 class... _Types2> inline
 constexpr bool operator<=(const tuple<_Types1...>& _Left,
  const tuple<_Types2...>& _Right)
 {
 return (!(_Right < _Left));
 }

template<class... _Types,
 class = enable_if_t<conjunction<_Is_swappable<_Types>...>::value>> inline
 void swap(tuple<_Types...>& _Left,
  tuple<_Types...>& _Right)
   noexcept(noexcept(_Left.swap(_Right)))
 {
 return (_Left.swap(_Right));
 }



template<class _Ty,
 class _Tuple>
 struct _Tuple_element;

template<class _This,
 class... _Rest>
 struct _Tuple_element<_This, tuple<_This, _Rest...> >
 {
 typedef int _Check_type;
 static_assert(is_void<typename _Tuple_element<_This,
  tuple<_Rest...> >::_Check_type>::value,
  "duplicate type T in get<T>(tuple)");

 typedef _This type;
 typedef tuple<_This, _Rest...> _Ttype;
 };

template<class _Ty,
 class _This,
 class... _Rest>
 struct _Tuple_element<_Ty, tuple<_This, _Rest...> >
  : public _Tuple_element<_Ty, tuple<_Rest...> >
 {
 };

template<class _Ty>
 struct _Tuple_element<_Ty, tuple<> >
 {
 typedef void _Check_type;
 };

template<class _Ty,
 class _Tuple>
 struct _Tuple_element<_Ty, const _Tuple>
  : public _Tuple_element<_Ty, _Tuple>
 {
 typedef _Tuple_element<_Ty, _Tuple> _Mybase;
 typedef typename add_const<typename _Mybase::type>::type type;
 };

template<class _Ty,
 class _Tuple>
 struct _Tuple_element<_Ty, volatile _Tuple>
  : public _Tuple_element<_Ty, _Tuple>
 {
 typedef _Tuple_element<_Ty, _Tuple> _Mybase;
 typedef typename add_volatile<typename _Mybase::type>::type type;
 };

template<class _Ty,
 class _Tuple>
 struct _Tuple_element<_Ty, const volatile _Tuple>
  : public _Tuple_element<_Ty, _Tuple>
 {
 typedef _Tuple_element<_Ty, _Tuple> _Mybase;
 typedef typename add_cv<typename _Mybase::type>::type type;
 };


template<size_t _Index,
 class... _Types> inline
 constexpr typename tuple_element<_Index, tuple<_Types...> >::type&
  get(tuple<_Types...>& _Tuple) noexcept
 {
 typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
  _Ttype;
 return (((_Ttype&)_Tuple)._Myfirst._Val);
 }

template<size_t _Index,
 class... _Types> inline
 constexpr const typename tuple_element<_Index, tuple<_Types...> >::type&
  get(const tuple<_Types...>& _Tuple) noexcept
 {
 typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
  _Ttype;
 return (((_Ttype&)_Tuple)._Myfirst._Val);
 }

template<size_t _Index,
 class... _Types> inline
 constexpr typename tuple_element<_Index, tuple<_Types...> >::type&&
  get(tuple<_Types...>&& _Tuple) noexcept
 {
 typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
  _Ttype;
 typedef typename tuple_element<_Index, tuple<_Types...> >::type&&
  _RRtype;
 return (::std:: forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));
 }


template<class _Ty,
 class... _Types> inline
 constexpr _Ty& get(tuple<_Types...>& _Tuple) noexcept
 {
 typedef typename _Tuple_element<_Ty, tuple<_Types...> >::_Ttype _Ttype;
 return (((_Ttype&)_Tuple)._Myfirst._Val);
 }

template<class _Ty,
 class... _Types> inline
 constexpr const _Ty& get(const tuple<_Types...>& _Tuple) noexcept
 {
 typedef typename _Tuple_element<_Ty, tuple<_Types...> >::_Ttype _Ttype;
 return (((_Ttype&)_Tuple)._Myfirst._Val);
 }

template<class _Ty,
 class... _Types> inline
 constexpr _Ty&& get(tuple<_Types...>&& _Tuple) noexcept
 {
 typedef typename _Tuple_element<_Ty, tuple<_Types...> >::_Ttype _Ttype;
 return (::std:: forward<_Ty&&>(((_Ttype&)_Tuple)._Myfirst._Val));
 }
# 950 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\tuple" 3
template<class _This,
 class... _Rest>
 template<class _Tag,
  class _Alloc,
  class _Tpl,
  size_t... _Indices,
  enable_if_t<is_same<_Tag, _Alloc_unpack_tuple_t>::value, int>> inline
  tuple<_This, _Rest...>::tuple(_Tag, const _Alloc& _Al, _Tpl&& _Right, integer_sequence<size_t, _Indices...>)
  : tuple(_Alloc_exact_args_t{}, _Al, ::std:: get<_Indices>(::std:: forward<_Tpl>(_Right))...)
  {
  }


template<class... _Types> inline
 constexpr tuple<typename _Unrefwrap<_Types>::type...>
  make_tuple(_Types&&... _Args)
 {
 typedef tuple<typename _Unrefwrap<_Types>::type...> _Ttype;
 return (_Ttype(::std:: forward<_Types>(_Args)...));
 }


template<class... _Types> inline
 constexpr tuple<_Types&...>
  tie(_Types&... _Args) noexcept
 {
 typedef tuple<_Types&...> _Ttype;
 return (_Ttype(_Args...));
 }




template<class... _Types> inline
 constexpr tuple<_Types&&...>
  forward_as_tuple(_Types&&... _Args) noexcept
 {
 return (tuple<_Types&&...>(::std:: forward<_Types>(_Args)...));
 }



template<class _Seq_type1,
 class _Seq_type2>
 struct _Cat_sequences;

template<size_t... _Indexes1,
 size_t... _Indexes2>
 struct _Cat_sequences<integer_sequence<size_t, _Indexes1...>,
  integer_sequence<size_t, _Indexes2...> >
 {
 typedef integer_sequence<size_t, _Indexes1..., _Indexes2...> type;
 };


template<class _Ty,
 size_t _Size>
 class array;

template<size_t _Idx,
 class _Ty,
 size_t _Size>
 constexpr _Ty& get(array<_Ty, _Size>& _Arr) noexcept;

template<size_t _Idx,
 class _Ty,
 size_t _Size>
 constexpr const _Ty& get(const array<_Ty, _Size>& _Arr) noexcept;

template<size_t _Idx,
 class _Ty,
 size_t _Size>
 constexpr _Ty&& get(array<_Ty, _Size>&& _Arr) noexcept;


template<class _Ty,
 class... _For_array>
 struct _View_as_tuple
 {
 static_assert(_Always_false<_Ty>::value,
  "Unsupported tuple_cat arguments.");
 };

template<class... _Types>
 struct _View_as_tuple<tuple<_Types...> >
 {
 typedef tuple<_Types...> type;
 };

template<class _Ty1,
 class _Ty2>
 struct _View_as_tuple<pair<_Ty1, _Ty2> >
 {
 typedef tuple<_Ty1, _Ty2> type;
 };

template<class _Ty,
 class... _Types>
 struct _View_as_tuple<array<_Ty, 0>, _Types...>
 {
 typedef tuple<_Types...> type;
 };

template<class _Ty,
 size_t _Size,
 class... _Types>
 struct _View_as_tuple<array<_Ty, _Size>, _Types...>
  : _View_as_tuple<array<_Ty, _Size - 1>, _Ty, _Types...>
 {
 };


template<size_t _Nx,
 class _Ty>
 struct _Repeat_for
  : integral_constant<size_t, _Nx>
 {
 };


template<class _Ret,
 class _Kx_arg,
 class _Ix_arg,
 size_t _Ix_next,
 class... _Tuples>
 struct _Tuple_cat2
 {
 static_assert(sizeof...(_Tuples) == 0,
  "Unsupported tuple_cat arguments.");
 typedef _Ret type;
 typedef _Kx_arg _Kx_arg_seq;
 typedef _Ix_arg _Ix_arg_seq;
 };

template<class... _Types1,
 class _Kx_arg,
 size_t... _Ix,
 size_t _Ix_next,
 class... _Types2,
 class... _Rest>
 struct _Tuple_cat2<tuple<_Types1...>, _Kx_arg,
  integer_sequence<size_t, _Ix...>, _Ix_next,
  tuple<_Types2...>, _Rest...>
  : _Tuple_cat2<
   tuple<_Types1..., _Types2...>,
   typename _Cat_sequences<_Kx_arg,
    make_integer_sequence<size_t, sizeof...(_Types2)> >::type,
   integer_sequence<size_t, _Ix...,
    _Repeat_for<_Ix_next, _Types2>::value...>,
   _Ix_next + 1,
   _Rest...>
 {
 };

template<class... _Tuples>
 struct _Tuple_cat1
  : _Tuple_cat2<tuple<>, integer_sequence<size_t>,
    integer_sequence<size_t>, 0,
   typename _View_as_tuple<typename decay<_Tuples>::type>::type...>
 {
 };

template<class _Ret,
 size_t... _Kx,
 size_t... _Ix,
 class _Ty> inline
 constexpr _Ret _Tuple_cat(integer_sequence<size_t, _Kx...>,
  integer_sequence<size_t, _Ix...>, _Ty&& _Arg)
 {
 return (_Ret(::std:: get<_Kx>(::std:: get<_Ix>(::std:: forward<_Ty>(_Arg)))...));
 }

template<class _Ret,
 class _Ty> inline
 constexpr _Ret _Tuple_cat(integer_sequence<size_t>,
  integer_sequence<size_t>, _Ty&&)
 {
 return (_Ret());
 }

template<class... _Tuples> inline
 constexpr typename _Tuple_cat1<_Tuples...>::type
  tuple_cat(_Tuples&&... _Tpls)
 {
 typedef _Tuple_cat1<_Tuples...> _Cat1;
 return (_Tuple_cat<typename _Cat1::type>(
  typename _Cat1::_Kx_arg_seq(), typename _Cat1::_Ix_arg_seq(),
  ::std:: forward_as_tuple(::std:: forward<_Tuples>(_Tpls)...)));
 }



template<class _Tpl,
 class _Fx,
 size_t... _Indices> inline
 void _For_each_tuple_element_impl(_Tpl&& _Tuple,
  _Fx _Func, integer_sequence<size_t, _Indices...>)
 {
 int _Ignored[] = { (static_cast<void>(_Func(
  ::std:: get<_Indices>(::std:: forward<_Tpl>(_Tuple))
  )), 0)... };
 (void)_Ignored;
 }

template<class _Tpl,
 class _Fx> inline
 void _For_each_tuple_element(_Tpl&& _Tuple, _Fx _Func)
 {
 _For_each_tuple_element_impl(
  ::std:: forward<_Tpl>(_Tuple),
  _Func,
  make_integer_sequence<size_t,
   tuple_size<remove_reference_t<_Tpl>>::value>()
  );
 }



template<class _Ty1,
 class _Ty2>
 template<class _Tuple1,
  class _Tuple2,
  size_t... _Indexes1,
  size_t... _Indexes2> inline
  pair<_Ty1, _Ty2>::pair(_Tuple1& _Val1,
   _Tuple2& _Val2,
   integer_sequence<size_t, _Indexes1...>,
   integer_sequence<size_t, _Indexes2...>)
  : first(::std:: get<_Indexes1>(::std:: move(_Val1))...),
   second(::std:: get<_Indexes2>(::std:: move(_Val2))...)
  {
  (void) _Val1;
  (void) _Val2;
  }


template<class _Ty1,
 class _Ty2>
 template<class... _Types1,
  class... _Types2> inline
  pair<_Ty1, _Ty2>::pair(piecewise_construct_t,
   tuple<_Types1...> _Val1,
   tuple<_Types2...> _Val2)
  : pair(_Val1, _Val2,
   make_integer_sequence<size_t, sizeof...(_Types1)>(),
   make_integer_sequence<size_t, sizeof...(_Types2)>())
  {
  }

}

namespace std {

template<class... _Types,
 class _Alloc>
 struct uses_allocator<tuple<_Types...>, _Alloc>
  : true_type
 {
 };

}


namespace std {
namespace tr1 {
using ::std:: get;
using ::std:: ignore;
using ::std:: make_tuple;
using ::std:: ref;
using ::std:: tie;
using ::std:: tuple;
}
}



#pragma warning(pop)
#pragma pack(pop)
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\functional" 2 3


#pragma pack(push,8)
#pragma warning(push, 3)



namespace std {

template<class _Memptr>
 class _Mem_fn
  : public _Weak_types<_Memptr>::type
 {
private:
 _Memptr _Pm;

public:
 explicit _Mem_fn(_Memptr _Val) noexcept
  : _Pm(_Val)
  {
  }

 template<class... _Types>
  auto operator()(_Types&&... _Args) const
  -> decltype(::std:: invoke(_Pm, ::std:: forward<_Types>(_Args)...))
  {
  return (::std:: invoke(_Pm, ::std:: forward<_Types>(_Args)...));
  }
 };

template<class _Rx,
 class _Ty> inline
 _Mem_fn<_Rx _Ty::*> mem_fn(_Rx _Ty::* _Pm) noexcept
 {
 return (_Mem_fn<_Rx _Ty::*>(_Pm));
 }




class bad_function_call
 : public ::std:: exception
 {
public:
 bad_function_call() noexcept
  {
  }

 virtual const char * what() const noexcept
  {
  return ("bad function call");
  }
 };

[[noreturn]] void __cdecl _Xbad_function_call();


template<class _Fty>
 class function;

template<class _Ty> inline
 bool _Test_callable(const _Ty& _Arg, true_type) noexcept
 {
 return (!!_Arg);
 }

template<class _Ty> inline
 bool _Test_callable(const _Ty&, false_type) noexcept
 {
 return (true);
 }

template<class _Ty> inline
 bool _Test_callable(const _Ty& _Arg) noexcept
 {
 _Cat_base<is_member_pointer<_Ty>::value || (is_pointer<_Ty>::value
  && is_function<typename remove_pointer<_Ty>::type>::value)> _Testable;
 return (_Test_callable(_Arg, _Testable));
 }

template<class _Fty> inline
 bool _Test_callable(const function<_Fty>& _Arg) noexcept
 {
 return (!!_Arg);
 }


#pragma warning(push)
#pragma warning(disable: 4265)
template<class _Rx,
 class... _Types>
 class _Func_base
 {
public:
 typedef _Func_base<_Rx, _Types...> _Myt;

 virtual _Myt *_Copy(void *) const = 0;
 virtual _Myt *_Move(void *) = 0;
 virtual _Rx _Do_call(_Types&&...) = 0;
 virtual const type_info& _Target_type() const noexcept = 0;
 virtual void _Delete_this(bool) noexcept = 0;

 const void *_Target(const type_info& _Info) const noexcept
  {
  return (_Target_type() == _Info ? _Get() : 0);
  }

 _Func_base(const _Myt&) = delete;
 _Myt& operator=(const _Myt&) = delete;

 _Func_base() = default;

 ~_Func_base() noexcept
  {
  }

private:
 virtual const void *_Get() const noexcept = 0;
 };
#pragma warning(pop)


const int _Num_ptrs = 6 + 16 / sizeof (void *);

const size_t _Space_size = (_Num_ptrs - 1) * sizeof (void *);

template<class _Impl>
 struct _Is_large
  : bool_constant<_Space_size < sizeof (_Impl)
   || !_Impl::_Nothrow_move::value>
 {
 };


#pragma warning(push)
#pragma warning(disable: 4265)
template<class _Callable,
 class _Alloc,
 class _Rx,
 class... _Types>
 class _Func_impl final
  : public _Func_base<_Rx, _Types...>
 {
public:
 typedef _Func_impl<_Callable, _Alloc, _Rx, _Types...> _Myt;
 typedef _Func_base<_Rx, _Types...> _Mybase;
 typedef _Wrap_alloc<_Alloc> _Myalty0;
 typedef typename _Myalty0::template rebind<_Myt>::other _Myalty;
 typedef is_nothrow_move_constructible<_Callable> _Nothrow_move;

 template<class _Other1,
  class _Other2>
  _Func_impl(_Other1&& _Val, _Other2&& _Ax)
  : _Mypair(_One_then_variadic_args_t(),
   ::std:: forward<_Other2>(_Ax), ::std:: forward<_Other1>(_Val))
  {
  }

 ~_Func_impl() noexcept
  {
  }

private:
 virtual _Mybase *_Copy(void *_Where) const
  {
  return (_Clone(_Where, _Is_large<_Myt>()));
  }

 template<class _Void>
  _Mybase *_Clone(_Void *, true_type) const
  {
  _Myalty _Al(_Myax());
  _Myt * _Ptr = _Al.allocate(1);

  try {
   _Al.construct(_Ptr, _Callee(), _Myax());
  } catch (...) {
   _Al.deallocate(_Ptr, 1);
  throw;
  }

  return (_Ptr);
  }

 template<class _Void>
  _Mybase *_Clone(_Void *_Where, false_type) const
  {
  _Myalty _Al(_Myax());
  _Myt * _Ptr = static_cast<_Myt *>(_Where);
  _Al.construct(_Ptr, _Callee(), _Myax());
  return (_Ptr);
  }

 virtual _Mybase *_Move(void *_Where)
  {
  _Myalty _Al(_Myax());
  _Myt *_Ptr = static_cast<_Myt *>(_Where);
  _Al.construct(_Ptr, ::std:: move(_Callee()), ::std:: move(_Myax()));
  return (_Ptr);
  }

 virtual _Rx _Do_call(_Types&&... _Args)
  {
  return (_Invoke_ret(_Forced<_Rx>(), _Callee(),
   ::std:: forward<_Types>(_Args)...));
  }

 virtual const type_info& _Target_type() const noexcept
  {
  return (typeid(_Callable));
  }

 virtual const void *_Get() const noexcept
  {
  return (::std:: addressof(_Callee()));
  }

 virtual void _Delete_this(bool _Deallocate) noexcept
  {
  _Myalty _Al(_Myax());
  _Al.destroy(this);
  if (_Deallocate)
   _Al.deallocate(this, 1);
  }

 _Compressed_pair<_Alloc, _Callable> _Mypair;

 _Alloc& _Myax() noexcept
  {
  return (_Mypair._Get_first());
  }

 const _Alloc& _Myax() const noexcept
  {
  return (_Mypair._Get_first());
  }

 _Callable& _Callee() noexcept
  {
  return (_Mypair._Get_second());
  }

 const _Callable& _Callee() const noexcept
  {
  return (_Mypair._Get_second());
  }
 };
#pragma warning(pop)


template<class _Ret,
 class... _Types>
 class _Func_class
  : public _Arg_types<_Types...>
 {
public:
 typedef _Ret result_type;

 typedef _Func_class<_Ret, _Types...> _Myt;
 typedef _Func_base<_Ret, _Types...> _Ptrt;

 _Func_class() noexcept
  {
  _Set(0);
  }

 _Ret operator()(_Types... _Args) const
  {
  if (_Empty())
   _Xbad_function_call();
  return (_Getimpl()->_Do_call(::std:: forward<_Types>(_Args)...));
  }

 ~_Func_class() noexcept
  {
  _Tidy();
  }

protected:
 template<class _Fx>
  using _Result_of_invoking_t = result_of_t<_Fx(_Types...)>;

 template<class _Inv_res>
  using _Enable_if_returnable_t = enable_if_t<
   is_convertible<_Inv_res, _Ret>::value || is_void<_Ret>::value>;

 bool _Empty() const noexcept
  {
  return (_Getimpl() == 0);
  }

 void _Reset_copy(const _Myt& _Right)
  {
  if (_Right._Empty())
   ;
  else
   _Set(_Right._Getimpl()->_Copy(_Getspace()));
  }

 void _Reset_move(_Myt&& _Right)
  {
  if (_Right._Empty())
   ;
  else if (_Right._Local())
   {
   _Set(_Right._Getimpl()->_Move(_Getspace()));
   _Right._Tidy();
   }
  else
   {
   _Set(_Right._Getimpl());
   _Right._Set(0);
   }
  }

 template<class _Fx>
  void _Reset(_Fx&& _Val)
  {
  _Reset_alloc(::std:: forward<_Fx>(_Val), allocator<int>());
  }

 template<class _Fx,
  class _Alloc>
  void _Reset_alloc(_Fx&& _Val, const _Alloc& _Ax)
  {
  if (!_Test_callable(_Val))
   {
   return;
   }

  typedef typename decay<_Fx>::type _Decayed;
  typedef _Func_impl<_Decayed, _Alloc, _Ret, _Types...> _Myimpl;
  _Myimpl *_Ptr = 0;

  typedef _Wrap_alloc<_Alloc> _Alimpl0;
  typedef typename _Alimpl0::template rebind<_Myimpl>::other _Alimpl;
  _Alimpl _Al(_Ax);

  _Reset_impl(::std:: forward<_Fx>(_Val), _Ax,
   _Ptr, _Al, _Is_large<_Myimpl>());
  }

 template<class _Fx,
  class _Alloc,
  class _Myimpl,
  class _Alimpl>
  void _Reset_impl(_Fx&& _Val, const _Alloc& _Ax,
   _Myimpl *, _Alimpl& _Al, true_type)
  {
  _Myimpl *_Ptr = _Al.allocate(1);

  try {
   _Al.construct(_Ptr, ::std:: forward<_Fx>(_Val), _Ax);
  } catch (...) {
   _Al.deallocate(_Ptr, 1);
  throw;
  }

  _Set(_Ptr);
  }

 template<class _Fx,
  class _Alloc,
  class _Myimpl,
  class _Alimpl>
  void _Reset_impl(_Fx&& _Val, const _Alloc& _Ax,
   _Myimpl *, _Alimpl& _Al, false_type)
  {
  _Myimpl *_Ptr = static_cast<_Myimpl *>(_Getspace());
  _Al.construct(_Ptr, ::std:: forward<_Fx>(_Val), _Ax);
  _Set(_Ptr);
  }

 void _Tidy() noexcept
  {
  if (!_Empty())
   {
   _Getimpl()->_Delete_this(!_Local());
   _Set(0);
   }
  }

 void _Swap(_Myt& _Right) noexcept
  {
  if (!_Local() && !_Right._Local())
   {
   _Ptrt *_Temp = _Getimpl();
   _Set(_Right._Getimpl());
   _Right._Set(_Temp);
   }
  else
   {
   _Myt _Temp;
   _Temp._Reset_move(::std:: move(*this));
   _Reset_move(::std:: move(_Right));
   _Right._Reset_move(::std:: move(_Temp));
   }
  }

 const type_info& _Target_type() const noexcept
  {
  return (_Getimpl() ? _Getimpl()->_Target_type() : typeid(void));
  }

 const void *_Target(const type_info& _Info) const noexcept
  {
  return (_Getimpl() ? _Getimpl()->_Target(_Info) : 0);
  }

private:
 bool _Local() const noexcept
  {
  return (_Getimpl() == _Getspace());
  }

 union _Storage
  {
  max_align_t _Dummy1;
  char _Dummy2[_Space_size];
  _Ptrt *_Ptrs[_Num_ptrs];
  };

 _Storage _Mystorage;
 enum {_EEN_IMPL = _Num_ptrs - 1};
 _Ptrt *_Getimpl() const noexcept
  {
  return (_Mystorage._Ptrs[_Num_ptrs - 1]);
  }

 void _Set(_Ptrt *_Ptr) noexcept
  {
  _Mystorage._Ptrs[_Num_ptrs - 1] = _Ptr;
  }

 void *_Getspace() noexcept
  {
  return (&_Mystorage);
  }

 const void *_Getspace() const noexcept
  {
  return (&_Mystorage);
  }
 };


template<class _Tx>
 struct _Get_function_impl;
# 466 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\functional" 3
template<class _Ret, class... _Types> struct _Get_function_impl<_Ret __cdecl (_Types...)> { typedef _Func_class<_Ret, _Types...> type; }; template<class _Ret, class... _Types> struct _Get_function_impl<_Ret __fastcall (_Types...)> { typedef _Func_class<_Ret, _Types...> type; }; template<class _Ret, class... _Types> struct _Get_function_impl<_Ret __stdcall (_Types...)> { typedef _Func_class<_Ret, _Types...> type; }; template<class _Ret, class... _Types> struct _Get_function_impl<_Ret __vectorcall (_Types...)> { typedef _Func_class<_Ret, _Types...> type; };



template<class _Fty>
 class function
  : public _Get_function_impl<_Fty>::type
 {
private:
 typedef typename _Get_function_impl<_Fty>::type _Mybase;

public:
 typedef function<_Fty> _Myt;

 function() noexcept
  {
  }

 function(nullptr_t) noexcept
  {
  }

 function(const _Myt& _Right)
  {
  this->_Reset_copy(_Right);
  }

 template<class _Fx,
  class _Inv_res = typename _Mybase::template _Result_of_invoking_t<_Fx&>,
  class = typename _Mybase::template _Enable_if_returnable_t<_Inv_res> >
  function(_Fx _Func)
  {
  this->_Reset(::std:: move(_Func));
  }

 template<class _Alloc>
  function(allocator_arg_t, const _Alloc&) noexcept
  {
  }

 template<class _Alloc>
  function(allocator_arg_t, const _Alloc&, nullptr_t) noexcept
  {
  }

 template<class _Alloc>
  function(allocator_arg_t, const _Alloc& _Ax, const _Myt& _Right)
  {
  this->_Reset_alloc(_Right, _Ax);
  }

 template<class _Fx,
  class _Alloc,
  class _Inv_res = typename _Mybase::template _Result_of_invoking_t<_Fx&>,
  class = typename _Mybase::template _Enable_if_returnable_t<_Inv_res> >
  function(allocator_arg_t, const _Alloc& _Ax, _Fx _Func)
  {
  this->_Reset_alloc(::std:: move(_Func), _Ax);
  }

 ~function() noexcept
  {
  }

 _Myt& operator=(const _Myt& _Right)
  {
  _Myt(_Right).swap(*this);
  return (*this);
  }

 function(_Myt&& _Right)
  {
  this->_Reset_move(::std:: move(_Right));
  }

 template<class _Alloc>
  function(allocator_arg_t, const _Alloc& _Al, _Myt&& _Right)
  {
  this->_Reset_alloc(::std:: move(_Right), _Al);
  }

 _Myt& operator=(_Myt&& _Right)
  {
  if (this != &_Right)
   {
   this->_Tidy();
   this->_Reset_move(::std:: move(_Right));
   }
  return (*this);
  }

 template<class _Fx,
  class _Inv_res = typename _Mybase::template _Result_of_invoking_t<decay_t<_Fx>&>,
  class = typename _Mybase::template _Enable_if_returnable_t<_Inv_res> >
  _Myt& operator=(_Fx&& _Func)
  {
  _Myt(::std:: forward<_Fx>(_Func)).swap(*this);
  return (*this);
  }


 template<class _Fx,
  class _Alloc>
  void assign(_Fx&& _Func, const _Alloc& _Ax)
  {
  _Myt(allocator_arg, _Ax, ::std:: forward<_Fx>(_Func)).swap(*this);
  }


 _Myt& operator=(nullptr_t) noexcept
  {
  this->_Tidy();
  return (*this);
  }

 template<class _Fx>
  _Myt& operator=(reference_wrapper<_Fx> _Func) noexcept
  {
  this->_Tidy();
  this->_Reset(_Func);
  return (*this);
  }

 void swap(_Myt& _Right) noexcept
  {
  this->_Swap(_Right);
  }

 explicit operator bool() const noexcept
  {
  return (!this->_Empty());
  }

 const type_info& target_type() const noexcept
  {
  return (this->_Target_type());
  }

 template<class _Fx>
  _Fx *target() noexcept
  {
  return (static_cast<_Fx *>(const_cast<void *>(
   this->_Target(typeid(_Fx)))));
  }

 template<class _Fx>
  const _Fx *target() const noexcept
  {
  return (static_cast<const _Fx *>(this->_Target(typeid(_Fx))));
  }
 };


template<class _Fty> inline
 void swap(function<_Fty>& _Left, function<_Fty>& _Right) noexcept
 {
 _Left.swap(_Right);
 }


template<class _Fty> inline
 bool operator==(const function<_Fty>& _Other,
  nullptr_t) noexcept
 {
 return (!_Other);
 }

template<class _Fty> inline
 bool operator==(nullptr_t,
  const function<_Fty>& _Other) noexcept
 {
 return (!_Other);
 }

template<class _Fty> inline
 bool operator!=(const function<_Fty>& _Other,
  nullptr_t) noexcept
 {
 return (static_cast<bool>(_Other));
 }

template<class _Fty> inline
 bool operator!=(nullptr_t,
  const function<_Fty>& _Other) noexcept
 {
 return (static_cast<bool>(_Other));
 }



template<int _Nx>
 struct _Ph
 {
 };

template<class _Tx>
 struct is_placeholder
  : integral_constant<int, 0>
 {
 };

template<int _Nx>
 struct is_placeholder<_Ph<_Nx> >
  : integral_constant<int, _Nx>
 {
 };

template<class _Tx>
 struct is_placeholder<const _Tx>
  : is_placeholder<_Tx>
 {
 };

template<class _Tx>
 struct is_placeholder<volatile _Tx>
  : is_placeholder<_Tx>
 {
 };

template<class _Tx>
 struct is_placeholder<const volatile _Tx>
  : is_placeholder<_Tx>
 {
 };


template<class _Ty>
 constexpr int is_placeholder_v = is_placeholder<_Ty>::value;



template<class _Ret,
 class _Fx,
 class... _Types>
 class _Binder;


template<class _Tx>
 struct is_bind_expression
  : false_type
 {
 };

template<class _Ret,
 class _Fx,
 class... _Types>
 struct is_bind_expression<_Binder<_Ret, _Fx, _Types...> >
  : true_type
 {
 };

template<class _Tx>
 struct is_bind_expression<const _Tx>
  : is_bind_expression<_Tx>
 {
 };

template<class _Tx>
 struct is_bind_expression<volatile _Tx>
  : is_bind_expression<_Tx>
 {
 };

template<class _Tx>
 struct is_bind_expression<const volatile _Tx>
  : is_bind_expression<_Tx>
 {
 };


template<class _Ty>
 constexpr bool is_bind_expression_v = is_bind_expression<_Ty>::value;



template<class _Cv_TiD,
 bool = _Unrefwrap<_Cv_TiD>::_Is_refwrap,
 bool = is_bind_expression<_Cv_TiD>::value,
 int = is_placeholder<_Cv_TiD>::value>
 struct _Select_fixer;

template<class _Cv_TiD>
 struct _Select_fixer<_Cv_TiD, true, false, 0>
 {
 template<class _Untuple>
  static auto _Fix(_Cv_TiD& _Tid, _Untuple&&)
  -> typename _Cv_TiD::type&
  {
  return (_Tid.get());
  }
 };

template<class _Cv_TiD>
 struct _Select_fixer<_Cv_TiD, false, true, 0>
 {
 template<class _Untuple,
  size_t... _Jx>
  static auto _Apply(_Cv_TiD& _Tid, _Untuple&& _Ut,
   integer_sequence<size_t, _Jx...>)
  -> decltype(_Tid(::std:: get<_Jx>(::std:: move(_Ut))...))
  {
  return (_Tid(::std:: get<_Jx>(::std:: move(_Ut))...));
  }

 template<class _Untuple>
  static auto _Fix(_Cv_TiD& _Tid, _Untuple&& _Ut)
  -> decltype(_Apply(_Tid, ::std:: move(_Ut),
   make_integer_sequence<size_t, tuple_size<_Untuple>::value>()))
  {
  return (_Apply(_Tid, ::std:: move(_Ut),
   make_integer_sequence<size_t, tuple_size<_Untuple>::value>()));
  }
 };

template<class _Cv_TiD>
 struct _Select_fixer<_Cv_TiD, false, false, 0>
 {
 template<class _Untuple>
  static _Cv_TiD& _Fix(_Cv_TiD& _Tid, _Untuple&&)
  {
  return (_Tid);
  }
 };

template<class _Cv_TiD,
 int _Jx>
 struct _Select_fixer<_Cv_TiD, false, false, _Jx>
 {
 static_assert(_Jx > 0, "invalid is_placeholder value");

 template<class _Untuple>
  static auto _Fix(_Cv_TiD&, _Untuple&& _Ut)
  -> decltype(::std:: get<_Jx - 1>(::std:: move(_Ut)))
  {
  return (::std:: get<_Jx - 1>(::std:: move(_Ut)));
  }
 };

template<class _Cv_TiD,
 class _Untuple> inline
 auto _Fix_arg(_Cv_TiD& _Tid, _Untuple&& _Ut)
 -> decltype(_Select_fixer<_Cv_TiD>::_Fix(_Tid, ::std:: move(_Ut)))
 {
 return (_Select_fixer<_Cv_TiD>::_Fix(_Tid, ::std:: move(_Ut)));
 }


template<class _Ret,
 size_t... _Ix,
 class _Cv_FD,
 class _Cv_tuple_TiD,
 class _Untuple> inline
 auto _Call_binder(_Forced<_Ret> _Fr, integer_sequence<size_t, _Ix...>,
  _Cv_FD& _Obj, _Cv_tuple_TiD& _Tpl, _Untuple&& _Ut)
 -> decltype(_Invoke_ret(_Fr, _Obj, _Fix_arg(
  ::std:: get<_Ix>(_Tpl), ::std:: move(_Ut))...))
 {
 (void) _Tpl;
 (void) _Ut;
 return (_Invoke_ret(_Fr, _Obj, _Fix_arg(
  ::std:: get<_Ix>(_Tpl), ::std:: move(_Ut))...));
 }


template<class _Ret>
 struct _Forced_result_type
 {
 typedef _Ret result_type;
 };

template<class _Ret,
 class _Fx>
 struct _Binder_result_type
 {
 typedef typename decay<_Fx>::type _Decayed;

 typedef typename _Weak_types<_Decayed>::type _All_weak_types;

 typedef typename _If<is_same<_Ret, _Unforced>::value,
  _Weak_result_type<_All_weak_types>,
  _Forced_result_type<_Ret> >::type type;
 };

template<class _Ret,
 class _Fx,
 class... _Types>
 class _Binder
  : public _Binder_result_type<_Ret, _Fx>::type
 {
private:
 typedef make_integer_sequence<size_t, sizeof...(_Types)> _Seq;
 typedef typename decay<_Fx>::type _First;
 typedef tuple<typename decay<_Types>::type...> _Second;

 _Compressed_pair<_First, _Second> _Mypair;

public:
 explicit _Binder(_Fx&& _Func, _Types&&... _Args)
  : _Mypair(_One_then_variadic_args_t(),
   ::std:: forward<_Fx>(_Func), ::std:: forward<_Types>(_Args)...)
  {
  }
# 881 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\functional" 3
template<class... _Unbound> auto operator()(_Unbound&&... _Unbargs) -> decltype(_Call_binder(_Forced<_Ret>(), _Seq(), _Mypair._Get_first(), _Mypair._Get_second(), ::std:: forward_as_tuple(::std:: forward<_Unbound>(_Unbargs)...))) { return (_Call_binder(_Forced<_Ret>(), _Seq(), _Mypair._Get_first(), _Mypair._Get_second(), ::std:: forward_as_tuple(::std:: forward<_Unbound>(_Unbargs)...))); } template<class... _Unbound> auto operator()(_Unbound&&... _Unbargs) const -> decltype(_Call_binder(_Forced<_Ret>(), _Seq(), _Mypair._Get_first(), _Mypair._Get_second(), ::std:: forward_as_tuple(::std:: forward<_Unbound>(_Unbargs)...))) { return (_Call_binder(_Forced<_Ret>(), _Seq(), _Mypair._Get_first(), _Mypair._Get_second(), ::std:: forward_as_tuple(::std:: forward<_Unbound>(_Unbargs)...))); }

 };


template<class _Fx,
 class... _Types> inline
 _Binder<_Unforced, _Fx, _Types...> bind(_Fx&& _Func, _Types&&... _Args)
 {
 return (_Binder<_Unforced, _Fx, _Types...>(
  ::std:: forward<_Fx>(_Func), ::std:: forward<_Types>(_Args)...));
 }


template<class _Ret,
 class _Fx,
 class... _Types> inline
 _Binder<_Ret, _Fx, _Types...> bind(_Fx&& _Func, _Types&&... _Args)
 {
 return (_Binder<_Ret, _Fx, _Types...>(
  ::std:: forward<_Fx>(_Func), ::std:: forward<_Types>(_Args)...));
 }


  namespace placeholders {
constexpr _Ph<1> _1{};
constexpr _Ph<2> _2{};
constexpr _Ph<3> _3{};
constexpr _Ph<4> _4{};
constexpr _Ph<5> _5{};
constexpr _Ph<6> _6{};
constexpr _Ph<7> _7{};
constexpr _Ph<8> _8{};
constexpr _Ph<9> _9{};
constexpr _Ph<10> _10{};
constexpr _Ph<11> _11{};
constexpr _Ph<12> _12{};
constexpr _Ph<13> _13{};
constexpr _Ph<14> _14{};
constexpr _Ph<15> _15{};
constexpr _Ph<16> _16{};
constexpr _Ph<17> _17{};
constexpr _Ph<18> _18{};
constexpr _Ph<19> _19{};
constexpr _Ph<20> _20{};
  }


namespace tr1 {
using ::std:: bad_function_call;
using ::std:: bind;
using ::std:: function;
using ::std:: is_bind_expression;
using ::std:: is_placeholder;
using ::std:: mem_fn;
using ::std:: swap;

namespace placeholders {
 using namespace ::std:: placeholders;
 }
}

}

namespace std {

template<class _Fty,
 class _Alloc>
 struct uses_allocator<function<_Fty>, _Alloc>
  : true_type
 {
 };
}

#pragma warning(pop)
#pragma pack(pop)
# 59 "..\\..\\..\\JUCE\\modules\\juce_core/system/juce_StandardHeader.h" 2

# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm" 1 3







#pragma pack(push,8)
#pragma warning(push, 3)


#pragma warning(disable: 4244 28309 28285)

namespace std {

const int _ISORT_MAX = 32;

template<class _Iter1,
 class _Iter2,
 class _UIter1,
 class _UIter2> inline
 pair<_Iter1, _Iter2>
  _Rechecked_both(_Iter1 _Dest1, _Iter2 _Dest2, pair<_UIter1, _UIter2> _Src)
 {
 return (pair<_Iter1, _Iter2>(
  _Rechecked(_Dest1, _Src.first),
  _Rechecked(_Dest2, _Src.second)
  ));
 }
# 64 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm" 3
template<class _InIt,
 class _Fn1> inline
 void _For_each_unchecked(_InIt _First, _InIt _Last, _Fn1& _Func)
 {
 for (; _First != _Last; ++_First)
  _Func(*_First);
 }

template<class _InIt,
 class _Fn1> inline
 _Fn1 for_each(_InIt _First, _InIt _Last, _Fn1 _Func)
 {
                                       ;
 _For_each_unchecked(_Unchecked(_First), _Unchecked(_Last), _Func);
 return (_Func);
 }


template<class _InIt,
 class _Pr> inline
 _InIt _Find_if_unchecked(_InIt _First, _InIt _Last, _Pr& _Pred)
 {
 for (; _First != _Last; ++_First)
  if (_Pred(*_First))
   break;
 return (_First);
 }

template<class _InIt,
 class _Pr> inline
 _InIt find_if(_InIt _First, _InIt _Last, _Pr _Pred)
 {
                                       ;
 return (_Rechecked(_First,
  _Find_if_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred)));
 }


template<class _FwdIt,
 class _Pr> inline
 _FwdIt _Adjacent_find_unchecked(_FwdIt _First, _FwdIt _Last, _Pr& _Pred)
 {
 if (_First != _Last)
  for (_FwdIt _Firstb; (void)(_Firstb = _First), ++_First != _Last; )
   if (_Pred(*_Firstb, *_First))
    return (_Firstb);
 return (_Last);
 }

template<class _FwdIt,
 class _Pr> inline
 _FwdIt adjacent_find(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
 {
                            ;
                                                                        ;
 return (_Rechecked(_First,
  _Adjacent_find_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred)));
 }


template<class _FwdIt> inline
 _FwdIt adjacent_find(_FwdIt _First, _FwdIt _Last)
 {
 return (::std:: adjacent_find(_First, _Last, equal_to<>()));
 }


template<class _InIt,
 class _Pr> inline
 typename iterator_traits<_InIt>::difference_type
  _Count_if_unchecked(_InIt _First, _InIt _Last, _Pr& _Pred)
 {
 typename iterator_traits<_InIt>::difference_type _Count = 0;

 for (; _First != _Last; ++_First)
  if (_Pred(*_First))
   ++_Count;
 return (_Count);
 }

template<class _InIt,
 class _Pr> inline
 typename iterator_traits<_InIt>::difference_type
  count_if(_InIt _First, _InIt _Last, _Pr _Pred)
 {
                                       ;
 return (_Count_if_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred));
 }


template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 pair<_InIt1, _InIt2>
  _Mismatch_unchecked(_InIt1 _First1, _InIt1 _Last1,
   _InIt2 _First2, _Pr& _Pred)
 {
 for (; _First1 != _Last1 && _Pred(*_First1, *_First2); )
  {
  ++_First1;
  ++_First2;
  }

 return (pair<_InIt1, _InIt2>(_First1, _First2));
 }

template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 auto _Mismatch_no_deprecate1(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _Pr& _Pred, input_iterator_tag, input_iterator_tag)
   -> pair<_InIt1, decltype(_Unchecked_idl0(_First2))>
 {
 return (_Mismatch_unchecked(_First1, _Last1,
  _Unchecked_idl0(_First2), _Pred));
 }

template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 pair<_InIt1, decltype(_Unchecked(::std:: declval<_InIt2>()))>
  _Mismatch_no_deprecate1(_InIt1 _First1, _InIt1 _Last1,
   _InIt2 _First2, _Pr& _Pred, random_access_iterator_tag, random_access_iterator_tag)
 {
                                             ;
 return (_Mismatch_unchecked(_First1, _Last1, _Unchecked(_First2), _Pred));
 }

template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 pair<_InIt1, _InIt2>
  _Mismatch_no_deprecate(_InIt1 _First1, _InIt1 _Last1,
   _InIt2 _First2, _Pr& _Pred)
 {
                                           ;
                                            ;
 return (_Rechecked_both(_First1, _First2,
  _Mismatch_no_deprecate1(_Unchecked(_First1), _Unchecked(_Last1),
   _First2, _Pred, _Iter_cat_t<_InIt1>(), _Iter_cat_t<_InIt2>())));
 }

template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 pair<_InIt1, _InIt2>
  mismatch(_InIt1 _First1, _InIt1 _Last1,
   _InIt2 _First2, _Pr _Pred)
 {
 struct _Unchecked_iterators { static void _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_First2)));
 return (_Mismatch_no_deprecate(_First1, _Last1, _First2, _Pred));
 }
# 233 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm" 3
template<class _InIt1,
 class _InIt2> inline
 pair<_InIt1, _InIt2>
  mismatch(_InIt1 _First1, _InIt1 _Last1,
   _InIt2 _First2)
 {
 return (::std:: mismatch(_First1, _Last1, _First2,
  equal_to<>()));
 }
# 257 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm" 3
template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 pair<_InIt1, _InIt2>
  _Mismatch_unchecked(_InIt1 _First1, _InIt1 _Last1,
   _InIt2 _First2, _InIt2 _Last2, _Pr& _Pred)
 {
 for (; _First1 != _Last1 && _First2 != _Last2
  && _Pred(*_First1, *_First2); )
  {
  ++_First1;
  ++_First2;
  }

 return (pair<_InIt1, _InIt2>(_First1, _First2));
 }

template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 pair<_InIt1, _InIt2>
  mismatch(_InIt1 _First1, _InIt1 _Last1,
   _InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
 {
                              ;
                              ;
                                                                 ;
 return (_Rechecked_both(_First1, _First2,
  _Mismatch_unchecked(_Unchecked(_First1), _Unchecked(_Last1),
   _Unchecked(_First2), _Unchecked(_Last2), _Pred)));
 }


template<class _InIt1,
 class _InIt2> inline
 pair<_InIt1, _InIt2>
  mismatch(_InIt1 _First1, _InIt1 _Last1,
   _InIt2 _First2, _InIt2 _Last2)
 {
 return (::std:: mismatch(_First1, _Last1, _First2, _Last2,
  equal_to<>()));
 }


template<class _InIt,
 class _Pr> inline
 bool _All_of_unchecked(_InIt _First, _InIt _Last, _Pr& _Pred)
 {
 for (; _First != _Last; ++_First)
  if (!_Pred(*_First))
   return (false);
 return (true);
 }

template<class _InIt,
 class _Pr> inline
 bool all_of(_InIt _First, _InIt _Last, _Pr _Pred)
 {
                                       ;
 return (_All_of_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred));
 }


template<class _InIt,
 class _Pr> inline
 bool _Any_of_unchecked(_InIt _First, _InIt _Last, _Pr& _Pred)
 {
 for (; _First != _Last; ++_First)
  if (_Pred(*_First))
   return (true);
 return (false);
 }

template<class _InIt,
 class _Pr> inline
 bool any_of(_InIt _First, _InIt _Last, _Pr _Pred)
 {
                                       ;
 return (_Any_of_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred));
 }


template<class _InIt,
 class _Pr> inline
 bool _None_of_unchecked(_InIt _First, _InIt _Last, _Pr& _Pred)
 {
 for (; _First != _Last; ++_First)
  if (_Pred(*_First))
   return (false);
 return (true);
 }

template<class _InIt,
 class _Pr> inline
 bool none_of(_InIt _First, _InIt _Last, _Pr _Pred)
 {
                                       ;
 return (_None_of_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred));
 }


template<class _InIt,
 class _Pr> inline
 _InIt _Find_if_not_unchecked(_InIt _First, _InIt _Last, _Pr& _Pred)
 {
 for (; _First != _Last; ++_First)
  if (!_Pred(*_First))
   break;
 return (_First);
 }

template<class _InIt,
 class _Pr> inline
 _InIt find_if_not(_InIt _First, _InIt _Last, _Pr _Pred)
 {
                                       ;
 return (_Rechecked(_First,
  _Find_if_not_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred)));
 }


template<class _InIt,
 class _OutIt,
 class _Pr> inline
 _OutIt _Copy_if_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest,
  _Pr& _Pred)
 {
 for (; _First != _Last; ++_First)
  if (_Pred(*_First))
   {
                        ;
   *_Dest++ = *_First;
   }

 return (_Dest);
 }

template<class _InIt,
 class _OutIt,
 class _Pr> inline
 _OutIt _Copy_if_no_deprecate(_InIt _First, _InIt _Last, _OutIt _Dest,
  _Pr& _Pred)
 {
                                       ;
 return (_Rechecked(_Dest,
  _Copy_if_unchecked(_Unchecked(_First), _Unchecked(_Last),
  _Unchecked_idl0(_Dest), _Pred)));
 }

template<class _InIt,
 class _OutIt,
 class _Pr> inline
 _OutIt copy_if(_InIt _First, _InIt _Last, _OutIt _Dest,
  _Pr _Pred)
 {
 struct _Unchecked_iterators { static void _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
 return (_Copy_if_no_deprecate(_First, _Last, _Dest, _Pred));
 }
# 431 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm" 3
template<class _InIt,
 class _OutIt1,
 class _OutIt2,
 class _Pr> inline
 pair<_OutIt1, _OutIt2>
  _Partition_copy_unchecked(_InIt _First, _InIt _Last,
   _OutIt1 _Dest1, _OutIt2 _Dest2, _Pr& _Pred)
 {
 for (; _First != _Last; ++_First)
  if (_Pred(*_First))
   {
                         ;
   *_Dest1++ = *_First;
   }
  else
   {
                         ;
   *_Dest2++ = *_First;
   }

 return (pair<_OutIt1, _OutIt2>(_Dest1, _Dest2));
 }

template<class _InIt,
 class _OutIt1,
 class _OutIt2,
 class _Pr> inline
 pair<_OutIt1, _OutIt2>
  _Partition_copy_no_deprecate(_InIt _First, _InIt _Last,
   _OutIt1 _Dest1, _OutIt2 _Dest2, _Pr& _Pred)
 {
                                       ;
 return (_Rechecked_both(_Dest1, _Dest2,
  _Partition_copy_unchecked(_Unchecked(_First), _Unchecked(_Last),
  _Unchecked_idl0(_Dest1), _Unchecked_idl0(_Dest2), _Pred)));
 }

template<class _InIt,
 class _OutIt1,
 class _OutIt2,
 class _Pr> inline
 pair<_OutIt1, _OutIt2>
  partition_copy(_InIt _First, _InIt _Last,
   _OutIt1 _Dest1, _OutIt2 _Dest2, _Pr _Pred)
 {
 struct _Unchecked_iterators { static void _Deprecate(false_type) { } static void _Deprecate(true_type) { } };
 (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest1)));
 (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest2)));
 return (_Partition_copy_no_deprecate(_First, _Last, _Dest1, _Dest2, _Pred));
 }
# 532 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm" 3
template<class _InIt,
 class _Pr> inline
 bool _Is_partitioned_unchecked(_InIt _First, _InIt _Last, _Pr& _Pred)
 {
 for (; _First != _Last; ++_First)
  if (!_Pred(*_First))
   break;
 for (; _First != _Last; ++_First)
  if (_Pred(*_First))
   return (false);
 return (true);
 }

template<class _InIt,
 class _Pr> inline
 bool is_partitioned(_InIt _First, _InIt _Last, _Pr _Pred)
 {
                                       ;
 return (_Is_partitioned_unchecked(_Unchecked(_First), _Unchecked(_Last),
  _Pred));
 }


template<class _FwdIt,
 class _Pr> inline
 _FwdIt _Partition_point_unchecked(_FwdIt _First, _FwdIt _Last, _Pr& _Pred)
 {
 _Iter_diff_t<_FwdIt> _Count = ::std:: distance(_First, _Last);
 while (0 < _Count)
  {
  _Iter_diff_t<_FwdIt> _Count2 = _Count / 2;
  _FwdIt _Mid = _First;
  ::std:: advance(_Mid, _Count2);

  if (_Pred(*_Mid))
   {
   _First = ++_Mid;
   _Count -= _Count2 + 1;
   }
  else
   _Count = _Count2;
  }

 return (_First);
 }

template<class _FwdIt,
 class _Pr> inline
 _FwdIt partition_point(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
 {
                                       ;
 return (_Rechecked(_First,
  _Partition_point_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred)));
 }


template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 _FwdIt1 _Search_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr& _Pred,
  forward_iterator_tag, forward_iterator_tag)
 {
 for (; ; ++_First1)
  {
  _FwdIt1 _Mid1 = _First1;
  for (_FwdIt2 _Mid2 = _First2; ; ++_Mid1, (void)++_Mid2)
   if (_Mid2 == _Last2)
    return (_First1);
   else if (_Mid1 == _Last1)
    return (_Last1);
   else if (!_Pred(*_Mid1, *_Mid2))
    break;
  }
 }

template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 _FwdIt1 _Search_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr& _Pred,
  random_access_iterator_tag, random_access_iterator_tag)
 {
 _Iter_diff_t<_FwdIt1> _Count1 = _Last1 - _First1;
 _Iter_diff_t<_FwdIt2> _Count2 = _Last2 - _First2;

 for (; _Count2 <= _Count1; ++_First1, (void)--_Count1)
  {
  _FwdIt1 _Mid1 = _First1;
  for (_FwdIt2 _Mid2 = _First2; ; ++_Mid1, (void)++_Mid2)
   if (_Mid2 == _Last2)
    return (_First1);
   else if (!_Pred(*_Mid1, *_Mid2))
    break;
  }

 return (_Last1);
 }

template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 _FwdIt1 search(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
 {
                              ;
                              ;
                                                                 ;
 return (_Rechecked(_First1,
  _Search_unchecked(_Unchecked(_First1), _Unchecked(_Last1),
   _Unchecked(_First2), _Unchecked(_Last2), _Pred,
   _Iter_cat_t<_FwdIt1>(), _Iter_cat_t<_FwdIt2>())));
 }


template<class _FwdIt1,
 class _FwdIt2> inline
 _FwdIt1 search(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2)
 {
 return (::std:: search(_First1, _Last1, _First2, _Last2,
  equal_to<>()));
 }


template<class _FwdIt,
 class _Diff,
 class _Ty,
 class _Pr> inline
 _FwdIt _Search_n_unchecked(_FwdIt _First, _FwdIt _Last,
  _Diff _Count, const _Ty& _Val, _Pr& _Pred, forward_iterator_tag)
 {
 if (_Count <= 0)
  return (_First);

 for (; _First != _Last; ++_First)
  if (_Pred(*_First, _Val))
   {
   _FwdIt _Mid = _First;

   for (_Diff _Count1 = _Count; ; )
    if (--_Count1 == 0)
     return (_First);
    else if (++_Mid == _Last)
     return (_Last);
    else if (!_Pred(*_Mid, _Val))
     {
     break;
     }

   _First = _Mid;
   }

 return (_Last);
 }

template<class _FwdIt,
 class _Diff,
 class _Ty,
 class _Pr> inline
 _FwdIt _Search_n_unchecked(_FwdIt _First, _FwdIt _Last,
  _Diff _Count, const _Ty& _Val, _Pr& _Pred, random_access_iterator_tag)
 {
 if (_Count <= 0)
  return (_First);

 _FwdIt _Oldfirst = _First;
 for (_Diff _Inc = 0; _Count <= _Last - _Oldfirst; )
  {
  _First = _Oldfirst + _Inc;
  if (_Pred(*_First, _Val))
   {
   _Diff _Count1 = _Count;
   _FwdIt _Mid = _First;

   for (; _Oldfirst != _First && _Pred(_First[-1], _Val);
    --_First)
    --_Count1;

   if (_Count1 <= _Last - _Mid)
    for (; ; )
     {
     if (--_Count1 == 0)
      return (_First);
     else if (!_Pred(*++_Mid, _Val))
      {
      break;
      }
     }
   _Oldfirst = ++_Mid;
   _Inc = 0;
   }
  else
   {
   _Oldfirst = _First + 1;
   _Inc = _Count - 1;
   }
  }

 return (_Last);
 }

template<class _FwdIt,
 class _Diff,
 class _Ty,
 class _Pr> inline
 _FwdIt search_n(_FwdIt _First, _FwdIt _Last,
  _Diff _Count, const _Ty& _Val, _Pr _Pred)
 {
                                       ;
 return (_Rechecked(_First,
  _Search_n_unchecked(_Unchecked(_First), _Unchecked(_Last), _Count, _Val,
   _Pred, _Iter_cat_t<_FwdIt>())));
 }


template<class _FwdIt,
 class _Diff,
 class _Ty> inline
 _FwdIt search_n(_FwdIt _First, _FwdIt _Last,
  _Diff _Count, const _Ty& _Val)
 {
 return (::std:: search_n(_First, _Last, _Count, _Val,
  equal_to<>()));
 }


template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 _FwdIt1 _Find_end_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr& _Pred)
 {
 _Iter_diff_t<_FwdIt1> _Count1 = ::std:: distance(_First1, _Last1);
 _Iter_diff_t<_FwdIt2> _Count2 = ::std:: distance(_First2, _Last2);
 _FwdIt1 _Ans = _Last1;

 if (0 < _Count2)
  {
                                              ;
  for (; _Count2 <= _Count1; ++_First1, (void)--_Count1)
   {
   _FwdIt1 _Mid1 = _First1;
   for (_FwdIt2 _Mid2 = _First2; ; ++_Mid1)
    if (!_Pred(*_Mid1, *_Mid2))
     break;
    else if (++_Mid2 == _Last2)
     {
     _Ans = _First1;
     break;
     }
   }
  }

 return (_Ans);
 }

template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 _FwdIt1 find_end(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
 {
                              ;
                              ;
 return (_Rechecked(_First1,
  _Find_end_unchecked(_Unchecked(_First1), _Unchecked(_Last1),
   _Unchecked(_First2), _Unchecked(_Last2), _Pred)));
 }


template<class _FwdIt1,
 class _FwdIt2> inline
 _FwdIt1 find_end(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2)
 {
 return (::std:: find_end(_First1, _Last1, _First2, _Last2,
  equal_to<>()));
 }


template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 _FwdIt1 _Find_first_of_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr& _Pred)
 {
 for (; _First1 != _Last1; ++_First1)
  for (_FwdIt2 _Mid2 = _First2; _Mid2 != _Last2; ++_Mid2)
   if (_Pred(*_First1, *_Mid2))
    return (_First1);
 return (_First1);
 }

template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 _FwdIt1 find_first_of(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
 {
                              ;
                              ;
                                                                 ;
 return (_Rechecked(_First1,
  _Find_first_of_unchecked(_Unchecked(_First1), _Unchecked(_Last1),
   _Unchecked(_First2), _Unchecked(_Last2), _Pred)));
 }


template<class _FwdIt1,
 class _FwdIt2> inline
 _FwdIt1 find_first_of(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2)
 {
 return (::std:: find_first_of(_First1, _Last1, _First2, _Last2,
  equal_to<>()));
 }


template<class _FwdIt1,
 class _FwdIt2> inline
 _FwdIt2 _Swap_ranges_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _Dest)
 {
 for (; _First1 != _Last1; ++_First1, (void)++_Dest)
  ::std:: iter_swap(_First1, _Dest);
 return (_Dest);
 }

template<class _FwdIt1,
 class _FwdIt2> inline
 _FwdIt2 _Swap_ranges1(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _Dest,
  forward_iterator_tag, forward_iterator_tag)
 {
 return (_Rechecked(_Dest,
  _Swap_ranges_unchecked(_First1, _Last1, _Unchecked_idl0(_Dest))));
 }

template<class _FwdIt1,
 class _FwdIt2> inline
 _FwdIt2 _Swap_ranges1(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _Dest,
  random_access_iterator_tag, random_access_iterator_tag)
 {
                                           ;
 return (_Rechecked(_Dest,
  _Swap_ranges_unchecked(_First1, _Last1, _Unchecked(_Dest))));
 }

template<class _FwdIt1,
 class _FwdIt2> inline
 _FwdIt2 swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _Dest)
 {
 struct _Unchecked_iterators { static void _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
                                         ;
 return (_Swap_ranges1(_Unchecked(_First1), _Unchecked(_Last1),
  _Dest, _Iter_cat_t<_FwdIt1>(), _Iter_cat_t<_FwdIt2>()));
 }
# 907 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm" 3
template<class _InIt,
 class _OutIt,
 class _Fn1> inline
 _OutIt _Transform_unchecked(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Fn1& _Func)
 {
 for (; _First != _Last; ++_First, (void)++_Dest)
  *_Dest = _Func(*_First);
 return (_Dest);
 }

template<class _InIt,
 class _OutIt,
 class _Fn1> inline
 _OutIt _Transform_no_deprecate1(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Fn1& _Func,
  input_iterator_tag, _Any_tag)
 {
 return (_Rechecked(_Dest,
  _Transform_unchecked(_First, _Last, _Unchecked_idl0(_Dest), _Func)));
 }

template<class _InIt,
 class _OutIt,
 class _Fn1> inline
 _OutIt _Transform_no_deprecate1(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Fn1& _Func,
  random_access_iterator_tag, random_access_iterator_tag)
 {
                                         ;
 return (_Rechecked(_Dest,
  _Transform_unchecked(_First, _Last, _Unchecked(_Dest), _Func)));
 }

template<class _InIt,
 class _OutIt,
 class _Fn1> inline
 _OutIt _Transform_no_deprecate(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Fn1& _Func)
 {
                                       ;
                                          ;
 return (_Transform_no_deprecate1(_Unchecked(_First), _Unchecked(_Last),
  _Dest, _Func, _Iter_cat_t<_InIt>(), _Iter_cat_t<_OutIt>()));
 }

template<class _InIt,
 class _OutIt,
 class _Fn1> inline
 _OutIt transform(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Fn1 _Func)
 {
 struct _Unchecked_iterators { static void _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
 return (_Transform_no_deprecate(_First, _Last, _Dest, _Func));
 }
# 978 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm" 3
template<class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Fn2> inline
 _OutIt _Transform_unchecked(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _OutIt _Dest, _Fn2& _Func)
 {
 for (; _First1 != _Last1; ++_First1, (void)++_First2, ++_Dest)
  *_Dest = _Func(*_First1, *_First2);
 return (_Dest);
 }

template<class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Fn2> inline
 _OutIt _Transform_no_deprecate2(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _OutIt _Dest, _Fn2& _Func,
  input_iterator_tag, _Any_tag)
 {
 return (_Rechecked(_Dest,
  _Transform_unchecked(_First1, _Last1, _First2, _Unchecked_idl0(_Dest), _Func)));
 }

template<class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Fn2> inline
 _OutIt _Transform_no_deprecate2(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _OutIt _Dest, _Fn2& _Func,
  random_access_iterator_tag, random_access_iterator_tag)
 {
                                           ;
 return (_Rechecked(_Dest,
  _Transform_unchecked(_First1, _Last1, _First2, _Unchecked(_Dest), _Func)));
 }

template<class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Fn2> inline
 _OutIt _Transform_no_deprecate1(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _OutIt _Dest, _Fn2& _Func,
  input_iterator_tag, input_iterator_tag)
 {
 return (_Transform_no_deprecate2(_First1, _Last1,
  _Unchecked_idl0(_First2), _Dest, _Func,
  _Iter_cat_t<_InIt1>(), _Iter_cat_t<_OutIt>()));
 }

template<class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Fn2> inline
 _OutIt _Transform_no_deprecate1(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _OutIt _Dest, _Fn2& _Func,
  random_access_iterator_tag, random_access_iterator_tag)
 {
                                             ;
 return (_Transform_no_deprecate2(_First1, _Last1,
  _Unchecked(_First2), _Dest, _Func,
  _Iter_cat_t<_InIt1>(), _Iter_cat_t<_OutIt>()));
 }

template<class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Fn2> inline
 _OutIt _Transform_no_deprecate(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _OutIt _Dest, _Fn2& _Func)
 {
                                           ;
                                            ;
                                            ;
 return (_Transform_no_deprecate1(_Unchecked(_First1), _Unchecked(_Last1),
  _First2, _Dest, _Func,
  _Iter_cat_t<_InIt1>(), _Iter_cat_t<_InIt2>()));
 }

template<class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Fn2> inline
 _OutIt transform(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _OutIt _Dest, _Fn2 _Func)
 {
 struct _Unchecked_iterators { static void _Deprecate(false_type) { } static void _Deprecate(true_type) { } };
 (_Unchecked_iterators::_Deprecate(_Is_checked(_First2)));
 (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
 return (_Transform_no_deprecate(_First1, _Last1, _First2, _Dest, _Func));
 }
# 1115 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm" 3
template<class _FwdIt,
 class _Ty> inline
 void _Replace_unchecked(_FwdIt _First, _FwdIt _Last,
  const _Ty& _Oldval, const _Ty& _Newval)
 {
 for (; _First != _Last; ++_First)
  if (*_First == _Oldval)
   *_First = _Newval;
 }

template<class _FwdIt,
 class _Ty> inline
 void replace(_FwdIt _First, _FwdIt _Last,
  const _Ty& _Oldval, const _Ty& _Newval)
 {
                            ;
 _Replace_unchecked(_Unchecked(_First), _Unchecked(_Last),
  _Oldval, _Newval);
 }


template<class _FwdIt,
 class _Pr,
 class _Ty> inline
 void _Replace_if_unchecked(_FwdIt _First, _FwdIt _Last, _Pr& _Pred, const _Ty& _Val)
 {
 for (; _First != _Last; ++_First)
  if (_Pred(*_First))
   *_First = _Val;
 }

template<class _FwdIt,
 class _Pr,
 class _Ty> inline
 void replace_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred, const _Ty& _Val)
 {
                                       ;
 _Replace_if_unchecked(_Unchecked(_First), _Unchecked(_Last),
  _Pred, _Val);
 }


template<class _InIt,
 class _OutIt,
 class _Ty> inline
 _OutIt _Replace_copy_unchecked(_InIt _First, _InIt _Last,
  _OutIt _Dest, const _Ty& _Oldval, const _Ty& _Newval)
 {
 for (; _First != _Last; ++_First, (void)++_Dest)
  *_Dest = *_First == _Oldval ? _Newval : *_First;
 return (_Dest);
 }

template<class _InIt,
 class _OutIt,
 class _Ty> inline
 _OutIt _Replace_copy1(_InIt _First, _InIt _Last,
  _OutIt _Dest, const _Ty& _Oldval, const _Ty& _Newval,
  input_iterator_tag, _Any_tag)
 {
 return (_Rechecked(_Dest,
  _Replace_copy_unchecked(_First, _Last, _Unchecked_idl0(_Dest),
  _Oldval, _Newval)));
 }

template<class _InIt,
 class _OutIt,
 class _Ty> inline
 _OutIt _Replace_copy1(_InIt _First, _InIt _Last,
  _OutIt _Dest, const _Ty& _Oldval, const _Ty& _Newval,
  random_access_iterator_tag, random_access_iterator_tag)
 {
                                         ;
 return (_Rechecked(_Dest,
  _Replace_copy_unchecked(_First, _Last, _Unchecked(_Dest),
  _Oldval, _Newval)));
 }

template<class _InIt,
 class _OutIt,
 class _Ty> inline
 _OutIt replace_copy(_InIt _First, _InIt _Last,
  _OutIt _Dest, const _Ty& _Oldval, const _Ty& _Newval)
 {
 struct _Unchecked_iterators { static void _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
                                       ;
 return (_Replace_copy1(_Unchecked(_First), _Unchecked(_Last),
  _Dest, _Oldval, _Newval,
  _Iter_cat_t<_InIt>(), _Iter_cat_t<_OutIt>()));
 }
# 1221 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm" 3
template<class _InIt,
 class _OutIt,
 class _Pr,
 class _Ty> inline
 _OutIt _Replace_copy_if_unchecked(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Pr& _Pred, const _Ty& _Val)
 {
 for (; _First != _Last; ++_First, (void)++_Dest)
  *_Dest = _Pred(*_First) ? _Val : *_First;
 return (_Dest);
 }

template<class _InIt,
 class _OutIt,
 class _Pr,
 class _Ty> inline
 _OutIt _Replace_copy_if_no_deprecate1(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Pr& _Pred, const _Ty& _Val,
  input_iterator_tag, _Any_tag)
 {
 return (_Rechecked(_Dest,
  _Replace_copy_if_unchecked(_First, _Last, _Unchecked_idl0(_Dest), _Pred, _Val)));
 }

template<class _InIt,
 class _OutIt,
 class _Pr,
 class _Ty> inline
 _OutIt _Replace_copy_if_no_deprecate1(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Pr& _Pred, const _Ty& _Val,
  random_access_iterator_tag, random_access_iterator_tag)
 {
                                         ;
 return (_Rechecked(_Dest,
  _Replace_copy_if_unchecked(_First, _Last, _Unchecked(_Dest), _Pred, _Val)));
 }

template<class _InIt,
 class _OutIt,
 class _Pr,
 class _Ty> inline
 _OutIt _Replace_copy_if_no_deprecate(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Pr& _Pred, const _Ty& _Val)
 {
                                       ;
                                          ;
 return (_Replace_copy_if_no_deprecate1(_Unchecked(_First), _Unchecked(_Last),
  _Dest, _Pred, _Val,
  _Iter_cat_t<_InIt>(), _Iter_cat_t<_OutIt>()));
 }

template<class _InIt,
 class _OutIt,
 class _Pr,
 class _Ty> inline
 _OutIt replace_copy_if(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Pr _Pred, const _Ty& _Val)
 {
 struct _Unchecked_iterators { static void _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
 return (_Replace_copy_if_no_deprecate(_First, _Last, _Dest, _Pred, _Val));
 }
# 1299 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm" 3
template<class _FwdIt,
 class _Fn0> inline
 void _Generate_unchecked(_FwdIt _First, _FwdIt _Last, _Fn0& _Func)
 {
 for (; _First != _Last; ++_First)
  *_First = _Func();
 }

template<class _FwdIt,
 class _Fn0> inline
 void generate(_FwdIt _First, _FwdIt _Last, _Fn0 _Func)
 {
                                       ;
 _Generate_unchecked(_Unchecked(_First), _Unchecked(_Last), _Func);
 }


template<class _OutIt,
 class _Diff,
 class _Fn0> inline
 _OutIt _Generate_n_unchecked(_OutIt _Dest, _Diff _Count, _Fn0& _Func)
 {
 for (; 0 < _Count; --_Count, (void)++_Dest)
  *_Dest = _Func();
 return (_Dest);
 }

template<class _OutIt,
 class _Diff,
 class _Fn0> inline
 _OutIt generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func)
 {
 return (_Rechecked(_Dest,
  _Generate_n_unchecked(_Unchecked_n(_Dest, _Count), _Count, _Func)));
 }
# 1348 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm" 3
template<class _InIt,
 class _OutIt,
 class _Ty> inline
 _OutIt _Remove_copy_unchecked(_InIt _First, _InIt _Last,
  _OutIt _Dest, const _Ty& _Val)
 {
 for (; _First != _Last; ++_First)
  if (!(*_First == _Val))
   {
                        ;
   *_Dest++ = *_First;
   }

 return (_Dest);
 }

template<class _InIt,
 class _OutIt,
 class _Ty> inline
 _OutIt remove_copy(_InIt _First, _InIt _Last,
  _OutIt _Dest, const _Ty& _Val)
 {
 struct _Unchecked_iterators { static void _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
                            ;
 return (_Rechecked(_Dest,
  _Remove_copy_unchecked(_Unchecked(_First), _Unchecked(_Last),
  _Unchecked_idl0(_Dest), _Val)));
 }
# 1392 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm" 3
template<class _InIt,
 class _OutIt,
 class _Pr> inline
 _OutIt _Remove_copy_if_unchecked(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Pr& _Pred)
 {
 for (; _First != _Last; ++_First)
  if (!_Pred(*_First))
   {
                        ;
   *_Dest++ = *_First;
   }

 return (_Dest);
 }

template<class _InIt,
 class _OutIt,
 class _Pr> inline
 _OutIt _Remove_copy_if_no_deprecate(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Pr& _Pred)
 {
                                       ;
 return (_Rechecked(_Dest,
  _Remove_copy_if_unchecked(_Unchecked(_First), _Unchecked(_Last),
  _Unchecked_idl0(_Dest), _Pred)));
 }

template<class _InIt,
 class _OutIt,
 class _Pr> inline
 _OutIt remove_copy_if(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Pr _Pred)
 {
 struct _Unchecked_iterators { static void _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
 return (_Remove_copy_if_no_deprecate(_First, _Last, _Dest, _Pred));
 }
# 1445 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm" 3
template<class _FwdIt,
 class _Ty> inline
 _FwdIt _Remove_unchecked(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
 {
 _First = _Find_unchecked(_First, _Last, _Val);
 _FwdIt _Next = _First;
 if (_First != _Last)
  {
  for (++_First; _First != _Last; ++_First)
   if (!(*_First == _Val))
    *_Next++ = ::std:: move(*_First);
  }

 return (_Next);
 }

template<class _FwdIt,
 class _Ty> inline
 _FwdIt remove(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
 {
                            ;
 return (_Rechecked(_First,
  _Remove_unchecked(_Unchecked(_First), _Unchecked(_Last), _Val)));
 }


template<class _FwdIt,
 class _Pr> inline
 _FwdIt _Remove_if_unchecked(_FwdIt _First, _FwdIt _Last, _Pr& _Pred)
 {
 _First = _Find_if_unchecked(_First, _Last, _Pred);
 _FwdIt _Next = _First;
 if (_First != _Last)
  {
  for (++_First; _First != _Last; ++_First)
  if (!_Pred(*_First))
   *_Next++ = ::std:: move(*_First);
  }

 return (_Next);
 }

template<class _FwdIt,
 class _Pr> inline
 _FwdIt remove_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
 {
                            ;
 return (_Rechecked(_First,
  _Remove_if_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred)));
 }


template<class _FwdIt,
 class _Pr> inline
 _FwdIt _Unique_unchecked(_FwdIt _First, _FwdIt _Last, _Pr& _Pred)
 {
 if (_First != _Last)
  for (_FwdIt _Firstb; (void)(_Firstb = _First), ++_First != _Last; )
   if (_Pred(*_Firstb, *_First))
    {
    for (; ++_First != _Last; )
     if (!_Pred(*_Firstb, *_First))
      *++_Firstb = ::std:: move(*_First);
    return (++_Firstb);
    }

 return (_Last);
 }

template<class _FwdIt,
 class _Pr> inline
 _FwdIt unique(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
 {
                            ;
                                                                        ;
 return (_Rechecked(_First,
  _Unique_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred)));
 }


template<class _FwdIt> inline
 _FwdIt unique(_FwdIt _First, _FwdIt _Last)
 {
 return (::std:: unique(_First, _Last, equal_to<>()));
 }


template<class _InIt,
 class _OutIt,
 class _Pr> inline
 _OutIt _Unique_copy_unchecked(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Pr& _Pred, input_iterator_tag)
 {
 if (_First != _Last)
  {
  _Iter_value_t<_InIt> _Val = *_First;

  for (*_Dest++ = _Val; ++_First != _Last; )
   if (!_Pred(_Val, *_First))
    {
    _Val = *_First;
    *_Dest++ = _Val;
    }
  }

 return (_Dest);
 }

template<class _FwdIt,
 class _OutIt,
 class _Pr> inline
 _OutIt _Unique_copy_unchecked(_FwdIt _First, _FwdIt _Last,
  _OutIt _Dest, _Pr& _Pred, forward_iterator_tag)
 {
 if (_First != _Last)
  {
  _FwdIt _Firstb = _First;

  for (*_Dest++ = *_Firstb; ++_First != _Last; )
   if (!_Pred(*_Firstb, *_First))
    {
    _Firstb = _First;
    *_Dest++ = *_Firstb;
    }
  }

 return (_Dest);
 }

template<class _InIt,
 class _OutIt,
 class _Pr> inline
 _OutIt _Unique_copy_no_deprecate(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Pr& _Pred)
 {
                                       ;
                                          ;
 return (_Rechecked(_Dest,
  _Unique_copy_unchecked(_Unchecked(_First), _Unchecked(_Last),
   _Unchecked_idl0(_Dest), _Pred, _Iter_cat_t<_InIt>())));
 }

template<class _InIt,
 class _OutIt,
 class _Pr> inline
 _OutIt unique_copy(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Pr _Pred)
 {
 struct _Unchecked_iterators { static void _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
 return (_Unique_copy_no_deprecate(_First, _Last, _Dest, _Pred));
 }
# 1612 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm" 3
template<class _InIt,
 class _OutIt> inline
 _OutIt unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest)
 {
 return (::std:: unique_copy(_First, _Last, _Dest,
  equal_to<>()));
 }
# 1633 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm" 3
template<class _BidIt,
 class _OutIt> inline
 _OutIt _Reverse_copy_unchecked(_BidIt _First, _BidIt _Last,
  _OutIt _Dest)
 {
 for (; _First != _Last; ++_Dest)
  *_Dest = *--_Last;
 return (_Dest);
 }

template<class _BidIt,
 class _OutIt> inline
 _OutIt _Reverse_copy1(_BidIt _First, _BidIt _Last,
  _OutIt _Dest,
  bidirectional_iterator_tag, _Any_tag)
 {
 return (_Rechecked(_Dest,
  _Reverse_copy_unchecked(_First, _Last, _Unchecked_idl0(_Dest))));
 }

template<class _BidIt,
 class _OutIt> inline
 _OutIt _Reverse_copy1(_BidIt _First, _BidIt _Last,
  _OutIt _Dest,
  random_access_iterator_tag, random_access_iterator_tag)
 {
                                         ;
 return (_Rechecked(_Dest,
  _Reverse_copy_unchecked(_First, _Last, _Unchecked(_Dest))));
 }

template<class _BidIt,
 class _OutIt> inline
 _OutIt reverse_copy(_BidIt _First, _BidIt _Last,
  _OutIt _Dest)
 {
 struct _Unchecked_iterators { static void _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
                                       ;
 return (_Reverse_copy1(_Unchecked(_First), _Unchecked(_Last),
  _Dest, _Iter_cat_t<_BidIt>(), _Iter_cat_t<_OutIt>()));
 }
# 1689 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm" 3
template<class _FwdIt,
 class _OutIt> inline
 _OutIt _Rotate_copy_unchecked(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last,
  _OutIt _Dest)
 {
 _Dest = _Copy_unchecked(_Mid, _Last, _Dest);
 return (_Copy_unchecked(_First, _Mid, _Dest));
 }

template<class _FwdIt,
 class _OutIt> inline
 _OutIt _Rotate_copy1(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last,
  _OutIt _Dest, forward_iterator_tag, _Any_tag)
 {
 return (_Rechecked(_Dest,
  _Rotate_copy_unchecked(_First, _Mid, _Last, _Unchecked_idl0(_Dest))));
 }

template<class _FwdIt,
 class _OutIt> inline
 _OutIt _Rotate_copy1(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last,
  _OutIt _Dest, random_access_iterator_tag, random_access_iterator_tag)
 {
                                         ;
 return (_Rechecked(_Dest,
  _Rotate_copy_unchecked(_First, _Mid, _Last, _Unchecked(_Dest))));
 }

template<class _FwdIt,
 class _OutIt> inline
 _OutIt rotate_copy(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last,
  _OutIt _Dest)
 {
                           ;
                          ;
 return (_Rotate_copy1(_Unchecked(_First), _Unchecked(_Mid),
  _Unchecked(_Last), _Dest, _Iter_cat_t<_FwdIt>(), _Iter_cat_t<_OutIt>()));
 }


template<class _RanIt,
 class _Fn1> inline
 void _Random_shuffle_unchecked(_RanIt _First, _RanIt _Last, _Fn1& _Func)
 {
 if (_Last - _First < 2)
  return;

 _RanIt _Next = _First;
 for (_Iter_diff_t<_RanIt> _Index = 2; ++_Next != _Last; ++_Index)
  {
  _Iter_diff_t<_RanIt> _Off = _Func(_Index);
# 1752 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm" 3
  ::std:: iter_swap(_Next, _First + _Off);
  }
 }

template<class _RanIt,
 class _Fn1> inline
 void _Random_shuffle1(_RanIt _First, _RanIt _Last, _Fn1& _Func)
 {
                            ;
 _Random_shuffle_unchecked(_Unchecked(_First), _Unchecked(_Last), _Func);
 }

template<class _RanIt,
 class _Urng> inline
 void shuffle(_RanIt _First, _RanIt _Last, _Urng&& _Func)
 {
 typedef typename iterator_traits<_RanIt>::difference_type _Diff;
 typedef typename remove_reference<_Urng>::type _Urng0;
 _Rng_from_urng<_Diff, _Urng0> _Rng(_Func);
 _Random_shuffle1(_First, _Last, _Rng);
 }



template<class _RanIt,
 class _Fn1> inline
 void random_shuffle(_RanIt _First, _RanIt _Last, _Fn1&& _Func)
 {
 _Random_shuffle1(_First, _Last, _Func);
 }


struct _Rand_urng_from_func
 {
 typedef unsigned int result_type;

 static result_type (min)()
  {
  return (0);
  }

 static result_type (max)()
  {
  return (0x7fff);
  }

 result_type operator()()
  {
  return (:: rand());
  }
 };


template<class _RanIt> inline
 void random_shuffle(_RanIt _First, _RanIt _Last)
 {
 _Rand_urng_from_func _Func;
 ::std:: shuffle(_First, _Last, _Func);
 }



template<class _FwdIt,
 class _Pr> inline
 _FwdIt _Partition_unchecked(_FwdIt _First, _FwdIt _Last, _Pr& _Pred,
  forward_iterator_tag)
 {
 while (_First != _Last && _Pred(*_First))
  ++_First;

 if (_First == _Last)
  return (_First);

 for (_FwdIt _Next = ::std:: next(_First); _Next != _Last; ++_Next)
  if (_Pred(*_Next))
   ::std:: iter_swap(_First++, _Next);

 return (_First);
 }

template<class _BidIt,
 class _Pr> inline
 _BidIt _Partition_unchecked(_BidIt _First, _BidIt _Last, _Pr& _Pred,
  bidirectional_iterator_tag)
 {
 for (; ; ++_First)
  {
  for (; _First != _Last && _Pred(*_First); ++_First)
   ;
  if (_First == _Last)
   break;

  for (; _First != --_Last && !_Pred(*_Last); )
   ;
  if (_First == _Last)
   break;

  ::std:: iter_swap(_First, _Last);
  }

 return (_First);
 }

template<class _FwdIt,
 class _Pr> inline
 _FwdIt partition(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
 {
                                       ;
 return (_Rechecked(_First,
  _Partition_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred,
   _Iter_cat_t<_FwdIt>())));
 }


template<class _BidIt,
 class _Diff,
 class _Ty> inline
 _BidIt _Buffered_rotate_unchecked(_BidIt _First, _BidIt _Mid, _BidIt _Last,
  _Diff _Count1, _Diff _Count2, _Temp_iterator<_Ty>& _Tempbuf)
 {
 if (_Count1 == 0 || _Count2 == 0)
  {
  ::std:: advance(_First, _Count2);
  return (_First);
  }
 else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())
  {
  _Move_unchecked(_First, _Mid, _Tempbuf._Init());
  _Move_unchecked(_Mid, _Last, _First);
  return (_Move_backward_unchecked(_Tempbuf._First(), _Tempbuf._Last(),
   _Last));
  }
 else if (_Count2 <= _Tempbuf._Maxlen())
  {
  _Move_unchecked(_Mid, _Last, _Tempbuf._Init());
  _Move_backward_unchecked(_First, _Mid, _Last);
  return (_Move_unchecked(_Tempbuf._First(), _Tempbuf._Last(), _First));
  }
 else
  {
  return (_Rotate_unchecked(_First, _Mid, _Last));
  }
 }

template<class _BidIt,
 class _Pr,
 class _Diff,
 class _Ty> inline
 _BidIt _Stable_partition_unchecked1(_BidIt _First, _BidIt _Last, _Pr& _Pred,
  _Diff _Count, _Temp_iterator<_Ty>& _Tempbuf)
 {
 if (_Count == 0)
  return (_First);
 else if (_Count == 1)
  return (_Pred(*_First) ? _Last : _First);
 else if (_Count <= _Tempbuf._Maxlen())
  {
  _BidIt _Next = _First;
  for (_Tempbuf._Init(); _First != _Last; ++_First)
   if (_Pred(*_First))
    *_Next++ = ::std:: move(*_First);
   else
    *_Tempbuf++ = ::std:: move(*_First);

  _Move_unchecked(_Tempbuf._First(), _Tempbuf._Last(), _Next);
  return (_Next);
  }
 else
  {
  _BidIt _Mid = _First;
  ::std:: advance(_Mid, _Count / 2);

  _BidIt _Left = _Stable_partition_unchecked1(_First, _Mid, _Pred,
   _Count / 2, _Tempbuf);
  _BidIt _Right = _Stable_partition_unchecked1(_Mid, _Last, _Pred,
   _Count - _Count / 2, _Tempbuf);

  _Diff _Count1 = ::std:: distance(_Left, _Mid);
  _Diff _Count2 = ::std:: distance(_Mid, _Right);

  return (_Buffered_rotate_unchecked(_Left, _Mid, _Right,
   _Count1, _Count2, _Tempbuf));
  }
 }

template<class _BidIt,
 class _Pr> inline
 _BidIt _Stable_partition_unchecked(_BidIt _First, _BidIt _Last, _Pr& _Pred)
 {
 if (_First == _Last)
  return (_First);
 _Iter_diff_t<_BidIt> _Count = ::std:: distance(_First, _Last);
 _Temp_iterator<_Iter_value_t<_BidIt>> _Tempbuf(_Count);
 return (_Stable_partition_unchecked1(_First, _Last, _Pred, _Count, _Tempbuf));
 }

template<class _BidIt,
 class _Pr> inline
 _BidIt stable_partition(_BidIt _First, _BidIt _Last, _Pr _Pred)
 {
                                       ;
 return (_Rechecked(_First,
  _Stable_partition_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred)));
 }
# 1983 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm" 3
template<class _RanIt,
 class _Diff,
 class _Ty,
 class _Pr> inline
 void _Push_heap_by_index(_RanIt _First, _Diff _Hole,
  _Diff _Top, _Ty&& _Val, _Pr& _Pred)
 {
 for (_Diff _Idx = (_Hole - 1) / 2;
  _Top < _Hole && _Pred(*(_First + _Idx), _Val);
  _Idx = (_Hole - 1) / 2)
  {
  *(_First + _Hole) = ::std:: move(*(_First + _Idx));
  _Hole = _Idx;
  }

 *(_First + _Hole) = ::std:: move(_Val);
 }

template<class _RanIt,
 class _Pr> inline
 void _Push_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr& _Pred)
 {
 typedef _Iter_diff_t<_RanIt> _Diff;
 _Diff _Count = _Last - _First;
 if (2 <= _Count)
  {
  _Iter_value_t<_RanIt> _Val = ::std:: move(*--_Last);
  _Push_heap_by_index(_First, --_Count, _Diff(0), ::std:: move(_Val), _Pred);
  }
 }

template<class _RanIt,
 class _Pr> inline
 void push_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
 {
                                       ;
 _Push_heap_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred);
 }


template<class _RanIt> inline
 void push_heap(_RanIt _First, _RanIt _Last)
 {
 ::std:: push_heap(_First, _Last, less<>());
 }


template<class _RanIt,
 class _Diff,
 class _Ty,
 class _Pr> inline
 void _Pop_heap_hole_by_index(_RanIt _First, _Diff _Hole, _Diff _Bottom,
  _Ty&& _Val, _Pr& _Pred)
 {

 const _Diff _Top = _Hole;
 _Diff _Idx = _Hole;



 const _Diff _Max_sequence_non_leaf = (_Bottom - 1) / 2;
 while (_Idx < _Max_sequence_non_leaf)
  {
  _Idx = 2 * _Idx + 2;
  if (_Pred(*(_First + _Idx), *(_First + (_Idx - 1))))
   --_Idx;
  *(_First + _Hole) = ::std:: move(*(_First + _Idx));
  _Hole = _Idx;
  }

 if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0)
  {
  *(_First + _Hole) = ::std:: move(*(_First + (_Bottom - 1)));
  _Hole = _Bottom - 1;
  }

 _Push_heap_by_index(_First, _Hole, _Top, ::std:: move(_Val), _Pred);
 }

template<class _RanIt,
 class _Ty,
 class _Pr> inline
 void _Pop_heap_hole_unchecked(_RanIt _First, _RanIt _Last, _RanIt _Dest,
  _Ty&& _Val, _Pr& _Pred)
 {


 *_Dest = ::std:: move(*_First);
 _Pop_heap_hole_by_index(_First, _Iter_diff_t<_RanIt>(0), _Iter_diff_t<_RanIt>(_Last - _First),
  ::std:: move(_Val), _Pred);
 }

template<class _RanIt,
 class _Pr> inline
 void _Pop_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr& _Pred)
 {
 if (2 <= _Last - _First)
  {
  --_Last;
  _Iter_value_t<_RanIt> _Val = ::std:: move(*_Last);
  _Pop_heap_hole_unchecked(_First, _Last, _Last,
   ::std:: move(_Val), _Pred);
  }
 }

template<class _RanIt,
 class _Pr> inline
 void pop_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
 {
                                       ;
                                       ;
 _Pop_heap_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred);
 }


template<class _RanIt> inline
 void pop_heap(_RanIt _First, _RanIt _Last)
 {
 ::std:: pop_heap(_First, _Last, less<>());
 }


template<class _RanIt,
 class _Pr> inline
 void _Make_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr& _Pred)
 {
 _Iter_diff_t<_RanIt> _Bottom = _Last - _First;
 if (2 <= _Bottom)
  {
  for (_Iter_diff_t<_RanIt> _Hole = _Bottom / 2; 0 < _Hole; )
   {
   --_Hole;
   _Iter_value_t<_RanIt> _Val = ::std:: move(*(_First + _Hole));
   _Pop_heap_hole_by_index(_First, _Hole, _Bottom,
    ::std:: move(_Val), _Pred);
   }
  }
 }

template<class _RanIt,
 class _Pr> inline
 void make_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
 {
                            ;
 _Make_heap_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred);
 }


template<class _RanIt> inline
 void make_heap(_RanIt _First, _RanIt _Last)
 {
 ::std:: make_heap(_First, _Last, less<>());
 }


template<class _RanIt,
 class _Pr> inline
 void _Sort_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr& _Pred)
 {
 for (; 2 <= _Last - _First; --_Last)
  _Pop_heap_unchecked(_First, _Last, _Pred);
 }

template<class _RanIt,
 class _Pr> inline
 void sort_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
 {
                            ;
                                              ;
                                       ;
 _Sort_heap_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred);
 }


template<class _RanIt> inline
 void sort_heap(_RanIt _First, _RanIt _Last)
 {
 ::std:: sort_heap(_First, _Last, less<>());
 }


template<class _FwdIt,
 class _Ty,
 class _Pr> inline
 _FwdIt _Lower_bound_unchecked(_FwdIt _First, _FwdIt _Last,
  const _Ty& _Val, _Pr& _Pred)
 {
 _Iter_diff_t<_FwdIt> _Count = ::std:: distance(_First, _Last);

 while (0 < _Count)
  {
  _Iter_diff_t<_FwdIt> _Count2 = _Count / 2;
  _FwdIt _Mid = _First;
  ::std:: advance(_Mid, _Count2);

  if (_Pred(*_Mid, _Val))
   {
   _First = ++_Mid;
   _Count -= _Count2 + 1;
   }
  else
   _Count = _Count2;
  }

 return (_First);
 }

template<class _FwdIt,
 class _Ty,
 class _Pr> inline
 _FwdIt lower_bound(_FwdIt _First, _FwdIt _Last,
  const _Ty& _Val, _Pr _Pred)
 {
                            ;
 return (_Rechecked(_First,
  _Lower_bound_unchecked(_Unchecked(_First), _Unchecked(_Last), _Val, _Pred)));
 }


template<class _FwdIt,
 class _Ty> inline
 _FwdIt lower_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
 {
 return (::std:: lower_bound(_First, _Last, _Val, less<>()));
 }


template<class _FwdIt,
 class _Ty,
 class _Pr> inline
 _FwdIt _Upper_bound_unchecked(_FwdIt _First, _FwdIt _Last,
  const _Ty& _Val, _Pr& _Pred)
 {
 _Iter_diff_t<_FwdIt> _Count = ::std:: distance(_First, _Last);

 while (0 < _Count)
  {
  _Iter_diff_t<_FwdIt> _Count2 = _Count / 2;
  _FwdIt _Mid = _First;
  ::std:: advance(_Mid, _Count2);

  if (!_Pred(_Val, *_Mid))
   {
   _First = ++_Mid;
   _Count -= _Count2 + 1;
   }
  else
   _Count = _Count2;
  }

 return (_First);
 }

template<class _FwdIt,
 class _Ty,
 class _Pr> inline
 _FwdIt upper_bound(_FwdIt _First, _FwdIt _Last,
  const _Ty& _Val, _Pr _Pred)
 {
                            ;
 return (_Rechecked(_First,
  _Upper_bound_unchecked(_Unchecked(_First), _Unchecked(_Last), _Val, _Pred)));
 }


template<class _FwdIt,
 class _Ty> inline
 _FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
 {
 return (::std:: upper_bound(_First, _Last, _Val, less<>()));
 }


template<class _FwdIt,
 class _Ty,
 class _Pr> inline
 pair<_FwdIt, _FwdIt>
  _Equal_range_unchecked(_FwdIt _First, _FwdIt _Last,
   const _Ty& _Val, _Pr& _Pred)
 {
 _Iter_diff_t<_FwdIt> _Count = ::std:: distance(_First, _Last);

 while (0 < _Count)
  {
  _Iter_diff_t<_FwdIt> _Count2 = _Count / 2;
  _FwdIt _Mid = _First;
  ::std:: advance(_Mid, _Count2);

  if (_Pred(*_Mid, _Val))
   {
   _First = ++_Mid;
   _Count -= _Count2 + 1;
   }
  else if (_Pred(_Val, *_Mid))
   _Count = _Count2;
  else
   {
   _FwdIt _First2 = _Lower_bound_unchecked(_First, _Mid, _Val, _Pred);
   ::std:: advance(_First, _Count);
   _FwdIt _Last2 = _Upper_bound_unchecked(++_Mid, _First, _Val, _Pred);
   return (pair<_FwdIt, _FwdIt>(_First2, _Last2));
   }
  }

 return (pair<_FwdIt, _FwdIt>(_First, _First));
 }

template<class _FwdIt,
 class _Ty,
 class _Pr> inline
 pair<_FwdIt, _FwdIt>
  equal_range(_FwdIt _First, _FwdIt _Last,
   const _Ty& _Val, _Pr _Pred)
 {
                            ;
 return (_Rechecked_both(_First, _Last,
  _Equal_range_unchecked(_Unchecked(_First), _Unchecked(_Last), _Val, _Pred)));
 }


template<class _FwdIt,
 class _Ty> inline
 pair<_FwdIt, _FwdIt>
  equal_range(_FwdIt _First, _FwdIt _Last,
   const _Ty& _Val)
 {
 return (::std:: equal_range(_First, _Last, _Val, less<>()));
 }


template<class _FwdIt,
 class _Ty,
 class _Pr> inline
 bool _Binary_search_unchecked(_FwdIt _First, _FwdIt _Last,
  const _Ty& _Val, _Pr& _Pred)
 {
 _First = _Lower_bound_unchecked(_First, _Last, _Val, _Pred);
 return (_First != _Last && !_Pred(_Val, *_First));
 }

template<class _FwdIt,
 class _Ty,
 class _Pr> inline
 bool binary_search(_FwdIt _First, _FwdIt _Last,
  const _Ty& _Val, _Pr _Pred)
 {
                            ;
 return (_Binary_search_unchecked(_Unchecked(_First), _Unchecked(_Last),
  _Val, _Pred));
 }


template<class _FwdIt,
 class _Ty> inline
 bool binary_search(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
 {
 return (::std:: binary_search(_First, _Last, _Val, less<>()));
 }


template<class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr> inline
 _OutIt _Merge_unchecked(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest, _Pr& _Pred)
 {
 if (_First1 != _Last1 && _First2 != _Last2)
  for (; ; )
   {
   if (_Pred(*_First2, *_First1))
    {
    *_Dest++ = *_First2++;
    if (_First2 == _Last2)
     break;
    }
   else
    {
    *_Dest++ = *_First1++;
    if (_First1 == _Last1)
     break;
    }
   }

 _Dest = _Copy_unchecked(_First1, _Last1, _Dest);
 return (_Copy_unchecked(_First2, _Last2, _Dest));
 }

template<class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr> inline
 _OutIt _Merge_no_deprecate1(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest, _Pr& _Pred, input_iterator_tag,
  input_iterator_tag, _Any_tag)
 {
 return (_Rechecked(_Dest,
  _Merge_unchecked(_First1, _Last1, _First2, _Last2, _Unchecked_idl0(_Dest), _Pred)));
 }

template<class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr> inline
 _OutIt _Merge_no_deprecate1(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest, _Pr& _Pred, random_access_iterator_tag,
  random_access_iterator_tag, random_access_iterator_tag)
 {
                                                                     ;
 return (_Rechecked(_Dest,
  _Merge_unchecked(_First1, _Last1, _First2, _Last2, _Unchecked(_Dest), _Pred)));
 }

template<class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr> inline
 _OutIt _Merge_no_deprecate(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest, _Pr& _Pred)
 {
                                          ;
                                          ;
                                                                 ;
 return (_Merge_no_deprecate1(_Unchecked(_First1), _Unchecked(_Last1),
  _Unchecked(_First2), _Unchecked(_Last2),
  _Dest, _Pred,
  _Iter_cat_t<_InIt1>(), _Iter_cat_t<_InIt2>(), _Iter_cat_t<_OutIt>()));
 }

template<class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr> inline
 _OutIt merge(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest, _Pr _Pred)
 {
 struct _Unchecked_iterators { static void _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
 return (_Merge_no_deprecate(_First1, _Last1, _First2, _Last2, _Dest, _Pred));
 }
# 2446 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm" 3
template<class _InIt1,
 class _InIt2,
 class _OutIt> inline
 _OutIt merge(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest)
 {
 return (::std:: merge(_First1, _Last1, _First2, _Last2, _Dest,
  less<>()));
 }
# 2472 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm" 3
template<class _BidIt1,
 class _BidIt2,
 class _BidIt3,
 class _Pr> inline
 _BidIt3 _Buffered_merge_backward_unchecked(_BidIt1 _First1, _BidIt1 _Last1,
  _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr& _Pred,
  bool _In_place = false)
 {
 if (_First1 != _Last1 && _First2 != _Last2)
  for (; ; )
   {
   if (_Pred(*--_Last2, *--_Last1))
    {
    *--_Dest = ::std:: move(*_Last1);
    ++_Last2;
    if (_First1 == _Last1)
     break;
    }
   else
    {
    *--_Dest = ::std:: move(*_Last2);
    ++_Last1;
    if (_First2 == _Last2)
     break;
    }
   }

 _Dest = _Move_backward_unchecked(_First2, _Last2, _Dest);
 if (!_In_place)
  _Dest = _Move_backward_unchecked(_First1, _Last1, _Dest);
 return (_Dest);
 }

template<class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr> inline
 _OutIt _Buffered_merge_unchecked(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest, _Pr& _Pred, bool _In_place = false)
 {
 if (_First1 != _Last1 && _First2 != _Last2)
  for (; ; )
   {
   if (_Pred(*_First2, *_First1))
    {
    *_Dest++ = ::std:: move(*_First2++);
    if (_First2 == _Last2)
     break;
    }
   else
    {
    *_Dest++ = ::std:: move(*_First1++);
    if (_First1 == _Last1)
     break;
    }
   }

 _Dest = _Move_unchecked(_First1, _Last1, _Dest);
 if (!_In_place)
  _Dest = _Move_unchecked(_First2, _Last2, _Dest);
 return (_Dest);
 }

template<class _BidIt,
 class _Diff,
 class _Ty,
 class _Pr> inline
 void _Buffered_merge_unchecked(_BidIt _First, _BidIt _Mid, _BidIt _Last,
  _Diff _Count1, _Diff _Count2,
   _Temp_iterator<_Ty>& _Tempbuf, _Pr& _Pred)
 {
 if (_Count1 == 0 || _Count2 == 0)
  ;
 else if (_Count1 + _Count2 == 2)
  {
  if (_Pred(*_Mid, *_First))
   ::std:: iter_swap(_First, _Mid);
  }
 else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())
  {
  _Move_unchecked(_First, _Mid, _Tempbuf._Init());
  _Buffered_merge_unchecked(_Tempbuf._First(), _Tempbuf._Last(),
   _Mid, _Last, _First, _Pred, true);
  }
 else if (_Count2 <= _Tempbuf._Maxlen())
  {
  _Move_unchecked(_Mid, _Last, _Tempbuf._Init());
  _Buffered_merge_backward_unchecked(_First, _Mid,
   _Tempbuf._First(), _Tempbuf._Last(), _Last, _Pred, true);
  }
 else
  {
  _BidIt _Firstn, _Lastn;
  _Diff _Count1n, _Count2n;
  if (_Count2 < _Count1)
   {
   _Count1n = _Count1 / 2;
   _Firstn = _First;
   ::std:: advance(_Firstn, _Count1n);
   _Lastn = _Lower_bound_unchecked(_Mid, _Last, *_Firstn, _Pred);
   _Count2n = ::std:: distance(_Mid, _Lastn);
   }
  else
   {
   _Count2n = _Count2 / 2;
   _Lastn = _Mid;
   ::std:: advance(_Lastn, _Count2n);
   _Firstn = _Upper_bound_unchecked(_First, _Mid, *_Lastn, _Pred);
   _Count1n = ::std:: distance(_First, _Firstn);
   }
  _BidIt _Midn = _Buffered_rotate_unchecked(_Firstn, _Mid, _Lastn,
   _Count1 - _Count1n, _Count2n, _Tempbuf);
  _Buffered_merge_unchecked(_First, _Firstn, _Midn,
   _Count1n, _Count2n, _Tempbuf, _Pred);
  _Buffered_merge_unchecked(_Midn, _Lastn, _Last,
   _Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf, _Pred);
  }
 }

template<class _BidIt,
 class _Pr> inline
 void _Inplace_merge_unchecked(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr& _Pred)
 {
 if (_First != _Mid && _Mid != _Last)
  {
  _Iter_diff_t<_BidIt> _Count1 = ::std:: distance(_First, _Mid);
  _Iter_diff_t<_BidIt> _Count2 = ::std:: distance(_Mid, _Last);
  _Temp_iterator<_Iter_value_t<_BidIt>> _Tempbuf(_Count1 < _Count2 ? _Count1 : _Count2);
  _Buffered_merge_unchecked(_First, _Mid, _Last,
   _Count1, _Count2, _Tempbuf, _Pred);
  }
 }

template<class _BidIt,
 class _Pr> inline
 void inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr _Pred)
 {
                                       ;
                                      ;
 _Inplace_merge_unchecked(
  _Unchecked(_First), _Unchecked(_Mid), _Unchecked(_Last), _Pred);
 }


template<class _BidIt> inline
 void inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last)
 {
 ::std:: inplace_merge(_First, _Mid, _Last, less<>());
 }


template<class _BidIt,
 class _Pr> inline
 void _Insertion_sort_unchecked(_BidIt _First, _BidIt _Last, _Pr& _Pred)
 {
 if (_First != _Last)
  for (_BidIt _Next = _First; ++_Next != _Last; )
   {
   _BidIt _Next1 = _Next;
   _Iter_value_t<_BidIt> _Val = ::std:: move(*_Next);

   if (_Pred(_Val, *_First))
    {
    _Move_backward_unchecked(_First, _Next, ++_Next1);
    *_First = ::std:: move(_Val);
    }
   else
    {
    for (_BidIt _First1 = _Next1;
     _Pred(_Val, *--_First1);
     _Next1 = _First1)
     *_Next1 = ::std:: move(*_First1);
    *_Next1 = ::std:: move(_Val);
    }
   }
 }

template<class _RanIt,
 class _Pr> inline
 void _Med3_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr& _Pred)
 {
 if (_Pred(*_Mid, *_First))
  ::std:: iter_swap(_Mid, _First);
 if (_Pred(*_Last, *_Mid))
  {
  ::std:: iter_swap(_Last, _Mid);
  if (_Pred(*_Mid, *_First))
   ::std:: iter_swap(_Mid, _First);
  }
 }

template<class _RanIt,
 class _Pr> inline
 void _Guess_median_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr& _Pred)
 {
 if (40 < _Last - _First)
  {
  size_t _Step = (_Last - _First + 1) / 8;
  _Med3_unchecked(_First, _First + _Step, _First + 2 * _Step, _Pred);
  _Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);
  _Med3_unchecked(_Last - 2 * _Step, _Last - _Step, _Last, _Pred);
  _Med3_unchecked(_First + _Step, _Mid, _Last - _Step, _Pred);
  }
 else
  _Med3_unchecked(_First, _Mid, _Last, _Pred);
 }

template<class _RanIt,
 class _Pr> inline
 pair<_RanIt, _RanIt>
  _Partition_by_median_guess_unchecked(_RanIt _First, _RanIt _Last, _Pr& _Pred)
 {
 _RanIt _Mid = _First + (_Last - _First) / 2;
 _Guess_median_unchecked(_First, _Mid, _Last - 1, _Pred);
 _RanIt _Pfirst = _Mid;
 _RanIt _Plast = _Pfirst + 1;

 while (_First < _Pfirst
  && !_Pred(*(_Pfirst - 1), *_Pfirst)
  && !_Pred(*_Pfirst, *(_Pfirst - 1)))
  --_Pfirst;
 while (_Plast < _Last
  && !_Pred(*_Plast, *_Pfirst)
  && !_Pred(*_Pfirst, *_Plast))
  ++_Plast;

 _RanIt _Gfirst = _Plast;
 _RanIt _Glast = _Pfirst;

 for (; ; )
  {
  for (; _Gfirst < _Last; ++_Gfirst)
   if (_Pred(*_Pfirst, *_Gfirst))
    ;
   else if (_Pred(*_Gfirst, *_Pfirst))
    break;
   else if (_Plast++ != _Gfirst)
    ::std:: iter_swap(_Plast - 1, _Gfirst);
  for (; _First < _Glast; --_Glast)
   if (_Pred(*(_Glast - 1), *_Pfirst))
    ;
   else if (_Pred(*_Pfirst, *(_Glast - 1)))
    break;
   else if (--_Pfirst != _Glast - 1)
    ::std:: iter_swap(_Pfirst, _Glast - 1);
  if (_Glast == _First && _Gfirst == _Last)
   return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

  if (_Glast == _First)
   {
   if (_Plast != _Gfirst)
    ::std:: iter_swap(_Pfirst, _Plast);
   ++_Plast;
   ::std:: iter_swap(_Pfirst++, _Gfirst++);
   }
  else if (_Gfirst == _Last)
   {
   if (--_Glast != --_Pfirst)
    ::std:: iter_swap(_Glast, _Pfirst);
   ::std:: iter_swap(_Pfirst, --_Plast);
   }
  else
   ::std:: iter_swap(_Gfirst++, --_Glast);
  }
 }

template<class _RanIt,
 class _Diff,
 class _Pr> inline
 void _Sort_unchecked1(_RanIt _First, _RanIt _Last, _Diff _Ideal, _Pr& _Pred)
 {
 _Diff _Count;
 while (_ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal)
  {
  pair<_RanIt, _RanIt> _Mid =
   _Partition_by_median_guess_unchecked(_First, _Last, _Pred);
  _Ideal /= 2, _Ideal += _Ideal / 2;

  if (_Mid.first - _First < _Last - _Mid.second)
   {
   _Sort_unchecked1(_First, _Mid.first, _Ideal, _Pred);
   _First = _Mid.second;
   }
  else
   {
   _Sort_unchecked1(_Mid.second, _Last, _Ideal, _Pred);
   _Last = _Mid.first;
   }
  }

 if (_ISORT_MAX < _Count)
  {
  _Make_heap_unchecked(_First, _Last, _Pred);
  _Sort_heap_unchecked(_First, _Last, _Pred);
  }
 else if (2 <= _Count)
  _Insertion_sort_unchecked(_First, _Last, _Pred);
 }

template<class _RanIt,
 class _Pr> inline
 void _Sort_unchecked(_RanIt _First, _RanIt _Last, _Pr& _Pred)
 {
 _Sort_unchecked1(_First, _Last, _Last - _First, _Pred);
 }

template<class _RanIt,
 class _Pr> inline
 void sort(_RanIt _First, _RanIt _Last, _Pr _Pred)
 {
                            ;
 _Sort_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred);
 }


template<class _RanIt> inline
 void sort(_RanIt _First, _RanIt _Last)
 {
 ::std:: sort(_First, _Last, less<>());
 }


template<class _BidIt,
 class _OutIt,
 class _Diff,
 class _Pr> inline
 void _Chunked_merge_unchecked(_BidIt _First, _BidIt _Last, _OutIt _Dest,
  _Diff _Chunk, _Diff _Count, _Pr& _Pred)
 {
 for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)
  {
  _BidIt _Mid1 = _First;
  ::std:: advance(_Mid1, _Chunk);
  _BidIt _Mid2 = _Mid1;
  ::std:: advance(_Mid2, _Chunk);

  _Dest = _Buffered_merge_unchecked(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);
  _First = _Mid2;
  }

 if (_Count <= _Chunk)
  _Move_unchecked(_First, _Last, _Dest);
 else
  {
  _BidIt _Mid1 = _First;
  ::std:: advance(_Mid1, _Chunk);

  _Buffered_merge_unchecked(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);
  }
 }

template<class _BidIt,
 class _Diff,
 class _Ty,
 class _Pr> inline
 void _Buffered_merge_sort_unchecked(_BidIt _First, _BidIt _Last, _Diff _Count,
  _Temp_iterator<_Ty>& _Tempbuf, _Pr& _Pred)
 {
 _BidIt _Mid = _First;
 for (_Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX)
  {
  _BidIt _Midn = _Mid;
  ::std:: advance(_Midn, (int)_ISORT_MAX);

  _Insertion_sort_unchecked(_Mid, _Midn, _Pred);
  _Mid = _Midn;
  }
 _Insertion_sort_unchecked(_Mid, _Last, _Pred);

 for (_Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2)
  {
  _Chunked_merge_unchecked(_First, _Last, _Tempbuf._Init(),
   _Chunk, _Count, _Pred);
  _Chunked_merge_unchecked(_Tempbuf._First(), _Tempbuf._Last(), _First,
   _Chunk *= 2, _Count, _Pred);
  }
 }

template<class _BidIt,
 class _Diff,
 class _Ty,
 class _Pr> inline
 void _Stable_sort_unchecked1(_BidIt _First, _BidIt _Last, _Diff _Count,
  _Temp_iterator<_Ty>& _Tempbuf, _Pr& _Pred)
 {
 if (_Count <= _ISORT_MAX)
  _Insertion_sort_unchecked(_First, _Last, _Pred);
 else
  {
  _Diff _Count2 = (_Count + 1) / 2;
  _BidIt _Mid = _First;
  ::std:: advance(_Mid, _Count2);

  if (_Count2 <= _Tempbuf._Maxlen())
   {
   _Buffered_merge_sort_unchecked(_First, _Mid, _Count2, _Tempbuf, _Pred);
   _Buffered_merge_sort_unchecked(_Mid, _Last, _Count - _Count2,
    _Tempbuf, _Pred);
   }
  else
   {
   _Stable_sort_unchecked1(_First, _Mid, _Count2, _Tempbuf, _Pred);
   _Stable_sort_unchecked1(_Mid, _Last, _Count - _Count2, _Tempbuf, _Pred);
   }

  _Buffered_merge_unchecked(_First, _Mid, _Last,
   _Count2, _Count - _Count2, _Tempbuf, _Pred);
  }
 }

template<class _BidIt,
 class _Pr> inline
 void _Stable_sort_unchecked(_BidIt _First, _BidIt _Last, _Pr& _Pred)
 {
 if (_First != _Last)
  {
  _Iter_diff_t<_BidIt> _Count = ::std:: distance(_First, _Last);
  _Temp_iterator<_Iter_value_t<_BidIt>> _Tempbuf((_Count + 1) / 2);
  _Stable_sort_unchecked1(_First, _Last, _Count, _Tempbuf, _Pred);
  }
 }

template<class _BidIt,
 class _Pr> inline
 void stable_sort(_BidIt _First, _BidIt _Last, _Pr _Pred)
 {
                            ;
 _Stable_sort_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred);
 }


template<class _BidIt> inline
 void stable_sort(_BidIt _First, _BidIt _Last)
 {
 ::std:: stable_sort(_First, _Last, less<>());
 }


template<class _RanIt,
 class _Pr> inline
 void _Partial_sort_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last,
  _Pr& _Pred)
 {
 if (_First == _Mid)
  return;
 _Make_heap_unchecked(_First, _Mid, _Pred);
 for (_RanIt _Next = _Mid; _Next < _Last; ++_Next)
  if (_Pred(*_Next, *_First))
   {
   _Iter_value_t<_RanIt> _Val = ::std:: move(*_Next);
   _Pop_heap_hole_unchecked(_First, _Mid, _Next, ::std:: move(_Val), _Pred);
   }
 _Sort_heap_unchecked(_First, _Mid, _Pred);
 }

template<class _RanIt,
 class _Pr> inline
 void partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred)
 {
                           ;
                          ;
                                              ;
 _Partial_sort_unchecked(
  _Unchecked(_First), _Unchecked(_Mid), _Unchecked(_Last), _Pred);
 }


template<class _RanIt> inline
 void partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last)
 {
 ::std:: partial_sort(_First, _Mid, _Last, less<>());
 }


template<class _InIt,
 class _RanIt,
 class _Pr> inline
 _RanIt _Partial_sort_copy_unchecked(_InIt _First1, _InIt _Last1,
  _RanIt _First2, _RanIt _Last2, _Pr& _Pred)
 {
 _RanIt _Mid2 = _First2;
 if (_First1 != _Last1 && _First2 != _Last2)
  {
  for (; _First1 != _Last1 && _Mid2 != _Last2; ++_First1, (void)++_Mid2)
   *_Mid2 = *_First1;
  _Make_heap_unchecked(_First2, _Mid2, _Pred);

  for (; _First1 != _Last1; ++_First1)
   if (_Pred(*_First1, *_First2))
    _Pop_heap_hole_by_index(_First2, _Iter_diff_t<_RanIt>(0), _Iter_diff_t<_RanIt>(_Mid2 - _First2),
     _Iter_value_t<_InIt>(*_First1), _Pred);

  _Sort_heap_unchecked(_First2, _Mid2, _Pred);
  }

 return (_Mid2);
 }

template<class _InIt,
 class _RanIt,
 class _Pr> inline
 _RanIt partial_sort_copy(_InIt _First1, _InIt _Last1,
  _RanIt _First2, _RanIt _Last2, _Pr _Pred)
 {
                              ;
                              ;
 return (_Rechecked(_First2,
  _Partial_sort_copy_unchecked(
   _Unchecked(_First1), _Unchecked(_Last1),
   _Unchecked(_First2), _Unchecked(_Last2), _Pred)));
 }


template<class _InIt,
 class _RanIt> inline
 _RanIt partial_sort_copy(_InIt _First1, _InIt _Last1,
  _RanIt _First2, _RanIt _Last2)
 {
 return (::std:: partial_sort_copy(_First1, _Last1, _First2, _Last2,
  less<>()));
 }


template<class _RanIt,
 class _Pr> inline
 void _Nth_element_unchecked(_RanIt _First, _RanIt _Nth, _RanIt _Last, _Pr& _Pred)
 {
 if (_Nth == _Last)
  return;

 for (; _ISORT_MAX < _Last - _First; )
  {
  pair<_RanIt, _RanIt> _Mid =
   _Partition_by_median_guess_unchecked(_First, _Last, _Pred);

  if (_Mid.second <= _Nth)
   _First = _Mid.second;
  else if (_Mid.first <= _Nth)
   return;
  else
   _Last = _Mid.first;
  }

 _Insertion_sort_unchecked(_First, _Last, _Pred);
 }

template<class _RanIt,
 class _Pr> inline
 void nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last, _Pr _Pred)
 {
                           ;
                          ;
                                              ;
 _Nth_element_unchecked(
  _Unchecked(_First), _Unchecked(_Nth), _Unchecked(_Last), _Pred);
 }


template<class _RanIt> inline
 void nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last)
 {
 ::std:: nth_element(_First, _Nth, _Last, less<>());
 }


template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool _Includes_unchecked(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr& _Pred)
 {
 for (; _First1 != _Last1 && _First2 != _Last2; )
  if (_Pred(*_First2, *_First1))
   return (false);
  else if (_Pred(*_First1, *_First2))
   ++_First1;
  else
   {
   ++_First1;
   ++_First2;
   }

 return (_First2 == _Last2);
 }

template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool includes(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
 {
                                          ;
                                          ;
 return (_Includes_unchecked(_Unchecked(_First1), _Unchecked(_Last1),
  _Unchecked(_First2), _Unchecked(_Last2), _Pred));
 }


template<class _InIt1,
 class _InIt2> inline
 bool includes(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2)
 {
 return (::std:: includes(_First1, _Last1, _First2, _Last2,
  less<>()));
 }


template<class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr> inline
 _OutIt _Set_union_no_deprecate1(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr& _Pred)
 {
 for (; _First1 != _Last1 && _First2 != _Last2; )
  if (_Pred(*_First1, *_First2))
   {
   *_Dest++ = *_First1;
   ++_First1;
   }
  else if (_Pred(*_First2, *_First1))
   {
   *_Dest++ = *_First2;
   ++_First2;
   }
  else
   {
   *_Dest++ = *_First1;
   ++_First1;
   ++_First2;
   }
 _Dest = _Copy_no_deprecate(_First1, _Last1, _Dest);
 return (_Copy_no_deprecate(_First2, _Last2, _Dest));
 }

template<class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr> inline
 _OutIt _Set_union_no_deprecate(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr& _Pred)
 {
                                          ;
                                          ;
                                                                 ;
 return (_Rechecked(_Dest,
  _Set_union_no_deprecate1(_Unchecked(_First1), _Unchecked(_Last1),
  _Unchecked(_First2), _Unchecked(_Last2),
  _Unchecked_idl0(_Dest), _Pred)));
 }

template<class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr> inline
 _OutIt set_union(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
 {
 struct _Unchecked_iterators { static void _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
 return (_Set_union_no_deprecate(_First1, _Last1, _First2, _Last2, _Dest, _Pred));
 }
# 3153 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm" 3
template<class _InIt1,
 class _InIt2,
 class _OutIt> inline
 _OutIt set_union(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
 {
 return (::std:: set_union(_First1, _Last1, _First2, _Last2, _Dest,
  less<>()));
 }
# 3177 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm" 3
template<class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr> inline
 _OutIt _Set_intersection_no_deprecate1(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr& _Pred)
 {
 for (; _First1 != _Last1 && _First2 != _Last2; )
  if (_Pred(*_First1, *_First2))
   ++_First1;
  else if (_Pred(*_First2, *_First1))
   ++_First2;
  else
   {
                        ;
   *_Dest++ = *_First1++;
   ++_First2;
   }

 return (_Dest);
 }

template<class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr> inline
 _OutIt _Set_intersection_no_deprecate(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr& _Pred)
 {
                                          ;
                                          ;
 return (_Rechecked(_Dest,
  _Set_intersection_no_deprecate1(_Unchecked(_First1), _Unchecked(_Last1),
  _Unchecked(_First2), _Unchecked(_Last2),
  _Unchecked_idl0(_Dest), _Pred)));
 }

template<class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr> inline
 _OutIt set_intersection(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
 {
 struct _Unchecked_iterators { static void _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
 return (_Set_intersection_no_deprecate(_First1, _Last1, _First2, _Last2, _Dest, _Pred));
 }
# 3242 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm" 3
template<class _InIt1,
 class _InIt2,
 class _OutIt> inline
 _OutIt set_intersection(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
 {
 return (::std:: set_intersection(_First1, _Last1, _First2, _Last2, _Dest,
  less<>()));
 }
# 3266 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm" 3
template<class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr> inline
 _OutIt _Set_difference_no_deprecate1(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest, _Pr& _Pred)
 {
 for (; _First1 != _Last1 && _First2 != _Last2; )
  if (_Pred(*_First1, *_First2))
   {
                        ;
   *_Dest++ = *_First1;
   ++_First1;
   }
  else if (_Pred(*_First2, *_First1))
   ++_First2;
  else
   {
   ++_First1;
   ++_First2;
   }

 return (_Copy_no_deprecate(_First1, _Last1, _Dest));
 }

template<class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr> inline
 _OutIt _Set_difference_no_deprecate(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest, _Pr& _Pred)
 {
                                          ;
                                          ;
 return (_Rechecked(_Dest,
  _Set_difference_no_deprecate1(_Unchecked(_First1), _Unchecked(_Last1),
  _Unchecked(_First2), _Unchecked(_Last2),
  _Unchecked_idl0(_Dest), _Pred)));
 }

template<class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr> inline
 _OutIt set_difference(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest, _Pr _Pred)
 {
 struct _Unchecked_iterators { static void _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
 return (_Set_difference_no_deprecate(_First1, _Last1, _First2, _Last2, _Dest, _Pred));
 }
# 3338 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm" 3
template<class _InIt1,
 class _InIt2,
 class _OutIt> inline
 _OutIt set_difference(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest)
 {
 return (::std:: set_difference(_First1, _Last1, _First2, _Last2, _Dest,
  less<>()));
 }
# 3364 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm" 3
template<class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr> inline
 _OutIt _Set_symmetric_difference_no_deprecate1(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest, _Pr& _Pred)
 {
 for (; _First1 != _Last1 && _First2 != _Last2; )
  if (_Pred(*_First1, *_First2))
   {
                        ;
   *_Dest++ = *_First1;
   ++_First1;
   }
  else if (_Pred(*_First2, *_First1))
   {
                        ;
   *_Dest++ = *_First2;
   ++_First2;
   }
  else
   {
   ++_First1;
   ++_First2;
   }
 _Dest = _Copy_no_deprecate(_First1, _Last1, _Dest);
 return (_Copy_no_deprecate(_First2, _Last2, _Dest));
 }

template<class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr> inline
 _OutIt _Set_symmetric_difference_no_deprecate(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest, _Pr& _Pred)
 {
                                          ;
                                          ;
 return (_Rechecked(_Dest,
  _Set_symmetric_difference_no_deprecate1(
  _Unchecked(_First1), _Unchecked(_Last1),
  _Unchecked(_First2), _Unchecked(_Last2),
  _Unchecked_idl0(_Dest), _Pred)));
 }

template<class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr> inline
 _OutIt set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest, _Pr _Pred)
 {
 struct _Unchecked_iterators { static void _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
 return (_Set_symmetric_difference_no_deprecate(
  _First1, _Last1, _First2, _Last2, _Dest, _Pred));
 }
# 3442 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm" 3
template<class _InIt1,
 class _InIt2,
 class _OutIt> inline
 _OutIt set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest)
 {
 return (::std:: set_symmetric_difference(_First1, _Last1, _First2, _Last2,
  _Dest, less<>()));
 }
# 3468 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm" 3
template<class _FwdIt,
 class _Pr> inline
 _FwdIt _Max_element_unchecked(_FwdIt _First, _FwdIt _Last, _Pr& _Pred)
 {
 _FwdIt _Found = _First;
 if (_First != _Last)
  for (; ++_First != _Last; )
   if (_Pred(*_Found, *_First))
    _Found = _First;
 return (_Found);
 }

template<class _FwdIt,
 class _Pr> inline
 _FwdIt max_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
 {
                            ;
 return (_Rechecked(_First,
  _Max_element_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred)));
 }


template<class _FwdIt> inline
 _FwdIt max_element(_FwdIt _First, _FwdIt _Last)
 {
 return (::std:: max_element(_First, _Last, less<>()));
 }


template<class _FwdIt,
 class _Pr> inline
 _FwdIt _Min_element_unchecked(_FwdIt _First, _FwdIt _Last, _Pr& _Pred)
 {
 _FwdIt _Found = _First;
 if (_First != _Last)
  for (; ++_First != _Last; )
   if (_Pred(*_First, *_Found))
    _Found = _First;
 return (_Found);
 }

template<class _FwdIt,
 class _Pr> inline
 _FwdIt min_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
 {
                            ;
 return (_Rechecked(_First,
  _Min_element_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred)));
 }


template<class _FwdIt> inline
 _FwdIt min_element(_FwdIt _First, _FwdIt _Last)
 {
 return (::std:: min_element(_First, _Last, less<>()));
 }


template<class _FwdIt,
 class _Pr> inline
 pair<_FwdIt, _FwdIt>
  _Minmax_element_unchecked(_FwdIt _First, _FwdIt _Last, _Pr& _Pred)
 {
 pair<_FwdIt, _FwdIt> _Found(_First, _First);

 if (_First != _Last)
  for (; ++_First != _Last; )
   {
   _FwdIt _Next = _First;
   if (++_Next == _Last)
    {
    if (_Pred(*_First, *_Found.first))
     _Found.first = _First;
    else if (!_Pred(*_First, *_Found.second))
     _Found.second = _First;
    }
   else
    {
    if (_Pred(*_Next, *_First))
     {
     if (_Pred(*_Next, *_Found.first))
      _Found.first = _Next;
     if (!_Pred(*_First, *_Found.second))
      _Found.second = _First;
     }
    else
     {
     if (_Pred(*_First, *_Found.first))
      _Found.first = _First;
     if (!_Pred(*_Next, *_Found.second))
      _Found.second = _Next;
     }
    _First = _Next;
    }
   }

 return (_Found);
 }

template<class _FwdIt,
 class _Pr> inline
 pair<_FwdIt, _FwdIt>
  minmax_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
 {
                            ;
 return (_Rechecked_both(_First, _Last,
  _Minmax_element_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred)));
 }


template<class _FwdIt> inline
 pair<_FwdIt, _FwdIt>
  minmax_element(_FwdIt _First, _FwdIt _Last)
 {
 return (::std:: minmax_element(_First, _Last, less<>()));
 }


template<class _Ty,
 class _Pr> inline
 constexpr const _Ty& (max)(const _Ty& _Left, const _Ty& _Right,
  _Pr _Pred)
  noexcept(noexcept(_Pred(_Left, _Right)))
 {
 return (_Pred(_Left, _Right) ? _Right : _Left);
 }

template<class _Ty,
 class _Pr> inline

 _Ty (max)(::std:: initializer_list<_Ty> _Ilist, _Pr _Pred)
 {
 const _Ty *_Res = _Max_element_unchecked(_Ilist.begin(), _Ilist.end(), _Pred);
 return (*_Res);
 }


template<class _Ty> inline



 constexpr const _Ty& (max)(const _Ty& _Left, const _Ty& _Right)
  noexcept(noexcept(((_Left) < (_Right))))
 {
 return (((_Left) < (_Right)) ? _Right : _Left);
 }

template<class _Ty> inline

 _Ty (max)(::std:: initializer_list<_Ty> _Ilist)
 {
 return ((::std:: max)(_Ilist, less<>()));
 }


template<class _Ty,
 class _Pr> inline
 constexpr const _Ty& (min)(const _Ty& _Left, const _Ty& _Right,
  _Pr _Pred)
  noexcept(noexcept(_Pred(_Right, _Left)))
 {
 return (_Pred(_Right, _Left) ? _Right : _Left);
 }

template<class _Ty,
 class _Pr> inline

 _Ty (min)(::std:: initializer_list<_Ty> _Ilist, _Pr _Pred)
 {
 const _Ty *_Res = _Min_element_unchecked(_Ilist.begin(), _Ilist.end(), _Pred);
 return (*_Res);
 }


template<class _Ty> inline



 constexpr const _Ty& (min)(const _Ty& _Left, const _Ty& _Right)
  noexcept(noexcept(((_Right) < (_Left))))
 {
 return (((_Right) < (_Left)) ? _Right : _Left);
 }

template<class _Ty> inline

 _Ty (min)(::std:: initializer_list<_Ty> _Ilist)
 {
 return ((::std:: min)(_Ilist, less<>()));
 }



template<class _Ty,
 class _Pr> inline
 constexpr pair<const _Ty&, const _Ty&>
  minmax(const _Ty& _Left, const _Ty& _Right, _Pr _Pred)
 {
 return (_Pred(_Right, _Left)
  ? pair<const _Ty&, const _Ty&>(_Right, _Left)
  : pair<const _Ty&, const _Ty&>(_Left, _Right));
 }

template<class _Ty,
 class _Pr> inline

 pair<_Ty, _Ty> minmax(::std:: initializer_list<_Ty> _Ilist,
  _Pr _Pred)
 {
 pair<const _Ty *, const _Ty *> _Res = _Minmax_element_unchecked(
  _Ilist.begin(), _Ilist.end(), _Pred);
 return (pair<_Ty, _Ty>(*_Res.first, *_Res.second));
 }


template<class _Ty> inline
 constexpr pair<const _Ty&, const _Ty&>
  minmax(const _Ty& _Left, const _Ty& _Right)
 {
 return (_Right < _Left
  ? pair<const _Ty&, const _Ty&>(_Right, _Left)
  : pair<const _Ty&, const _Ty&>(_Left, _Right));
 }

template<class _Ty> inline

 pair<_Ty, _Ty> minmax(::std:: initializer_list<_Ty> _Ilist)
 {
 return (::std:: minmax(_Ilist, less<>()));
 }


template<class _BidIt,
 class _Pr> inline
 bool _Next_permutation_unchecked(_BidIt _First, _BidIt _Last, _Pr& _Pred)
 {
 _BidIt _Next = _Last;
 if (_First == _Last || _First == --_Next)
  return (false);

 for (; ; )
  {
  _BidIt _Next1 = _Next;
  if (_Pred(*--_Next, *_Next1))
   {
   _BidIt _Mid = _Last;
   for (; !_Pred(*_Next, *--_Mid); )
    ;
   ::std:: iter_swap(_Next, _Mid);
   _Reverse_unchecked(_Next1, _Last);
   return (true);
   }

  if (_Next == _First)
   {
   _Reverse_unchecked(_First, _Last);
   return (false);
   }
  }
 }

template<class _BidIt,
 class _Pr> inline
 bool next_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred)
 {
                                       ;
 return (_Next_permutation_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred));
 }


template<class _BidIt> inline
 bool next_permutation(_BidIt _First, _BidIt _Last)
 {
 return (::std:: next_permutation(_First, _Last, less<>()));
 }


template<class _BidIt,
 class _Pr> inline
 bool _Prev_permutation_unchecked(_BidIt _First, _BidIt _Last, _Pr& _Pred)
 {
 _BidIt _Next = _Last;
 if (_First == _Last || _First == --_Next)
  return (false);

 for (; ; )
  {
  _BidIt _Next1 = _Next;
  if (_Pred(*_Next1, *--_Next))
   {
   _BidIt _Mid = _Last;
   for (; !_Pred(*--_Mid, *_Next); )
    ;
   ::std:: iter_swap(_Next, _Mid);
   _Reverse_unchecked(_Next1, _Last);
   return (true);
   }

  if (_Next == _First)
   {
   _Reverse_unchecked(_First, _Last);
   return (false);
   }
  }
 }

template<class _BidIt,
 class _Pr> inline
 bool prev_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred)
 {
                                       ;
 return (_Prev_permutation_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred));
 }


template<class _BidIt> inline
 bool prev_permutation(_BidIt _First, _BidIt _Last)
 {
 return (::std:: prev_permutation(_First, _Last, less<>()));
 }


template<class _RanIt,
 class _Pr> inline
 _RanIt _Is_heap_until_unchecked(_RanIt _First, _RanIt _Last, _Pr& _Pred)
 {
 _Iter_diff_t<_RanIt> _Size = _Last - _First;

 if (2 <= _Size)
  for (_Iter_diff_t<_RanIt> _Off = 0; ++_Off < _Size; )
   if (_Pred(*(_First + (_Off - 1) / 2), *(_First + _Off)))

    return (_First + _Off);
 return (_Last);
 }

template<class _RanIt,
 class _Pr> inline
 _RanIt is_heap_until(_RanIt _First, _RanIt _Last, _Pr _Pred)
 {
                            ;
 return (_Rechecked(_First,
  _Is_heap_until_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred)));
 }

template<class _RanIt,
 class _Pr> inline
 bool is_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
 {
                            ;
 return (_Is_heap_until_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred) == _Unchecked(_Last));
 }


template<class _RanIt> inline
 _RanIt is_heap_until(_RanIt _First, _RanIt _Last)
 {
 return (::std:: is_heap_until(_First, _Last, less<>()));
 }

template<class _RanIt> inline
 bool is_heap(_RanIt _First, _RanIt _Last)
 {
 return (::std:: is_heap(_First, _Last, less<>()));
 }


template<class _FwdIt,
 class _Pr> inline
 _FwdIt _Is_sorted_until_unchecked(_FwdIt _First, _FwdIt _Last, _Pr& _Pred)
 {
 if (_First != _Last)
  for (_FwdIt _Next = _First; ++_Next != _Last; ++_First)
   if (_Pred(*_Next, *_First))
    return (_Next);
 return (_Last);
 }

template<class _FwdIt,
 class _Pr> inline
 _FwdIt is_sorted_until(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
 {
                            ;
 return (_Rechecked(_First,
  _Is_sorted_until_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred)));
 }

template<class _FwdIt,
 class _Pr> inline
 bool is_sorted(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
 {
                            ;
 return (_Is_sorted_until_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred) == _Unchecked(_Last));
 }


template<class _FwdIt> inline
 _FwdIt is_sorted_until(_FwdIt _First, _FwdIt _Last)
 {
 return (::std:: is_sorted_until(_First, _Last, less<>()));
 }

template<class _FwdIt> inline
 bool is_sorted(_FwdIt _First, _FwdIt _Last)
 {
 return (::std:: is_sorted(_First, _Last, less<>()));
 }
# 3908 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm" 3
}

#pragma warning(pop)
#pragma pack(pop)
# 60 "..\\..\\..\\JUCE\\modules\\juce_core/system/juce_StandardHeader.h" 2




# 1 "..\\..\\..\\JUCE\\modules\\juce_core/system/juce_CompilerSupport.h" 1
# 64 "..\\..\\..\\JUCE\\modules\\juce_core/system/juce_StandardHeader.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/system/juce_PlatformDefs.h" 1
# 75 "..\\..\\..\\JUCE\\modules\\juce_core/system/juce_PlatformDefs.h"
#pragma intrinsic (__debugbreak)
# 65 "..\\..\\..\\JUCE\\modules\\juce_core/system/juce_StandardHeader.h" 2





#pragma warning(push)
#pragma warning(disable: 4514 4245 4100)
# 97 "..\\..\\..\\JUCE\\modules\\juce_core/system/juce_StandardHeader.h"
#pragma warning(pop)
# 182 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2


namespace juce
{

class StringRef;
class MemoryBlock;
class File;
class InputStream;
class OutputStream;
class DynamicObject;
class FileInputStream;
class FileOutputStream;
class XmlElement;
class JSONFormatter;

extern bool __stdcall juce_isRunningUnderDebugger() noexcept;
extern void __stdcall logAssertion (const char* file, int line) noexcept;


# 1 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_Memory.h" 1
# 36 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_Memory.h"
inline void zeromem (void* memory, size_t numBytes) noexcept { memset (memory, 0, numBytes); }


template <typename Type>
inline void zerostruct (Type& structure) noexcept { memset (&structure, 0, sizeof (structure)); }






template <typename Type>
inline void deleteAndZero (Type& pointer) { delete pointer; pointer = nullptr; }





template <typename Type, typename IntegerType>
inline Type* addBytesToPointer (Type* basePointer, IntegerType bytes) noexcept { return (Type*) (((char*) basePointer) + bytes); }




template <typename Type1, typename Type2>
inline int getAddressDifference (Type1* pointer1, Type2* pointer2) noexcept { return (int) (((const char*) pointer1) - (const char*) pointer2); }




template <class Type>
inline Type* createCopyIfNotNull (const Type* objectToCopy) { return objectToCopy != nullptr ? new Type (*objectToCopy) : nullptr; }



template <typename Type>
inline Type readUnaligned (const void* srcPtr) noexcept
{
    Type value;
    memcpy (&value, srcPtr, sizeof (Type));

    return value;
}


template <typename Type>
inline void writeUnaligned (void* dstPtr, Type value) noexcept
{
    memcpy (dstPtr, &value, sizeof(Type));
}
# 201 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_MathsFunctions.h" 1
# 43 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_MathsFunctions.h"
typedef signed char int8;

typedef unsigned char uint8;

typedef signed short int16;

typedef unsigned short uint16;

typedef signed int int32;

typedef unsigned int uint32;



  typedef __int64 int64;

  typedef unsigned __int64 uint64;
# 83 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_MathsFunctions.h"
  typedef int pointer_sized_int;

  typedef unsigned int pointer_sized_uint;
# 94 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_MathsFunctions.h"
  typedef pointer_sized_int ssize_t;






template <typename Type>
Type jmax (const Type a, const Type b) { return (a < b) ? b : a; }


template <typename Type>
Type jmax (const Type a, const Type b, const Type c) { return (a < b) ? ((b < c) ? c : b) : ((a < c) ? c : a); }


template <typename Type>
Type jmax (const Type a, const Type b, const Type c, const Type d) { return jmax (a, jmax (b, c, d)); }


template <typename Type>
Type jmin (const Type a, const Type b) { return (b < a) ? b : a; }


template <typename Type>
Type jmin (const Type a, const Type b, const Type c) { return (b < a) ? ((c < b) ? c : b) : ((c < a) ? c : a); }


template <typename Type>
Type jmin (const Type a, const Type b, const Type c, const Type d) { return jmin (a, jmin (b, c, d)); }




template <typename Type>
Type jmap (Type value0To1, Type targetRangeMin, Type targetRangeMax)
{
    return targetRangeMin + value0To1 * (targetRangeMax - targetRangeMin);
}


template <typename Type>
Type jmap (Type sourceValue, Type sourceRangeMin, Type sourceRangeMax, Type targetRangeMin, Type targetRangeMax)
{
#pragma warning(push)
# 137 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_MathsFunctions.h"
#pragma warning(disable: 4127)
# 137 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_MathsFunctions.h"
 do { ; } while (false)
# 137 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_MathsFunctions.h"
#pragma warning(pop)
# 137 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_MathsFunctions.h"
;
    return targetRangeMin + ((targetRangeMax - targetRangeMin) * (sourceValue - sourceRangeMin)) / (sourceRangeMax - sourceRangeMin);
}


template <typename Type>
Type findMinimum (const Type* data, int numValues)
{
    if (numValues <= 0)
        return Type();

    Type result (*data++);

    while (--numValues > 0)
    {
        const Type& v = *data++;
        if (v < result) result = v;
    }

    return result;
}


template <typename Type>
Type findMaximum (const Type* values, int numValues)
{
    if (numValues <= 0)
        return Type();

    Type result (*values++);

    while (--numValues > 0)
    {
        const Type& v = *values++;
        if (result < v) result = v;
    }

    return result;
}


template <typename Type>
void findMinAndMax (const Type* values, int numValues, Type& lowest, Type& highest)
{
    if (numValues <= 0)
    {
        lowest = Type();
        highest = Type();
    }
    else
    {
        Type mn (*values++);
        Type mx (mn);

        while (--numValues > 0)
        {
            const Type& v = *values++;

            if (mx < v) mx = v;
            if (v < mn) mn = v;
        }

        lowest = mn;
        highest = mx;
    }
}
# 222 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_MathsFunctions.h"
template <typename Type>
Type jlimit (const Type lowerLimit,
             const Type upperLimit,
             const Type valueToConstrain) noexcept
{
#pragma warning(push)
# 227 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_MathsFunctions.h"
#pragma warning(disable: 4127)
# 227 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_MathsFunctions.h"
 do { ; } while (false)
# 227 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_MathsFunctions.h"
#pragma warning(pop)
# 227 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_MathsFunctions.h"
;

    return (valueToConstrain < lowerLimit) ? lowerLimit
                                           : ((upperLimit < valueToConstrain) ? upperLimit
                                                                              : valueToConstrain);
}






template <typename Type>
bool isPositiveAndBelow (Type valueToTest, Type upperLimit) noexcept
{
#pragma warning(push)
# 242 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_MathsFunctions.h"
#pragma warning(disable: 4127)
# 242 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_MathsFunctions.h"
 do { ; } while (false)
# 242 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_MathsFunctions.h"
#pragma warning(pop)
# 242 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_MathsFunctions.h"
;
    return Type() <= valueToTest && valueToTest < upperLimit;
}

template <>
inline bool isPositiveAndBelow (const int valueToTest, const int upperLimit) noexcept
{
#pragma warning(push)
# 249 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_MathsFunctions.h"
#pragma warning(disable: 4127)
# 249 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_MathsFunctions.h"
 do { ; } while (false)
# 249 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_MathsFunctions.h"
#pragma warning(pop)
# 249 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_MathsFunctions.h"
;
    return static_cast<unsigned int> (valueToTest) < static_cast<unsigned int> (upperLimit);
}






template <typename Type>
bool isPositiveAndNotGreaterThan (Type valueToTest, Type upperLimit) noexcept
{
#pragma warning(push)
# 261 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_MathsFunctions.h"
#pragma warning(disable: 4127)
# 261 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_MathsFunctions.h"
 do { ; } while (false)
# 261 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_MathsFunctions.h"
#pragma warning(pop)
# 261 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_MathsFunctions.h"
;
    return Type() <= valueToTest && valueToTest <= upperLimit;
}

template <>
inline bool isPositiveAndNotGreaterThan (const int valueToTest, const int upperLimit) noexcept
{
#pragma warning(push)
# 268 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_MathsFunctions.h"
#pragma warning(disable: 4127)
# 268 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_MathsFunctions.h"
 do { ; } while (false)
# 268 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_MathsFunctions.h"
#pragma warning(pop)
# 268 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_MathsFunctions.h"
;
    return static_cast<unsigned int> (valueToTest) <= static_cast<unsigned int> (upperLimit);
}



template <typename Type>
void swapVariables (Type& variable1, Type& variable2)
{
    std::swap (variable1, variable2);
}


template <typename Type1>
void ignoreUnused (const Type1&) noexcept {}

template <typename Type1, typename Type2>
void ignoreUnused (const Type1&, const Type2&) noexcept {}

template <typename Type1, typename Type2, typename Type3>
void ignoreUnused (const Type1&, const Type2&, const Type3&) noexcept {}

template <typename Type1, typename Type2, typename Type3, typename Type4>
void ignoreUnused (const Type1&, const Type2&, const Type3&, const Type4&) noexcept {}
# 301 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_MathsFunctions.h"
template <typename Type, int N>
int numElementsInArray (Type (&array)[N])
{
    ignoreUnused (array);
    (void) sizeof (0[array]);
    return N;
}






template <typename Type>
Type juce_hypot (Type a, Type b) noexcept
{

    return static_cast<Type> (_hypot (a, b));



}


template <>
inline float juce_hypot (float a, float b) noexcept
{

    return _hypotf (a, b);



}



inline int64 abs64 (const int64 n) noexcept
{
    return (n >= 0) ? n : -n;
}


 template<typename Type> Type asinh (Type x) { return std::log (x + std::sqrt (x * x + (Type) 1)); }
 template<typename Type> Type acosh (Type x) { return std::log (x + std::sqrt (x * x - (Type) 1)); }
 template<typename Type> Type atanh (Type x) { return (std::log (x + (Type) 1) - std::log (((Type) 1) - x)) / (Type) 2; }






const double double_Pi = 3.1415926535897932384626433832795;




const float float_Pi = 3.14159265358979323846f;



inline float degreesToRadians (float degrees) noexcept { return degrees * (float_Pi / 180.0f); }


inline double degreesToRadians (double degrees) noexcept { return degrees * (double_Pi / 180.0); }


inline float radiansToDegrees (float radians) noexcept { return radians * (180.0f / float_Pi); }


inline double radiansToDegrees (double radians) noexcept { return radians * (180.0 / double_Pi); }






template <typename NumericType>
bool juce_isfinite (NumericType) noexcept
{
    return true;
}

template <>
inline bool juce_isfinite (float value) noexcept
{

    return _finite (value) != 0;



}

template <>
inline bool juce_isfinite (double value) noexcept
{

    return _finite (value) != 0;



}



#pragma optimize ("t", off)

#pragma float_control (precise, on, push)
# 421 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_MathsFunctions.h"
template <typename FloatType>
int roundToInt (const FloatType value) noexcept
{




    union { int asInt[2]; double asDouble; } n;
    n.asDouble = ((double) value) + 6755399441055744.0;




    return n.asInt [0];

}

inline int roundToInt (int value) noexcept
{
    return value;
}



#pragma float_control (pop)

#pragma optimize ("", on)







inline int roundToIntAccurate (double value) noexcept
{




    return roundToInt (value + 1.5e-8);
}
# 475 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_MathsFunctions.h"
inline int roundDoubleToInt (double value) noexcept
{
    return roundToInt (value);
}
# 490 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_MathsFunctions.h"
inline int roundFloatToInt (float value) noexcept
{
    return roundToInt (value);
}



template <typename IntegerType>
bool isPowerOfTwo (IntegerType value)
{
   return (value & (value - 1)) == 0;
}


inline int nextPowerOfTwo (int n) noexcept
{
    --n;
    n |= (n >> 1);
    n |= (n >> 2);
    n |= (n >> 4);
    n |= (n >> 8);
    n |= (n >> 16);
    return n + 1;
}





int findHighestSetBit (uint32 n) noexcept;


inline int countNumberOfBits (uint32 n) noexcept
{
    n -= ((n >> 1) & 0x55555555);
    n = (((n >> 2) & 0x33333333) + (n & 0x33333333));
    n = (((n >> 4) + n) & 0x0f0f0f0f);
    n += (n >> 8);
    n += (n >> 16);
    return (int) (n & 0x3f);
}


inline int countNumberOfBits (uint64 n) noexcept
{
    return countNumberOfBits ((uint32) n) + countNumberOfBits ((uint32) (n >> 32));
}




template <typename IntegerType>
IntegerType negativeAwareModulo (IntegerType dividend, const IntegerType divisor) noexcept
{
#pragma warning(push)
# 544 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_MathsFunctions.h"
#pragma warning(disable: 4127)
# 544 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_MathsFunctions.h"
 do { ; } while (false)
# 544 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_MathsFunctions.h"
#pragma warning(pop)
# 544 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_MathsFunctions.h"
;
    dividend %= divisor;
    return (dividend < 0) ? (dividend + divisor) : dividend;
}


template <typename NumericType>
NumericType square (NumericType n) noexcept
{
    return n * n;
}
# 564 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_MathsFunctions.h"
void writeLittleEndianBitsInBuffer (void* targetBuffer, uint32 startBit, uint32 numBits, uint32 value) noexcept;
# 573 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_MathsFunctions.h"
uint32 readLittleEndianBitsInBuffer (const void* sourceBuffer, uint32 startBit, uint32 numBits) noexcept;
# 590 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_MathsFunctions.h"
namespace TypeHelpers
{
# 607 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_MathsFunctions.h"
    template <typename Type> struct ParameterType { typedef const Type& type; };


    template <typename Type> struct ParameterType <Type&> { typedef Type& type; };
    template <typename Type> struct ParameterType <Type*> { typedef Type* type; };
    template <> struct ParameterType <char> { typedef char type; };
    template <> struct ParameterType <unsigned char> { typedef unsigned char type; };
    template <> struct ParameterType <short> { typedef short type; };
    template <> struct ParameterType <unsigned short> { typedef unsigned short type; };
    template <> struct ParameterType <int> { typedef int type; };
    template <> struct ParameterType <unsigned int> { typedef unsigned int type; };
    template <> struct ParameterType <long> { typedef long type; };
    template <> struct ParameterType <unsigned long> { typedef unsigned long type; };
    template <> struct ParameterType <int64> { typedef int64 type; };
    template <> struct ParameterType <uint64> { typedef uint64 type; };
    template <> struct ParameterType <bool> { typedef bool type; };
    template <> struct ParameterType <float> { typedef float type; };
    template <> struct ParameterType <double> { typedef double type; };
# 637 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_MathsFunctions.h"
    template <typename Type> struct SmallestFloatType { typedef float type; };
    template <> struct SmallestFloatType <double> { typedef double type; };
}
# 202 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ByteOrder.h" 1
# 39 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ByteOrder.h"
class ByteOrder
{
public:


    static uint16 swap (uint16 value) noexcept;


    static uint32 swap (uint32 value) noexcept;


    static uint64 swap (uint64 value) noexcept;



    static uint16 swapIfBigEndian (uint16 value) noexcept;


    static uint32 swapIfBigEndian (uint32 value) noexcept;


    static uint64 swapIfBigEndian (uint64 value) noexcept;


    static int16 swapIfBigEndian (int16 value) noexcept;


    static int32 swapIfBigEndian (int32 value) noexcept;


    static int64 swapIfBigEndian (int64 value) noexcept;


    static float swapIfBigEndian (float value) noexcept;


    static double swapIfBigEndian (double value) noexcept;


    static uint16 swapIfLittleEndian (uint16 value) noexcept;


    static uint32 swapIfLittleEndian (uint32 value) noexcept;


    static uint64 swapIfLittleEndian (uint64 value) noexcept;


    static int16 swapIfLittleEndian (int16 value) noexcept;


    static int32 swapIfLittleEndian (int32 value) noexcept;


    static int64 swapIfLittleEndian (int64 value) noexcept;


    static float swapIfLittleEndian (float value) noexcept;


    static double swapIfLittleEndian (double value) noexcept;



    static uint32 littleEndianInt (const void* bytes) noexcept;


    static uint64 littleEndianInt64 (const void* bytes) noexcept;


    static uint16 littleEndianShort (const void* bytes) noexcept;


    static uint32 bigEndianInt (const void* bytes) noexcept;


    static uint64 bigEndianInt64 (const void* bytes) noexcept;


    static uint16 bigEndianShort (const void* bytes) noexcept;



    static int littleEndian24Bit (const void* bytes) noexcept;


    static int bigEndian24Bit (const void* bytes) noexcept;


    static void littleEndian24BitToChars (int value, void* destBytes) noexcept;


    static void bigEndian24BitToChars (int value, void* destBytes) noexcept;



    static bool isBigEndian() noexcept;

private:
    ByteOrder() = delete;

    ByteOrder (const ByteOrder&) = delete; ByteOrder& operator= (const ByteOrder&) = delete;
};




#pragma intrinsic (_byteswap_ulong)


inline uint16 ByteOrder::swap (uint16 n) noexcept
{
    return static_cast<uint16> ((n << 8) | (n >> 8));
}

inline uint32 ByteOrder::swap (uint32 n) noexcept
{






    return _byteswap_ulong (n);





}

inline uint64 ByteOrder::swap (uint64 value) noexcept
{



    return _byteswap_uint64 (value);



}


 inline uint16 ByteOrder::swapIfBigEndian (const uint16 v) noexcept { return v; }
 inline uint32 ByteOrder::swapIfBigEndian (const uint32 v) noexcept { return v; }
 inline uint64 ByteOrder::swapIfBigEndian (const uint64 v) noexcept { return v; }
 inline int16 ByteOrder::swapIfBigEndian (const int16 v) noexcept { return v; }
 inline int32 ByteOrder::swapIfBigEndian (const int32 v) noexcept { return v; }
 inline int64 ByteOrder::swapIfBigEndian (const int64 v) noexcept { return v; }
 inline float ByteOrder::swapIfBigEndian (const float v) noexcept { return v; }
 inline double ByteOrder::swapIfBigEndian (const double v) noexcept { return v; }

 inline uint16 ByteOrder::swapIfLittleEndian (const uint16 v) noexcept { return swap (v); }
 inline uint32 ByteOrder::swapIfLittleEndian (const uint32 v) noexcept { return swap (v); }
 inline uint64 ByteOrder::swapIfLittleEndian (const uint64 v) noexcept { return swap (v); }
 inline int16 ByteOrder::swapIfLittleEndian (const int16 v) noexcept { return static_cast<int16> (swap (static_cast<uint16> (v))); }
 inline int32 ByteOrder::swapIfLittleEndian (const int32 v) noexcept { return static_cast<int32> (swap (static_cast<uint32> (v))); }
 inline int64 ByteOrder::swapIfLittleEndian (const int64 v) noexcept { return static_cast<int64> (swap (static_cast<uint64> (v))); }
inline float ByteOrder::swapIfLittleEndian (const float v) noexcept { union { uint32 asUInt; float asFloat; } n; n.asFloat = v; n.asUInt = ByteOrder::swap (n.asUInt); return n.asFloat; }
 inline double ByteOrder::swapIfLittleEndian (const double v) noexcept { union { uint64 asUInt; double asFloat; } n; n.asFloat = v; n.asUInt = ByteOrder::swap (n.asUInt); return n.asFloat; }

 inline uint32 ByteOrder::littleEndianInt (const void* const bytes) noexcept { return *static_cast<const uint32*> (bytes); }
 inline uint64 ByteOrder::littleEndianInt64 (const void* const bytes) noexcept { return *static_cast<const uint64*> (bytes); }
 inline uint16 ByteOrder::littleEndianShort (const void* const bytes) noexcept { return *static_cast<const uint16*> (bytes); }
 inline uint32 ByteOrder::bigEndianInt (const void* const bytes) noexcept { return swap (*static_cast<const uint32*> (bytes)); }
 inline uint64 ByteOrder::bigEndianInt64 (const void* const bytes) noexcept { return swap (*static_cast<const uint64*> (bytes)); }
 inline uint16 ByteOrder::bigEndianShort (const void* const bytes) noexcept { return swap (*static_cast<const uint16*> (bytes)); }
 inline bool ByteOrder::isBigEndian() noexcept { return false; }
# 235 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ByteOrder.h"
inline int ByteOrder::littleEndian24Bit (const void* const bytes) noexcept { return (((int) static_cast<const int8*> (bytes)[2]) << 16) | (((int) static_cast<const uint8*> (bytes)[1]) << 8) | ((int) static_cast<const uint8*> (bytes)[0]); }
inline int ByteOrder::bigEndian24Bit (const void* const bytes) noexcept { return (((int) static_cast<const int8*> (bytes)[0]) << 16) | (((int) static_cast<const uint8*> (bytes)[1]) << 8) | ((int) static_cast<const uint8*> (bytes)[2]); }
inline void ByteOrder::littleEndian24BitToChars (const int value, void* const destBytes) noexcept { static_cast<uint8*> (destBytes)[0] = (uint8) value; static_cast<uint8*> (destBytes)[1] = (uint8) (value >> 8); static_cast<uint8*> (destBytes)[2] = (uint8) (value >> 16); }
inline void ByteOrder::bigEndian24BitToChars (const int value, void* const destBytes) noexcept { static_cast<uint8*> (destBytes)[0] = (uint8) (value >> 16); static_cast<uint8*> (destBytes)[1] = (uint8) (value >> 8); static_cast<uint8*> (destBytes)[2] = (uint8) value; }
# 203 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_Atomic.h" 1
# 42 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_Atomic.h"
template <typename Type>
class Atomic
{
public:

    inline Atomic() noexcept
        : value (0)
    {
    }


    inline explicit Atomic (const Type initialValue) noexcept
        : value (initialValue)
    {
    }


    inline Atomic (const Atomic& other) noexcept
        : value (other.get())
    {
    }


    inline ~Atomic() noexcept
    {

        static_assert(sizeof (Type) == 4 || sizeof (Type) == 8, "sizeof (Type) == 4 || sizeof (Type) == 8");;
    }


    Type get() const noexcept;


    inline Atomic& operator= (const Atomic& other) noexcept { exchange (other.get()); return *this; }


    inline Atomic& operator= (const Type newValue) noexcept { exchange (newValue); return *this; }


    void set (Type newValue) noexcept { exchange (newValue); }


    Type exchange (Type value) noexcept;


    Type operator+= (Type amountToAdd) noexcept;


    Type operator-= (Type amountToSubtract) noexcept;


    Type operator++() noexcept;


    Type operator--() noexcept;
# 119 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_Atomic.h"
    bool compareAndSetBool (Type newValue, Type valueToCompare) noexcept;
# 139 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_Atomic.h"
    Type compareAndSetValue (Type newValue, Type valueToCompare) noexcept;


    static void memoryBarrier() noexcept;





    __declspec (align (4))






    volatile Type value;

private:
    template <typename Dest, typename Source>
    static inline Dest castTo (Source value) noexcept { union { Dest d; Source s; } u; u.s = value; return u.d; }

    static inline Type castFrom32Bit (int32 value) noexcept { return castTo <Type, int32> (value); }
    static inline Type castFrom64Bit (int64 value) noexcept { return castTo <Type, int64> (value); }
    static inline int32 castTo32Bit (Type value) noexcept { return castTo <int32, Type> (value); }
    static inline int64 castTo64Bit (Type value) noexcept { return castTo <int64, Type> (value); }

    Type operator++ (int);
    Type operator-- (int);


    template <typename ValueType>
    inline ValueType negateValue (ValueType n) noexcept
    {
        return sizeof (ValueType) == 1 ? (ValueType) -(signed char) n
            : (sizeof (ValueType) == 2 ? (ValueType) -(short) n
            : (sizeof (ValueType) == 4 ? (ValueType) -(int) n
            : ((ValueType) -(int64) n)));
    }


    template <typename PointerType>
    inline PointerType* negateValue (PointerType* n) noexcept
    {
        return reinterpret_cast<PointerType*> (-reinterpret_cast<pointer_sized_int> (n));
    }
};
# 208 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_Atomic.h"
#pragma intrinsic (_InterlockedExchange, _InterlockedIncrement, _InterlockedDecrement, _InterlockedCompareExchange, _InterlockedCompareExchange64, _InterlockedExchangeAdd, _ReadWriteBarrier)
# 229 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_Atomic.h"
 template <typename Type> static Type juce_InterlockedExchangeAdd64 (volatile Type* a, Type b) noexcept {
# 229 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_Atomic.h"
#pragma warning(push)
# 229 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_Atomic.h"
#pragma warning(disable: 4127)
# 229 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_Atomic.h"
 do { } while (false)
# 229 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_Atomic.h"
#pragma warning(pop)
# 229 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_Atomic.h"
; Type old = *a; *a += b; return old; }
    template <typename Type> static Type juce_InterlockedExchange64 (volatile Type* a, Type b) noexcept {
# 230 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_Atomic.h"
#pragma warning(push)
# 230 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_Atomic.h"
#pragma warning(disable: 4127)
# 230 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_Atomic.h"
 do { } while (false)
# 230 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_Atomic.h"
#pragma warning(pop)
# 230 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_Atomic.h"
; Type old = *a; *a = b; return old; }
    template <typename Type> static Type juce_InterlockedIncrement64 (volatile Type* a) noexcept {
# 231 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_Atomic.h"
#pragma warning(push)
# 231 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_Atomic.h"
#pragma warning(disable: 4127)
# 231 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_Atomic.h"
 do { } while (false)
# 231 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_Atomic.h"
#pragma warning(pop)
# 231 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_Atomic.h"
; return ++*a; }
    template <typename Type> static Type juce_InterlockedDecrement64 (volatile Type* a) noexcept {
# 232 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_Atomic.h"
#pragma warning(push)
# 232 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_Atomic.h"
#pragma warning(disable: 4127)
# 232 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_Atomic.h"
 do { } while (false)
# 232 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_Atomic.h"
#pragma warning(pop)
# 232 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_Atomic.h"
; return --*a; }



  template <typename Type, std::size_t sizeOfType>
  struct WindowsInterlockedHelpersBase
  {};

  template <typename Type>
  struct WindowsInterlockedHelpersBase<Type, 4>
  {
      static inline Type exchange (volatile Type* value, Type other) noexcept
      {
          return castFrom (_InterlockedExchange(reinterpret_cast<volatile long*> (value), castTo (other)));
      }

      static inline Type add (volatile Type* value, Type other) noexcept
      {
          return castFrom (_InterlockedExchangeAdd(reinterpret_cast<volatile long*> (value), castTo (other)) + castTo (other));
      }

      static inline Type inc (volatile Type* value) noexcept
      {
          return castFrom (_InterlockedIncrement(reinterpret_cast<volatile long*> (value)));
      }

      static inline Type dec (volatile Type* value) noexcept
      {
          return castFrom (_InterlockedDecrement(reinterpret_cast<volatile long*> (value)));
      }

      static inline Type cmp (volatile Type* value, Type other, Type comparand) noexcept
      {
          return castFrom (_InterlockedCompareExchange(reinterpret_cast<volatile long*> (value), castTo (other), castTo (comparand)));
      }

      static inline Type castFrom (long value) { union { long in; Type out; } u; u.in = value; return u.out; }
      static inline long castTo (Type value) { union { Type in; long out; } u; u.in = value; return u.out; }
  };

  template <typename Type>
  struct WindowsInterlockedHelpersBase<Type, 8>
  {
      static inline Type exchange (volatile Type* value, Type other) noexcept
      {
          return castFrom (juce_InterlockedExchange64 (reinterpret_cast<volatile __int64*> (value), castTo (other)));
      }

      static inline Type add (volatile Type* value, Type other) noexcept
      {
          return castFrom (juce_InterlockedExchangeAdd64 (reinterpret_cast<volatile __int64*> (value), castTo (other)) + castTo (other));
      }

      static inline Type inc (volatile Type* value) noexcept
      {
          return castFrom (juce_InterlockedIncrement64 (reinterpret_cast<volatile __int64*> (value)));
      }

      static inline Type dec (volatile Type* value) noexcept
      {
          return castFrom (juce_InterlockedDecrement64 (reinterpret_cast<volatile __int64*> (value)));
      }

      static inline Type cmp (volatile Type* value, Type other, Type comparand) noexcept
      {
          return castFrom (_InterlockedCompareExchange64(reinterpret_cast<volatile __int64*> (value), castTo (other), castTo (comparand)));
      }

      static inline Type castFrom (__int64 value) { union { __int64 in; Type out; } u; u.in = value; return u.out; }
      static inline __int64 castTo (Type value) { union { Type in; __int64 out; } u; u.in = value; return u.out; }
  };

  template <typename Type>
  struct WindowsInterlockedHelpers : WindowsInterlockedHelpersBase<Type, sizeof (Type)> {};




#pragma warning(push)
#pragma warning(disable: 4311)



template <typename Type>
inline Type Atomic<Type>::get() const noexcept
{




    return WindowsInterlockedHelpers<Type>::add (const_cast<volatile Type*> (&value), (Type) 0);




}

template <typename Type>
inline Type Atomic<Type>::exchange (const Type newValue) noexcept
{





    return WindowsInterlockedHelpers<Type>::exchange (&value, newValue);

}

template <typename Type>
inline Type Atomic<Type>::operator+= (const Type amountToAdd) noexcept
{




    return WindowsInterlockedHelpers<Type>::add (&value, amountToAdd);



}

template <typename Type>
inline Type Atomic<Type>::operator-= (const Type amountToSubtract) noexcept
{
    return operator+= (negateValue (amountToSubtract));
}

template <typename Type>
inline Type Atomic<Type>::operator++() noexcept
{




    return WindowsInterlockedHelpers<Type>::inc (&value);




}

template <typename Type>
inline Type Atomic<Type>::operator--() noexcept
{




    return WindowsInterlockedHelpers<Type>::dec (&value);




}

template <typename Type>
inline bool Atomic<Type>::compareAndSetBool (const Type newValue, const Type valueToCompare) noexcept
{




    return compareAndSetValue (newValue, valueToCompare) == valueToCompare;




}

template <typename Type>
inline Type Atomic<Type>::compareAndSetValue (const Type newValue, const Type valueToCompare) noexcept
{
# 417 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_Atomic.h"
    return WindowsInterlockedHelpers<Type>::cmp (&value, newValue, valueToCompare);




}

template <typename Type>
inline void Atomic<Type>::memoryBarrier() noexcept
{





    _ReadWriteBarrier();

}


#pragma warning(pop)
# 204 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_CharacterFunctions.h" 1
# 53 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_CharacterFunctions.h"
 typedef uint32 juce_wchar;
# 81 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_CharacterFunctions.h"
class CharacterFunctions
{
public:


    static juce_wchar toUpperCase (juce_wchar character) noexcept;

    static juce_wchar toLowerCase (juce_wchar character) noexcept;


    static bool isUpperCase (juce_wchar character) noexcept;

    static bool isLowerCase (juce_wchar character) noexcept;


    static bool isWhitespace (char character) noexcept;

    static bool isWhitespace (juce_wchar character) noexcept;


    static bool isDigit (char character) noexcept;

    static bool isDigit (juce_wchar character) noexcept;


    static bool isLetter (char character) noexcept;

    static bool isLetter (juce_wchar character) noexcept;


    static bool isLetterOrDigit (char character) noexcept;

    static bool isLetterOrDigit (juce_wchar character) noexcept;




    static bool isPrintable (char character) noexcept;




    static bool isPrintable (juce_wchar character) noexcept;


    static int getHexDigitValue (juce_wchar digit) noexcept;


    static juce_wchar getUnicodeCharFromWindows1252Codepage (uint8 windows1252Char) noexcept;






    template <typename CharPointerType>
    static double readDoubleValue (CharPointerType& text) noexcept
    {
        double result[3] = { 0 }, accumulator[2] = { 0 };
        int exponentAdjustment[2] = { 0 }, exponentAccumulator[2] = { -1, -1 };
        int exponent = 0, decPointIndex = 0, digit = 0;
        int lastDigit = 0, numSignificantDigits = 0;
        bool isNegative = false, digitsFound = false;
        const int maxSignificantDigits = 15 + 2;

        text = text.findEndOfWhitespace();
        juce_wchar c = *text;

        switch (c)
        {
            case '-': isNegative = true;
            case '+': c = *++text;
        }

        switch (c)
        {
            case 'n':
            case 'N':
                if ((text[1] == 'a' || text[1] == 'A') && (text[2] == 'n' || text[2] == 'N'))
                    return std::numeric_limits<double>::quiet_NaN();
                break;

            case 'i':
            case 'I':
                if ((text[1] == 'n' || text[1] == 'N') && (text[2] == 'f' || text[2] == 'F'))
                    return std::numeric_limits<double>::infinity();
                break;
        }

        for (;;)
        {
            if (text.isDigit())
            {
                lastDigit = digit;
                digit = (int) text.getAndAdvance() - '0';
                digitsFound = true;

                if (decPointIndex != 0)
                    exponentAdjustment[1]++;

                if (numSignificantDigits == 0 && digit == 0)
                    continue;

                if (++numSignificantDigits > maxSignificantDigits)
                {
                    if (digit > 5)
                        ++accumulator [decPointIndex];
                    else if (digit == 5 && (lastDigit & 1) != 0)
                        ++accumulator [decPointIndex];

                    if (decPointIndex > 0)
                        exponentAdjustment[1]--;
                    else
                        exponentAdjustment[0]++;

                    while (text.isDigit())
                    {
                        ++text;
                        if (decPointIndex == 0)
                            exponentAdjustment[0]++;
                    }
                }
                else
                {
                    const double maxAccumulatorValue = (double) ((std::numeric_limits<unsigned int>::max() - 9) / 10);
                    if (accumulator [decPointIndex] > maxAccumulatorValue)
                    {
                        result [decPointIndex] = mulexp10 (result [decPointIndex], exponentAccumulator [decPointIndex])
                                                    + accumulator [decPointIndex];
                        accumulator [decPointIndex] = 0;
                        exponentAccumulator [decPointIndex] = 0;
                    }

                    accumulator [decPointIndex] = accumulator[decPointIndex] * 10 + digit;
                    exponentAccumulator [decPointIndex]++;
                }
            }
            else if (decPointIndex == 0 && *text == '.')
            {
                ++text;
                decPointIndex = 1;

                if (numSignificantDigits > maxSignificantDigits)
                {
                    while (text.isDigit())
                        ++text;
                    break;
                }
            }
            else
            {
                break;
            }
        }

        result[0] = mulexp10 (result[0], exponentAccumulator[0]) + accumulator[0];

        if (decPointIndex != 0)
            result[1] = mulexp10 (result[1], exponentAccumulator[1]) + accumulator[1];

        c = *text;
        if ((c == 'e' || c == 'E') && digitsFound)
        {
            bool negativeExponent = false;

            switch (*++text)
            {
                case '-': negativeExponent = true;
                case '+': ++text;
            }

            while (text.isDigit())
                exponent = (exponent * 10) + ((int) text.getAndAdvance() - '0');

            if (negativeExponent)
                exponent = -exponent;
        }

        double r = mulexp10 (result[0], exponent + exponentAdjustment[0]);
        if (decPointIndex != 0)
            r += mulexp10 (result[1], exponent - exponentAdjustment[1]);

        return isNegative ? -r : r;
    }


    template <typename CharPointerType>
    static double getDoubleValue (CharPointerType text) noexcept
    {
        return readDoubleValue (text);
    }



    template <typename IntType, typename CharPointerType>
    static IntType getIntValue (const CharPointerType text) noexcept
    {
        IntType v = 0;
        CharPointerType s (text.findEndOfWhitespace());

        const bool isNeg = *s == '-';
        if (isNeg)
            ++s;

        for (;;)
        {
            const juce_wchar c = s.getAndAdvance();

            if (c >= '0' && c <= '9')
                v = v * 10 + (IntType) (c - '0');
            else
                break;
        }

        return isNeg ? -v : v;
    }

    template <typename ResultType>
    struct HexParser
    {
        template <typename CharPointerType>
        static ResultType parse (CharPointerType t) noexcept
        {
            ResultType result = 0;

            while (! t.isEmpty())
            {
                const int hexValue = CharacterFunctions::getHexDigitValue (t.getAndAdvance());

                if (hexValue >= 0)
                    result = (result << 4) | hexValue;
            }

            return result;
        }
    };




    template <typename CharPointerType>
    static size_t lengthUpTo (CharPointerType text, const size_t maxCharsToCount) noexcept
    {
        size_t len = 0;

        while (len < maxCharsToCount && text.getAndAdvance() != 0)
            ++len;

        return len;
    }



    template <typename CharPointerType>
    static size_t lengthUpTo (CharPointerType start, const CharPointerType end) noexcept
    {
        size_t len = 0;

        while (start < end && start.getAndAdvance() != 0)
            ++len;

        return len;
    }


    template <typename DestCharPointerType, typename SrcCharPointerType>
    static void copyAll (DestCharPointerType& dest, SrcCharPointerType src) noexcept
    {
        while (juce_wchar c = src.getAndAdvance())
            dest.write (c);

        dest.writeNull();
    }



    template <typename DestCharPointerType, typename SrcCharPointerType>
    static size_t copyWithDestByteLimit (DestCharPointerType& dest, SrcCharPointerType src, size_t maxBytesToWrite) noexcept
    {
        typename DestCharPointerType::CharType const* const startAddress = dest.getAddress();
        ssize_t maxBytes = (ssize_t) maxBytesToWrite;
        maxBytes -= sizeof (typename DestCharPointerType::CharType);

        for (;;)
        {
            const juce_wchar c = src.getAndAdvance();
            const size_t bytesNeeded = DestCharPointerType::getBytesRequiredFor (c);

            maxBytes -= bytesNeeded;
            if (c == 0 || maxBytes < 0)
                break;

            dest.write (c);
        }

        dest.writeNull();

        return (size_t) getAddressDifference (dest.getAddress(), startAddress)
                 + sizeof (typename DestCharPointerType::CharType);
    }



    template <typename DestCharPointerType, typename SrcCharPointerType>
    static void copyWithCharLimit (DestCharPointerType& dest, SrcCharPointerType src, int maxChars) noexcept
    {
        while (--maxChars > 0)
        {
            const juce_wchar c = src.getAndAdvance();
            if (c == 0)
                break;

            dest.write (c);
        }

        dest.writeNull();
    }


    static inline int compare (juce_wchar char1, juce_wchar char2) noexcept
    {
        if (int diff = static_cast<int> (char1) - static_cast<int> (char2))
            return diff < 0 ? -1 : 1;

        return 0;
    }


    template <typename CharPointerType1, typename CharPointerType2>
    static int compare (CharPointerType1 s1, CharPointerType2 s2) noexcept
    {
        for (;;)
        {
            const juce_wchar c1 = s1.getAndAdvance();

            if (int diff = compare (c1, s2.getAndAdvance()))
                return diff;

            if (c1 == 0)
                break;
        }

        return 0;
    }


    template <typename CharPointerType1, typename CharPointerType2>
    static int compareUpTo (CharPointerType1 s1, CharPointerType2 s2, int maxChars) noexcept
    {
        while (--maxChars >= 0)
        {
            const juce_wchar c1 = s1.getAndAdvance();

            if (int diff = compare (c1, s2.getAndAdvance()))
                return diff;

            if (c1 == 0)
                break;
        }

        return 0;
    }


    static inline int compareIgnoreCase (juce_wchar char1, juce_wchar char2) noexcept
    {
        return char1 != char2 ? compare (toUpperCase (char1), toUpperCase (char2)) : 0;
    }


    template <typename CharPointerType1, typename CharPointerType2>
    static int compareIgnoreCase (CharPointerType1 s1, CharPointerType2 s2) noexcept
    {
        for (;;)
        {
            const juce_wchar c1 = s1.getAndAdvance();

            if (int diff = compareIgnoreCase (c1, s2.getAndAdvance()))
                return diff;

            if (c1 == 0)
                break;
        }

        return 0;
    }


    template <typename CharPointerType1, typename CharPointerType2>
    static int compareIgnoreCaseUpTo (CharPointerType1 s1, CharPointerType2 s2, int maxChars) noexcept
    {
        while (--maxChars >= 0)
        {
            const juce_wchar c1 = s1.getAndAdvance();

            if (int diff = compareIgnoreCase (c1, s2.getAndAdvance()))
                return diff;

            if (c1 == 0)
                break;
        }

        return 0;
    }




    template <typename CharPointerType1, typename CharPointerType2>
    static int indexOf (CharPointerType1 textToSearch, const CharPointerType2 substringToLookFor) noexcept
    {
        int index = 0;
        const int substringLength = (int) substringToLookFor.length();

        for (;;)
        {
            if (textToSearch.compareUpTo (substringToLookFor, substringLength) == 0)
                return index;

            if (textToSearch.getAndAdvance() == 0)
                return -1;

            ++index;
        }
    }





    template <typename CharPointerType1, typename CharPointerType2>
    static CharPointerType1 find (CharPointerType1 textToSearch, const CharPointerType2 substringToLookFor) noexcept
    {
        const int substringLength = (int) substringToLookFor.length();

        while (textToSearch.compareUpTo (substringToLookFor, substringLength) != 0
                 && ! textToSearch.isEmpty())
            ++textToSearch;

        return textToSearch;
    }





    template <typename CharPointerType>
    static CharPointerType find (CharPointerType textToSearch, const juce_wchar charToLookFor) noexcept
    {
        for (;; ++textToSearch)
        {
            const juce_wchar c = *textToSearch;

            if (c == charToLookFor || c == 0)
                break;
        }

        return textToSearch;
    }





    template <typename CharPointerType1, typename CharPointerType2>
    static int indexOfIgnoreCase (CharPointerType1 haystack, const CharPointerType2 needle) noexcept
    {
        int index = 0;
        const int needleLength = (int) needle.length();

        for (;;)
        {
            if (haystack.compareIgnoreCaseUpTo (needle, needleLength) == 0)
                return index;

            if (haystack.getAndAdvance() == 0)
                return -1;

            ++index;
        }
    }




    template <typename Type>
    static int indexOfChar (Type text, const juce_wchar charToFind) noexcept
    {
        int i = 0;

        while (! text.isEmpty())
        {
            if (text.getAndAdvance() == charToFind)
                return i;

            ++i;
        }

        return -1;
    }





    template <typename Type>
    static int indexOfCharIgnoreCase (Type text, juce_wchar charToFind) noexcept
    {
        charToFind = CharacterFunctions::toLowerCase (charToFind);
        int i = 0;

        while (! text.isEmpty())
        {
            if (text.toLowerCase() == charToFind)
                return i;

            ++text;
            ++i;
        }

        return -1;
    }





    template <typename Type>
    static Type findEndOfWhitespace (Type text) noexcept
    {
        while (text.isWhitespace())
            ++text;

        return text;
    }




    template <typename Type, typename BreakType>
    static Type findEndOfToken (Type text, const BreakType breakCharacters, const Type quoteCharacters)
    {
        juce_wchar currentQuoteChar = 0;

        while (! text.isEmpty())
        {
            const juce_wchar c = text.getAndAdvance();

            if (currentQuoteChar == 0 && breakCharacters.indexOf (c) >= 0)
            {
                --text;
                break;
            }

            if (quoteCharacters.indexOf (c) >= 0)
            {
                if (currentQuoteChar == 0)
                    currentQuoteChar = c;
                else if (currentQuoteChar == c)
                    currentQuoteChar = 0;
            }
        }

        return text;
    }

private:
    static double mulexp10 (const double value, int exponent) noexcept;
};
# 205 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2



#pragma warning(push)
#pragma warning(disable: 4514 4996)



# 1 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_CharPointer_UTF8.h" 1
# 40 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_CharPointer_UTF8.h"
class CharPointer_UTF8
{
public:
    typedef char CharType;

    inline explicit CharPointer_UTF8 (const CharType* const rawPointer) noexcept
        : data (const_cast<CharType*> (rawPointer))
    {
    }

    inline CharPointer_UTF8 (const CharPointer_UTF8& other) noexcept
        : data (other.data)
    {
    }

    inline CharPointer_UTF8 operator= (CharPointer_UTF8 other) noexcept
    {
        data = other.data;
        return *this;
    }

    inline CharPointer_UTF8 operator= (const CharType* text) noexcept
    {
        data = const_cast<CharType*> (text);
        return *this;
    }


    inline bool operator== (CharPointer_UTF8 other) const noexcept { return data == other.data; }
    inline bool operator!= (CharPointer_UTF8 other) const noexcept { return data != other.data; }
    inline bool operator<= (CharPointer_UTF8 other) const noexcept { return data <= other.data; }
    inline bool operator< (CharPointer_UTF8 other) const noexcept { return data < other.data; }
    inline bool operator>= (CharPointer_UTF8 other) const noexcept { return data >= other.data; }
    inline bool operator> (CharPointer_UTF8 other) const noexcept { return data > other.data; }


    inline CharType* getAddress() const noexcept { return data; }


    inline operator const CharType*() const noexcept { return data; }


    inline bool isEmpty() const noexcept { return *data == 0; }


    juce_wchar operator*() const noexcept
    {
        const signed char byte = (signed char) *data;

        if (byte >= 0)
            return (juce_wchar) (uint8) byte;

        uint32 n = (uint32) (uint8) byte;
        uint32 mask = 0x7f;
        uint32 bit = 0x40;
        int numExtraValues = 0;

        while ((n & bit) != 0 && bit > 0x8)
        {
            mask >>= 1;
            ++numExtraValues;
            bit >>= 1;
        }

        n &= mask;

        for (int i = 1; i <= numExtraValues; ++i)
        {
            const uint32 nextByte = (uint32) (uint8) data[i];

            if ((nextByte & 0xc0) != 0x80)
                break;

            n <<= 6;
            n |= (nextByte & 0x3f);
        }

        return (juce_wchar) n;
    }


    CharPointer_UTF8& operator++() noexcept
    {
#pragma warning(push)
# 123 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_CharPointer_UTF8.h"
#pragma warning(disable: 4127)
# 123 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_CharPointer_UTF8.h"
 do { ; } while (false)
# 123 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_CharPointer_UTF8.h"
#pragma warning(pop)
# 123 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_CharPointer_UTF8.h"
;
        const signed char n = (signed char) *data++;

        if (n < 0)
        {
            juce_wchar bit = 0x40;

            while ((n & bit) != 0 && bit > 0x8)
            {
                ++data;
                bit >>= 1;
            }
        }

        return *this;
    }


    CharPointer_UTF8 operator--() noexcept
    {
        int count = 0;

        while ((*--data & 0xc0) == 0x80 && ++count < 4)
        {}

        return *this;
    }



    juce_wchar getAndAdvance() noexcept
    {
        const signed char byte = (signed char) *data++;

        if (byte >= 0)
            return (juce_wchar) (uint8) byte;

        uint32 n = (uint32) (uint8) byte;
        uint32 mask = 0x7f;
        uint32 bit = 0x40;
        int numExtraValues = 0;

        while ((n & bit) != 0 && bit > 0x8)
        {
            mask >>= 1;
            ++numExtraValues;
            bit >>= 1;
        }

        n &= mask;

        while (--numExtraValues >= 0)
        {
            const uint32 nextByte = (uint32) (uint8) *data;

            if ((nextByte & 0xc0) != 0x80)
                break;

            ++data;
            n <<= 6;
            n |= (nextByte & 0x3f);
        }

        return (juce_wchar) n;
    }


    CharPointer_UTF8 operator++ (int) noexcept
    {
        CharPointer_UTF8 temp (*this);
        ++*this;
        return temp;
    }


    void operator+= (int numToSkip) noexcept
    {
        if (numToSkip < 0)
        {
            while (++numToSkip <= 0)
                --*this;
        }
        else
        {
            while (--numToSkip >= 0)
                ++*this;
        }
    }


    void operator-= (int numToSkip) noexcept
    {
        operator+= (-numToSkip);
    }


    juce_wchar operator[] (int characterIndex) const noexcept
    {
        CharPointer_UTF8 p (*this);
        p += characterIndex;
        return *p;
    }


    CharPointer_UTF8 operator+ (int numToSkip) const noexcept
    {
        CharPointer_UTF8 p (*this);
        p += numToSkip;
        return p;
    }


    CharPointer_UTF8 operator- (int numToSkip) const noexcept
    {
        CharPointer_UTF8 p (*this);
        p += -numToSkip;
        return p;
    }


    size_t length() const noexcept
    {
        const CharType* d = data;
        size_t count = 0;

        for (;;)
        {
            const uint32 n = (uint32) (uint8) *d++;

            if ((n & 0x80) != 0)
            {
                while ((*d & 0xc0) == 0x80)
                    ++d;
            }
            else if (n == 0)
                break;

            ++count;
        }

        return count;
    }


    size_t lengthUpTo (const size_t maxCharsToCount) const noexcept
    {
        return CharacterFunctions::lengthUpTo (*this, maxCharsToCount);
    }


    size_t lengthUpTo (const CharPointer_UTF8 end) const noexcept
    {
        return CharacterFunctions::lengthUpTo (*this, end);
    }




    size_t sizeInBytes() const noexcept
    {
#pragma warning(push)
# 283 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_CharPointer_UTF8.h"
#pragma warning(disable: 4127)
# 283 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_CharPointer_UTF8.h"
 do { ; } while (false)
# 283 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_CharPointer_UTF8.h"
#pragma warning(pop)
# 283 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_CharPointer_UTF8.h"
;
        return strlen (data) + 1;
    }




    static size_t getBytesRequiredFor (const juce_wchar charToWrite) noexcept
    {
        size_t num = 1;
        const uint32 c = (uint32) charToWrite;

        if (c >= 0x80)
        {
            ++num;
            if (c >= 0x800)
            {
                ++num;
                if (c >= 0x10000)
                    ++num;
            }
        }

        return num;
    }





    template <class CharPointer>
    static size_t getBytesRequiredFor (CharPointer text) noexcept
    {
        size_t count = 0;

        while (juce_wchar n = text.getAndAdvance())
            count += getBytesRequiredFor (n);

        return count;
    }


    CharPointer_UTF8 findTerminatingNull() const noexcept
    {
        return CharPointer_UTF8 (data + strlen (data));
    }


    void write (const juce_wchar charToWrite) noexcept
    {
        const uint32 c = (uint32) charToWrite;

        if (c >= 0x80)
        {
            int numExtraBytes = 1;
            if (c >= 0x800)
            {
                ++numExtraBytes;
                if (c >= 0x10000)
                    ++numExtraBytes;
            }

            *data++ = (CharType) ((uint32) (0xff << (7 - numExtraBytes)) | (c >> (numExtraBytes * 6)));

            while (--numExtraBytes >= 0)
                *data++ = (CharType) (0x80 | (0x3f & (c >> (numExtraBytes * 6))));
        }
        else
        {
            *data++ = (CharType) c;
        }
    }


    inline void writeNull() const noexcept
    {
        *data = 0;
    }


    template <typename CharPointer>
    void writeAll (const CharPointer src) noexcept
    {
        CharacterFunctions::copyAll (*this, src);
    }


    void writeAll (const CharPointer_UTF8 src) noexcept
    {
        const CharType* s = src.data;

        while ((*data = *s) != 0)
        {
            ++data;
            ++s;
        }
    }





    template <typename CharPointer>
    size_t writeWithDestByteLimit (const CharPointer src, const size_t maxDestBytes) noexcept
    {
        return CharacterFunctions::copyWithDestByteLimit (*this, src, maxDestBytes);
    }





    template <typename CharPointer>
    void writeWithCharLimit (const CharPointer src, const int maxChars) noexcept
    {
        CharacterFunctions::copyWithCharLimit (*this, src, maxChars);
    }


    template <typename CharPointer>
    int compare (const CharPointer other) const noexcept
    {
        return CharacterFunctions::compare (*this, other);
    }


    template <typename CharPointer>
    int compareUpTo (const CharPointer other, const int maxChars) const noexcept
    {
        return CharacterFunctions::compareUpTo (*this, other, maxChars);
    }


    template <typename CharPointer>
    int compareIgnoreCase (const CharPointer other) const noexcept
    {
        return CharacterFunctions::compareIgnoreCase (*this, other);
    }


    int compareIgnoreCase (const CharPointer_UTF8 other) const noexcept
    {
        return CharacterFunctions::compareIgnoreCase (*this, other);
    }


    template <typename CharPointer>
    int compareIgnoreCaseUpTo (const CharPointer other, const int maxChars) const noexcept
    {
        return CharacterFunctions::compareIgnoreCaseUpTo (*this, other, maxChars);
    }


    template <typename CharPointer>
    int indexOf (const CharPointer stringToFind) const noexcept
    {
        return CharacterFunctions::indexOf (*this, stringToFind);
    }


    int indexOf (const juce_wchar charToFind) const noexcept
    {
        return CharacterFunctions::indexOfChar (*this, charToFind);
    }


    int indexOf (const juce_wchar charToFind, const bool ignoreCase) const noexcept
    {
        return ignoreCase ? CharacterFunctions::indexOfCharIgnoreCase (*this, charToFind)
                          : CharacterFunctions::indexOfChar (*this, charToFind);
    }


    bool isWhitespace() const noexcept { const CharType c = *data; return c == ' ' || (c <= 13 && c >= 9); }

    bool isDigit() const noexcept { const CharType c = *data; return c >= '0' && c <= '9'; }

    bool isLetter() const noexcept { return CharacterFunctions::isLetter (operator*()) != 0; }

    bool isLetterOrDigit() const noexcept { return CharacterFunctions::isLetterOrDigit (operator*()) != 0; }

    bool isUpperCase() const noexcept { return CharacterFunctions::isUpperCase (operator*()) != 0; }

    bool isLowerCase() const noexcept { return CharacterFunctions::isLowerCase (operator*()) != 0; }


    juce_wchar toUpperCase() const noexcept { return CharacterFunctions::toUpperCase (operator*()); }

    juce_wchar toLowerCase() const noexcept { return CharacterFunctions::toLowerCase (operator*()); }


    int getIntValue32() const noexcept { return atoi (data); }


    int64 getIntValue64() const noexcept
    {



        return _atoi64 (data);



    }


    double getDoubleValue() const noexcept { return CharacterFunctions::getDoubleValue (*this); }


    CharPointer_UTF8 findEndOfWhitespace() const noexcept { return CharacterFunctions::findEndOfWhitespace (*this); }


    static bool canRepresent (juce_wchar character) noexcept
    {
        return ((unsigned int) character) < (unsigned int) 0x10ffff;
    }


    static bool isValidString (const CharType* dataToTest, int maxBytesToRead)
    {
        while (--maxBytesToRead >= 0 && *dataToTest != 0)
        {
            const signed char byte = (signed char) *dataToTest++;

            if (byte < 0)
            {
                int bit = 0x40;
                int numExtraValues = 0;

                while ((byte & bit) != 0)
                {
                    if (bit < 8)
                        return false;

                    ++numExtraValues;
                    bit >>= 1;

                    if (bit == 8 && (numExtraValues > maxBytesToRead
                                       || *CharPointer_UTF8 (dataToTest - 1) > 0x10ffff))
                        return false;
                }

                if (numExtraValues == 0)
                    return false;

                maxBytesToRead -= numExtraValues;
                if (maxBytesToRead < 0)
                    return false;

                while (--numExtraValues >= 0)
                    if ((*dataToTest++ & 0xc0) != 0x80)
                        return false;
            }
        }

        return true;
    }


    CharPointer_UTF8 atomicSwap (const CharPointer_UTF8 newValue)
    {
        return CharPointer_UTF8 (reinterpret_cast<Atomic<CharType*>&> (data).exchange (newValue.data));
    }


    enum
    {
        byteOrderMark1 = 0xef,
        byteOrderMark2 = 0xbb,
        byteOrderMark3 = 0xbf
    };




    static bool isByteOrderMark (const void* possibleByteOrder) noexcept
    {
#pragma warning(push)
# 560 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_CharPointer_UTF8.h"
#pragma warning(disable: 4127)
# 560 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_CharPointer_UTF8.h"
 do { ; } while (false)
# 560 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_CharPointer_UTF8.h"
#pragma warning(pop)
# 560 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_CharPointer_UTF8.h"
;
        const uint8* const c = static_cast<const uint8*> (possibleByteOrder);

        return c[0] == (uint8) byteOrderMark1
            && c[1] == (uint8) byteOrderMark2
            && c[2] == (uint8) byteOrderMark3;
    }

private:
    CharType* data;
};
# 212 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_CharPointer_UTF16.h" 1
# 41 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_CharPointer_UTF16.h"
class CharPointer_UTF16
{
public:

    typedef wchar_t CharType;




    inline explicit CharPointer_UTF16 (const CharType* const rawPointer) noexcept
        : data (const_cast<CharType*> (rawPointer))
    {
    }

    inline CharPointer_UTF16 (const CharPointer_UTF16& other) noexcept
        : data (other.data)
    {
    }

    inline CharPointer_UTF16 operator= (CharPointer_UTF16 other) noexcept
    {
        data = other.data;
        return *this;
    }

    inline CharPointer_UTF16 operator= (const CharType* text) noexcept
    {
        data = const_cast<CharType*> (text);
        return *this;
    }


    inline bool operator== (CharPointer_UTF16 other) const noexcept { return data == other.data; }
    inline bool operator!= (CharPointer_UTF16 other) const noexcept { return data != other.data; }
    inline bool operator<= (CharPointer_UTF16 other) const noexcept { return data <= other.data; }
    inline bool operator< (CharPointer_UTF16 other) const noexcept { return data < other.data; }
    inline bool operator>= (CharPointer_UTF16 other) const noexcept { return data >= other.data; }
    inline bool operator> (CharPointer_UTF16 other) const noexcept { return data > other.data; }


    inline CharType* getAddress() const noexcept { return data; }


    inline operator const CharType*() const noexcept { return data; }


    inline bool isEmpty() const noexcept { return *data == 0; }


    juce_wchar operator*() const noexcept
    {
        uint32 n = (uint32) (uint16) *data;

        if (n >= 0xd800 && n <= 0xdfff && ((uint32) (uint16) data[1]) >= 0xdc00)
            n = 0x10000 + (((n - 0xd800) << 10) | (((uint32) (uint16) data[1]) - 0xdc00));

        return (juce_wchar) n;
    }


    CharPointer_UTF16 operator++() noexcept
    {
        const juce_wchar n = *data++;

        if (n >= 0xd800 && n <= 0xdfff && ((uint32) (uint16) *data) >= 0xdc00)
            ++data;

        return *this;
    }


    CharPointer_UTF16 operator--() noexcept
    {
        const juce_wchar n = *--data;

        if (n >= 0xdc00 && n <= 0xdfff)
            --data;

        return *this;
    }



    juce_wchar getAndAdvance() noexcept
    {
        uint32 n = (uint32) (uint16) *data++;

        if (n >= 0xd800 && n <= 0xdfff && ((uint32) (uint16) *data) >= 0xdc00)
            n = 0x10000 + ((((n - 0xd800) << 10) | (((uint32) (uint16) *data++) - 0xdc00)));

        return (juce_wchar) n;
    }


    CharPointer_UTF16 operator++ (int) noexcept
    {
        CharPointer_UTF16 temp (*this);
        ++*this;
        return temp;
    }


    void operator+= (int numToSkip) noexcept
    {
        if (numToSkip < 0)
        {
            while (++numToSkip <= 0)
                --*this;
        }
        else
        {
            while (--numToSkip >= 0)
                ++*this;
        }
    }


    void operator-= (int numToSkip) noexcept
    {
        operator+= (-numToSkip);
    }


    juce_wchar operator[] (const int characterIndex) const noexcept
    {
        CharPointer_UTF16 p (*this);
        p += characterIndex;
        return *p;
    }


    CharPointer_UTF16 operator+ (const int numToSkip) const noexcept
    {
        CharPointer_UTF16 p (*this);
        p += numToSkip;
        return p;
    }


    CharPointer_UTF16 operator- (const int numToSkip) const noexcept
    {
        CharPointer_UTF16 p (*this);
        p += -numToSkip;
        return p;
    }


    void write (juce_wchar charToWrite) noexcept
    {
        if (charToWrite >= 0x10000)
        {
            charToWrite -= 0x10000;
            *data++ = (CharType) (0xd800 + (charToWrite >> 10));
            *data++ = (CharType) (0xdc00 + (charToWrite & 0x3ff));
        }
        else
        {
            *data++ = (CharType) charToWrite;
        }
    }


    inline void writeNull() const noexcept
    {
        *data = 0;
    }


    size_t length() const noexcept
    {
        const CharType* d = data;
        size_t count = 0;

        for (;;)
        {
            const int n = *d++;

            if (n >= 0xd800 && n <= 0xdfff)
            {
                if (*d++ == 0)
                    break;
            }
            else if (n == 0)
                break;

            ++count;
        }

        return count;
    }


    size_t lengthUpTo (const size_t maxCharsToCount) const noexcept
    {
        return CharacterFunctions::lengthUpTo (*this, maxCharsToCount);
    }


    size_t lengthUpTo (const CharPointer_UTF16 end) const noexcept
    {
        return CharacterFunctions::lengthUpTo (*this, end);
    }




    size_t sizeInBytes() const noexcept
    {
        return sizeof (CharType) * (findNullIndex (data) + 1);
    }




    static size_t getBytesRequiredFor (const juce_wchar charToWrite) noexcept
    {
        return (charToWrite >= 0x10000) ? (sizeof (CharType) * 2) : sizeof (CharType);
    }





    template <class CharPointer>
    static size_t getBytesRequiredFor (CharPointer text) noexcept
    {
        size_t count = 0;
        juce_wchar n;

        while ((n = text.getAndAdvance()) != 0)
            count += getBytesRequiredFor (n);

        return count;
    }


    CharPointer_UTF16 findTerminatingNull() const noexcept
    {
        const CharType* t = data;

        while (*t != 0)
            ++t;

        return CharPointer_UTF16 (t);
    }


    template <typename CharPointer>
    void writeAll (const CharPointer src) noexcept
    {
        CharacterFunctions::copyAll (*this, src);
    }


    void writeAll (const CharPointer_UTF16 src) noexcept
    {
        const CharType* s = src.data;

        while ((*data = *s) != 0)
        {
            ++data;
            ++s;
        }
    }





    template <typename CharPointer>
    size_t writeWithDestByteLimit (const CharPointer src, const size_t maxDestBytes) noexcept
    {
        return CharacterFunctions::copyWithDestByteLimit (*this, src, maxDestBytes);
    }





    template <typename CharPointer>
    void writeWithCharLimit (const CharPointer src, const int maxChars) noexcept
    {
        CharacterFunctions::copyWithCharLimit (*this, src, maxChars);
    }


    template <typename CharPointer>
    int compare (const CharPointer other) const noexcept
    {
        return CharacterFunctions::compare (*this, other);
    }


    template <typename CharPointer>
    int compareUpTo (const CharPointer other, const int maxChars) const noexcept
    {
        return CharacterFunctions::compareUpTo (*this, other, maxChars);
    }


    template <typename CharPointer>
    int compareIgnoreCase (const CharPointer other) const noexcept
    {
        return CharacterFunctions::compareIgnoreCase (*this, other);
    }


    template <typename CharPointer>
    int compareIgnoreCaseUpTo (const CharPointer other, const int maxChars) const noexcept
    {
        return CharacterFunctions::compareIgnoreCaseUpTo (*this, other, maxChars);
    }


    int compareIgnoreCase (const CharPointer_UTF16 other) const noexcept
    {
        return _wcsicmp (data, other.data);
    }

    int compareIgnoreCaseUpTo (const CharPointer_UTF16 other, int maxChars) const noexcept
    {
        return _wcsnicmp (data, other.data, (size_t) maxChars);
    }

    int indexOf (const CharPointer_UTF16 stringToFind) const noexcept
    {
        const CharType* const t = wcsstr (data, stringToFind.getAddress());
        return t == nullptr ? -1 : (int) (t - data);
    }



    template <typename CharPointer>
    int indexOf (const CharPointer stringToFind) const noexcept
    {
        return CharacterFunctions::indexOf (*this, stringToFind);
    }


    int indexOf (const juce_wchar charToFind) const noexcept
    {
        return CharacterFunctions::indexOfChar (*this, charToFind);
    }


    int indexOf (const juce_wchar charToFind, const bool ignoreCase) const noexcept
    {
        return ignoreCase ? CharacterFunctions::indexOfCharIgnoreCase (*this, charToFind)
                          : CharacterFunctions::indexOfChar (*this, charToFind);
    }


    bool isWhitespace() const noexcept { return CharacterFunctions::isWhitespace (operator*()) != 0; }

    bool isDigit() const noexcept { return CharacterFunctions::isDigit (operator*()) != 0; }

    bool isLetter() const noexcept { return CharacterFunctions::isLetter (operator*()) != 0; }

    bool isLetterOrDigit() const noexcept { return CharacterFunctions::isLetterOrDigit (operator*()) != 0; }

    bool isUpperCase() const noexcept { return CharacterFunctions::isUpperCase (operator*()) != 0; }

    bool isLowerCase() const noexcept { return CharacterFunctions::isLowerCase (operator*()) != 0; }


    juce_wchar toUpperCase() const noexcept { return CharacterFunctions::toUpperCase (operator*()); }

    juce_wchar toLowerCase() const noexcept { return CharacterFunctions::toLowerCase (operator*()); }


    int getIntValue32() const noexcept
    {

        return _wtoi (data);



    }


    int64 getIntValue64() const noexcept
    {

        return _wtoi64 (data);



    }


    double getDoubleValue() const noexcept { return CharacterFunctions::getDoubleValue (*this); }


    CharPointer_UTF16 findEndOfWhitespace() const noexcept { return CharacterFunctions::findEndOfWhitespace (*this); }


    static bool canRepresent (juce_wchar character) noexcept
    {
        return ((unsigned int) character) < (unsigned int) 0x10ffff
                 && (((unsigned int) character) < 0xd800 || ((unsigned int) character) > 0xdfff);
    }


    static bool isValidString (const CharType* dataToTest, int maxBytesToRead)
    {
        maxBytesToRead /= (int) sizeof (CharType);

        while (--maxBytesToRead >= 0 && *dataToTest != 0)
        {
            const uint32 n = (uint32) (uint16) *dataToTest++;

            if (n >= 0xd800)
            {
                if (n > 0x10ffff)
                    return false;

                if (n <= 0xdfff)
                {
                    if (n > 0xdc00)
                        return false;

                    const uint32 nextChar = (uint32) (uint16) *dataToTest++;

                    if (nextChar < 0xdc00 || nextChar > 0xdfff)
                        return false;
                }
            }
        }

        return true;
    }


    CharPointer_UTF16 atomicSwap (const CharPointer_UTF16 newValue)
    {
        return CharPointer_UTF16 (reinterpret_cast<Atomic<CharType*>&> (data).exchange (newValue.data));
    }


    enum
    {
        byteOrderMarkBE1 = 0xfe,
        byteOrderMarkBE2 = 0xff,
        byteOrderMarkLE1 = 0xff,
        byteOrderMarkLE2 = 0xfe
    };




    static bool isByteOrderMarkBigEndian (const void* possibleByteOrder) noexcept
    {
#pragma warning(push)
# 493 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_CharPointer_UTF16.h"
#pragma warning(disable: 4127)
# 493 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_CharPointer_UTF16.h"
 do { ; } while (false)
# 493 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_CharPointer_UTF16.h"
#pragma warning(pop)
# 493 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_CharPointer_UTF16.h"
;
        const uint8* const c = static_cast<const uint8*> (possibleByteOrder);

        return c[0] == (uint8) byteOrderMarkBE1
            && c[1] == (uint8) byteOrderMarkBE2;
    }




    static bool isByteOrderMarkLittleEndian (const void* possibleByteOrder) noexcept
    {
#pragma warning(push)
# 505 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_CharPointer_UTF16.h"
#pragma warning(disable: 4127)
# 505 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_CharPointer_UTF16.h"
 do { ; } while (false)
# 505 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_CharPointer_UTF16.h"
#pragma warning(pop)
# 505 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_CharPointer_UTF16.h"
;
        const uint8* const c = static_cast<const uint8*> (possibleByteOrder);

        return c[0] == (uint8) byteOrderMarkLE1
            && c[1] == (uint8) byteOrderMarkLE2;
    }

private:
    CharType* data;

    static unsigned int findNullIndex (const CharType* const t) noexcept
    {
        unsigned int n = 0;

        while (t[n] != 0)
            ++n;

        return n;
    }
};
# 213 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_CharPointer_UTF32.h" 1
# 41 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_CharPointer_UTF32.h"
class CharPointer_UTF32
{
public:
    typedef juce_wchar CharType;

    inline explicit CharPointer_UTF32 (const CharType* const rawPointer) noexcept
        : data (const_cast<CharType*> (rawPointer))
    {
    }

    inline CharPointer_UTF32 (const CharPointer_UTF32& other) noexcept
        : data (other.data)
    {
    }

    inline CharPointer_UTF32 operator= (CharPointer_UTF32 other) noexcept
    {
        data = other.data;
        return *this;
    }

    inline CharPointer_UTF32 operator= (const CharType* text) noexcept
    {
        data = const_cast<CharType*> (text);
        return *this;
    }


    inline bool operator== (CharPointer_UTF32 other) const noexcept { return data == other.data; }
    inline bool operator!= (CharPointer_UTF32 other) const noexcept { return data != other.data; }
    inline bool operator<= (CharPointer_UTF32 other) const noexcept { return data <= other.data; }
    inline bool operator< (CharPointer_UTF32 other) const noexcept { return data < other.data; }
    inline bool operator>= (CharPointer_UTF32 other) const noexcept { return data >= other.data; }
    inline bool operator> (CharPointer_UTF32 other) const noexcept { return data > other.data; }


    inline CharType* getAddress() const noexcept { return data; }


    inline operator const CharType*() const noexcept { return data; }


    inline bool isEmpty() const noexcept { return *data == 0; }


    inline juce_wchar operator*() const noexcept { return *data; }


    inline CharPointer_UTF32 operator++() noexcept
    {
        ++data;
        return *this;
    }


    inline CharPointer_UTF32 operator--() noexcept
    {
        --data;
        return *this;
    }



    inline juce_wchar getAndAdvance() noexcept { return *data++; }


    CharPointer_UTF32 operator++ (int) noexcept
    {
        CharPointer_UTF32 temp (*this);
        ++data;
        return temp;
    }


    inline void operator+= (const int numToSkip) noexcept
    {
        data += numToSkip;
    }

    inline void operator-= (const int numToSkip) noexcept
    {
        data -= numToSkip;
    }


    inline juce_wchar& operator[] (const int characterIndex) const noexcept
    {
        return data [characterIndex];
    }


    CharPointer_UTF32 operator+ (const int numToSkip) const noexcept
    {
        return CharPointer_UTF32 (data + numToSkip);
    }


    CharPointer_UTF32 operator- (const int numToSkip) const noexcept
    {
        return CharPointer_UTF32 (data - numToSkip);
    }


    inline void write (const juce_wchar charToWrite) noexcept
    {
        *data++ = charToWrite;
    }

    inline void replaceChar (const juce_wchar newChar) noexcept
    {
        *data = newChar;
    }


    inline void writeNull() const noexcept
    {
        *data = 0;
    }


    size_t length() const noexcept
    {



        size_t n = 0;
        while (data[n] != 0)
            ++n;
        return n;

    }


    size_t lengthUpTo (const size_t maxCharsToCount) const noexcept
    {
        return CharacterFunctions::lengthUpTo (*this, maxCharsToCount);
    }


    size_t lengthUpTo (const CharPointer_UTF32 end) const noexcept
    {
        return CharacterFunctions::lengthUpTo (*this, end);
    }




    size_t sizeInBytes() const noexcept
    {
        return sizeof (CharType) * (length() + 1);
    }




    static inline size_t getBytesRequiredFor (const juce_wchar) noexcept
    {
        return sizeof (CharType);
    }





    template <class CharPointer>
    static size_t getBytesRequiredFor (const CharPointer text) noexcept
    {
        return sizeof (CharType) * text.length();
    }


    CharPointer_UTF32 findTerminatingNull() const noexcept
    {
        return CharPointer_UTF32 (data + length());
    }


    template <typename CharPointer>
    void writeAll (const CharPointer src) noexcept
    {
        CharacterFunctions::copyAll (*this, src);
    }


    void writeAll (const CharPointer_UTF32 src) noexcept
    {
        const CharType* s = src.data;

        while ((*data = *s) != 0)
        {
            ++data;
            ++s;
        }
    }





    template <typename CharPointer>
    size_t writeWithDestByteLimit (const CharPointer src, const size_t maxDestBytes) noexcept
    {
        return CharacterFunctions::copyWithDestByteLimit (*this, src, maxDestBytes);
    }





    template <typename CharPointer>
    void writeWithCharLimit (const CharPointer src, const int maxChars) noexcept
    {
        CharacterFunctions::copyWithCharLimit (*this, src, maxChars);
    }


    template <typename CharPointer>
    int compare (const CharPointer other) const noexcept
    {
        return CharacterFunctions::compare (*this, other);
    }
# 272 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_CharPointer_UTF32.h"
    template <typename CharPointer>
    int compareUpTo (const CharPointer other, const int maxChars) const noexcept
    {
        return CharacterFunctions::compareUpTo (*this, other, maxChars);
    }


    template <typename CharPointer>
    int compareIgnoreCase (const CharPointer other) const
    {
        return CharacterFunctions::compareIgnoreCase (*this, other);
    }


    template <typename CharPointer>
    int compareIgnoreCaseUpTo (const CharPointer other, const int maxChars) const noexcept
    {
        return CharacterFunctions::compareIgnoreCaseUpTo (*this, other, maxChars);
    }


    template <typename CharPointer>
    int indexOf (const CharPointer stringToFind) const noexcept
    {
        return CharacterFunctions::indexOf (*this, stringToFind);
    }


    int indexOf (const juce_wchar charToFind) const noexcept
    {
        int i = 0;

        while (data[i] != 0)
        {
            if (data[i] == charToFind)
                return i;

            ++i;
        }

        return -1;
    }


    int indexOf (const juce_wchar charToFind, const bool ignoreCase) const noexcept
    {
        return ignoreCase ? CharacterFunctions::indexOfCharIgnoreCase (*this, charToFind)
                          : CharacterFunctions::indexOfChar (*this, charToFind);
    }


    bool isWhitespace() const { return CharacterFunctions::isWhitespace (*data) != 0; }

    bool isDigit() const { return CharacterFunctions::isDigit (*data) != 0; }

    bool isLetter() const { return CharacterFunctions::isLetter (*data) != 0; }

    bool isLetterOrDigit() const { return CharacterFunctions::isLetterOrDigit (*data) != 0; }

    bool isUpperCase() const { return CharacterFunctions::isUpperCase (*data) != 0; }

    bool isLowerCase() const { return CharacterFunctions::isLowerCase (*data) != 0; }


    juce_wchar toUpperCase() const noexcept { return CharacterFunctions::toUpperCase (*data); }

    juce_wchar toLowerCase() const noexcept { return CharacterFunctions::toLowerCase (*data); }


    int getIntValue32() const noexcept { return CharacterFunctions::getIntValue <int, CharPointer_UTF32> (*this); }

    int64 getIntValue64() const noexcept { return CharacterFunctions::getIntValue <int64, CharPointer_UTF32> (*this); }


    double getDoubleValue() const noexcept { return CharacterFunctions::getDoubleValue (*this); }


    CharPointer_UTF32 findEndOfWhitespace() const noexcept { return CharacterFunctions::findEndOfWhitespace (*this); }


    static bool canRepresent (juce_wchar character) noexcept
    {
        return ((unsigned int) character) < (unsigned int) 0x10ffff;
    }


    static bool isValidString (const CharType* dataToTest, int maxBytesToRead)
    {
        maxBytesToRead /= (int) sizeof (CharType);

        while (--maxBytesToRead >= 0 && *dataToTest != 0)
            if (! canRepresent (*dataToTest++))
                return false;

        return true;
    }


    CharPointer_UTF32 atomicSwap (const CharPointer_UTF32 newValue)
    {
        return CharPointer_UTF32 (reinterpret_cast<Atomic<CharType*>&> (data).exchange (newValue.data));
    }

private:
    CharType* data;
};
# 214 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_CharPointer_ASCII.h" 1
# 44 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_CharPointer_ASCII.h"
class CharPointer_ASCII
{
public:
    typedef char CharType;

    inline explicit CharPointer_ASCII (const CharType* const rawPointer) noexcept
        : data (const_cast<CharType*> (rawPointer))
    {
    }

    inline CharPointer_ASCII (const CharPointer_ASCII& other) noexcept
        : data (other.data)
    {
    }

    inline CharPointer_ASCII operator= (const CharPointer_ASCII other) noexcept
    {
        data = other.data;
        return *this;
    }

    inline CharPointer_ASCII operator= (const CharType* text) noexcept
    {
        data = const_cast<CharType*> (text);
        return *this;
    }


    inline bool operator== (CharPointer_ASCII other) const noexcept { return data == other.data; }
    inline bool operator!= (CharPointer_ASCII other) const noexcept { return data != other.data; }
    inline bool operator<= (CharPointer_ASCII other) const noexcept { return data <= other.data; }
    inline bool operator< (CharPointer_ASCII other) const noexcept { return data < other.data; }
    inline bool operator>= (CharPointer_ASCII other) const noexcept { return data >= other.data; }
    inline bool operator> (CharPointer_ASCII other) const noexcept { return data > other.data; }


    inline CharType* getAddress() const noexcept { return data; }


    inline operator const CharType*() const noexcept { return data; }


    inline bool isEmpty() const noexcept { return *data == 0; }


    inline juce_wchar operator*() const noexcept { return (juce_wchar) (uint8) *data; }


    inline CharPointer_ASCII operator++() noexcept
    {
        ++data;
        return *this;
    }


    inline CharPointer_ASCII operator--() noexcept
    {
        --data;
        return *this;
    }



    inline juce_wchar getAndAdvance() noexcept { return (juce_wchar) (uint8) *data++; }


    CharPointer_ASCII operator++ (int) noexcept
    {
        CharPointer_ASCII temp (*this);
        ++data;
        return temp;
    }


    inline void operator+= (const int numToSkip) noexcept
    {
        data += numToSkip;
    }

    inline void operator-= (const int numToSkip) noexcept
    {
        data -= numToSkip;
    }


    inline juce_wchar operator[] (const int characterIndex) const noexcept
    {
        return (juce_wchar) (unsigned char) data [characterIndex];
    }


    CharPointer_ASCII operator+ (const int numToSkip) const noexcept
    {
        return CharPointer_ASCII (data + numToSkip);
    }


    CharPointer_ASCII operator- (const int numToSkip) const noexcept
    {
        return CharPointer_ASCII (data - numToSkip);
    }


    inline void write (const juce_wchar charToWrite) noexcept
    {
        *data++ = (char) charToWrite;
    }

    inline void replaceChar (const juce_wchar newChar) noexcept
    {
        *data = (char) newChar;
    }


    inline void writeNull() const noexcept
    {
        *data = 0;
    }


    size_t length() const noexcept
    {
        return (size_t) strlen (data);
    }


    size_t lengthUpTo (const size_t maxCharsToCount) const noexcept
    {
        return CharacterFunctions::lengthUpTo (*this, maxCharsToCount);
    }


    size_t lengthUpTo (const CharPointer_ASCII end) const noexcept
    {
        return CharacterFunctions::lengthUpTo (*this, end);
    }




    size_t sizeInBytes() const noexcept
    {
        return length() + 1;
    }




    static inline size_t getBytesRequiredFor (const juce_wchar) noexcept
    {
        return 1;
    }





    template <class CharPointer>
    static size_t getBytesRequiredFor (const CharPointer text) noexcept
    {
        return text.length();
    }


    CharPointer_ASCII findTerminatingNull() const noexcept
    {
        return CharPointer_ASCII (data + length());
    }


    template <typename CharPointer>
    void writeAll (const CharPointer src) noexcept
    {
        CharacterFunctions::copyAll (*this, src);
    }





    template <typename CharPointer>
    size_t writeWithDestByteLimit (const CharPointer src, const size_t maxDestBytes) noexcept
    {
        return CharacterFunctions::copyWithDestByteLimit (*this, src, maxDestBytes);
    }





    template <typename CharPointer>
    void writeWithCharLimit (const CharPointer src, const int maxChars) noexcept
    {
        CharacterFunctions::copyWithCharLimit (*this, src, maxChars);
    }


    template <typename CharPointer>
    int compare (const CharPointer other) const noexcept
    {
        return CharacterFunctions::compare (*this, other);
    }


    int compare (const CharPointer_ASCII other) const noexcept
    {
        return strcmp (data, other.data);
    }


    template <typename CharPointer>
    int compareUpTo (const CharPointer other, const int maxChars) const noexcept
    {
        return CharacterFunctions::compareUpTo (*this, other, maxChars);
    }


    int compareUpTo (const CharPointer_ASCII other, const int maxChars) const noexcept
    {
        return strncmp (data, other.data, (size_t) maxChars);
    }


    template <typename CharPointer>
    int compareIgnoreCase (const CharPointer other) const
    {
        return CharacterFunctions::compareIgnoreCase (*this, other);
    }

    int compareIgnoreCase (const CharPointer_ASCII other) const
    {



        return stricmp (data, other.data);



    }


    template <typename CharPointer>
    int compareIgnoreCaseUpTo (const CharPointer other, const int maxChars) const noexcept
    {
        return CharacterFunctions::compareIgnoreCaseUpTo (*this, other, maxChars);
    }


    template <typename CharPointer>
    int indexOf (const CharPointer stringToFind) const noexcept
    {
        return CharacterFunctions::indexOf (*this, stringToFind);
    }


    int indexOf (const juce_wchar charToFind) const noexcept
    {
        int i = 0;

        while (data[i] != 0)
        {
            if (data[i] == (char) charToFind)
                return i;

            ++i;
        }

        return -1;
    }


    int indexOf (const juce_wchar charToFind, const bool ignoreCase) const noexcept
    {
        return ignoreCase ? CharacterFunctions::indexOfCharIgnoreCase (*this, charToFind)
                          : CharacterFunctions::indexOfChar (*this, charToFind);
    }


    bool isWhitespace() const { return CharacterFunctions::isWhitespace (*data) != 0; }

    bool isDigit() const { return CharacterFunctions::isDigit (*data) != 0; }

    bool isLetter() const { return CharacterFunctions::isLetter (*data) != 0; }

    bool isLetterOrDigit() const { return CharacterFunctions::isLetterOrDigit (*data) != 0; }

    bool isUpperCase() const { return CharacterFunctions::isUpperCase ((juce_wchar) (uint8) *data) != 0; }

    bool isLowerCase() const { return CharacterFunctions::isLowerCase ((juce_wchar) (uint8) *data) != 0; }


    juce_wchar toUpperCase() const noexcept { return CharacterFunctions::toUpperCase ((juce_wchar) (uint8) *data); }

    juce_wchar toLowerCase() const noexcept { return CharacterFunctions::toLowerCase ((juce_wchar) (uint8) *data); }


    int getIntValue32() const noexcept { return atoi (data); }


    int64 getIntValue64() const noexcept
    {



        return _atoi64 (data);



    }


    double getDoubleValue() const noexcept { return CharacterFunctions::getDoubleValue (*this); }


    CharPointer_ASCII findEndOfWhitespace() const noexcept { return CharacterFunctions::findEndOfWhitespace (*this); }


    static bool canRepresent (juce_wchar character) noexcept
    {
        return ((unsigned int) character) < (unsigned int) 128;
    }


    static bool isValidString (const CharType* dataToTest, int maxBytesToRead)
    {
        while (--maxBytesToRead >= 0)
        {
            if (((signed char) *dataToTest) <= 0)
                return *dataToTest == 0;

            ++dataToTest;
        }

        return true;
    }

private:
    CharType* data;
};
# 215 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2



#pragma warning(pop)



# 1 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h" 1
# 45 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
class String
{
public:




    String() noexcept;


    String (const String& other) noexcept;


    String (String&& other) noexcept;
# 74 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    String (const char* text);
# 92 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    String (const char* text, size_t maxChars);




    String (const wchar_t* text);




    String (const wchar_t* text, size_t maxChars);



    String (const CharPointer_UTF8 text);


    String (const CharPointer_UTF8 text, size_t maxChars);


    String (const CharPointer_UTF8 start, const CharPointer_UTF8 end);



    String (const CharPointer_UTF16 text);


    String (const CharPointer_UTF16 text, size_t maxChars);


    String (const CharPointer_UTF16 start, const CharPointer_UTF16 end);



    String (const CharPointer_UTF32 text);


    String (const CharPointer_UTF32 text, size_t maxChars);


    String (const CharPointer_UTF32 start, const CharPointer_UTF32 end);



    String (const CharPointer_ASCII text);


    String (const std::string&);


    String (StringRef);



    static String charToString (juce_wchar character);


    ~String() noexcept;
# 159 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    static const String empty;
# 179 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    typedef CharPointer_UTF8 CharPointerType;






    int hashCode() const noexcept;


    int64 hashCode64() const noexcept;


    size_t hash() const noexcept;


    int length() const noexcept;





    String& operator= (const String& other) noexcept;


    String& operator= (String&& other) noexcept;



    String& operator+= (const String& stringToAppend);

    String& operator+= (const char* textToAppend);

    String& operator+= (const wchar_t* textToAppend);

    String& operator+= (StringRef textToAppend);

    String& operator+= (int numberToAppend);

    String& operator+= (long numberToAppend);

    String& operator+= (int64 numberToAppend);

    String& operator+= (uint64 numberToAppend);

    String& operator+= (char characterToAppend);

    String& operator+= (wchar_t characterToAppend);


    String& operator+= (juce_wchar characterToAppend);







    void append (const String& textToAppend, size_t maxCharsToTake);






    void appendCharPointer (const CharPointerType startOfTextToAppend,
                            const CharPointerType endOfTextToAppend);






    template <class CharPointer>
    void appendCharPointer (const CharPointer startOfTextToAppend,
                            const CharPointer endOfTextToAppend)
    {
#pragma warning(push)
# 256 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
#pragma warning(disable: 4127)
# 256 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
 do { ; } while (false)
# 256 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
#pragma warning(pop)
# 256 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
;

        size_t extraBytesNeeded = 0, numChars = 1;

        for (CharPointer t (startOfTextToAppend); t != endOfTextToAppend && ! t.isEmpty(); ++numChars)
            extraBytesNeeded += CharPointerType::getBytesRequiredFor (t.getAndAdvance());

        if (extraBytesNeeded > 0)
        {
            const size_t byteOffsetOfNull = getByteOffsetOfEnd();

            preallocateBytes (byteOffsetOfNull + extraBytesNeeded);
            CharPointerType (addBytesToPointer (text.getAddress(), (int) byteOffsetOfNull))
                .writeWithCharLimit (startOfTextToAppend, (int) numChars);
        }
    }


    void appendCharPointer (const CharPointerType textToAppend);






    template <class CharPointer>
    void appendCharPointer (const CharPointer textToAppend, size_t maxCharsToTake)
    {
        if (textToAppend.getAddress() != nullptr)
        {
            size_t extraBytesNeeded = 0, numChars = 1;

            for (CharPointer t (textToAppend); numChars <= maxCharsToTake && ! t.isEmpty(); ++numChars)
                extraBytesNeeded += CharPointerType::getBytesRequiredFor (t.getAndAdvance());

            if (extraBytesNeeded > 0)
            {
                const size_t byteOffsetOfNull = getByteOffsetOfEnd();

                preallocateBytes (byteOffsetOfNull + extraBytesNeeded);
                CharPointerType (addBytesToPointer (text.getAddress(), (int) byteOffsetOfNull))
                    .writeWithCharLimit (textToAppend, (int) numChars);
            }
        }
    }


    template <class CharPointer>
    void appendCharPointer (const CharPointer textToAppend)
    {
        appendCharPointer (textToAppend, std::numeric_limits<size_t>::max());
    }
# 316 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    inline bool isEmpty() const noexcept { return text.isEmpty(); }





    inline bool isNotEmpty() const noexcept { return ! text.isEmpty(); }


    void clear() noexcept;


    bool equalsIgnoreCase (const String& other) const noexcept;


    bool equalsIgnoreCase (StringRef other) const noexcept;


    bool equalsIgnoreCase (const wchar_t* other) const noexcept;


    bool equalsIgnoreCase (const char* other) const noexcept;





    int compare (const String& other) const noexcept;





    int compare (const char* other) const noexcept;





    int compare (const wchar_t* other) const noexcept;





    int compareIgnoreCase (const String& other) const noexcept;
# 371 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    int compareNatural (StringRef other, bool isCaseSensitive = false) const noexcept;





    bool startsWith (StringRef text) const noexcept;





    bool startsWithChar (juce_wchar character) const noexcept;





    bool startsWithIgnoreCase (StringRef text) const noexcept;





    bool endsWith (StringRef text) const noexcept;





    bool endsWithChar (juce_wchar character) const noexcept;





    bool endsWithIgnoreCase (StringRef text) const noexcept;





    bool contains (StringRef text) const noexcept;




    bool containsChar (juce_wchar character) const noexcept;




    bool containsIgnoreCase (StringRef text) const noexcept;







    bool containsWholeWord (StringRef wordToLookFor) const noexcept;







    bool containsWholeWordIgnoreCase (StringRef wordToLookFor) const noexcept;
# 448 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    int indexOfWholeWord (StringRef wordToLookFor) const noexcept;
# 457 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    int indexOfWholeWordIgnoreCase (StringRef wordToLookFor) const noexcept;







    bool containsAnyOf (StringRef charactersItMightContain) const noexcept;
# 474 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    bool containsOnly (StringRef charactersItMightContain) const noexcept;
# 483 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    bool containsNonWhitespaceChars() const noexcept;
# 492 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    bool matchesWildcard (StringRef wildcard, bool ignoreCase) const noexcept;
# 502 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    int indexOfChar (juce_wchar characterToLookFor) const noexcept;
# 511 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    int indexOfChar (int startIndex, juce_wchar characterToLookFor) const noexcept;
# 525 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    int indexOfAnyOf (StringRef charactersToLookFor,
                      int startIndex = 0,
                      bool ignoreCase = false) const noexcept;






    int indexOf (StringRef textToLookFor) const noexcept;
# 543 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    int indexOf (int startIndex, StringRef textToLookFor) const noexcept;






    int indexOfIgnoreCase (StringRef textToLookFor) const noexcept;
# 559 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    int indexOfIgnoreCase (int startIndex, StringRef textToLookFor) const noexcept;





    int lastIndexOfChar (juce_wchar character) const noexcept;






    int lastIndexOf (StringRef textToLookFor) const noexcept;






    int lastIndexOfIgnoreCase (StringRef textToLookFor) const noexcept;
# 593 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    int lastIndexOfAnyOf (StringRef charactersToLookFor,
                          bool ignoreCase = false) const noexcept;
# 611 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    juce_wchar operator[] (int index) const noexcept;




    juce_wchar getLastCharacter() const noexcept;
# 629 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    String substring (int startIndex, int endIndex) const;
# 639 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    String substring (int startIndex) const;
# 650 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    String dropLastCharacters (int numberToDrop) const;
# 659 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    String getLastCharacters (int numCharacters) const;
# 677 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    String fromFirstOccurrenceOf (StringRef substringToStartFrom,
                                  bool includeSubStringInResult,
                                  bool ignoreCase) const;
# 689 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    String fromLastOccurrenceOf (StringRef substringToFind,
                                 bool includeSubStringInResult,
                                 bool ignoreCase) const;
# 706 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    String upToFirstOccurrenceOf (StringRef substringToEndWith,
                                  bool includeSubStringInResult,
                                  bool ignoreCase) const;
# 717 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    String upToLastOccurrenceOf (StringRef substringToFind,
                                 bool includeSubStringInResult,
                                 bool ignoreCase) const;



    String trim() const;


    String trimStart() const;


    String trimEnd() const;







    String trimCharactersAtStart (StringRef charactersToTrim) const;







    String trimCharactersAtEnd (StringRef charactersToTrim) const;



    String toUpperCase() const;


    String toLowerCase() const;
# 770 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    String replaceSection (int startIndex,
                           int numCharactersToReplace,
                           StringRef stringToInsert) const;
# 781 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    String replace (StringRef stringToReplace,
                    StringRef stringToInsertInstead,
                    bool ignoreCase = false) const;


    String replaceCharacter (juce_wchar characterToReplace,
                             juce_wchar characterToInsertInstead) const;
# 799 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    String replaceCharacters (StringRef charactersToReplace,
                              StringRef charactersToInsertInstead) const;
# 811 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    String retainCharacters (StringRef charactersToRetain) const;
# 822 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    String removeCharacters (StringRef charactersToRemove) const;






    String initialSectionContainingOnly (StringRef permittedCharacters) const;







    String initialSectionNotContaining (StringRef charactersToStopAt) const;
# 846 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    bool isQuotedString() const;
# 858 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    String unquoted() const;
# 871 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    String quoted (juce_wchar quoteCharacter = '"') const;
# 880 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    static String repeatedString (StringRef stringToRepeat,
                                  int numberOfTimesToRepeat);




    String paddedLeft (juce_wchar padCharacter, int minimumLength) const;




    String paddedRight (juce_wchar padCharacter, int minimumLength) const;
# 901 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    static String createStringFromData (const void* data, int size);
# 914 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    static String formatted (const String formatString, ... );







    explicit String (int decimalInteger);




    explicit String (unsigned int decimalInteger);




    explicit String (short decimalInteger);




    explicit String (unsigned short decimalInteger);




    explicit String (int64 largeIntegerValue);




    explicit String (uint64 largeIntegerValue);




    explicit String (long decimalInteger);




    explicit String (unsigned long decimalInteger);





    explicit String (float floatValue);





    explicit String (double doubleValue);
# 978 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    String (float floatValue, int numberOfDecimalPlaces);
# 987 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    String (double doubleValue, int numberOfDecimalPlaces);






    int getIntValue() const noexcept;




    int64 getLargeIntValue() const noexcept;
# 1010 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    int getTrailingIntValue() const noexcept;






    float getFloatValue() const noexcept;






    double getDoubleValue() const noexcept;
# 1035 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    int getHexValue32() const noexcept;
# 1046 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    int64 getHexValue64() const noexcept;


    static String toHexString (int number);


    static String toHexString (int64 number);


    static String toHexString (short number);
# 1066 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    static String toHexString (const void* data, int size, int groupSize = 1);
# 1075 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    inline CharPointerType getCharPointer() const noexcept { return text; }
# 1088 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    CharPointer_UTF8 toUTF8() const;
# 1101 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    const char* toRawUTF8() const;
# 1114 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    CharPointer_UTF16 toUTF16() const;
# 1124 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    CharPointer_UTF32 toUTF32() const;
# 1138 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    const wchar_t* toWideCharPointer() const;


    std::string toStdString() const;





    static String fromUTF8 (const char* utf8buffer, int bufferSizeBytes = -1);





    size_t getNumBytesAsUTF8() const noexcept;
# 1171 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    size_t copyToUTF8 (CharPointer_UTF8::CharType* destBuffer, size_t maxBufferSizeBytes) const noexcept;
# 1188 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    size_t copyToUTF16 (CharPointer_UTF16::CharType* destBuffer, size_t maxBufferSizeBytes) const noexcept;
# 1205 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    size_t copyToUTF32 (CharPointer_UTF32::CharType* destBuffer, size_t maxBufferSizeBytes) const noexcept;
# 1222 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    void preallocateBytes (size_t numBytesNeeded);




    void swapWith (String& other) noexcept;
# 1248 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_String.h"
    int getReferenceCount() const noexcept;

private:

    CharPointerType text;


    struct PreallocationBytes
    {
        explicit PreallocationBytes (size_t) noexcept;
        size_t numBytes;
    };

    explicit String (const PreallocationBytes&);
    size_t getByteOffsetOfEnd() const noexcept;
    __declspec(deprecated) String (const String&, size_t);




    operator bool() const noexcept { return false; }
};



         String __stdcall operator+ (const char* string1, const String& string2);

         String __stdcall operator+ (const wchar_t* string1, const String& string2);

         String __stdcall operator+ (char string1, const String& string2);

         String __stdcall operator+ (wchar_t string1, const String& string2);


         String __stdcall operator+ (juce_wchar string1, const String& string2);



         String __stdcall operator+ (String string1, const String& string2);

         String __stdcall operator+ (String string1, const char* string2);

         String __stdcall operator+ (String string1, const wchar_t* string2);

         String __stdcall operator+ (String string1, char characterToAppend);

         String __stdcall operator+ (String string1, wchar_t characterToAppend);


         String __stdcall operator+ (String string1, juce_wchar characterToAppend);




         String& __stdcall operator<< (String& string1, char characterToAppend);

         String& __stdcall operator<< (String& string1, wchar_t characterToAppend);


         String& __stdcall operator<< (String& string1, juce_wchar characterToAppend);



         String& __stdcall operator<< (String& string1, const char* string2);

         String& __stdcall operator<< (String& string1, const wchar_t* string2);

         String& __stdcall operator<< (String& string1, const String& string2);

         String& __stdcall operator<< (String& string1, StringRef string2);


         String& __stdcall operator<< (String& string1, short number);

         String& __stdcall operator<< (String& string1, int number);

         String& __stdcall operator<< (String& string1, long number);

         String& __stdcall operator<< (String& string1, int64 number);

         String& __stdcall operator<< (String& string1, uint64 number);

         String& __stdcall operator<< (String& string1, float number);

         String& __stdcall operator<< (String& string1, double number);



         bool __stdcall operator== (const String& string1, const String& string2) noexcept;

         bool __stdcall operator== (const String& string1, const char* string2) noexcept;

         bool __stdcall operator== (const String& string1, const wchar_t* string2) noexcept;

         bool __stdcall operator== (const String& string1, const CharPointer_UTF8 string2) noexcept;

         bool __stdcall operator== (const String& string1, const CharPointer_UTF16 string2) noexcept;

         bool __stdcall operator== (const String& string1, const CharPointer_UTF32 string2) noexcept;


         bool __stdcall operator!= (const String& string1, const String& string2) noexcept;

         bool __stdcall operator!= (const String& string1, const char* string2) noexcept;

         bool __stdcall operator!= (const String& string1, const wchar_t* string2) noexcept;

         bool __stdcall operator!= (const String& string1, const CharPointer_UTF8 string2) noexcept;

         bool __stdcall operator!= (const String& string1, const CharPointer_UTF16 string2) noexcept;

         bool __stdcall operator!= (const String& string1, const CharPointer_UTF32 string2) noexcept;


         bool __stdcall operator> (const String& string1, const String& string2) noexcept;

         bool __stdcall operator< (const String& string1, const String& string2) noexcept;

         bool __stdcall operator>= (const String& string1, const String& string2) noexcept;

         bool __stdcall operator<= (const String& string1, const String& string2) noexcept;





template <class traits>
std::basic_ostream <char, traits>& __stdcall operator<< (std::basic_ostream <char, traits>& stream, const String& stringToWrite)
{
    return stream << stringToWrite.toRawUTF8();
}




template <class traits>
std::basic_ostream <wchar_t, traits>& __stdcall operator<< (std::basic_ostream <wchar_t, traits>& stream, const String& stringToWrite)
{
    return stream << stringToWrite.toWideCharPointer();
}


         OutputStream& __stdcall operator<< (OutputStream& stream, const String& stringToWrite);


         OutputStream& __stdcall operator<< (OutputStream& stream, StringRef stringToWrite);
# 221 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_StringRef.h" 1
# 67 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_StringRef.h"
class StringRef
{
public:





    StringRef (const char* stringLiteral) noexcept;





    StringRef (String::CharPointerType stringLiteral) noexcept;






    StringRef (const String& string) noexcept;


    StringRef() noexcept;



    operator const String::CharPointerType::CharType*() const noexcept { return text.getAddress(); }

    operator String::CharPointerType() const noexcept { return text; }


    bool isEmpty() const noexcept { return text.isEmpty(); }

    bool isNotEmpty() const noexcept { return ! text.isEmpty(); }

    int length() const noexcept { return (int) text.length(); }


    juce_wchar operator[] (int index) const noexcept { return text[index]; }


    bool operator== (const String& s) const noexcept { return text.compare (s.getCharPointer()) == 0; }

    bool operator!= (const String& s) const noexcept { return text.compare (s.getCharPointer()) != 0; }


    bool operator== (StringRef s) const noexcept { return text.compare (s.text) == 0; }

    bool operator!= (StringRef s) const noexcept { return text.compare (s.text) != 0; }



    String::CharPointerType text;






};



         bool __stdcall operator== (const String& string1, StringRef string2) noexcept;

         bool __stdcall operator!= (const String& string1, StringRef string2) noexcept;

inline String operator+ (String s1, StringRef s2) { return s1 += String (s2.text); }
inline String operator+ (StringRef s1, const String& s2) { return String (s1.text) + s2; }
inline String operator+ (const char* s1, StringRef s2) { return String (s1) + String (s2.text); }
inline String operator+ (StringRef s1, const char* s2) { return String (s1.text) + String (s2); }
# 222 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/logging/juce_Logger.h" 1
# 47 "..\\..\\..\\JUCE\\modules\\juce_core/logging/juce_Logger.h"
class Logger
{
public:


    virtual ~Logger();
# 61 "..\\..\\..\\JUCE\\modules\\juce_core/logging/juce_Logger.h"
    static void __stdcall setCurrentLogger (Logger* newLogger) noexcept;


    static Logger* __stdcall getCurrentLogger() noexcept;
# 73 "..\\..\\..\\JUCE\\modules\\juce_core/logging/juce_Logger.h"
    static void __stdcall writeToLog (const String& message);
# 82 "..\\..\\..\\JUCE\\modules\\juce_core/logging/juce_Logger.h"
    static void __stdcall outputDebugString (const String& text);


protected:

    Logger();




    virtual void logMessage (const String& message) = 0;

private:
    static Logger* currentLogger;
};
# 223 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_LeakedObjectDetector.h" 1
# 48 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_LeakedObjectDetector.h"
template <class OwnerClass>
class LeakedObjectDetector
{
public:

    LeakedObjectDetector() noexcept { ++(getCounter().numObjects); }
    LeakedObjectDetector (const LeakedObjectDetector&) noexcept { ++(getCounter().numObjects); }

    ~LeakedObjectDetector()
    {
        if (--(getCounter().numObjects) < 0)
        {
                                                                                        ;
# 73 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_LeakedObjectDetector.h"
#pragma warning(push)
# 73 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_LeakedObjectDetector.h"
#pragma warning(disable: 4127)
# 73 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_LeakedObjectDetector.h"
 do { } while (false)
# 73 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_LeakedObjectDetector.h"
#pragma warning(pop)
# 73 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_LeakedObjectDetector.h"
;
        }
    }

private:

    class LeakCounter
    {
    public:
        LeakCounter() noexcept {}

        ~LeakCounter()
        {
            if (numObjects.value > 0)
            {
                                                                                                                                   ;








#pragma warning(push)
# 97 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_LeakedObjectDetector.h"
#pragma warning(disable: 4127)
# 97 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_LeakedObjectDetector.h"
 do { } while (false)
# 97 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_LeakedObjectDetector.h"
#pragma warning(pop)
# 97 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_LeakedObjectDetector.h"
;
            }
        }

        Atomic<int> numObjects;
    };

    static const char* getLeakedObjectClassName()
    {
        return OwnerClass::getLeakedObjectClassName();
    }

    static LeakCounter& getCounter() noexcept
    {
        static LeakCounter counter;
        return counter;
    }
};
# 224 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ContainerDeletePolicy.h" 1
# 45 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ContainerDeletePolicy.h"
template <typename ObjectType>
struct ContainerDeletePolicy
{
    static void destroy (ObjectType* object)
    {
# 58 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ContainerDeletePolicy.h"
        ignoreUnused (sizeof (ObjectType));

        delete object;
    }
};
# 225 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_HeapBlock.h" 1
# 35 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_HeapBlock.h"
namespace HeapBlockHelper
{
    template <bool shouldThrow>
    struct ThrowOnFail { static void checkPointer (void*) {} };

    template<>
    struct ThrowOnFail<true> { static void checkPointer (void* data) { if (data == nullptr) throw std::bad_alloc(); } };
}
# 91 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_HeapBlock.h"
template <class ElementType, bool throwOnFailure = false>
class HeapBlock
{
public:






    HeapBlock() noexcept : data (nullptr)
    {
    }
# 113 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_HeapBlock.h"
    explicit HeapBlock (const size_t numElements)
        : data (static_cast<ElementType*> (std::malloc (numElements * sizeof (ElementType))))
    {
        throwOnAllocationFailure();
    }






    HeapBlock (const size_t numElements, const bool initialiseToZero)
        : data (static_cast<ElementType*> (initialiseToZero
                                               ? std::calloc (numElements, sizeof (ElementType))
                                               : std::malloc (numElements * sizeof (ElementType))))
    {
        throwOnAllocationFailure();
    }




    ~HeapBlock()
    {
        std::free (data);
    }


    HeapBlock (HeapBlock&& other) noexcept
        : data (other.data)
    {
        other.data = nullptr;
    }

    HeapBlock& operator= (HeapBlock&& other) noexcept
    {
        std::swap (data, other.data);
        return *this;
    }







    inline operator ElementType*() const noexcept { return data; }





    inline ElementType* getData() const noexcept { return data; }





    inline operator void*() const noexcept { return static_cast<void*> (data); }





    inline operator const void*() const noexcept { return static_cast<const void*> (data); }





    inline ElementType* operator->() const noexcept { return data; }





    template <typename IndexType>
    inline ElementType& operator[] (IndexType index) const noexcept { return data [index]; }




    template <typename IndexType>
    inline ElementType* operator+ (IndexType index) const noexcept { return data + index; }





    inline bool operator== (const ElementType* const otherPointer) const noexcept { return otherPointer == data; }




    inline bool operator!= (const ElementType* const otherPointer) const noexcept { return otherPointer != data; }
# 222 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_HeapBlock.h"
    void malloc (const size_t newNumElements, const size_t elementSize = sizeof (ElementType))
    {
        std::free (data);
        data = static_cast<ElementType*> (std::malloc (newNumElements * elementSize));
        throwOnAllocationFailure();
    }




    void calloc (const size_t newNumElements, const size_t elementSize = sizeof (ElementType))
    {
        std::free (data);
        data = static_cast<ElementType*> (std::calloc (newNumElements, elementSize));
        throwOnAllocationFailure();
    }





    void allocate (const size_t newNumElements, bool initialiseToZero)
    {
        std::free (data);
        data = static_cast<ElementType*> (initialiseToZero
                                             ? std::calloc (newNumElements, sizeof (ElementType))
                                             : std::malloc (newNumElements * sizeof (ElementType)));
        throwOnAllocationFailure();
    }






    void realloc (const size_t newNumElements, const size_t elementSize = sizeof (ElementType))
    {
        data = static_cast<ElementType*> (data == nullptr ? std::malloc (newNumElements * elementSize)
                                                          : std::realloc (data, newNumElements * elementSize));
        throwOnAllocationFailure();
    }




    void free() noexcept
    {
        std::free (data);
        data = nullptr;
    }




    template <bool otherBlockThrows>
    void swapWith (HeapBlock<ElementType, otherBlockThrows>& other) noexcept
    {
        std::swap (data, other.data);
    }





    void clear (size_t numElements) noexcept
    {
        zeromem (data, sizeof (ElementType) * numElements);
    }


    typedef ElementType Type;

private:

    ElementType* data;

    void throwOnAllocationFailure() const
    {



        HeapBlockHelper::ThrowOnFail<throwOnFailure>::checkPointer (data);

    }


    HeapBlock (const HeapBlock&) = delete; HeapBlock& operator= (const HeapBlock&) = delete;
    private: static void* operator new (size_t) = delete; static void operator delete (void*) = delete;

};
# 226 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_MemoryBlock.h" 1
# 40 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_MemoryBlock.h"
class MemoryBlock
{
public:


    MemoryBlock() noexcept;






    MemoryBlock (const size_t initialSize,
                 bool initialiseToZero = false);


    MemoryBlock (const MemoryBlock&);






    MemoryBlock (const void* dataToInitialiseFrom, size_t sizeInBytes);


    ~MemoryBlock() noexcept;




    MemoryBlock& operator= (const MemoryBlock&);


    MemoryBlock (MemoryBlock&&) noexcept;
    MemoryBlock& operator= (MemoryBlock&&) noexcept;






    bool operator== (const MemoryBlock& other) const noexcept;




    bool operator!= (const MemoryBlock& other) const noexcept;


    bool matches (const void* data, size_t dataSize) const noexcept;







    void* getData() const noexcept { return data; }




    template <typename Type>
    char& operator[] (const Type offset) const noexcept { return data [offset]; }




    size_t getSize() const noexcept { return size; }
# 123 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_MemoryBlock.h"
    void setSize (const size_t newSize,
                  bool initialiseNewSpaceToZero = false);
# 135 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_MemoryBlock.h"
    void ensureSize (const size_t minimumSize,
                     bool initialiseNewSpaceToZero = false);


    void reset();





    void fillWith (uint8 valueToUse) noexcept;




    void append (const void* data, size_t numBytes);




    void replaceWith (const void* data, size_t numBytes);






    void insert (const void* dataToInsert, size_t numBytesToInsert, size_t insertPosition);
# 171 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_MemoryBlock.h"
    void removeSection (size_t startByte, size_t numBytesToRemove);
# 181 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_MemoryBlock.h"
    void copyFrom (const void* srcData,
                   int destinationOffset,
                   size_t numBytes) noexcept;
# 192 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_MemoryBlock.h"
    void copyTo (void* destData,
                 int sourceOffset,
                 size_t numBytes) const noexcept;





    void swapWith (MemoryBlock& other) noexcept;



    String toString() const;
# 214 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_MemoryBlock.h"
    void loadFromHexString (StringRef sourceHexString);



    void setBitRange (size_t bitRangeStart,
                      size_t numBits,
                      int binaryNumberToApply) noexcept;


    int getBitRange (size_t bitRangeStart,
                     size_t numBitsToRead) const noexcept;
# 238 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_MemoryBlock.h"
    String toBase64Encoding() const;
# 251 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_MemoryBlock.h"
    bool fromBase64Encoding (StringRef encodedString);


private:

    HeapBlock<char> data;
    size_t size;


};
# 227 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ReferenceCountedObject.h" 1
# 67 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ReferenceCountedObject.h"
class ReferenceCountedObject
{
public:






    void incReferenceCount() noexcept
    {
        ++refCount;
    }




    void decReferenceCount() noexcept
    {
#pragma warning(push)
# 86 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ReferenceCountedObject.h"
#pragma warning(disable: 4127)
# 86 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ReferenceCountedObject.h"
 do { ; } while (false)
# 86 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ReferenceCountedObject.h"
#pragma warning(pop)
# 86 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ReferenceCountedObject.h"
;

        if (--refCount == 0)
            delete this;
    }





    bool decReferenceCountWithoutDeleting() noexcept
    {
#pragma warning(push)
# 98 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ReferenceCountedObject.h"
#pragma warning(disable: 4127)
# 98 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ReferenceCountedObject.h"
 do { ; } while (false)
# 98 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ReferenceCountedObject.h"
#pragma warning(pop)
# 98 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ReferenceCountedObject.h"
;
        return --refCount == 0;
    }


    int getReferenceCount() const noexcept { return refCount.get(); }


protected:


    ReferenceCountedObject() {}


    virtual ~ReferenceCountedObject()
    {

#pragma warning(push)
# 115 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ReferenceCountedObject.h"
#pragma warning(disable: 4127)
# 115 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ReferenceCountedObject.h"
 do { ; } while (false)
# 115 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ReferenceCountedObject.h"
#pragma warning(pop)
# 115 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ReferenceCountedObject.h"
;
    }




    void resetReferenceCount() noexcept
    {
        refCount = 0;
    }

private:

    Atomic <int> refCount;

    friend struct ContainerDeletePolicy<ReferenceCountedObject>;
    ReferenceCountedObject (const ReferenceCountedObject&) = delete; ReferenceCountedObject& operator= (const ReferenceCountedObject&) = delete;
};
# 146 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ReferenceCountedObject.h"
class SingleThreadedReferenceCountedObject
{
public:






    void incReferenceCount() noexcept
    {
        ++refCount;
    }




    void decReferenceCount() noexcept
    {
#pragma warning(push)
# 165 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ReferenceCountedObject.h"
#pragma warning(disable: 4127)
# 165 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ReferenceCountedObject.h"
 do { ; } while (false)
# 165 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ReferenceCountedObject.h"
#pragma warning(pop)
# 165 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ReferenceCountedObject.h"
;

        if (--refCount == 0)
            delete this;
    }





    bool decReferenceCountWithoutDeleting() noexcept
    {
#pragma warning(push)
# 177 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ReferenceCountedObject.h"
#pragma warning(disable: 4127)
# 177 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ReferenceCountedObject.h"
 do { ; } while (false)
# 177 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ReferenceCountedObject.h"
#pragma warning(pop)
# 177 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ReferenceCountedObject.h"
;
        return --refCount == 0;
    }


    int getReferenceCount() const noexcept { return refCount; }


protected:


    SingleThreadedReferenceCountedObject() : refCount (0) {}


    virtual ~SingleThreadedReferenceCountedObject()
    {

#pragma warning(push)
# 194 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ReferenceCountedObject.h"
#pragma warning(disable: 4127)
# 194 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ReferenceCountedObject.h"
 do { ; } while (false)
# 194 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ReferenceCountedObject.h"
#pragma warning(pop)
# 194 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ReferenceCountedObject.h"
;
    }

private:

    int refCount;

    friend struct ContainerDeletePolicy<ReferenceCountedObject>;
    SingleThreadedReferenceCountedObject (const SingleThreadedReferenceCountedObject&) = delete; SingleThreadedReferenceCountedObject& operator= (const SingleThreadedReferenceCountedObject&) = delete;
};
# 228 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ReferenceCountedObject.h"
template <class ReferenceCountedObjectClass>
class ReferenceCountedObjectPtr
{
public:

    typedef ReferenceCountedObjectClass ReferencedType;



    ReferenceCountedObjectPtr() noexcept
        : referencedObject (nullptr)
    {
    }




    ReferenceCountedObjectPtr (ReferencedType* refCountedObject) noexcept
        : referencedObject (refCountedObject)
    {
        incIfNotNull (refCountedObject);
    }



    ReferenceCountedObjectPtr (decltype (nullptr)) noexcept
        : referencedObject (nullptr)
    {
    }





    ReferenceCountedObjectPtr (const ReferenceCountedObjectPtr& other) noexcept
        : referencedObject (other.referencedObject)
    {
        incIfNotNull (referencedObject);
    }




    template <typename Convertible>
    ReferenceCountedObjectPtr (const ReferenceCountedObjectPtr<Convertible>& other) noexcept
        : referencedObject (static_cast<ReferencedType*> (other.get()))
    {
        incIfNotNull (referencedObject);
    }





    ReferenceCountedObjectPtr& operator= (const ReferenceCountedObjectPtr& other)
    {
        return operator= (other.referencedObject);
    }





    template <typename Convertible>
    ReferenceCountedObjectPtr& operator= (const ReferenceCountedObjectPtr<Convertible>& other)
    {
        return operator= (static_cast<ReferencedType*> (other.get()));
    }






    ReferenceCountedObjectPtr& operator= (ReferencedType* const newObject)
    {
        if (referencedObject != newObject)
        {
            incIfNotNull (newObject);
            ReferencedType* const oldObject = referencedObject;
            referencedObject = newObject;
            decIfNotNull (oldObject);
        }

        return *this;
    }



    ReferenceCountedObjectPtr (ReferenceCountedObjectPtr&& other) noexcept
        : referencedObject (other.referencedObject)
    {
        other.referencedObject = nullptr;
    }


    ReferenceCountedObjectPtr& operator= (ReferenceCountedObjectPtr&& other)
    {
        std::swap (referencedObject, other.referencedObject);
        return *this;
    }






    ~ReferenceCountedObjectPtr()
    {
        decIfNotNull (referencedObject);
    }





    operator ReferencedType*() const noexcept { return referencedObject; }




    ReferencedType* get() const noexcept { return referencedObject; }




    ReferencedType* getObject() const noexcept { return referencedObject; }


    ReferencedType* operator->() const noexcept
    {
#pragma warning(push)
# 359 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ReferenceCountedObject.h"
#pragma warning(disable: 4127)
# 359 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ReferenceCountedObject.h"
 do { ; } while (false)
# 359 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ReferenceCountedObject.h"
#pragma warning(pop)
# 359 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ReferenceCountedObject.h"
;
        return referencedObject;
    }

private:

    ReferencedType* referencedObject;

    static void incIfNotNull (ReferencedType* o) noexcept
    {
        if (o != nullptr)
            o->incReferenceCount();
    }

    static void decIfNotNull (ReferencedType* o) noexcept
    {
        if (o != nullptr && o->decReferenceCountWithoutDeleting())
            ContainerDeletePolicy<ReferencedType>::destroy (o);
    }
};




template <typename ReferenceCountedObjectClass>
bool operator== (const ReferenceCountedObjectPtr<ReferenceCountedObjectClass>& object1, ReferenceCountedObjectClass* const object2) noexcept
{
    return object1.get() == object2;
}


template <typename ReferenceCountedObjectClass>
bool operator== (const ReferenceCountedObjectPtr<ReferenceCountedObjectClass>& object1, const ReferenceCountedObjectPtr<ReferenceCountedObjectClass>& object2) noexcept
{
    return object1.get() == object2.get();
}


template <typename ReferenceCountedObjectClass>
bool operator== (ReferenceCountedObjectClass* object1, const ReferenceCountedObjectPtr<ReferenceCountedObjectClass>& object2) noexcept
{
    return object1 == object2.get();
}


template <typename ReferenceCountedObjectClass>
bool operator!= (const ReferenceCountedObjectPtr<ReferenceCountedObjectClass>& object1, const ReferenceCountedObjectClass* object2) noexcept
{
    return object1.get() != object2;
}


template <typename ReferenceCountedObjectClass>
bool operator!= (const ReferenceCountedObjectPtr<ReferenceCountedObjectClass>& object1, const ReferenceCountedObjectPtr<ReferenceCountedObjectClass>& object2) noexcept
{
    return object1.get() != object2.get();
}


template <typename ReferenceCountedObjectClass>
bool operator!= (ReferenceCountedObjectClass* object1, const ReferenceCountedObjectPtr<ReferenceCountedObjectClass>& object2) noexcept
{
    return object1 != object2.get();
}
# 228 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ScopedPointer.h" 1
# 71 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ScopedPointer.h"
template <class ObjectType>
class ScopedPointer
{
public:


    inline ScopedPointer() noexcept : object (nullptr)
    {
    }



    inline ScopedPointer (decltype (nullptr)) noexcept : object (nullptr)
    {
    }



    inline ScopedPointer (ObjectType* const objectToTakePossessionOf) noexcept
        : object (objectToTakePossessionOf)
    {
    }







    ScopedPointer (ScopedPointer& objectToTransferFrom) noexcept
        : object (objectToTransferFrom.object)
    {
        objectToTransferFrom.object = nullptr;
    }




    inline ~ScopedPointer() { ContainerDeletePolicy<ObjectType>::destroy (object); }
# 120 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ScopedPointer.h"
    ScopedPointer& operator= (ScopedPointer& objectToTransferFrom)
    {
        if (this != objectToTransferFrom.getAddress())
        {


#pragma warning(push)
# 126 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ScopedPointer.h"
#pragma warning(disable: 4127)
# 126 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ScopedPointer.h"
 do { ; } while (false)
# 126 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ScopedPointer.h"
#pragma warning(pop)
# 126 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ScopedPointer.h"
;

            ObjectType* const oldObject = object;
            object = objectToTransferFrom.object;
            objectToTransferFrom.object = nullptr;
            ContainerDeletePolicy<ObjectType>::destroy (oldObject);
        }

        return *this;
    }
# 144 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ScopedPointer.h"
    ScopedPointer& operator= (ObjectType* const newObjectToTakePossessionOf)
    {
        if (object != newObjectToTakePossessionOf)
        {
            ObjectType* const oldObject = object;
            object = newObjectToTakePossessionOf;
            ContainerDeletePolicy<ObjectType>::destroy (oldObject);
        }

        return *this;
    }


    ScopedPointer (ScopedPointer&& other) noexcept
        : object (other.object)
    {
        other.object = nullptr;
    }

    ScopedPointer& operator= (ScopedPointer&& other) noexcept
    {
        ContainerDeletePolicy<ObjectType>::destroy (object);
        object = other.object;
        other.object = nullptr;
        return *this;
    }




    inline operator ObjectType*() const noexcept { return object; }


    inline ObjectType* get() const noexcept { return object; }


    inline ObjectType& operator*() const noexcept { return *object; }


    inline ObjectType* operator->() const noexcept { return object; }





    ObjectType* release() noexcept { ObjectType* const o = object; object = nullptr; return o; }





    void swapWith (ScopedPointer<ObjectType>& other) noexcept
    {


#pragma warning(push)
# 199 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ScopedPointer.h"
#pragma warning(disable: 4127)
# 199 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ScopedPointer.h"
 do { ; } while (false)
# 199 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ScopedPointer.h"
#pragma warning(pop)
# 199 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ScopedPointer.h"
;

        std::swap (object, other.object);
    }




    inline ObjectType* createCopy() const { return createCopyIfNotNull (object); }

private:

    ObjectType* object;


    const ScopedPointer* getAddress() const noexcept { return this; }
# 235 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_ScopedPointer.h"
};





template <class ObjectType>
bool operator== (const ScopedPointer<ObjectType>& pointer1, ObjectType* const pointer2) noexcept
{
    return static_cast<ObjectType*> (pointer1) == pointer2;
}




template <class ObjectType>
bool operator!= (const ScopedPointer<ObjectType>& pointer1, ObjectType* const pointer2) noexcept
{
    return static_cast<ObjectType*> (pointer1) != pointer2;
}




template <typename Type>
void deleteAndZero (ScopedPointer<Type>&) { static_assert(sizeof (Type) == 12345, "sizeof (Type) == 12345");; }
# 229 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_OptionalScopedPointer.h" 1
# 45 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_OptionalScopedPointer.h"
template <class ObjectType>
class OptionalScopedPointer
{
public:


    OptionalScopedPointer() : shouldDelete (false) {}
# 60 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_OptionalScopedPointer.h"
    OptionalScopedPointer (ObjectType* objectToHold, bool takeOwnership)
        : object (objectToHold), shouldDelete (takeOwnership)
    {
    }
# 73 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_OptionalScopedPointer.h"
    OptionalScopedPointer (OptionalScopedPointer& objectToTransferFrom)
        : object (objectToTransferFrom.release()),
          shouldDelete (objectToTransferFrom.shouldDelete)
    {
    }
# 87 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_OptionalScopedPointer.h"
    OptionalScopedPointer& operator= (OptionalScopedPointer& objectToTransferFrom)
    {
        if (object != objectToTransferFrom.object)
        {
            clear();
            object = objectToTransferFrom.object;
        }

        shouldDelete = objectToTransferFrom.shouldDelete;
        return *this;
    }





    ~OptionalScopedPointer()
    {
        clear();
    }



    inline operator ObjectType*() const noexcept { return object; }


    inline ObjectType* get() const noexcept { return object; }


    inline ObjectType& operator*() const noexcept { return *object; }


    inline ObjectType* operator->() const noexcept { return object; }





    ObjectType* release() noexcept { return object.release(); }




    void clear()
    {
        if (! shouldDelete)
            object.release();
    }
# 143 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_OptionalScopedPointer.h"
    void set (ObjectType* newObject, bool takeOwnership)
    {
        if (object != newObject)
        {
            clear();
            object = newObject;
        }

        shouldDelete = takeOwnership;
    }


    void setOwned (ObjectType* newObject)
    {
        set (newObject, true);
    }


    void setNonOwned (ObjectType* newObject)
    {
        set (newObject, false);
    }




    bool willDeleteObject() const noexcept { return shouldDelete; }





    void swapWith (OptionalScopedPointer<ObjectType>& other) noexcept
    {
        object.swapWith (other.object);
        std::swap (shouldDelete, other.shouldDelete);
    }

private:

    ScopedPointer<ObjectType> object;
    bool shouldDelete;





    void setOwned (const ScopedPointer<ObjectType>&) = delete;
};
# 230 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_Singleton.h" 1
# 231 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_WeakReference.h" 1
# 83 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_WeakReference.h"
template <class ObjectType, class ReferenceCountingType = ReferenceCountedObject>
class WeakReference
{
public:

    inline WeakReference() noexcept {}


    WeakReference (ObjectType* const object) : holder (getRef (object)) {}


    WeakReference (const WeakReference& other) noexcept : holder (other.holder) {}


    WeakReference& operator= (const WeakReference& other) { holder = other.holder; return *this; }


    WeakReference& operator= (ObjectType* const newObject) { holder = getRef (newObject); return *this; }


    WeakReference (WeakReference&& other) noexcept : holder (static_cast<SharedRef&&> (other.holder)) {}
    WeakReference& operator= (WeakReference&& other) noexcept { holder = static_cast<SharedRef&&> (other.holder); return *this; }



    ObjectType* get() const noexcept { return holder != nullptr ? holder->get() : nullptr; }


    operator ObjectType*() const noexcept { return get(); }


    ObjectType* operator->() noexcept { return get(); }


    const ObjectType* operator->() const noexcept { return get(); }
# 126 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_WeakReference.h"
    bool wasObjectDeleted() const noexcept { return holder != nullptr && holder->get() == nullptr; }

    bool operator== (ObjectType* const object) const noexcept { return get() == object; }
    bool operator!= (ObjectType* const object) const noexcept { return get() != object; }






    class SharedPointer : public ReferenceCountingType
    {
    public:
        explicit SharedPointer (ObjectType* const obj) noexcept : owner (obj) {}

        inline ObjectType* get() const noexcept { return owner; }
        void clearPointer() noexcept { owner = nullptr; }

    private:
        ObjectType* volatile owner;

        SharedPointer (const SharedPointer&) = delete; SharedPointer& operator= (const SharedPointer&) = delete;
    };

    typedef ReferenceCountedObjectPtr<SharedPointer> SharedRef;







    class Master
    {
    public:
        Master() noexcept {}

        ~Master() noexcept
        {


#pragma warning(push)
# 167 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_WeakReference.h"
#pragma warning(disable: 4127)
# 167 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_WeakReference.h"
 do { ; } while (false)
# 167 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_WeakReference.h"
#pragma warning(pop)
# 167 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_WeakReference.h"
;
        }




        SharedPointer* getSharedPointer (ObjectType* const object)
        {
            if (sharedPointer == nullptr)
            {
                sharedPointer = new SharedPointer (object);
            }
            else
            {

#pragma warning(push)
# 182 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_WeakReference.h"
#pragma warning(disable: 4127)
# 182 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_WeakReference.h"
 do { ; } while (false)
# 182 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_WeakReference.h"
#pragma warning(pop)
# 182 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_WeakReference.h"
;
            }

            return sharedPointer;
        }





        void clear() noexcept
        {
            if (sharedPointer != nullptr)
                sharedPointer->clearPointer();
        }

    private:
        SharedRef sharedPointer;

        Master (const Master&) = delete; Master& operator= (const Master&) = delete;
    };

private:
    SharedRef holder;

    static inline SharedPointer* getRef (ObjectType* const o)
    {
        return (o != nullptr) ? o->masterReference.getSharedPointer (o) : nullptr;
    }
};
# 232 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_ScopedLock.h" 1
# 60 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_ScopedLock.h"
template <class LockType>
class GenericScopedLock
{
public:
# 74 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_ScopedLock.h"
    inline explicit GenericScopedLock (const LockType& lock) noexcept : lock_ (lock) { lock.enter(); }






    inline ~GenericScopedLock() noexcept { lock_.exit(); }

private:

    const LockType& lock_;

    GenericScopedLock (const GenericScopedLock&) = delete; GenericScopedLock& operator= (const GenericScopedLock&) = delete;
};
# 129 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_ScopedLock.h"
template <class LockType>
class GenericScopedUnlock
{
public:
# 144 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_ScopedLock.h"
    inline explicit GenericScopedUnlock (const LockType& lock) noexcept : lock_ (lock) { lock.exit(); }
# 153 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_ScopedLock.h"
    inline ~GenericScopedUnlock() noexcept { lock_.enter(); }


private:

    const LockType& lock_;

    GenericScopedUnlock (const GenericScopedUnlock&) = delete; GenericScopedUnlock& operator= (const GenericScopedUnlock&) = delete;
};
# 199 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_ScopedLock.h"
template <class LockType>
class GenericScopedTryLock
{
public:
# 214 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_ScopedLock.h"
    inline explicit GenericScopedTryLock (const LockType& lock) noexcept
        : lock_ (lock), lockWasSuccessful (lock.tryEnter()) {}
# 225 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_ScopedLock.h"
    inline ~GenericScopedTryLock() noexcept { if (lockWasSuccessful) lock_.exit(); }


    bool isLocked() const noexcept { return lockWasSuccessful; }

private:

    const LockType& lock_;
    const bool lockWasSuccessful;

    GenericScopedTryLock (const GenericScopedTryLock&) = delete; GenericScopedTryLock& operator= (const GenericScopedTryLock&) = delete;
};
# 233 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_CriticalSection.h" 1
# 49 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_CriticalSection.h"
class CriticalSection
{
public:


    CriticalSection() noexcept;





    ~CriticalSection() noexcept;
# 73 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_CriticalSection.h"
    void enter() const noexcept;
# 83 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_CriticalSection.h"
    bool tryEnter() const noexcept;
# 95 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_CriticalSection.h"
    void exit() const noexcept;




    typedef GenericScopedLock <CriticalSection> ScopedLockType;


    typedef GenericScopedUnlock <CriticalSection> ScopedUnlockType;


    typedef GenericScopedTryLock <CriticalSection> ScopedTryLockType;


private:
# 118 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_CriticalSection.h"
     uint8 lock[24];





    CriticalSection (const CriticalSection&) = delete; CriticalSection& operator= (const CriticalSection&) = delete;
};
# 138 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_CriticalSection.h"
class DummyCriticalSection
{
public:
    inline DummyCriticalSection() noexcept {}
    inline ~DummyCriticalSection() noexcept {}

    inline void enter() const noexcept {}
    inline bool tryEnter() const noexcept { return true; }
    inline void exit() const noexcept {}



    struct ScopedLockType
    {
        ScopedLockType (const DummyCriticalSection&) noexcept {}
    };


    typedef ScopedLockType ScopedUnlockType;

private:
    DummyCriticalSection (const DummyCriticalSection&) = delete; DummyCriticalSection& operator= (const DummyCriticalSection&) = delete;
};
# 191 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_CriticalSection.h"
typedef CriticalSection::ScopedLockType ScopedLock;
# 231 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_CriticalSection.h"
typedef CriticalSection::ScopedUnlockType ScopedUnlock;
# 265 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_CriticalSection.h"
typedef CriticalSection::ScopedTryLockType ScopedTryLock;
# 234 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_Range.h" 1
# 45 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_Range.h"
template <typename ValueType>
class Range
{
public:


    Range() noexcept : start(), end()
    {
    }


    Range (const ValueType startValue, const ValueType endValue) noexcept
        : start (startValue), end (jmax (startValue, endValue))
    {
    }


    Range (const Range& other) noexcept
        : start (other.start), end (other.end)
    {
    }


    Range& operator= (Range other) noexcept
    {
        start = other.start;
        end = other.end;
        return *this;
    }


    static Range between (const ValueType position1, const ValueType position2) noexcept
    {
        return position1 < position2 ? Range (position1, position2)
                                     : Range (position2, position1);
    }


    static Range withStartAndLength (const ValueType startValue, const ValueType length) noexcept
    {
#pragma warning(push)
# 85 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_Range.h"
#pragma warning(disable: 4127)
# 85 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_Range.h"
 do { ; } while (false)
# 85 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_Range.h"
#pragma warning(pop)
# 85 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_Range.h"
;
        return Range (startValue, startValue + length);
    }


    static Range emptyRange (const ValueType start) noexcept
    {
        return Range (start, start);
    }



    inline ValueType getStart() const noexcept { return start; }


    inline ValueType getLength() const noexcept { return end - start; }


    inline ValueType getEnd() const noexcept { return end; }


    inline bool isEmpty() const noexcept { return start == end; }






    void setStart (const ValueType newStart) noexcept
    {
        start = newStart;
        if (end < newStart)
            end = newStart;
    }





    Range withStart (const ValueType newStart) const noexcept
    {
        return Range (newStart, jmax (newStart, end));
    }


    Range movedToStartAt (const ValueType newStart) const noexcept
    {
        return Range (newStart, end + (newStart - start));
    }





    void setEnd (const ValueType newEnd) noexcept
    {
        end = newEnd;
        if (newEnd < start)
            start = newEnd;
    }





    Range withEnd (const ValueType newEnd) const noexcept
    {
        return Range (jmin (start, newEnd), newEnd);
    }


    Range movedToEndAt (const ValueType newEnd) const noexcept
    {
        return Range (start + (newEnd - end), newEnd);
    }




    void setLength (const ValueType newLength) noexcept
    {
        end = start + jmax (ValueType(), newLength);
    }




    Range withLength (const ValueType newLength) const noexcept
    {
        return Range (start, start + newLength);
    }





    Range expanded (ValueType amount) const noexcept
    {
        return Range (start - amount, end + amount);
    }



    inline Range operator+= (const ValueType amountToAdd) noexcept
    {
        start += amountToAdd;
        end += amountToAdd;
        return *this;
    }


    inline Range operator-= (const ValueType amountToSubtract) noexcept
    {
        start -= amountToSubtract;
        end -= amountToSubtract;
        return *this;
    }




    Range operator+ (const ValueType amountToAdd) const noexcept
    {
        return Range (start + amountToAdd, end + amountToAdd);
    }



    Range operator- (const ValueType amountToSubtract) const noexcept
    {
        return Range (start - amountToSubtract, end - amountToSubtract);
    }

    bool operator== (Range other) const noexcept { return start == other.start && end == other.end; }
    bool operator!= (Range other) const noexcept { return start != other.start || end != other.end; }






    bool contains (const ValueType position) const noexcept
    {
        return start <= position && position < end;
    }


    ValueType clipValue (const ValueType value) const noexcept
    {
        return jlimit (start, end, value);
    }


    bool contains (Range other) const noexcept
    {
        return start <= other.start && end >= other.end;
    }


    bool intersects (Range other) const noexcept
    {
        return other.start < end && start < other.end;
    }



    Range getIntersectionWith (Range other) const noexcept
    {
        return Range (jmax (start, other.start),
                      jmin (end, other.end));
    }


    Range getUnionWith (Range other) const noexcept
    {
        return Range (jmin (start, other.start),
                      jmax (end, other.end));
    }


    Range getUnionWith (const ValueType valueToInclude) const noexcept
    {
        return Range (jmin (valueToInclude, start),
                      jmax (valueToInclude, end));
    }
# 281 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_Range.h"
    Range constrainRange (Range rangeToConstrain) const noexcept
    {
        const ValueType otherLen = rangeToConstrain.getLength();
        return getLength() <= otherLen
                ? *this
                : rangeToConstrain.movedToStartAt (jlimit (start, end - otherLen, rangeToConstrain.getStart()));
    }


    static Range findMinAndMax (const ValueType* values, int numValues) noexcept
    {
        if (numValues <= 0)
            return Range();

        const ValueType first (*values++);
        Range r (first, first);

        while (--numValues > 0)
        {
            const ValueType v (*values++);

            if (r.end < v) r.end = v;
            if (v < r.start) r.start = v;
        }

        return r;
    }

private:

    ValueType start, end;
};
# 235 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_NormalisableRange.h" 1
# 45 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_NormalisableRange.h"
template <typename ValueType>
class NormalisableRange
{
public:

    NormalisableRange() noexcept : start(), end (1), interval(), skew (static_cast<ValueType> (1)), symmetricSkew (false) {}


    NormalisableRange (const NormalisableRange& other) noexcept
        : start (other.start), end (other.end),
          interval (other.interval), skew (other.skew),
          symmetricSkew (other.symmetricSkew)
    {
        checkInvariants();
    }


    NormalisableRange& operator= (const NormalisableRange& other) noexcept
    {
        start = other.start;
        end = other.end;
        interval = other.interval;
        skew = other.skew;
        symmetricSkew = other.symmetricSkew;
        checkInvariants();
        return *this;
    }


    NormalisableRange (ValueType rangeStart,
                       ValueType rangeEnd,
                       ValueType intervalValue,
                       ValueType skewFactor,
                       bool useSymmetricSkew = false) noexcept
        : start (rangeStart), end (rangeEnd), interval (intervalValue),
          skew (skewFactor), symmetricSkew (useSymmetricSkew)
    {
        checkInvariants();
    }


    NormalisableRange (ValueType rangeStart,
                       ValueType rangeEnd,
                       ValueType intervalValue) noexcept
        : start (rangeStart), end (rangeEnd), interval (intervalValue),
          skew (static_cast<ValueType> (1)), symmetricSkew (false)
    {
        checkInvariants();
    }


    NormalisableRange (ValueType rangeStart,
                       ValueType rangeEnd) noexcept
        : start (rangeStart), end (rangeEnd), interval(),
          skew (static_cast<ValueType> (1)), symmetricSkew (false)
    {
        checkInvariants();
    }




    ValueType convertTo0to1 (ValueType v) const noexcept
    {
        ValueType proportion = (v - start) / (end - start);

        if (skew == static_cast<ValueType> (1))
            return proportion;

        if (! symmetricSkew)
            return std::pow (proportion, skew);

        ValueType distanceFromMiddle = static_cast<ValueType> (2) * proportion - static_cast<ValueType> (1);

        return (static_cast<ValueType> (1) + std::pow (std::abs (distanceFromMiddle), skew)
                                           * (distanceFromMiddle < static_cast<ValueType> (0) ? static_cast<ValueType> (-1)
                                                                                              : static_cast<ValueType> (1)))
               / static_cast<ValueType> (2);
    }




    ValueType convertFrom0to1 (ValueType proportion) const noexcept
    {
        if (! symmetricSkew)
        {
            if (skew != static_cast<ValueType> (1) && proportion > ValueType())
                proportion = std::exp (std::log (proportion) / skew);

                return start + (end - start) * proportion;
        }

        ValueType distanceFromMiddle = static_cast<ValueType> (2) * proportion - static_cast<ValueType> (1);

        if (skew != static_cast<ValueType> (1) && distanceFromMiddle != static_cast<ValueType> (0))
            distanceFromMiddle = std::exp (std::log (std::abs (distanceFromMiddle)) / skew)
                                 * (distanceFromMiddle < static_cast<ValueType> (0) ? static_cast<ValueType> (-1)
                                                                                    : static_cast<ValueType> (1));

        return start + (end - start) / static_cast<ValueType> (2) * (static_cast<ValueType> (1) + distanceFromMiddle);
    }



    ValueType snapToLegalValue (ValueType v) const noexcept
    {
        if (interval > ValueType())
            v = start + interval * std::floor ((v - start) / interval + static_cast<ValueType> (0.5));

        if (v <= start || end <= start)
            return start;

        if (v >= end)
            return end;

        return v;
    }

    Range<ValueType> getRange() const noexcept { return Range<ValueType> (start, end); }


    ValueType start;


    ValueType end;


    ValueType interval;
# 184 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_NormalisableRange.h"
    ValueType skew;


    bool symmetricSkew;

private:
    void checkInvariants() const
    {
#pragma warning(push)
# 192 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_NormalisableRange.h"
#pragma warning(disable: 4127)
# 192 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_NormalisableRange.h"
 do { ; } while (false)
# 192 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_NormalisableRange.h"
#pragma warning(pop)
# 192 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_NormalisableRange.h"
;
#pragma warning(push)
# 193 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_NormalisableRange.h"
#pragma warning(disable: 4127)
# 193 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_NormalisableRange.h"
 do { ; } while (false)
# 193 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_NormalisableRange.h"
#pragma warning(pop)
# 193 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_NormalisableRange.h"
;
#pragma warning(push)
# 194 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_NormalisableRange.h"
#pragma warning(disable: 4127)
# 194 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_NormalisableRange.h"
 do { ; } while (false)
# 194 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_NormalisableRange.h"
#pragma warning(pop)
# 194 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_NormalisableRange.h"
;
    }
};
# 236 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_StatisticsAccumulator.h" 1
# 40 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_StatisticsAccumulator.h"
template <typename FloatType>
class StatisticsAccumulator
{
public:


    StatisticsAccumulator() noexcept
        : count (0),
          minimum ( std::numeric_limits<FloatType>::infinity()),
          maximum (-std::numeric_limits<FloatType>::infinity())
    {}





    void addValue (FloatType v) noexcept
    {
#pragma warning(push)
# 58 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_StatisticsAccumulator.h"
#pragma warning(disable: 4127)
# 58 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_StatisticsAccumulator.h"
 do { ; } while (false)
# 58 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_StatisticsAccumulator.h"
#pragma warning(pop)
# 58 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_StatisticsAccumulator.h"
;

        sum += v;
        sumSquares += v * v;
        ++count;

        if (v > maximum) maximum = v;
        if (v < minimum) minimum = v;
    }




    void reset() noexcept { *this = StatisticsAccumulator<FloatType>(); }





    FloatType getAverage() const noexcept
    {
        return count > 0 ? sum / (FloatType) count
                         : FloatType();
    }




    FloatType getVariance() const noexcept
    {
        return count > 0 ? (sumSquares - sum * sum / (FloatType) count) / (FloatType) count
                         : FloatType();
    }




    FloatType getStandardDeviation() const noexcept
    {
        return std::sqrt (getVariance());
    }




    FloatType getMinValue() const noexcept
    {
        return minimum;
    }




    FloatType getMaxValue() const noexcept
    {
        return maximum;
    }


    size_t getCount() const noexcept
    {
        return count;
    }

private:

    struct KahanSum
    {
        KahanSum() noexcept : sum(), error() {}
        operator FloatType() const noexcept { return sum; }

        void operator+= (FloatType value) noexcept
        {
            FloatType correctedValue = value - error;
            FloatType newSum = sum + correctedValue;
            error = (newSum - sum) - correctedValue;
            sum = newSum;
        }

        FloatType sum, error;
    };


    size_t count;
    KahanSum sum, sumSquares;
    FloatType minimum, maximum;
};
# 237 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ElementComparator.h" 1
# 40 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ElementComparator.h"
template <typename ElementComparator>
struct SortFunctionConverter
{
    SortFunctionConverter (ElementComparator& e) : comparator (e) {}

    template <typename Type>
    bool operator() (Type a, Type b) { return comparator.compareElements (a, b) < 0; }

private:
    ElementComparator& comparator;
    SortFunctionConverter& operator= (const SortFunctionConverter&) = delete;
};
# 84 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ElementComparator.h"
template <class ElementType, class ElementComparator>
static void sortArray (ElementComparator& comparator,
                       ElementType* const array,
                       int firstElement,
                       int lastElement,
                       const bool retainOrderOfEquivalentItems)
{
    SortFunctionConverter<ElementComparator> converter (comparator);

    if (retainOrderOfEquivalentItems)
        std::stable_sort (array + firstElement, array + lastElement + 1, converter);
    else
        std::sort (array + firstElement, array + lastElement + 1, converter);
}
# 124 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ElementComparator.h"
template <class ElementType, class ElementComparator>
static int findInsertIndexInSortedArray (ElementComparator& comparator,
                                         ElementType* const array,
                                         const ElementType newElement,
                                         int firstElement,
                                         int lastElement)
{
#pragma warning(push)
# 131 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ElementComparator.h"
#pragma warning(disable: 4127)
# 131 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ElementComparator.h"
 do { ; } while (false)
# 131 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ElementComparator.h"
#pragma warning(pop)
# 131 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ElementComparator.h"
;

    ignoreUnused (comparator);


    while (firstElement < lastElement)
    {
        if (comparator.compareElements (newElement, array [firstElement]) == 0)
        {
            ++firstElement;
            break;
        }
        else
        {
            const int halfway = (firstElement + lastElement) >> 1;

            if (halfway == firstElement)
            {
                if (comparator.compareElements (newElement, array [halfway]) >= 0)
                    ++firstElement;

                break;
            }
            else if (comparator.compareElements (newElement, array [halfway]) >= 0)
            {
                firstElement = halfway;
            }
            else
            {
                lastElement = halfway;
            }
        }
    }

    return firstElement;
}
# 183 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ElementComparator.h"
template <class ElementType>
class DefaultElementComparator
{
private:
    typedef typename TypeHelpers::ParameterType<ElementType>::type ParameterType;

public:
    static int compareElements (ParameterType first, ParameterType second)
    {
        return (first < second) ? -1 : ((second < first) ? 1 : 0);
    }
};
# 238 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ArrayAllocationBase.h" 1
# 47 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ArrayAllocationBase.h"
template <class ElementType, class TypeOfCriticalSectionToUse>
class ArrayAllocationBase : public TypeOfCriticalSectionToUse
{
public:


    ArrayAllocationBase() noexcept
        : numAllocated (0)
    {
    }


    ~ArrayAllocationBase() noexcept
    {
    }


    ArrayAllocationBase (ArrayAllocationBase<ElementType, TypeOfCriticalSectionToUse>&& other) noexcept
        : elements (static_cast<HeapBlock<ElementType>&&> (other.elements)),
          numAllocated (other.numAllocated)
    {
    }

    ArrayAllocationBase& operator= (ArrayAllocationBase<ElementType, TypeOfCriticalSectionToUse>&& other) noexcept
    {
        elements = static_cast<HeapBlock<ElementType>&&> (other.elements);
        numAllocated = other.numAllocated;
        return *this;
    }
# 86 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ArrayAllocationBase.h"
    void setAllocatedSize (const int numElements)
    {
        if (numAllocated != numElements)
        {
            if (numElements > 0)
                elements.realloc ((size_t) numElements);
            else
                elements.free();

            numAllocated = numElements;
        }
    }
# 107 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ArrayAllocationBase.h"
    void ensureAllocatedSize (const int minNumElements)
    {
        if (minNumElements > numAllocated)
            setAllocatedSize ((minNumElements + minNumElements / 2 + 8) & ~7);

#pragma warning(push)
# 112 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ArrayAllocationBase.h"
#pragma warning(disable: 4127)
# 112 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ArrayAllocationBase.h"
 do { ; } while (false)
# 112 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ArrayAllocationBase.h"
#pragma warning(pop)
# 112 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ArrayAllocationBase.h"
;
    }




    void shrinkToNoMoreThan (const int maxNumElements)
    {
        if (maxNumElements < numAllocated)
            setAllocatedSize (maxNumElements);
    }


    void swapWith (ArrayAllocationBase <ElementType, TypeOfCriticalSectionToUse>& other) noexcept
    {
        elements.swapWith (other.elements);
        std::swap (numAllocated, other.numAllocated);
    }


    HeapBlock<ElementType> elements;
    int numAllocated;

private:
    ArrayAllocationBase (const ArrayAllocationBase&) = delete; ArrayAllocationBase& operator= (const ArrayAllocationBase&) = delete;
};
# 239 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h" 1
# 59 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
template <typename ElementType,
          typename TypeOfCriticalSectionToUse = DummyCriticalSection,
          int minimumAllocatedSize = 0>
class Array
{
private:
    typedef typename TypeHelpers::ParameterType<ElementType>::type ParameterType;

public:


    Array() noexcept : numUsed (0)
    {
    }




    Array (const Array<ElementType, TypeOfCriticalSectionToUse>& other)
    {
        const ScopedLockType lock (other.getLock());
        numUsed = other.numUsed;
        data.setAllocatedSize (other.numUsed);

        for (int i = 0; i < numUsed; ++i)
            new (data.elements + i) ElementType (other.data.elements[i]);
    }


    Array (Array<ElementType, TypeOfCriticalSectionToUse>&& other) noexcept
        : data (static_cast<ArrayAllocationBase<ElementType, TypeOfCriticalSectionToUse>&&> (other.data)),
          numUsed (other.numUsed)
    {
        other.numUsed = 0;
    }






    template <typename TypeToCreateFrom>
    explicit Array (const TypeToCreateFrom* values) : numUsed (0)
    {
        while (*values != TypeToCreateFrom())
            add (*values++);
    }






    template <typename TypeToCreateFrom>
    Array (const TypeToCreateFrom* values, int numValues) : numUsed (numValues)
    {
        data.setAllocatedSize (numValues);

        for (int i = 0; i < numValues; ++i)
            new (data.elements + i) ElementType (values[i]);
    }


    template <typename TypeToCreateFrom>
    Array (const std::initializer_list<TypeToCreateFrom>& items) : numUsed (0)
    {
        addArray (items);
    }



    ~Array()
    {
        deleteAllElements();
    }




    Array& operator= (const Array& other)
    {
        if (this != &other)
        {
            Array<ElementType, TypeOfCriticalSectionToUse> otherCopy (other);
            swapWith (otherCopy);
        }

        return *this;
    }


    Array& operator= (Array&& other) noexcept
    {
        const ScopedLockType lock (getLock());
        deleteAllElements();
        data = static_cast<ArrayAllocationBase<ElementType, TypeOfCriticalSectionToUse>&&> (other.data);
        numUsed = other.numUsed;
        other.numUsed = 0;
        return *this;
    }
# 167 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
    template <class OtherArrayType>
    bool operator== (const OtherArrayType& other) const
    {
        const ScopedLockType lock (getLock());
        const typename OtherArrayType::ScopedLockType lock2 (other.getLock());

        if (numUsed != other.numUsed)
            return false;

        for (int i = numUsed; --i >= 0;)
            if (! (data.elements [i] == other.data.elements [i]))
                return false;

        return true;
    }






    template <class OtherArrayType>
    bool operator!= (const OtherArrayType& other) const
    {
        return ! operator== (other);
    }
# 202 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
    void clear()
    {
        const ScopedLockType lock (getLock());
        deleteAllElements();
        data.setAllocatedSize (0);
        numUsed = 0;
    }




    void clearQuick()
    {
        const ScopedLockType lock (getLock());
        deleteAllElements();
        numUsed = 0;
    }



    inline int size() const noexcept
    {
        return numUsed;
    }


    inline bool isEmpty() const noexcept
    {
        return size() == 0;
    }
# 243 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
    ElementType operator[] (const int index) const
    {
        const ScopedLockType lock (getLock());

        if (isPositiveAndBelow (index, numUsed))
        {
#pragma warning(push)
# 249 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
#pragma warning(disable: 4127)
# 249 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
 do { ; } while (false)
# 249 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
#pragma warning(pop)
# 249 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
;
            return data.elements [index];
        }

        return ElementType();
    }
# 265 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
    inline ElementType getUnchecked (const int index) const
    {
        const ScopedLockType lock (getLock());
#pragma warning(push)
# 268 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
#pragma warning(disable: 4127)
# 268 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
 do { ; } while (false)
# 268 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
#pragma warning(pop)
# 268 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
;
        return data.elements [index];
    }
# 281 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
    inline ElementType& getReference (const int index) const noexcept
    {
        const ScopedLockType lock (getLock());
#pragma warning(push)
# 284 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
#pragma warning(disable: 4127)
# 284 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
 do { ; } while (false)
# 284 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
#pragma warning(pop)
# 284 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
;
        return data.elements [index];
    }





    inline ElementType getFirst() const
    {
        const ScopedLockType lock (getLock());

        if (numUsed > 0)
        {
#pragma warning(push)
# 298 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
#pragma warning(disable: 4127)
# 298 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
 do { ; } while (false)
# 298 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
#pragma warning(pop)
# 298 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
;
            return data.elements[0];
        }

        return ElementType();
    }





    inline ElementType getLast() const
    {
        const ScopedLockType lock (getLock());

        if (numUsed > 0)
        {
#pragma warning(push)
# 315 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
#pragma warning(disable: 4127)
# 315 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
 do { ; } while (false)
# 315 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
#pragma warning(pop)
# 315 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
;
            return data.elements[numUsed - 1];
        }

        return ElementType();
    }





    inline ElementType* getRawDataPointer() noexcept
    {
        return data.elements;
    }





    inline ElementType* begin() const noexcept
    {
        return data.elements;
    }




    inline ElementType* end() const noexcept
    {





        return data.elements + numUsed;
    }
# 362 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
    int indexOf (ParameterType elementToLookFor) const
    {
        const ScopedLockType lock (getLock());
        const ElementType* e = data.elements.getData();
        const ElementType* const end_ = e + numUsed;

        for (; e != end_; ++e)
            if (elementToLookFor == *e)
                return static_cast<int> (e - data.elements.getData());

        return -1;
    }






    bool contains (ParameterType elementToLookFor) const
    {
        const ScopedLockType lock (getLock());
        const ElementType* e = data.elements.getData();
        const ElementType* const end_ = e + numUsed;

        for (; e != end_; ++e)
            if (elementToLookFor == *e)
                return true;

        return false;
    }







    void add (const ElementType& newElement)
    {
        const ScopedLockType lock (getLock());
        data.ensureAllocatedSize (numUsed + 1);
        new (data.elements + numUsed++) ElementType (newElement);
    }







    void add (ElementType&& newElement)
    {
        const ScopedLockType lock (getLock());
        data.ensureAllocatedSize (numUsed + 1);
        new (data.elements + numUsed++) ElementType (static_cast<ElementType&&> (newElement));
    }
# 432 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
    void insert (int indexToInsertAt, ParameterType newElement)
    {
        const ScopedLockType lock (getLock());
        data.ensureAllocatedSize (numUsed + 1);
#pragma warning(push)
# 436 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
#pragma warning(disable: 4127)
# 436 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
 do { ; } while (false)
# 436 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
#pragma warning(pop)
# 436 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
;

        if (isPositiveAndBelow (indexToInsertAt, numUsed))
        {
            ElementType* const insertPos = data.elements + indexToInsertAt;
            const int numberToMove = numUsed - indexToInsertAt;

            if (numberToMove > 0)
                memmove (insertPos + 1, insertPos, ((size_t) numberToMove) * sizeof (ElementType));

            new (insertPos) ElementType (newElement);
            ++numUsed;
        }
        else
        {
            new (data.elements + numUsed++) ElementType (newElement);
        }
    }
# 467 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
    void insertMultiple (int indexToInsertAt, ParameterType newElement,
                         int numberOfTimesToInsertIt)
    {
        if (numberOfTimesToInsertIt > 0)
        {
            const ScopedLockType lock (getLock());
            data.ensureAllocatedSize (numUsed + numberOfTimesToInsertIt);
            ElementType* insertPos;

            if (isPositiveAndBelow (indexToInsertAt, numUsed))
            {
                insertPos = data.elements + indexToInsertAt;
                const int numberToMove = numUsed - indexToInsertAt;
                memmove (insertPos + numberOfTimesToInsertIt, insertPos, ((size_t) numberToMove) * sizeof (ElementType));
            }
            else
            {
                insertPos = data.elements + numUsed;
            }

            numUsed += numberOfTimesToInsertIt;

            while (--numberOfTimesToInsertIt >= 0)
            {
                new (insertPos) ElementType (newElement);
                ++insertPos;

            }
        }
    }
# 510 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
    void insertArray (int indexToInsertAt,
                      const ElementType* newElements,
                      int numberOfElements)
    {
        if (numberOfElements > 0)
        {
            const ScopedLockType lock (getLock());
            data.ensureAllocatedSize (numUsed + numberOfElements);
            ElementType* insertPos = data.elements;

            if (isPositiveAndBelow (indexToInsertAt, numUsed))
            {
                insertPos += indexToInsertAt;
                const int numberToMove = numUsed - indexToInsertAt;
                memmove (insertPos + numberOfElements, insertPos, (size_t) numberToMove * sizeof (ElementType));
            }
            else
            {
                insertPos += numUsed;
            }

            numUsed += numberOfElements;

            while (--numberOfElements >= 0)
                new (insertPos++) ElementType (*newElements++);
        }
    }
# 547 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
    bool addIfNotAlreadyThere (ParameterType newElement)
    {
        const ScopedLockType lock (getLock());

        if (contains (newElement))
            return false;

        add (newElement);
        return true;
    }
# 567 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
    void set (const int indexToChange, ParameterType newValue)
    {
#pragma warning(push)
# 569 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
#pragma warning(disable: 4127)
# 569 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
 do { ; } while (false)
# 569 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
#pragma warning(pop)
# 569 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
;
        const ScopedLockType lock (getLock());

        if (isPositiveAndBelow (indexToChange, numUsed))
        {
#pragma warning(push)
# 574 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
#pragma warning(disable: 4127)
# 574 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
 do { ; } while (false)
# 574 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
#pragma warning(pop)
# 574 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
;
            data.elements [indexToChange] = newValue;
        }
        else if (indexToChange >= 0)
        {
            data.ensureAllocatedSize (numUsed + 1);
            new (data.elements + numUsed++) ElementType (newValue);
        }
    }
# 593 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
    void setUnchecked (const int indexToChange, ParameterType newValue)
    {
        const ScopedLockType lock (getLock());
#pragma warning(push)
# 596 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
#pragma warning(disable: 4127)
# 596 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
 do { ; } while (false)
# 596 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
#pragma warning(pop)
# 596 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
;
        data.elements [indexToChange] = newValue;
    }
# 607 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
    template <typename Type>
    void addArray (const Type* elementsToAdd, int numElementsToAdd)
    {
        const ScopedLockType lock (getLock());

        if (numElementsToAdd > 0)
        {
            data.ensureAllocatedSize (numUsed + numElementsToAdd);

            while (--numElementsToAdd >= 0)
            {
                new (data.elements + numUsed) ElementType (*elementsToAdd++);
                ++numUsed;
            }
        }
    }


    template <typename TypeToCreateFrom>
    void addArray (const std::initializer_list<TypeToCreateFrom>& items)
    {
        const ScopedLockType lock (getLock());
        data.ensureAllocatedSize (numUsed + (int) items.size());

        for (auto& item : items)
        {
            new (data.elements + numUsed) ElementType (item);
            ++numUsed;
        }
    }
# 645 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
    template <typename Type>
    void addNullTerminatedArray (const Type* const* elementsToAdd)
    {
        int num = 0;
        for (const Type* const* e = elementsToAdd; *e != nullptr; ++e)
            ++num;

        addArray (elementsToAdd, num);
    }






    template <class OtherArrayType>
    void swapWith (OtherArrayType& otherArray) noexcept
    {
        const ScopedLockType lock1 (getLock());
        const typename OtherArrayType::ScopedLockType lock2 (otherArray.getLock());
        data.swapWith (otherArray.data);
        std::swap (numUsed, otherArray.numUsed);
    }
# 678 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
    template <class OtherArrayType>
    void addArray (const OtherArrayType& arrayToAddFrom,
                   int startIndex = 0,
                   int numElementsToAdd = -1)
    {
        const typename OtherArrayType::ScopedLockType lock1 (arrayToAddFrom.getLock());

        {
            const ScopedLockType lock2 (getLock());

            if (startIndex < 0)
            {
#pragma warning(push)
# 690 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
#pragma warning(disable: 4127)
# 690 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
 do { } while (false)
# 690 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
#pragma warning(pop)
# 690 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
;
                startIndex = 0;
            }

            if (numElementsToAdd < 0 || startIndex + numElementsToAdd > arrayToAddFrom.size())
                numElementsToAdd = arrayToAddFrom.size() - startIndex;

            while (--numElementsToAdd >= 0)
                add (arrayToAddFrom.getUnchecked (startIndex++));
        }
    }
# 709 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
    void resize (const int targetNumItems)
    {
#pragma warning(push)
# 711 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
#pragma warning(disable: 4127)
# 711 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
 do { ; } while (false)
# 711 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
#pragma warning(pop)
# 711 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
;

        const int numToAdd = targetNumItems - numUsed;
        if (numToAdd > 0)
            insertMultiple (numUsed, ElementType(), numToAdd);
        else if (numToAdd < 0)
            removeRange (targetNumItems, -numToAdd);
    }
# 732 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
    template <class ElementComparator>
    int addSorted (ElementComparator& comparator, ParameterType newElement)
    {
        const ScopedLockType lock (getLock());
        const int index = findInsertIndexInSortedArray (comparator, data.elements.getData(), newElement, 0, numUsed);
        insert (index, newElement);
        return index;
    }
# 750 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
    void addUsingDefaultSort (ParameterType newElement)
    {
        DefaultElementComparator <ElementType> comparator;
        addSorted (comparator, newElement);
    }
# 768 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
    template <typename ElementComparator, typename TargetValueType>
    int indexOfSorted (ElementComparator& comparator, TargetValueType elementToLookFor) const
    {
        ignoreUnused (comparator);


        const ScopedLockType lock (getLock());

        for (int s = 0, e = numUsed;;)
        {
            if (s >= e)
                return -1;

            if (comparator.compareElements (elementToLookFor, data.elements [s]) == 0)
                return s;

            const int halfway = (s + e) / 2;
            if (halfway == s)
                return -1;

            if (comparator.compareElements (elementToLookFor, data.elements [halfway]) >= 0)
                s = halfway;
            else
                e = halfway;
        }
    }
# 805 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
    void remove (int indexToRemove)
    {
        const ScopedLockType lock (getLock());

        if (isPositiveAndBelow (indexToRemove, numUsed))
        {
#pragma warning(push)
# 811 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
#pragma warning(disable: 4127)
# 811 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
 do { ; } while (false)
# 811 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
#pragma warning(pop)
# 811 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
;
            removeInternal (indexToRemove);
        }
    }
# 826 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
    ElementType removeAndReturn (const int indexToRemove)
    {
        const ScopedLockType lock (getLock());

        if (isPositiveAndBelow (indexToRemove, numUsed))
        {
#pragma warning(push)
# 832 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
#pragma warning(disable: 4127)
# 832 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
 do { ; } while (false)
# 832 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
#pragma warning(pop)
# 832 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
;
            ElementType removed (data.elements[indexToRemove]);
            removeInternal (indexToRemove);
            return removed;
        }

        return ElementType();
    }
# 851 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
    void remove (const ElementType* elementToRemove)
    {
#pragma warning(push)
# 853 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
#pragma warning(disable: 4127)
# 853 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
 do { ; } while (false)
# 853 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
#pragma warning(pop)
# 853 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
;
        const ScopedLockType lock (getLock());

#pragma warning(push)
# 856 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
#pragma warning(disable: 4127)
# 856 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
 do { ; } while (false)
# 856 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
#pragma warning(pop)
# 856 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
;
        const int indexToRemove = int (elementToRemove - data.elements);

        if (! isPositiveAndBelow (indexToRemove, numUsed))
        {
#pragma warning(push)
# 861 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
#pragma warning(disable: 4127)
# 861 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
 do { } while (false)
# 861 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
#pragma warning(pop)
# 861 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
;
            return;
        }

        removeInternal (indexToRemove);
    }
# 876 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
    void removeFirstMatchingValue (ParameterType valueToRemove)
    {
        const ScopedLockType lock (getLock());
        ElementType* const e = data.elements;

        for (int i = 0; i < numUsed; ++i)
        {
            if (valueToRemove == e[i])
            {
                removeInternal (i);
                break;
            }
        }
    }
# 900 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
    int removeAllInstancesOf (ParameterType valueToRemove)
    {
        int numRemoved = 0;
        const ScopedLockType lock (getLock());

        for (int i = numUsed; --i >= 0;)
        {
            if (valueToRemove == data.elements[i])
            {
                removeInternal (i);
                ++numRemoved;
            }
        }

        return numRemoved;
    }
# 928 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
    template <typename PredicateType>
    int removeIf (PredicateType predicate)
    {
        int numRemoved = 0;
        const ScopedLockType lock (getLock());

        for (int i = numUsed; --i >= 0;)
        {
            if (predicate (data.elements[i]) == true)
            {
                removeInternal (i);
                ++numRemoved;
            }
        }

        return numRemoved;
    }
# 958 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
    void removeRange (int startIndex, int numberToRemove)
    {
        const ScopedLockType lock (getLock());
        const int endIndex = jlimit (0, numUsed, startIndex + numberToRemove);
        startIndex = jlimit (0, numUsed, startIndex);

        if (endIndex > startIndex)
        {
            ElementType* const e = data.elements + startIndex;

            numberToRemove = endIndex - startIndex;
            for (int i = 0; i < numberToRemove; ++i)
                e[i].~ElementType();

            const int numToShift = numUsed - endIndex;
            if (numToShift > 0)
                memmove (e, e + numberToRemove, ((size_t) numToShift) * sizeof (ElementType));

            numUsed -= numberToRemove;
            minimiseStorageAfterRemoval();
        }
    }






    void removeLast (int howManyToRemove = 1)
    {
        const ScopedLockType lock (getLock());

        if (howManyToRemove > numUsed)
            howManyToRemove = numUsed;

        for (int i = 1; i <= howManyToRemove; ++i)
            data.elements [numUsed - i].~ElementType();

        numUsed -= howManyToRemove;
        minimiseStorageAfterRemoval();
    }






    template <class OtherArrayType>
    void removeValuesIn (const OtherArrayType& otherArray)
    {
        const typename OtherArrayType::ScopedLockType lock1 (otherArray.getLock());
        const ScopedLockType lock2 (getLock());

        if (this == &otherArray)
        {
            clear();
        }
        else
        {
            if (otherArray.size() > 0)
            {
                for (int i = numUsed; --i >= 0;)
                    if (otherArray.contains (data.elements [i]))
                        removeInternal (i);
            }
        }
    }
# 1033 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
    template <class OtherArrayType>
    void removeValuesNotIn (const OtherArrayType& otherArray)
    {
        const typename OtherArrayType::ScopedLockType lock1 (otherArray.getLock());
        const ScopedLockType lock2 (getLock());

        if (this != &otherArray)
        {
            if (otherArray.size() <= 0)
            {
                clear();
            }
            else
            {
                for (int i = numUsed; --i >= 0;)
                    if (! otherArray.contains (data.elements [i]))
                        removeInternal (i);
            }
        }
    }
# 1062 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
    void swap (const int index1,
               const int index2)
    {
        const ScopedLockType lock (getLock());

        if (isPositiveAndBelow (index1, numUsed)
             && isPositiveAndBelow (index2, numUsed))
        {
            std::swap (data.elements [index1],
                       data.elements [index2]);
        }
    }
# 1089 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
    void move (const int currentIndex, int newIndex) noexcept
    {
        if (currentIndex != newIndex)
        {
            const ScopedLockType lock (getLock());

            if (isPositiveAndBelow (currentIndex, numUsed))
            {
                if (! isPositiveAndBelow (newIndex, numUsed))
                    newIndex = numUsed - 1;

                char tempCopy [sizeof (ElementType)];
                memcpy (tempCopy, data.elements + currentIndex, sizeof (ElementType));

                if (newIndex > currentIndex)
                {
                    memmove (data.elements + currentIndex,
                             data.elements + currentIndex + 1,
                             sizeof (ElementType) * (size_t) (newIndex - currentIndex));
                }
                else
                {
                    memmove (data.elements + newIndex + 1,
                             data.elements + newIndex,
                             sizeof (ElementType) * (size_t) (currentIndex - newIndex));
                }

                memcpy (data.elements + newIndex, tempCopy, sizeof (ElementType));
            }
        }
    }
# 1128 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
    void minimiseStorageOverheads()
    {
        const ScopedLockType lock (getLock());
        data.shrinkToNoMoreThan (numUsed);
    }







    void ensureStorageAllocated (const int minNumElements)
    {
        const ScopedLockType lock (getLock());
        data.ensureAllocatedSize (minNumElements);
    }






    void sort()
    {
        DefaultElementComparator<ElementType> comparator;
        sort (comparator);
    }
# 1183 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Array.h"
    template <class ElementComparator>
    void sort (ElementComparator& comparator,
               const bool retainOrderOfEquivalentItems = false)
    {
        const ScopedLockType lock (getLock());
        ignoreUnused (comparator);

        sortArray (comparator, data.elements.getData(), 0, size() - 1, retainOrderOfEquivalentItems);
    }






    inline const TypeOfCriticalSectionToUse& getLock() const noexcept { return data; }


    typedef typename TypeOfCriticalSectionToUse::ScopedLockType ScopedLockType;






    __declspec(deprecated) void swapWithArray (Array& other) noexcept { swapWith (other); }


private:

    ArrayAllocationBase <ElementType, TypeOfCriticalSectionToUse> data;
    int numUsed;

    void removeInternal (const int indexToRemove)
    {
        --numUsed;
        ElementType* const e = data.elements + indexToRemove;
        e->~ElementType();
        const int numberToShift = numUsed - indexToRemove;

        if (numberToShift > 0)
            memmove (e, e + 1, ((size_t) numberToShift) * sizeof (ElementType));

        minimiseStorageAfterRemoval();
    }

    inline void deleteAllElements() noexcept
    {
        for (int i = 0; i < numUsed; ++i)
            data.elements[i].~ElementType();
    }

    void minimiseStorageAfterRemoval()
    {
        if (data.numAllocated > jmax (minimumAllocatedSize, numUsed * 2))
            data.shrinkToNoMoreThan (jmax (numUsed, jmax (minimumAllocatedSize, 64 / (int) sizeof (ElementType))));
    }
};
# 240 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_LinkedListPointer.h" 1
# 62 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_LinkedListPointer.h"
template <class ObjectType>
class LinkedListPointer
{
public:


    LinkedListPointer() noexcept
        : item (nullptr)
    {
    }


    explicit LinkedListPointer (ObjectType* const headItem) noexcept
        : item (headItem)
    {
    }


    LinkedListPointer& operator= (ObjectType* const newItem) noexcept
    {
        item = newItem;
        return *this;
    }


    LinkedListPointer (LinkedListPointer&& other) noexcept
        : item (other.item)
    {
        other.item = nullptr;
    }

    LinkedListPointer& operator= (LinkedListPointer&& other) noexcept
    {
#pragma warning(push)
# 95 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_LinkedListPointer.h"
#pragma warning(disable: 4127)
# 95 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_LinkedListPointer.h"
 do { ; } while (false)
# 95 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_LinkedListPointer.h"
#pragma warning(pop)
# 95 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_LinkedListPointer.h"
;

        item = other.item;
        other.item = nullptr;
        return *this;
    }




    inline operator ObjectType*() const noexcept
    {
        return item;
    }


    inline ObjectType* get() const noexcept
    {
        return item;
    }
# 123 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_LinkedListPointer.h"
    LinkedListPointer& getLast() noexcept
    {
        LinkedListPointer* l = this;

        while (l->item != nullptr)
            l = &(l->item->nextListItem);

        return *l;
    }





    int size() const noexcept
    {
        int total = 0;

        for (ObjectType* i = item; i != nullptr; i = i->nextListItem)
            ++total;

        return total;
    }





    LinkedListPointer& operator[] (int index) noexcept
    {
        LinkedListPointer* l = this;

        while (--index >= 0 && l->item != nullptr)
            l = &(l->item->nextListItem);

        return *l;
    }





    const LinkedListPointer& operator[] (int index) const noexcept
    {
        const LinkedListPointer* l = this;

        while (--index >= 0 && l->item != nullptr)
            l = &(l->item->nextListItem);

        return *l;
    }


    bool contains (const ObjectType* const itemToLookFor) const noexcept
    {
        for (ObjectType* i = item; i != nullptr; i = i->nextListItem)
            if (itemToLookFor == i)
                return true;

        return false;
    }





    void insertNext (ObjectType* const newItem)
    {
#pragma warning(push)
# 191 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_LinkedListPointer.h"
#pragma warning(disable: 4127)
# 191 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_LinkedListPointer.h"
 do { ; } while (false)
# 191 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_LinkedListPointer.h"
#pragma warning(pop)
# 191 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_LinkedListPointer.h"
;
#pragma warning(push)
# 192 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_LinkedListPointer.h"
#pragma warning(disable: 4127)
# 192 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_LinkedListPointer.h"
 do { ; } while (false)
# 192 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_LinkedListPointer.h"
#pragma warning(pop)
# 192 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_LinkedListPointer.h"
;
        newItem->nextListItem = item;
        item = newItem;
    }





    void insertAtIndex (int index, ObjectType* newItem)
    {
#pragma warning(push)
# 203 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_LinkedListPointer.h"
#pragma warning(disable: 4127)
# 203 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_LinkedListPointer.h"
 do { ; } while (false)
# 203 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_LinkedListPointer.h"
#pragma warning(pop)
# 203 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_LinkedListPointer.h"
;
        LinkedListPointer* l = this;

        while (index != 0 && l->item != nullptr)
        {
            l = &(l->item->nextListItem);
            --index;
        }

        l->insertNext (newItem);
    }




    ObjectType* replaceNext (ObjectType* const newItem) noexcept
    {
#pragma warning(push)
# 220 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_LinkedListPointer.h"
#pragma warning(disable: 4127)
# 220 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_LinkedListPointer.h"
 do { ; } while (false)
# 220 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_LinkedListPointer.h"
#pragma warning(pop)
# 220 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_LinkedListPointer.h"
;
#pragma warning(push)
# 221 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_LinkedListPointer.h"
#pragma warning(disable: 4127)
# 221 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_LinkedListPointer.h"
 do { ; } while (false)
# 221 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_LinkedListPointer.h"
#pragma warning(pop)
# 221 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_LinkedListPointer.h"
;

        ObjectType* const oldItem = item;
        item = newItem;
        item->nextListItem = oldItem->nextListItem.item;
        oldItem->nextListItem.item = nullptr;
        return oldItem;
    }







    void append (ObjectType* const newItem)
    {
        getLast().item = newItem;
    }





    void addCopyOfList (const LinkedListPointer& other)
    {
        LinkedListPointer* insertPoint = this;

        for (ObjectType* i = other.item; i != nullptr; i = i->nextListItem)
        {
            insertPoint->insertNext (new ObjectType (*i));
            insertPoint = &(insertPoint->item->nextListItem);
        }
    }





    ObjectType* removeNext() noexcept
    {
        ObjectType* const oldItem = item;

        if (oldItem != nullptr)
        {
            item = oldItem->nextListItem;
            oldItem->nextListItem.item = nullptr;
        }

        return oldItem;
    }




    void remove (ObjectType* const itemToRemove)
    {
        if (LinkedListPointer* const l = findPointerTo (itemToRemove))
            l->removeNext();
    }




    void deleteAll()
    {
        while (item != nullptr)
        {
            ObjectType* const oldItem = item;
            item = oldItem->nextListItem;
            delete oldItem;
        }
    }





    LinkedListPointer* findPointerTo (ObjectType* const itemToLookFor) noexcept
    {
        LinkedListPointer* l = this;

        while (l->item != nullptr)
        {
            if (l->item == itemToLookFor)
                return l;

            l = &(l->item->nextListItem);
        }

        return nullptr;
    }





    void copyToArray (ObjectType** destArray) const noexcept
    {
#pragma warning(push)
# 320 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_LinkedListPointer.h"
#pragma warning(disable: 4127)
# 320 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_LinkedListPointer.h"
 do { ; } while (false)
# 320 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_LinkedListPointer.h"
#pragma warning(pop)
# 320 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_LinkedListPointer.h"
;

        for (ObjectType* i = item; i != nullptr; i = i->nextListItem)
            *destArray++ = i;
    }


    void swapWith (LinkedListPointer& other) noexcept
    {
        std::swap (item, other.item);
    }
# 340 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_LinkedListPointer.h"
    class Appender
    {
    public:


        Appender (LinkedListPointer& endOfListPointer) noexcept
            : endOfList (&endOfListPointer)
        {

#pragma warning(push)
# 349 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_LinkedListPointer.h"
#pragma warning(disable: 4127)
# 349 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_LinkedListPointer.h"
 do { ; } while (false)
# 349 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_LinkedListPointer.h"
#pragma warning(pop)
# 349 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_LinkedListPointer.h"
;
        }


        void append (ObjectType* const newItem) noexcept
        {
            *endOfList = newItem;
            endOfList = &(newItem->nextListItem);
        }

    private:
        LinkedListPointer* endOfList;

        Appender (const Appender&) = delete; Appender& operator= (const Appender&) = delete;
    };

private:

    ObjectType* item;

    LinkedListPointer (const LinkedListPointer&) = delete; LinkedListPointer& operator= (const LinkedListPointer&) = delete;
};
# 241 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ListenerList.h" 1
# 73 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ListenerList.h"
template <class ListenerClass,
          class ArrayType = Array<ListenerClass*> >
class ListenerList
{
# 88 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ListenerList.h"
public:


    ListenerList()
    {
    }


    ~ListenerList()
    {
    }







    void add (ListenerClass* const listenerToAdd)
    {

#pragma warning(push)
# 109 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ListenerList.h"
#pragma warning(disable: 4127)
# 109 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ListenerList.h"
 do { ; } while (false)
# 109 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ListenerList.h"
#pragma warning(pop)
# 109 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ListenerList.h"
;

        if (listenerToAdd != nullptr)
            listeners.addIfNotAlreadyThere (listenerToAdd);
    }




    void remove (ListenerClass* const listenerToRemove)
    {

#pragma warning(push)
# 121 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ListenerList.h"
#pragma warning(disable: 4127)
# 121 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ListenerList.h"
 do { ; } while (false)
# 121 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ListenerList.h"
#pragma warning(pop)
# 121 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ListenerList.h"
;

        listeners.removeFirstMatchingValue (listenerToRemove);
    }


    int size() const noexcept
    {
        return listeners.size();
    }


    bool isEmpty() const noexcept
    {
        return listeners.size() == 0;
    }


    void clear()
    {
        listeners.clear();
    }


    bool contains (ListenerClass* const listener) const noexcept
    {
        return listeners.contains (listener);
    }



    void call (void (ListenerClass::*callbackFunction) ())
    {
        callChecked (static_cast<const DummyBailOutChecker&> (DummyBailOutChecker()), callbackFunction);
    }




    void callExcluding (ListenerClass& listenerToExclude, void (ListenerClass::*callbackFunction) ())
    {
        callCheckedExcluding (listenerToExclude,
                              static_cast<const DummyBailOutChecker&> (DummyBailOutChecker()), callbackFunction);
    }




    template <class BailOutCheckerType>
    void callChecked (const BailOutCheckerType& bailOutChecker,
                      void (ListenerClass::*callbackFunction) ())
    {
        for (Iterator<BailOutCheckerType, ThisType> iter (*this); iter.next (bailOutChecker);)
            (iter.getListener()->*callbackFunction) ();
    }





    template <class BailOutCheckerType>
    void callCheckedExcluding (ListenerClass& listenerToExclude,
                               const BailOutCheckerType& bailOutChecker,
                               void (ListenerClass::*callbackFunction) ())
    {
        for (Iterator<BailOutCheckerType, ThisType> iter (*this); iter.next (bailOutChecker);)
            if (iter.getListener() != &listenerToExclude)
                (iter.getListener()->*callbackFunction) ();
    }



    template <typename P1>
    void call (void (ListenerClass::*callbackFunction) (P1), typename TypeHelpers::ParameterType<P1>::type param1)
    {
        for (Iterator<DummyBailOutChecker, ThisType> iter (*this); iter.next();)
            (iter.getListener()->*callbackFunction) (param1);
    }




    template <typename P1>
    void callExcluding (ListenerClass& listenerToExclude,
                        void (ListenerClass::*callbackFunction) (P1), typename TypeHelpers::ParameterType<P1>::type param1)
    {
        for (Iterator<DummyBailOutChecker, ThisType> iter (*this); iter.next();)
            if (iter.getListener() != &listenerToExclude)
                (iter.getListener()->*callbackFunction) (param1);
    }




    template <class BailOutCheckerType, typename P1>
    void callChecked (const BailOutCheckerType& bailOutChecker,
                      void (ListenerClass::*callbackFunction) (P1),
                      typename TypeHelpers::ParameterType<P1>::type param1)
    {
        for (Iterator<BailOutCheckerType, ThisType> iter (*this); iter.next (bailOutChecker);)
            (iter.getListener()->*callbackFunction) (param1);
    }





    template <class BailOutCheckerType, typename P1>
    void callCheckedExcluding (ListenerClass& listenerToExclude,
                               const BailOutCheckerType& bailOutChecker,
                               void (ListenerClass::*callbackFunction) (P1),
                               typename TypeHelpers::ParameterType<P1>::type param1)
    {
        for (Iterator<BailOutCheckerType, ThisType> iter (*this); iter.next (bailOutChecker);)
            if (iter.getListener() != &listenerToExclude)
                (iter.getListener()->*callbackFunction) (param1);
    }



    template <typename P1, typename P2>
    void call (void (ListenerClass::*callbackFunction) (P1, P2),
               typename TypeHelpers::ParameterType<P1>::type param1, typename TypeHelpers::ParameterType<P2>::type param2)
    {
        for (Iterator<DummyBailOutChecker, ThisType> iter (*this); iter.next();)
            (iter.getListener()->*callbackFunction) (param1, param2);
    }




    template <typename P1, typename P2>
    void callExcluding (ListenerClass& listenerToExclude,
                        void (ListenerClass::*callbackFunction) (P1, P2),
                        typename TypeHelpers::ParameterType<P1>::type param1, typename TypeHelpers::ParameterType<P2>::type param2)
    {
        for (Iterator<DummyBailOutChecker, ThisType> iter (*this); iter.next();)
            if (iter.getListener() != &listenerToExclude)
                (iter.getListener()->*callbackFunction) (param1, param2);
    }




    template <class BailOutCheckerType, typename P1, typename P2>
    void callChecked (const BailOutCheckerType& bailOutChecker,
                      void (ListenerClass::*callbackFunction) (P1, P2),
                      typename TypeHelpers::ParameterType<P1>::type param1, typename TypeHelpers::ParameterType<P2>::type param2)
    {
        for (Iterator<BailOutCheckerType, ThisType> iter (*this); iter.next (bailOutChecker);)
            (iter.getListener()->*callbackFunction) (param1, param2);
    }





    template <class BailOutCheckerType, typename P1, typename P2>
    void callCheckedExcluding (ListenerClass& listenerToExclude,
                               const BailOutCheckerType& bailOutChecker,
                               void (ListenerClass::*callbackFunction) (P1, P2),
                               typename TypeHelpers::ParameterType<P1>::type param1, typename TypeHelpers::ParameterType<P2>::type param2)
    {
        for (Iterator<BailOutCheckerType, ThisType> iter (*this); iter.next (bailOutChecker);)
            if (iter.getListener() != &listenerToExclude)
                (iter.getListener()->*callbackFunction) (param1, param2);
    }



    template <typename P1, typename P2, typename P3>
    void call (void (ListenerClass::*callbackFunction) (P1, P2, P3),
               typename TypeHelpers::ParameterType<P1>::type param1, typename TypeHelpers::ParameterType<P2>::type param2, typename TypeHelpers::ParameterType<P3>::type param3)
    {
        for (Iterator<DummyBailOutChecker, ThisType> iter (*this); iter.next();)
            (iter.getListener()->*callbackFunction) (param1, param2, param3);
    }




    template <typename P1, typename P2, typename P3>
    void callExcluding (ListenerClass& listenerToExclude,
                        void (ListenerClass::*callbackFunction) (P1, P2, P3),
                        typename TypeHelpers::ParameterType<P1>::type param1, typename TypeHelpers::ParameterType<P2>::type param2, typename TypeHelpers::ParameterType<P3>::type param3)
    {
        for (Iterator<DummyBailOutChecker, ThisType> iter (*this); iter.next();)
            if (iter.getListener() != &listenerToExclude)
                (iter.getListener()->*callbackFunction) (param1, param2, param3);
    }




    template <class BailOutCheckerType, typename P1, typename P2, typename P3>
    void callChecked (const BailOutCheckerType& bailOutChecker,
                      void (ListenerClass::*callbackFunction) (P1, P2, P3),
                      typename TypeHelpers::ParameterType<P1>::type param1, typename TypeHelpers::ParameterType<P2>::type param2, typename TypeHelpers::ParameterType<P3>::type param3)
    {
        for (Iterator<BailOutCheckerType, ThisType> iter (*this); iter.next (bailOutChecker);)
            (iter.getListener()->*callbackFunction) (param1, param2, param3);
    }





    template <class BailOutCheckerType, typename P1, typename P2, typename P3>
    void callCheckedExcluding (ListenerClass& listenerToExclude,
                               const BailOutCheckerType& bailOutChecker,
                               void (ListenerClass::*callbackFunction) (P1, P2, P3),
                               typename TypeHelpers::ParameterType<P1>::type param1, typename TypeHelpers::ParameterType<P2>::type param2, typename TypeHelpers::ParameterType<P3>::type param3)
    {
        for (Iterator<BailOutCheckerType, ThisType> iter (*this); iter.next (bailOutChecker);)
            if (iter.getListener() != &listenerToExclude)
                (iter.getListener()->*callbackFunction) (param1, param2, param3);
    }



    template <typename P1, typename P2, typename P3, typename P4>
    void call (void (ListenerClass::*callbackFunction) (P1, P2, P3, P4),
               typename TypeHelpers::ParameterType<P1>::type param1, typename TypeHelpers::ParameterType<P2>::type param2, typename TypeHelpers::ParameterType<P3>::type param3, typename TypeHelpers::ParameterType<P4>::type param4)
    {
        for (Iterator<DummyBailOutChecker, ThisType> iter (*this); iter.next();)
            (iter.getListener()->*callbackFunction) (param1, param2, param3, param4);
    }




    template <typename P1, typename P2, typename P3, typename P4>
    void callExcluding (ListenerClass& listenerToExclude,
                        void (ListenerClass::*callbackFunction) (P1, P2, P3, P4),
                        typename TypeHelpers::ParameterType<P1>::type param1, typename TypeHelpers::ParameterType<P2>::type param2, typename TypeHelpers::ParameterType<P3>::type param3, typename TypeHelpers::ParameterType<P4>::type param4)
    {
        for (Iterator<DummyBailOutChecker, ThisType> iter (*this); iter.next();)
            if (iter.getListener() != &listenerToExclude)
                (iter.getListener()->*callbackFunction) (param1, param2, param3, param4);
    }




    template <class BailOutCheckerType, typename P1, typename P2, typename P3, typename P4>
    void callChecked (const BailOutCheckerType& bailOutChecker,
                      void (ListenerClass::*callbackFunction) (P1, P2, P3, P4),
                      typename TypeHelpers::ParameterType<P1>::type param1, typename TypeHelpers::ParameterType<P2>::type param2, typename TypeHelpers::ParameterType<P3>::type param3, typename TypeHelpers::ParameterType<P4>::type param4)
    {
        for (Iterator<BailOutCheckerType, ThisType> iter (*this); iter.next (bailOutChecker);)
            (iter.getListener()->*callbackFunction) (param1, param2, param3, param4);
    }





    template <class BailOutCheckerType, typename P1, typename P2, typename P3, typename P4>
    void callCheckedExcluding (ListenerClass& listenerToExclude,
                               const BailOutCheckerType& bailOutChecker,
                               void (ListenerClass::*callbackFunction) (P1, P2, P3, P4),
                               typename TypeHelpers::ParameterType<P1>::type param1, typename TypeHelpers::ParameterType<P2>::type param2, typename TypeHelpers::ParameterType<P3>::type param3, typename TypeHelpers::ParameterType<P4>::type param4)
    {
        for (Iterator<BailOutCheckerType, ThisType> iter (*this); iter.next (bailOutChecker);)
            if (iter.getListener() != &listenerToExclude)
                (iter.getListener()->*callbackFunction) (param1, param2, param3, param4);
    }



    template <typename P1, typename P2, typename P3, typename P4, typename P5>
    void call (void (ListenerClass::*callbackFunction) (P1, P2, P3, P4, P5),
               typename TypeHelpers::ParameterType<P1>::type param1, typename TypeHelpers::ParameterType<P2>::type param2, typename TypeHelpers::ParameterType<P3>::type param3, typename TypeHelpers::ParameterType<P4>::type param4, typename TypeHelpers::ParameterType<P5>::type param5)
    {
        for (Iterator<DummyBailOutChecker, ThisType> iter (*this); iter.next();)
            (iter.getListener()->*callbackFunction) (param1, param2, param3, param4, param5);
    }




    template <typename P1, typename P2, typename P3, typename P4, typename P5>
    void callExcluding (ListenerClass& listenerToExclude,
                        void (ListenerClass::*callbackFunction) (P1, P2, P3, P4, P5),
                        typename TypeHelpers::ParameterType<P1>::type param1, typename TypeHelpers::ParameterType<P2>::type param2, typename TypeHelpers::ParameterType<P3>::type param3, typename TypeHelpers::ParameterType<P4>::type param4, typename TypeHelpers::ParameterType<P5>::type param5)
    {
        for (Iterator<DummyBailOutChecker, ThisType> iter (*this); iter.next();)
            if (iter.getListener() != &listenerToExclude)
                (iter.getListener()->*callbackFunction) (param1, param2, param3, param4, param5);
    }




    template <class BailOutCheckerType, typename P1, typename P2, typename P3, typename P4, typename P5>
    void callChecked (const BailOutCheckerType& bailOutChecker,
                      void (ListenerClass::*callbackFunction) (P1, P2, P3, P4, P5),
                      typename TypeHelpers::ParameterType<P1>::type param1, typename TypeHelpers::ParameterType<P2>::type param2, typename TypeHelpers::ParameterType<P3>::type param3, typename TypeHelpers::ParameterType<P4>::type param4, typename TypeHelpers::ParameterType<P5>::type param5)
    {
        for (Iterator<BailOutCheckerType, ThisType> iter (*this); iter.next (bailOutChecker);)
            (iter.getListener()->*callbackFunction) (param1, param2, param3, param4, param5);
    }





    template <class BailOutCheckerType, typename P1, typename P2, typename P3, typename P4, typename P5>
    void callCheckedExcluding (ListenerClass& listenerToExclude,
                               const BailOutCheckerType& bailOutChecker,
                               void (ListenerClass::*callbackFunction) (P1, P2, P3, P4, P5),
                               typename TypeHelpers::ParameterType<P1>::type param1, typename TypeHelpers::ParameterType<P2>::type param2, typename TypeHelpers::ParameterType<P3>::type param3, typename TypeHelpers::ParameterType<P4>::type param4, typename TypeHelpers::ParameterType<P5>::type param5)
    {
        for (Iterator<BailOutCheckerType, ThisType> iter (*this); iter.next (bailOutChecker);)
            if (iter.getListener() != &listenerToExclude)
                (iter.getListener()->*callbackFunction) (param1, param2, param3, param4, param5);
    }



    template <typename P1, typename P2, typename P3, typename P4, typename P5, typename P6>
    void call (void (ListenerClass::*callbackFunction) (P1, P2, P3, P4, P5, P6),
               typename TypeHelpers::ParameterType<P1>::type param1, typename TypeHelpers::ParameterType<P2>::type param2, typename TypeHelpers::ParameterType<P3>::type param3, typename TypeHelpers::ParameterType<P4>::type param4, typename TypeHelpers::ParameterType<P5>::type param5, typename TypeHelpers::ParameterType<P6>::type param6)
    {
        for (Iterator<DummyBailOutChecker, ThisType> iter (*this); iter.next();)
            (iter.getListener()->*callbackFunction) (param1, param2, param3, param4, param5, param6);
    }




    template <typename P1, typename P2, typename P3, typename P4, typename P5, typename P6>
    void callExcluding (ListenerClass& listenerToExclude,
                        void (ListenerClass::*callbackFunction) (P1, P2, P3, P4, P5, P6),
                        typename TypeHelpers::ParameterType<P1>::type param1, typename TypeHelpers::ParameterType<P2>::type param2, typename TypeHelpers::ParameterType<P3>::type param3, typename TypeHelpers::ParameterType<P4>::type param4, typename TypeHelpers::ParameterType<P5>::type param5, typename TypeHelpers::ParameterType<P6>::type param6)
    {
        for (Iterator<DummyBailOutChecker, ThisType> iter (*this); iter.next();)
            if (iter.getListener() != &listenerToExclude)
                (iter.getListener()->*callbackFunction) (param1, param2, param3, param4, param5, param6);
    }




    template <class BailOutCheckerType, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6>
    void callChecked (const BailOutCheckerType& bailOutChecker,
                      void (ListenerClass::*callbackFunction) (P1, P2, P3, P4, P5, P6),
                      typename TypeHelpers::ParameterType<P1>::type param1, typename TypeHelpers::ParameterType<P2>::type param2, typename TypeHelpers::ParameterType<P3>::type param3, typename TypeHelpers::ParameterType<P4>::type param4, typename TypeHelpers::ParameterType<P5>::type param5, typename TypeHelpers::ParameterType<P6>::type param6)
    {
        for (Iterator<BailOutCheckerType, ThisType> iter (*this); iter.next (bailOutChecker);)
            (iter.getListener()->*callbackFunction) (param1, param2, param3, param4, param5, param6);
    }





    template <class BailOutCheckerType, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6>
    void callCheckedExcluding (ListenerClass& listenerToExclude,
                               const BailOutCheckerType& bailOutChecker,
                               void (ListenerClass::*callbackFunction) (P1, P2, P3, P4, P5, P6),
                               typename TypeHelpers::ParameterType<P1>::type param1, typename TypeHelpers::ParameterType<P2>::type param2, typename TypeHelpers::ParameterType<P3>::type param3, typename TypeHelpers::ParameterType<P4>::type param4, typename TypeHelpers::ParameterType<P5>::type param5, typename TypeHelpers::ParameterType<P6>::type param6)
    {
        for (Iterator<BailOutCheckerType, ThisType> iter (*this); iter.next (bailOutChecker);)
            if (iter.getListener() != &listenerToExclude)
                (iter.getListener()->*callbackFunction) (param1, param2, param3, param4, param5, param6);
    }





    struct DummyBailOutChecker
    {
        bool shouldBailOut() const noexcept { return false; }
    };



    template <class BailOutCheckerType, class ListType>
    class Iterator
    {
    public:

        Iterator (const ListType& listToIterate) noexcept
            : list (listToIterate), index (listToIterate.size())
        {}

        ~Iterator() noexcept {}


        bool next() noexcept
        {
            if (index <= 0)
                return false;

            const int listSize = list.size();

            if (--index < listSize)
                return true;

            index = listSize - 1;
            return index >= 0;
        }

        bool next (const BailOutCheckerType& bailOutChecker) noexcept
        {
            return (! bailOutChecker.shouldBailOut()) && next();
        }

        typename ListType::ListenerType* getListener() const noexcept
        {
            return list.getListeners().getUnchecked (index);
        }


    private:
        const ListType& list;
        int index;

        Iterator (const Iterator&) = delete; Iterator& operator= (const Iterator&) = delete;
    };

    typedef ListenerList<ListenerClass, ArrayType> ThisType;
    typedef ListenerClass ListenerType;

    const ArrayType& getListeners() const noexcept { return listeners; }

private:

    ArrayType listeners;

    ListenerList (const ListenerList&) = delete; ListenerList& operator= (const ListenerList&) = delete;



};
# 242 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h" 1
# 54 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
template <class ObjectClass,
          class TypeOfCriticalSectionToUse = DummyCriticalSection>

class OwnedArray
{
public:


    OwnedArray() noexcept
        : numUsed (0)
    {
    }






    ~OwnedArray()
    {
        deleteAllObjects();
    }


    OwnedArray (OwnedArray&& other) noexcept
        : data (static_cast<ArrayAllocationBase <ObjectClass*, TypeOfCriticalSectionToUse>&&> (other.data)),
          numUsed (other.numUsed)
    {
        other.numUsed = 0;
    }

    OwnedArray& operator= (OwnedArray&& other) noexcept
    {
        const ScopedLockType lock (getLock());
        deleteAllObjects();

        data = static_cast<ArrayAllocationBase <ObjectClass*, TypeOfCriticalSectionToUse>&&> (other.data);
        numUsed = other.numUsed;
        other.numUsed = 0;
        return *this;
    }




    void clear (bool deleteObjects = true)
    {
        const ScopedLockType lock (getLock());

        if (deleteObjects)
            deleteAllObjects();

        data.setAllocatedSize (0);
        numUsed = 0;
    }



    void clearQuick (bool deleteObjects)
    {
        const ScopedLockType lock (getLock());

        if (deleteObjects)
            deleteAllObjects();

        numUsed = 0;
    }





    inline int size() const noexcept
    {
        return numUsed;
    }


    inline bool isEmpty() const noexcept
    {
        return size() == 0;
    }
# 145 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
    inline ObjectClass* operator[] (const int index) const noexcept
    {
        const ScopedLockType lock (getLock());
        if (isPositiveAndBelow (index, numUsed))
        {
#pragma warning(push)
# 150 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
#pragma warning(disable: 4127)
# 150 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
 do { ; } while (false)
# 150 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
#pragma warning(pop)
# 150 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
;
            return data.elements [index];
        }

        return nullptr;
    }






    inline ObjectClass* getUnchecked (const int index) const noexcept
    {
        const ScopedLockType lock (getLock());
#pragma warning(push)
# 165 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
#pragma warning(disable: 4127)
# 165 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
 do { ; } while (false)
# 165 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
#pragma warning(pop)
# 165 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
;
        return data.elements [index];
    }






    inline ObjectClass* getFirst() const noexcept
    {
        const ScopedLockType lock (getLock());

        if (numUsed > 0)
        {
#pragma warning(push)
# 180 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
#pragma warning(disable: 4127)
# 180 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
 do { ; } while (false)
# 180 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
#pragma warning(pop)
# 180 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
;
            return data.elements [0];
        }

        return nullptr;
    }






    inline ObjectClass* getLast() const noexcept
    {
        const ScopedLockType lock (getLock());

        if (numUsed > 0)
        {
#pragma warning(push)
# 198 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
#pragma warning(disable: 4127)
# 198 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
 do { ; } while (false)
# 198 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
#pragma warning(pop)
# 198 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
;
            return data.elements [numUsed - 1];
        }

        return nullptr;
    }





    inline ObjectClass** getRawDataPointer() noexcept
    {
        return data.elements;
    }





    inline ObjectClass** begin() const noexcept
    {
        return data.elements;
    }




    inline ObjectClass** end() const noexcept
    {





        return data.elements + numUsed;
    }







    int indexOf (const ObjectClass* objectToLookFor) const noexcept
    {
        const ScopedLockType lock (getLock());
        ObjectClass* const* e = data.elements.getData();
        ObjectClass* const* const end_ = e + numUsed;

        for (; e != end_; ++e)
            if (objectToLookFor == *e)
                return static_cast<int> (e - data.elements.getData());

        return -1;
    }






    bool contains (const ObjectClass* objectToLookFor) const noexcept
    {
        const ScopedLockType lock (getLock());
        ObjectClass* const* e = data.elements.getData();
        ObjectClass* const* const end_ = e + numUsed;

        for (; e != end_; ++e)
            if (objectToLookFor == *e)
                return true;

        return false;
    }
# 286 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
    ObjectClass* add (ObjectClass* newObject) noexcept
    {
        const ScopedLockType lock (getLock());
        data.ensureAllocatedSize (numUsed + 1);
#pragma warning(push)
# 290 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
#pragma warning(disable: 4127)
# 290 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
 do { ; } while (false)
# 290 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
#pragma warning(pop)
# 290 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
;
        data.elements [numUsed++] = newObject;
        return newObject;
    }
# 313 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
    ObjectClass* insert (int indexToInsertAt, ObjectClass* newObject) noexcept
    {
        if (indexToInsertAt < 0)
            return add (newObject);

        const ScopedLockType lock (getLock());

        if (indexToInsertAt > numUsed)
            indexToInsertAt = numUsed;

        data.ensureAllocatedSize (numUsed + 1);
#pragma warning(push)
# 324 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
#pragma warning(disable: 4127)
# 324 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
 do { ; } while (false)
# 324 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
#pragma warning(pop)
# 324 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
;

        ObjectClass** const e = data.elements + indexToInsertAt;
        const int numToMove = numUsed - indexToInsertAt;

        if (numToMove > 0)
            memmove (e + 1, e, sizeof (ObjectClass*) * (size_t) numToMove);

        *e = newObject;
        ++numUsed;
        return newObject;
    }
# 349 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
    void insertArray (int indexToInsertAt,
                      ObjectClass* const* newObjects,
                      int numberOfElements)
    {
        if (numberOfElements > 0)
        {
            const ScopedLockType lock (getLock());
            data.ensureAllocatedSize (numUsed + numberOfElements);
            ObjectClass** insertPos = data.elements;

            if (isPositiveAndBelow (indexToInsertAt, numUsed))
            {
                insertPos += indexToInsertAt;
                const size_t numberToMove = (size_t) (numUsed - indexToInsertAt);
                memmove (insertPos + numberOfElements, insertPos, numberToMove * sizeof (ObjectClass*));
            }
            else
            {
                insertPos += numUsed;
            }

            numUsed += numberOfElements;

            while (--numberOfElements >= 0)
                *insertPos++ = *newObjects++;
        }
    }
# 385 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
    bool addIfNotAlreadyThere (ObjectClass* newObject) noexcept
    {
        const ScopedLockType lock (getLock());

        if (contains (newObject))
            return false;

        add (newObject);
        return true;
    }
# 409 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
    ObjectClass* set (int indexToChange, ObjectClass* newObject, bool deleteOldElement = true)
    {
        if (indexToChange >= 0)
        {
            ScopedPointer<ObjectClass> toDelete;

            {
                const ScopedLockType lock (getLock());

                if (indexToChange < numUsed)
                {
                    if (deleteOldElement)
                    {
                        toDelete = data.elements [indexToChange];

                        if (toDelete == newObject)
                            toDelete.release();
                    }

                    data.elements [indexToChange] = newObject;
                }
                else
                {
                    data.ensureAllocatedSize (numUsed + 1);
                    data.elements [numUsed++] = newObject;
                }
            }
        }
        else
        {
#pragma warning(push)
# 439 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
#pragma warning(disable: 4127)
# 439 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
 do { } while (false)
# 439 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
#pragma warning(pop)
# 439 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
;

        }

        return newObject;
    }
# 455 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
    template <class OtherArrayType>
    void addArray (const OtherArrayType& arrayToAddFrom,
                   int startIndex = 0,
                   int numElementsToAdd = -1)
    {
        const typename OtherArrayType::ScopedLockType lock1 (arrayToAddFrom.getLock());
        const ScopedLockType lock2 (getLock());

        if (startIndex < 0)
        {
#pragma warning(push)
# 465 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
#pragma warning(disable: 4127)
# 465 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
 do { } while (false)
# 465 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
#pragma warning(pop)
# 465 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
;
            startIndex = 0;
        }

        if (numElementsToAdd < 0 || startIndex + numElementsToAdd > arrayToAddFrom.size())
            numElementsToAdd = arrayToAddFrom.size() - startIndex;

        data.ensureAllocatedSize (numUsed + numElementsToAdd);
#pragma warning(push)
# 473 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
#pragma warning(disable: 4127)
# 473 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
 do { ; } while (false)
# 473 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
#pragma warning(pop)
# 473 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
;

        while (--numElementsToAdd >= 0)
        {
            data.elements [numUsed] = arrayToAddFrom.getUnchecked (startIndex++);
            ++numUsed;
        }
    }
# 496 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
    template <class OtherArrayType>
    void addCopiesOf (const OtherArrayType& arrayToAddFrom,
                      int startIndex = 0,
                      int numElementsToAdd = -1)
    {
        const typename OtherArrayType::ScopedLockType lock1 (arrayToAddFrom.getLock());
        const ScopedLockType lock2 (getLock());

        if (startIndex < 0)
        {
#pragma warning(push)
# 506 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
#pragma warning(disable: 4127)
# 506 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
 do { } while (false)
# 506 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
#pragma warning(pop)
# 506 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
;
            startIndex = 0;
        }

        if (numElementsToAdd < 0 || startIndex + numElementsToAdd > arrayToAddFrom.size())
            numElementsToAdd = arrayToAddFrom.size() - startIndex;

        data.ensureAllocatedSize (numUsed + numElementsToAdd);
#pragma warning(push)
# 514 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
#pragma warning(disable: 4127)
# 514 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
 do { ; } while (false)
# 514 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
#pragma warning(pop)
# 514 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
;

        while (--numElementsToAdd >= 0)
            data.elements [numUsed++] = createCopyIfNotNull (arrayToAddFrom.getUnchecked (startIndex++));
    }
# 532 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
    template <class ElementComparator>
    int addSorted (ElementComparator& comparator, ObjectClass* const newObject) noexcept
    {
        ignoreUnused (comparator);

        const ScopedLockType lock (getLock());
        const int index = findInsertIndexInSortedArray (comparator, data.elements.getData(), newObject, 0, numUsed);
        insert (index, newObject);
        return index;
    }
# 555 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
    template <typename ElementComparator>
    int indexOfSorted (ElementComparator& comparator, const ObjectClass* const objectToLookFor) const noexcept
    {
        ignoreUnused (comparator);
        const ScopedLockType lock (getLock());
        int s = 0, e = numUsed;

        while (s < e)
        {
            if (comparator.compareElements (objectToLookFor, data.elements [s]) == 0)
                return s;

            const int halfway = (s + e) / 2;
            if (halfway == s)
                break;

            if (comparator.compareElements (objectToLookFor, data.elements [halfway]) >= 0)
                s = halfway;
            else
                e = halfway;
        }

        return -1;
    }
# 591 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
    void remove (int indexToRemove, bool deleteObject = true)
    {
        ScopedPointer<ObjectClass> toDelete;

        {
            const ScopedLockType lock (getLock());

            if (isPositiveAndBelow (indexToRemove, numUsed))
            {
                ObjectClass** const e = data.elements + indexToRemove;

                if (deleteObject)
                    toDelete = *e;

                --numUsed;
                const int numToShift = numUsed - indexToRemove;

                if (numToShift > 0)
                    memmove (e, e + 1, sizeof (ObjectClass*) * (size_t) numToShift);
            }
        }

        if ((numUsed << 1) < data.numAllocated)
            minimiseStorageOverheads();
    }
# 626 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
    ObjectClass* removeAndReturn (int indexToRemove)
    {
        ObjectClass* removedItem = nullptr;
        const ScopedLockType lock (getLock());

        if (isPositiveAndBelow (indexToRemove, numUsed))
        {
            ObjectClass** const e = data.elements + indexToRemove;
            removedItem = *e;

            --numUsed;
            const int numToShift = numUsed - indexToRemove;

            if (numToShift > 0)
                memmove (e, e + 1, sizeof (ObjectClass*) * (size_t) numToShift);

            if ((numUsed << 1) < data.numAllocated)
                minimiseStorageOverheads();
        }

        return removedItem;
    }
# 657 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
    void removeObject (const ObjectClass* objectToRemove, bool deleteObject = true)
    {
        const ScopedLockType lock (getLock());
        ObjectClass** const e = data.elements.getData();

        for (int i = 0; i < numUsed; ++i)
        {
            if (objectToRemove == e[i])
            {
                remove (i, deleteObject);
                break;
            }
        }
    }
# 685 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
    void removeRange (int startIndex, int numberToRemove, bool deleteObjects = true)
    {
        const ScopedLockType lock (getLock());
        const int endIndex = jlimit (0, numUsed, startIndex + numberToRemove);
        startIndex = jlimit (0, numUsed, startIndex);

        if (endIndex > startIndex)
        {
            if (deleteObjects)
            {
                for (int i = startIndex; i < endIndex; ++i)
                {
                    ContainerDeletePolicy<ObjectClass>::destroy (data.elements [i]);
                    data.elements [i] = nullptr;
                }
            }

            const int rangeSize = endIndex - startIndex;
            ObjectClass** e = data.elements + startIndex;
            int numToShift = numUsed - endIndex;
            numUsed -= rangeSize;

            while (--numToShift >= 0)
            {
                *e = e [rangeSize];
                ++e;
            }

            if ((numUsed << 1) < data.numAllocated)
                minimiseStorageOverheads();
        }
    }







    void removeLast (int howManyToRemove = 1,
                     bool deleteObjects = true)
    {
        const ScopedLockType lock (getLock());

        if (howManyToRemove >= numUsed)
            clear (deleteObjects);
        else
            removeRange (numUsed - howManyToRemove, howManyToRemove, deleteObjects);
    }






    void swap (int index1,
               int index2) noexcept
    {
        const ScopedLockType lock (getLock());

        if (isPositiveAndBelow (index1, numUsed)
             && isPositiveAndBelow (index2, numUsed))
        {
            std::swap (data.elements [index1],
                       data.elements [index2]);
        }
    }
# 766 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
    void move (int currentIndex, int newIndex) noexcept
    {
        if (currentIndex != newIndex)
        {
            const ScopedLockType lock (getLock());

            if (isPositiveAndBelow (currentIndex, numUsed))
            {
                if (! isPositiveAndBelow (newIndex, numUsed))
                    newIndex = numUsed - 1;

                ObjectClass* const value = data.elements [currentIndex];

                if (newIndex > currentIndex)
                {
                    memmove (data.elements + currentIndex,
                             data.elements + currentIndex + 1,
                             sizeof (ObjectClass*) * (size_t) (newIndex - currentIndex));
                }
                else
                {
                    memmove (data.elements + newIndex + 1,
                             data.elements + newIndex,
                             sizeof (ObjectClass*) * (size_t) (currentIndex - newIndex));
                }

                data.elements [newIndex] = value;
            }
        }
    }






    template <class OtherArrayType>
    void swapWith (OtherArrayType& otherArray) noexcept
    {
        const ScopedLockType lock1 (getLock());
        const typename OtherArrayType::ScopedLockType lock2 (otherArray.getLock());
        data.swapWith (otherArray.data);
        std::swap (numUsed, otherArray.numUsed);
    }
# 818 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
    void minimiseStorageOverheads() noexcept
    {
        const ScopedLockType lock (getLock());
        data.shrinkToNoMoreThan (numUsed);
    }







    void ensureStorageAllocated (const int minNumElements) noexcept
    {
        const ScopedLockType lock (getLock());
        data.ensureAllocatedSize (minNumElements);
    }
# 862 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_OwnedArray.h"
    template <class ElementComparator>
    void sort (ElementComparator& comparator,
               bool retainOrderOfEquivalentItems = false) const noexcept
    {
        ignoreUnused (comparator);


        const ScopedLockType lock (getLock());
        sortArray (comparator, data.elements.getData(), 0, size() - 1, retainOrderOfEquivalentItems);
    }






    inline const TypeOfCriticalSectionToUse& getLock() const noexcept { return data; }


    typedef typename TypeOfCriticalSectionToUse::ScopedLockType ScopedLockType;






    __declspec(deprecated) void swapWithArray (OwnedArray& other) noexcept { swapWith (other); }


private:

    ArrayAllocationBase <ObjectClass*, TypeOfCriticalSectionToUse> data;
    int numUsed;

    void deleteAllObjects()
    {
        while (numUsed > 0)
            ContainerDeletePolicy<ObjectClass>::destroy (data.elements [--numUsed]);
    }

    OwnedArray (const OwnedArray&) = delete; OwnedArray& operator= (const OwnedArray&) = delete;
};
# 243 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h" 1
# 56 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
template <class ObjectClass, class TypeOfCriticalSectionToUse = DummyCriticalSection>
class ReferenceCountedArray
{
public:
    typedef ReferenceCountedObjectPtr<ObjectClass> ObjectClassPtr;





    ReferenceCountedArray() noexcept
        : numUsed (0)
    {
    }


    ReferenceCountedArray (const ReferenceCountedArray& other) noexcept
    {
        const ScopedLockType lock (other.getLock());
        numUsed = other.size();
        data.setAllocatedSize (numUsed);
        memcpy (data.elements, other.getRawDataPointer(), (size_t) numUsed * sizeof (ObjectClass*));

        for (int i = numUsed; --i >= 0;)
            if (ObjectClass* o = data.elements[i])
                o->incReferenceCount();
    }


    template <class OtherObjectClass, class OtherCriticalSection>
    ReferenceCountedArray (const ReferenceCountedArray<OtherObjectClass, OtherCriticalSection>& other) noexcept
    {
        const typename ReferenceCountedArray<OtherObjectClass, OtherCriticalSection>::ScopedLockType lock (other.getLock());
        numUsed = other.size();
        data.setAllocatedSize (numUsed);
        memcpy (data.elements, other.getRawDataPointer(), numUsed * sizeof (ObjectClass*));

        for (int i = numUsed; --i >= 0;)
            if (ObjectClass* o = data.elements[i])
                o->incReferenceCount();
    }




    ReferenceCountedArray& operator= (const ReferenceCountedArray& other) noexcept
    {
        ReferenceCountedArray otherCopy (other);
        swapWith (otherCopy);
        return *this;
    }




    template <class OtherObjectClass>
    ReferenceCountedArray<ObjectClass, TypeOfCriticalSectionToUse>& operator= (const ReferenceCountedArray<OtherObjectClass, TypeOfCriticalSectionToUse>& other) noexcept
    {
        ReferenceCountedArray<ObjectClass, TypeOfCriticalSectionToUse> otherCopy (other);
        swapWith (otherCopy);
        return *this;
    }




    ~ReferenceCountedArray()
    {
        releaseAllObjects();
    }





    void clear()
    {
        const ScopedLockType lock (getLock());
        releaseAllObjects();
        data.setAllocatedSize (0);
    }





    void clearQuick()
    {
        const ScopedLockType lock (getLock());
        releaseAllObjects();
    }


    inline int size() const noexcept
    {
        return numUsed;
    }


    inline bool isEmpty() const noexcept
    {
        return size() == 0;
    }
# 168 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
    inline ObjectClassPtr operator[] (const int index) const noexcept
    {
        return getObjectPointer (index);
    }







    inline ObjectClassPtr getUnchecked (const int index) const noexcept
    {
        return getObjectPointerUnchecked (index);
    }
# 192 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
    inline ObjectClass* getObjectPointer (const int index) const noexcept
    {
        const ScopedLockType lock (getLock());

        if (isPositiveAndBelow (index, numUsed))
        {
#pragma warning(push)
# 198 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
#pragma warning(disable: 4127)
# 198 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
 do { ; } while (false)
# 198 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
#pragma warning(pop)
# 198 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
;
            return data.elements [index];
        }

        return ObjectClassPtr();
    }




    inline ObjectClass* getObjectPointerUnchecked (const int index) const noexcept
    {
        const ScopedLockType lock (getLock());
#pragma warning(push)
# 211 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
#pragma warning(disable: 4127)
# 211 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
 do { ; } while (false)
# 211 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
#pragma warning(pop)
# 211 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
;
        return data.elements [index];
    }






    inline ObjectClassPtr getFirst() const noexcept
    {
        const ScopedLockType lock (getLock());

        if (numUsed > 0)
        {
#pragma warning(push)
# 226 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
#pragma warning(disable: 4127)
# 226 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
 do { ; } while (false)
# 226 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
#pragma warning(pop)
# 226 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
;
            return data.elements [0];
        }

        return ObjectClassPtr();
    }






    inline ObjectClassPtr getLast() const noexcept
    {
        const ScopedLockType lock (getLock());

        if (numUsed > 0)
        {
#pragma warning(push)
# 244 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
#pragma warning(disable: 4127)
# 244 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
 do { ; } while (false)
# 244 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
#pragma warning(pop)
# 244 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
;
            return data.elements [numUsed - 1];
        }

        return ObjectClassPtr();
    }





    inline ObjectClass** getRawDataPointer() const noexcept
    {
        return data.elements;
    }





    inline ObjectClass** begin() const noexcept
    {
        return data.elements;
    }




    inline ObjectClass** end() const noexcept
    {
        return data.elements + numUsed;
    }







    int indexOf (const ObjectClass* const objectToLookFor) const noexcept
    {
        const ScopedLockType lock (getLock());
        ObjectClass** e = data.elements.getData();
        ObjectClass** const endPointer = e + numUsed;

        while (e != endPointer)
        {
            if (objectToLookFor == *e)
                return static_cast<int> (e - data.elements.getData());

            ++e;
        }

        return -1;
    }






    bool contains (const ObjectClass* const objectToLookFor) const noexcept
    {
        const ScopedLockType lock (getLock());
        ObjectClass** e = data.elements.getData();
        ObjectClass** const endPointer = e + numUsed;

        while (e != endPointer)
        {
            if (objectToLookFor == *e)
                return true;

            ++e;
        }

        return false;
    }
# 329 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
    ObjectClass* add (ObjectClass* const newObject) noexcept
    {
        const ScopedLockType lock (getLock());
        data.ensureAllocatedSize (numUsed + 1);
#pragma warning(push)
# 333 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
#pragma warning(disable: 4127)
# 333 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
 do { ; } while (false)
# 333 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
#pragma warning(pop)
# 333 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
;
        data.elements [numUsed++] = newObject;

        if (newObject != nullptr)
            newObject->incReferenceCount();

        return newObject;
    }
# 355 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
    ObjectClass* insert (int indexToInsertAt,
                         ObjectClass* const newObject) noexcept
    {
        if (indexToInsertAt < 0)
            return add (newObject);

        const ScopedLockType lock (getLock());

        if (indexToInsertAt > numUsed)
            indexToInsertAt = numUsed;

        data.ensureAllocatedSize (numUsed + 1);
#pragma warning(push)
# 367 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
#pragma warning(disable: 4127)
# 367 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
 do { ; } while (false)
# 367 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
#pragma warning(pop)
# 367 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
;

        ObjectClass** const e = data.elements + indexToInsertAt;
        const int numToMove = numUsed - indexToInsertAt;

        if (numToMove > 0)
            memmove (e + 1, e, sizeof (ObjectClass*) * (size_t) numToMove);

        *e = newObject;

        if (newObject != nullptr)
            newObject->incReferenceCount();

        ++numUsed;

        return newObject;
    }
# 393 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
    bool addIfNotAlreadyThere (ObjectClass* const newObject) noexcept
    {
        const ScopedLockType lock (getLock());

        if (contains (newObject))
            return false;

        add (newObject);
        return true;
    }
# 416 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
    void set (const int indexToChange,
              ObjectClass* const newObject)
    {
        if (indexToChange >= 0)
        {
            const ScopedLockType lock (getLock());

            if (newObject != nullptr)
                newObject->incReferenceCount();

            if (indexToChange < numUsed)
            {
                if (ObjectClass* o = data.elements [indexToChange])
                    releaseObject (o);

                data.elements [indexToChange] = newObject;
            }
            else
            {
                data.ensureAllocatedSize (numUsed + 1);
#pragma warning(push)
# 436 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
#pragma warning(disable: 4127)
# 436 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
 do { ; } while (false)
# 436 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
#pragma warning(pop)
# 436 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
;
                data.elements [numUsed++] = newObject;
            }
        }
    }
# 451 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
    void addArray (const ReferenceCountedArray<ObjectClass, TypeOfCriticalSectionToUse>& arrayToAddFrom,
                   int startIndex = 0,
                   int numElementsToAdd = -1) noexcept
    {
        const ScopedLockType lock1 (arrayToAddFrom.getLock());

        {
            const ScopedLockType lock2 (getLock());

            if (startIndex < 0)
            {
#pragma warning(push)
# 462 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
#pragma warning(disable: 4127)
# 462 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
 do { } while (false)
# 462 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
#pragma warning(pop)
# 462 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
;
                startIndex = 0;
            }

            if (numElementsToAdd < 0 || startIndex + numElementsToAdd > arrayToAddFrom.size())
                numElementsToAdd = arrayToAddFrom.size() - startIndex;

            if (numElementsToAdd > 0)
            {
                data.ensureAllocatedSize (numUsed + numElementsToAdd);

                while (--numElementsToAdd >= 0)
                    add (arrayToAddFrom.getUnchecked (startIndex++));
            }
        }
    }
# 491 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
    template <class ElementComparator>
    int addSorted (ElementComparator& comparator, ObjectClass* newObject) noexcept
    {
        const ScopedLockType lock (getLock());
        const int index = findInsertIndexInSortedArray (comparator, data.elements.getData(), newObject, 0, numUsed);
        insert (index, newObject);
        return index;
    }






    template <class ElementComparator>
    void addOrReplaceSorted (ElementComparator& comparator,
                             ObjectClass* newObject) noexcept
    {
        const ScopedLockType lock (getLock());
        const int index = findInsertIndexInSortedArray (comparator, data.elements.getData(), newObject, 0, numUsed);

        if (index > 0 && comparator.compareElements (newObject, data.elements [index - 1]) == 0)
            set (index - 1, newObject);
        else
            insert (index, newObject);
    }
# 530 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
    template <class ElementComparator>
    int indexOfSorted (ElementComparator& comparator,
                       const ObjectClass* const objectToLookFor) const noexcept
    {
        ignoreUnused (comparator);
        const ScopedLockType lock (getLock());
        int s = 0, e = numUsed;

        while (s < e)
        {
            if (comparator.compareElements (objectToLookFor, data.elements [s]) == 0)
                return s;

            const int halfway = (s + e) / 2;
            if (halfway == s)
                break;

            if (comparator.compareElements (objectToLookFor, data.elements [halfway]) >= 0)
                s = halfway;
            else
                e = halfway;
        }

        return -1;
    }
# 570 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
    void remove (const int indexToRemove)
    {
        const ScopedLockType lock (getLock());

        if (isPositiveAndBelow (indexToRemove, numUsed))
        {
            ObjectClass** const e = data.elements + indexToRemove;

            if (ObjectClass* o = *e)
                releaseObject (o);

            --numUsed;
            const int numberToShift = numUsed - indexToRemove;

            if (numberToShift > 0)
                memmove (e, e + 1, sizeof (ObjectClass*) * (size_t) numberToShift);

            if ((numUsed << 1) < data.numAllocated)
                minimiseStorageOverheads();
        }
    }
# 601 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
    ObjectClassPtr removeAndReturn (const int indexToRemove)
    {
        ObjectClassPtr removedItem;
        const ScopedLockType lock (getLock());

        if (isPositiveAndBelow (indexToRemove, numUsed))
        {
            ObjectClass** const e = data.elements + indexToRemove;

            if (ObjectClass* o = *e)
            {
                removedItem = o;
                releaseObject (o);
            }

            --numUsed;
            const int numberToShift = numUsed - indexToRemove;

            if (numberToShift > 0)
                memmove (e, e + 1, sizeof (ObjectClass*) * (size_t) numberToShift);

            if ((numUsed << 1) < data.numAllocated)
                minimiseStorageOverheads();
        }

        return removedItem;
    }
# 637 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
    void removeObject (ObjectClass* const objectToRemove)
    {
        const ScopedLockType lock (getLock());
        remove (indexOf (objectToRemove));
    }
# 658 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
    void removeRange (const int startIndex,
                      const int numberToRemove)
    {
        const ScopedLockType lock (getLock());

        const int start = jlimit (0, numUsed, startIndex);
        const int endIndex = jlimit (0, numUsed, startIndex + numberToRemove);

        if (endIndex > start)
        {
            int i;
            for (i = start; i < endIndex; ++i)
            {
                if (ObjectClass* o = data.elements[i])
                {
                    releaseObject (o);
                    data.elements[i] = nullptr;
                }
            }

            const int rangeSize = endIndex - start;
            ObjectClass** e = data.elements + start;
            i = numUsed - endIndex;
            numUsed -= rangeSize;

            while (--i >= 0)
            {
                *e = e [rangeSize];
                ++e;
            }

            if ((numUsed << 1) < data.numAllocated)
                minimiseStorageOverheads();
        }
    }
# 702 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
    void removeLast (int howManyToRemove = 1)
    {
        const ScopedLockType lock (getLock());

        if (howManyToRemove > numUsed)
            howManyToRemove = numUsed;

        while (--howManyToRemove >= 0)
            remove (numUsed - 1);
    }






    void swap (const int index1,
               const int index2) noexcept
    {
        const ScopedLockType lock (getLock());

        if (isPositiveAndBelow (index1, numUsed)
             && isPositiveAndBelow (index2, numUsed))
        {
            std::swap (data.elements [index1],
                       data.elements [index2]);
        }
    }
# 744 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
    void move (const int currentIndex,
               int newIndex) noexcept
    {
        if (currentIndex != newIndex)
        {
            const ScopedLockType lock (getLock());

            if (isPositiveAndBelow (currentIndex, numUsed))
            {
                if (! isPositiveAndBelow (newIndex, numUsed))
                    newIndex = numUsed - 1;

                ObjectClass* const value = data.elements [currentIndex];

                if (newIndex > currentIndex)
                {
                    memmove (data.elements + currentIndex,
                             data.elements + currentIndex + 1,
                             sizeof (ObjectClass*) * (size_t) (newIndex - currentIndex));
                }
                else
                {
                    memmove (data.elements + newIndex + 1,
                             data.elements + newIndex,
                             sizeof (ObjectClass*) * (size_t) (currentIndex - newIndex));
                }

                data.elements [newIndex] = value;
            }
        }
    }







    template <class OtherArrayType>
    void swapWith (OtherArrayType& otherArray) noexcept
    {
        const ScopedLockType lock1 (getLock());
        const typename OtherArrayType::ScopedLockType lock2 (otherArray.getLock());
        data.swapWith (otherArray.data);
        std::swap (numUsed, otherArray.numUsed);
    }






    bool operator== (const ReferenceCountedArray& other) const noexcept
    {
        const ScopedLockType lock2 (other.getLock());
        const ScopedLockType lock1 (getLock());

        if (numUsed != other.numUsed)
            return false;

        for (int i = numUsed; --i >= 0;)
            if (data.elements [i] != other.data.elements [i])
                return false;

        return true;
    }





    bool operator!= (const ReferenceCountedArray<ObjectClass, TypeOfCriticalSectionToUse>& other) const noexcept
    {
        return ! operator== (other);
    }
# 847 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
    template <class ElementComparator>
    void sort (ElementComparator& comparator,
               const bool retainOrderOfEquivalentItems = false) const noexcept
    {
        ignoreUnused (comparator);


        const ScopedLockType lock (getLock());
        sortArray (comparator, data.elements.getData(), 0, size() - 1, retainOrderOfEquivalentItems);
    }
# 865 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
    void minimiseStorageOverheads() noexcept
    {
        const ScopedLockType lock (getLock());
        data.shrinkToNoMoreThan (numUsed);
    }







    void ensureStorageAllocated (const int minNumElements)
    {
        const ScopedLockType lock (getLock());
        data.ensureAllocatedSize (minNumElements);
    }






    inline const TypeOfCriticalSectionToUse& getLock() const noexcept { return data; }


    typedef typename TypeOfCriticalSectionToUse::ScopedLockType ScopedLockType;






    __declspec(deprecated) void swapWithArray (ReferenceCountedArray& other) noexcept { swapWith (other); }


private:

    ArrayAllocationBase <ObjectClass*, TypeOfCriticalSectionToUse> data;
    int numUsed;

    void releaseAllObjects()
    {
        while (numUsed > 0)
            if (ObjectClass* o = data.elements [--numUsed])
                releaseObject (o);

#pragma warning(push)
# 912 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
#pragma warning(disable: 4127)
# 912 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
 do { ; } while (false)
# 912 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
#pragma warning(pop)
# 912 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ReferenceCountedArray.h"
;
    }

    static void releaseObject (ObjectClass* o)
    {
        if (o->decReferenceCountWithoutDeleting())
            ContainerDeletePolicy<ObjectClass>::destroy (o);
    }
};
# 244 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ScopedValueSetter.h" 1
# 61 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_ScopedValueSetter.h"
template <typename ValueType>
class ScopedValueSetter
{
public:



    ScopedValueSetter (ValueType& valueToSet,
                       ValueType newValue)
        : value (valueToSet),
          originalValue (valueToSet)
    {
        valueToSet = newValue;
    }




    ScopedValueSetter (ValueType& valueToSet,
                       ValueType newValue,
                       ValueType valueWhenDeleted)
        : value (valueToSet),
          originalValue (valueWhenDeleted)
    {
        valueToSet = newValue;
    }

    ~ScopedValueSetter()
    {
        value = originalValue;
    }

private:

    ValueType& value;
    const ValueType originalValue;

    ScopedValueSetter (const ScopedValueSetter&) = delete; ScopedValueSetter& operator= (const ScopedValueSetter&) = delete;
};
# 245 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_SortedSet.h" 1
# 35 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_SortedSet.h"
#pragma warning(push)
#pragma warning(disable: 4512)
# 61 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_SortedSet.h"
template <class ElementType, class TypeOfCriticalSectionToUse = DummyCriticalSection>
class SortedSet
{
public:


    SortedSet() noexcept
    {
    }




    SortedSet (const SortedSet& other)
        : data (other.data)
    {
    }


    ~SortedSet() noexcept
    {
    }




    SortedSet& operator= (const SortedSet& other) noexcept
    {
        data = other.data;
        return *this;
    }






    bool operator== (const SortedSet<ElementType>& other) const noexcept
    {
        return data == other.data;
    }





    bool operator!= (const SortedSet<ElementType>& other) const noexcept
    {
        return ! operator== (other);
    }
# 121 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_SortedSet.h"
    void clear() noexcept
    {
        data.clear();
    }




    void clearQuick() noexcept
    {
        data.clearQuick();
    }



    inline int size() const noexcept
    {
        return data.size();
    }


    inline bool isEmpty() const noexcept
    {
        return size() == 0;
    }
# 158 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_SortedSet.h"
    inline ElementType operator[] (const int index) const noexcept
    {
        return data [index];
    }
# 171 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_SortedSet.h"
    inline ElementType getUnchecked (const int index) const noexcept
    {
        return data.getUnchecked (index);
    }
# 184 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_SortedSet.h"
    inline ElementType& getReference (const int index) const noexcept
    {
        return data.getReference (index);
    }




    inline ElementType getFirst() const noexcept
    {
        return data.getFirst();
    }




    inline ElementType getLast() const noexcept
    {
        return data.getLast();
    }





    inline ElementType* begin() const noexcept
    {
        return data.begin();
    }




    inline ElementType* end() const noexcept
    {
        return data.end();
    }
# 231 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_SortedSet.h"
    int indexOf (const ElementType& elementToLookFor) const noexcept
    {
        const ScopedLockType lock (data.getLock());

        int s = 0;
        int e = data.size();

        for (;;)
        {
            if (s >= e)
                return -1;

            if (elementToLookFor == data.getReference (s))
                return s;

            const int halfway = (s + e) / 2;

            if (halfway == s)
                return -1;

            if (elementToLookFor < data.getReference (halfway))
                e = halfway;
            else
                s = halfway;
        }
    }






    bool contains (const ElementType& elementToLookFor) const noexcept
    {
        return indexOf (elementToLookFor) >= 0;
    }
# 280 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_SortedSet.h"
    bool add (const ElementType& newElement) noexcept
    {
        const ScopedLockType lock (getLock());

        int s = 0;
        int e = data.size();

        while (s < e)
        {
            ElementType& elem = data.getReference (s);
            if (newElement == elem)
            {
                elem = newElement;
                return false;
            }

            const int halfway = (s + e) / 2;
            const bool isBeforeHalfway = (newElement < data.getReference (halfway));

            if (halfway == s)
            {
                if (! isBeforeHalfway)
                    ++s;

                break;
            }

            if (isBeforeHalfway)
                e = halfway;
            else
                s = halfway;
        }

        data.insert (s, newElement);
        return true;
    }







    void addArray (const ElementType* elementsToAdd,
                   int numElementsToAdd) noexcept
    {
        const ScopedLockType lock (getLock());

        while (--numElementsToAdd >= 0)
            add (*elementsToAdd++);
    }
# 341 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_SortedSet.h"
    template <class OtherSetType>
    void addSet (const OtherSetType& setToAddFrom,
                 int startIndex = 0,
                 int numElementsToAdd = -1) noexcept
    {
        const typename OtherSetType::ScopedLockType lock1 (setToAddFrom.getLock());

        {
            const ScopedLockType lock2 (getLock());
#pragma warning(push)
# 350 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_SortedSet.h"
#pragma warning(disable: 4127)
# 350 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_SortedSet.h"
 do { ; } while (false)
# 350 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_SortedSet.h"
#pragma warning(pop)
# 350 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_SortedSet.h"
;

            if (this != &setToAddFrom)
            {
                if (startIndex < 0)
                {
#pragma warning(push)
# 356 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_SortedSet.h"
#pragma warning(disable: 4127)
# 356 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_SortedSet.h"
 do { } while (false)
# 356 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_SortedSet.h"
#pragma warning(pop)
# 356 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_SortedSet.h"
;
                    startIndex = 0;
                }

                if (numElementsToAdd < 0 || startIndex + numElementsToAdd > setToAddFrom.size())
                    numElementsToAdd = setToAddFrom.size() - startIndex;

                if (numElementsToAdd > 0)
                    addArray (&setToAddFrom.data.getReference (startIndex), numElementsToAdd);
            }
        }
    }
# 379 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_SortedSet.h"
    ElementType remove (const int indexToRemove) noexcept
    {
        return data.removeAndReturn (indexToRemove);
    }
# 391 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_SortedSet.h"
    void removeValue (const ElementType valueToRemove) noexcept
    {
        const ScopedLockType lock (getLock());
        data.remove (indexOf (valueToRemove));
    }






    template <class OtherSetType>
    void removeValuesIn (const OtherSetType& otherSet) noexcept
    {
        const typename OtherSetType::ScopedLockType lock1 (otherSet.getLock());
        const ScopedLockType lock2 (getLock());

        if (this == &otherSet)
        {
            clear();
        }
        else if (otherSet.size() > 0)
        {
            for (int i = data.size(); --i >= 0;)
                if (otherSet.contains (data.getReference (i)))
                    remove (i);
        }
    }
# 427 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_SortedSet.h"
    template <class OtherSetType>
    void removeValuesNotIn (const OtherSetType& otherSet) noexcept
    {
        const typename OtherSetType::ScopedLockType lock1 (otherSet.getLock());
        const ScopedLockType lock2 (getLock());

        if (this != &otherSet)
        {
            if (otherSet.size() <= 0)
            {
                clear();
            }
            else
            {
                for (int i = data.size(); --i >= 0;)
                    if (! otherSet.contains (data.getReference (i)))
                        remove (i);
            }
        }
    }






    template <class OtherSetType>
    void swapWith (OtherSetType& otherSet) noexcept
    {
        data.swapWith (otherSet.data);
    }
# 466 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_SortedSet.h"
    void minimiseStorageOverheads() noexcept
    {
        data.minimiseStorageOverheads();
    }







    void ensureStorageAllocated (const int minNumElements)
    {
        data.ensureStorageAllocated (minNumElements);
    }






    inline const TypeOfCriticalSectionToUse& getLock() const noexcept { return data.getLock(); }


    typedef typename TypeOfCriticalSectionToUse::ScopedLockType ScopedLockType;


private:

    Array<ElementType, TypeOfCriticalSectionToUse> data;
};


#pragma warning(pop)
# 246 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_SparseSet.h" 1
# 46 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_SparseSet.h"
template <class Type>
class SparseSet
{
public:


    SparseSet()
    {
    }


    SparseSet (const SparseSet<Type>& other)
        : values (other.values)
    {
    }



    void clear()
    {
        values.clear();
    }





    bool isEmpty() const noexcept
    {
        return values.size() == 0;
    }







    Type size() const
    {
        Type total (0);

        for (int i = 0; i < values.size(); i += 2)
            total += values.getUnchecked (i + 1) - values.getUnchecked (i);

        return total;
    }






    Type operator[] (Type index) const
    {
        for (int i = 0; i < values.size(); i += 2)
        {
            const Type start (values.getUnchecked (i));
            const Type len (values.getUnchecked (i + 1) - start);

            if (index < len)
                return start + index;

            index -= len;
        }

        return Type();
    }


    bool contains (const Type valueToLookFor) const
    {
        for (int i = 0; i < values.size(); ++i)
            if (valueToLookFor < values.getUnchecked(i))
                return (i & 1) != 0;

        return false;
    }





    int getNumRanges() const noexcept
    {
        return values.size() >> 1;
    }






    const Range<Type> getRange (const int rangeIndex) const
    {
        if (isPositiveAndBelow (rangeIndex, getNumRanges()))
            return Range<Type> (values.getUnchecked (rangeIndex << 1),
                                values.getUnchecked ((rangeIndex << 1) + 1));

        return Range<Type>();
    }




    Range<Type> getTotalRange() const
    {
        if (values.size() > 0)
        {
#pragma warning(push)
# 155 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_SparseSet.h"
#pragma warning(disable: 4127)
# 155 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_SparseSet.h"
 do { ; } while (false)
# 155 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_SparseSet.h"
#pragma warning(pop)
# 155 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_SparseSet.h"
;
            return Range<Type> (values.getUnchecked (0),
                                values.getUnchecked (values.size() - 1));
        }

        return Range<Type>();
    }





    void addRange (const Range<Type> range)
    {
#pragma warning(push)
# 169 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_SparseSet.h"
#pragma warning(disable: 4127)
# 169 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_SparseSet.h"
 do { ; } while (false)
# 169 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_SparseSet.h"
#pragma warning(pop)
# 169 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_SparseSet.h"
;
        if (range.getLength() > 0)
        {
            removeRange (range);

            values.addUsingDefaultSort (range.getStart());
            values.addUsingDefaultSort (range.getEnd());

            simplify();
        }
    }




    void removeRange (const Range<Type> rangeToRemove)
    {
#pragma warning(push)
# 186 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_SparseSet.h"
#pragma warning(disable: 4127)
# 186 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_SparseSet.h"
 do { ; } while (false)
# 186 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_SparseSet.h"
#pragma warning(pop)
# 186 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_SparseSet.h"
;

        if (rangeToRemove.getLength() > 0
             && values.size() > 0
             && rangeToRemove.getStart() < values.getUnchecked (values.size() - 1)
             && values.getUnchecked(0) < rangeToRemove.getEnd())
        {
            const bool onAtStart = contains (rangeToRemove.getStart() - 1);
            const Type lastValue (jmin (rangeToRemove.getEnd(), values.getLast()));
            const bool onAtEnd = contains (lastValue);

            for (int i = values.size(); --i >= 0;)
            {
                if (values.getUnchecked(i) <= lastValue)
                {
                    while (values.getUnchecked(i) >= rangeToRemove.getStart())
                    {
                        values.remove (i);

                        if (--i < 0)
                            break;
                    }

                    break;
                }
            }

            if (onAtStart) values.addUsingDefaultSort (rangeToRemove.getStart());
            if (onAtEnd) values.addUsingDefaultSort (lastValue);

            simplify();
        }
    }


    void invertRange (const Range<Type> range)
    {
        SparseSet newItems;
        newItems.addRange (range);

        for (int i = getNumRanges(); --i >= 0;)
            newItems.removeRange (getRange (i));

        removeRange (range);

        for (int i = newItems.getNumRanges(); --i >= 0;)
            addRange (newItems.getRange(i));
    }


    bool overlapsRange (const Range<Type> range)
    {
        if (range.getLength() > 0)
        {
            for (int i = getNumRanges(); --i >= 0;)
            {
                if (values.getUnchecked ((i << 1) + 1) <= range.getStart())
                    return false;

                if (values.getUnchecked (i << 1) < range.getEnd())
                    return true;
            }
        }

        return false;
    }


    bool containsRange (const Range<Type> range)
    {
        if (range.getLength() > 0)
        {
            for (int i = getNumRanges(); --i >= 0;)
            {
                if (values.getUnchecked ((i << 1) + 1) <= range.getStart())
                    return false;

                if (values.getUnchecked (i << 1) <= range.getStart()
                     && range.getEnd() <= values.getUnchecked ((i << 1) + 1))
                    return true;
            }
        }

        return false;
    }


    bool operator== (const SparseSet<Type>& other) noexcept
    {
        return values == other.values;
    }

    bool operator!= (const SparseSet<Type>& other) noexcept
    {
        return values != other.values;
    }

private:


    Array<Type, DummyCriticalSection> values;

    void simplify()
    {
#pragma warning(push)
# 290 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_SparseSet.h"
#pragma warning(disable: 4127)
# 290 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_SparseSet.h"
 do { ; } while (false)
# 290 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_SparseSet.h"
#pragma warning(pop)
# 290 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_SparseSet.h"
;

        for (int i = values.size(); --i > 0;)
            if (values.getUnchecked(i) == values.getUnchecked (i - 1))
                values.removeRange (--i, 2);
    }
};
# 247 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_AbstractFifo.h" 1
# 91 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_AbstractFifo.h"
class AbstractFifo
{
public:


    AbstractFifo (int capacity) noexcept;


    ~AbstractFifo();



    int getTotalSize() const noexcept;


    int getFreeSpace() const noexcept;


    int getNumReady() const noexcept;


    void reset() noexcept;





    void setTotalSize (int newSize) noexcept;
# 160 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_AbstractFifo.h"
    void prepareToWrite (int numToWrite, int& startIndex1, int& blockSize1, int& startIndex2, int& blockSize2) const noexcept;




    void finishedWrite (int numWritten) noexcept;
# 205 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_AbstractFifo.h"
    void prepareToRead (int numWanted, int& startIndex1, int& blockSize1, int& startIndex2, int& blockSize2) const noexcept;




    void finishedRead (int numRead) noexcept;


private:

    int bufferSize;
    Atomic <int> validStart, validEnd;

    AbstractFifo (const AbstractFifo&) = delete; AbstractFifo& operator= (const AbstractFifo&) = delete;
};
# 248 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_NewLine.h" 1
# 46 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_NewLine.h"
class NewLine
{
public:



    static const char* getDefault() noexcept { return "\r\n"; }




    operator String() const { return getDefault(); }




    operator StringRef() const noexcept { return getDefault(); }
};
# 73 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_NewLine.h"
extern NewLine newLine;
# 82 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_NewLine.h"
inline String& operator<< (String& string1, const NewLine&) { return string1 += NewLine::getDefault(); }
inline String& operator+= (String& s1, const NewLine&) { return s1 += NewLine::getDefault(); }

inline String operator+ (const NewLine&, const NewLine&) { return String (NewLine::getDefault()) + NewLine::getDefault(); }
inline String operator+ (String s1, const NewLine&) { return s1 += NewLine::getDefault(); }
inline String operator+ (const NewLine&, const char* s2) { return String (NewLine::getDefault()) + s2; }
# 249 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_StringPool.h" 1
# 46 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_StringPool.h"
class StringPool
{
public:


    StringPool() noexcept;


    ~StringPool();





    String getPooledString (const String& original);




    String getPooledString (const char* original);




    String getPooledString (StringRef original);




    String getPooledString (String::CharPointerType start, String::CharPointerType end);






    void garbageCollect();


    static StringPool& getGlobalPool() noexcept;

private:
    Array<String> strings;
    CriticalSection lock;
    uint32 lastGarbageCollectionTime;

    void garbageCollectIfNeeded();

    StringPool (const StringPool&) = delete; StringPool& operator= (const StringPool&) = delete;
};
# 250 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_Identifier.h" 1
# 45 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_Identifier.h"
class Identifier
{
public:

    Identifier() noexcept;





    Identifier (const char* name);





    Identifier (const String& name);





    Identifier (String::CharPointerType nameStart, String::CharPointerType nameEnd);


    Identifier (const Identifier& other) noexcept;


    Identifier& operator= (const Identifier& other) noexcept;



    Identifier (Identifier&& other) noexcept;


    Identifier& operator= (Identifier&& other) noexcept;



    ~Identifier() noexcept;


    inline bool operator== (const Identifier& other) const noexcept { return name.getCharPointer() == other.name.getCharPointer(); }


    inline bool operator!= (const Identifier& other) const noexcept { return name.getCharPointer() != other.name.getCharPointer(); }


    inline bool operator== (StringRef other) const noexcept { return name == other; }


    inline bool operator!= (StringRef other) const noexcept { return name != other; }


    inline bool operator< (StringRef other) const noexcept { return name < other; }


    inline bool operator<= (StringRef other) const noexcept { return name <= other; }


    inline bool operator> (StringRef other) const noexcept { return name > other; }


    inline bool operator>= (StringRef other) const noexcept { return name >= other; }


    const String& toString() const noexcept { return name; }


    operator String::CharPointerType() const noexcept { return name.getCharPointer(); }


    String::CharPointerType getCharPointer() const noexcept { return name.getCharPointer(); }


    operator StringRef() const noexcept { return name; }


    bool isValid() const noexcept { return name.isNotEmpty(); }


    bool isNull() const noexcept { return name.isEmpty(); }


    static Identifier null;





    static bool isValidIdentifier (const String& possibleIdentifier) noexcept;

private:
    String name;
};
# 251 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_StringArray.h" 1
# 41 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_StringArray.h"
class StringArray
{
public:


    StringArray() noexcept;


    StringArray (const StringArray&);


    StringArray (StringArray&&) noexcept;



    explicit StringArray (const String& firstValue);





    StringArray (const String* strings, int numberOfStrings);






    StringArray (const char* const* strings, int numberOfStrings);






    explicit StringArray (const char* const* strings);





    explicit StringArray (const wchar_t* const* strings);






    StringArray (const wchar_t* const* strings, int numberOfStrings);


    StringArray (const std::initializer_list<const char*>& strings);



    ~StringArray();


    StringArray& operator= (const StringArray&);


    StringArray& operator= (StringArray&&) noexcept;



    void swapWith (StringArray&) noexcept;






    bool operator== (const StringArray&) const noexcept;





    bool operator!= (const StringArray&) const noexcept;



    inline int size() const noexcept { return strings.size(); }


    inline bool isEmpty() const noexcept { return size() == 0; }
# 135 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_StringArray.h"
    const String& operator[] (int index) const noexcept;





    String& getReference (int index) noexcept;




    inline String* begin() const noexcept { return strings.begin(); }




    inline String* end() const noexcept { return strings.end(); }







    bool contains (StringRef stringToLookFor,
                   bool ignoreCase = false) const;
# 172 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_StringArray.h"
    int indexOf (StringRef stringToLookFor,
                 bool ignoreCase = false,
                 int startIndex = 0) const;



    void add (const String& stringToAdd);



    void add (String&& stringToAdd);
# 192 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_StringArray.h"
    void insert (int index, const String& stringToAdd);






    bool addIfNotAlreadyThere (const String& stringToAdd, bool ignoreCase = false);






    void set (int index, const String& newString);
# 215 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_StringArray.h"
    void addArray (const StringArray& other,
                   int startIndex = 0,
                   int numElementsToAdd = -1);







    void mergeArray (const StringArray& other,
                     bool ignoreCase = false);
# 235 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_StringArray.h"
    int addTokens (StringRef stringToTokenise, bool preserveQuotedStrings);
# 251 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_StringArray.h"
    int addTokens (StringRef stringToTokenise,
                   StringRef breakCharacters,
                   StringRef quoteCharacters);







    int addLines (StringRef stringToBreakUp);







    static StringArray fromTokens (StringRef stringToTokenise,
                                   bool preserveQuotedStrings);
# 285 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_StringArray.h"
    static StringArray fromTokens (StringRef stringToTokenise,
                                   StringRef breakCharacters,
                                   StringRef quoteCharacters);







    static StringArray fromLines (StringRef stringToBreakUp);



    void clear();




    void clearQuick();




    void remove (int index);





    void removeString (StringRef stringToRemove,
                       bool ignoreCase = false);
# 329 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_StringArray.h"
    void removeRange (int startIndex, int numberToRemove);
# 338 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_StringArray.h"
    void removeDuplicates (bool ignoreCase);





    void removeEmptyStrings (bool removeWhitespaceStrings = true);
# 360 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_StringArray.h"
    void move (int currentIndex, int newIndex) noexcept;


    void trim();
# 380 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_StringArray.h"
    void appendNumbersToDuplicates (bool ignoreCaseWhenComparing,
                                    bool appendNumberToFirstInstance,
                                    CharPointer_UTF8 preNumberString = CharPointer_UTF8 (nullptr),
                                    CharPointer_UTF8 postNumberString = CharPointer_UTF8 (nullptr));
# 398 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_StringArray.h"
    String joinIntoString (StringRef separatorString,
                           int startIndex = 0,
                           int numberOfElements = -1) const;





    void sort (bool ignoreCase);





    void sortNatural();
# 421 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_StringArray.h"
    void ensureStorageAllocated (int minNumElements);







    void minimiseStorageOverheads();




    Array<String> strings;

private:

};
# 252 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_StringPairArray.h" 1
# 41 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_StringPairArray.h"
class StringPairArray
{
public:


    StringPairArray (bool ignoreCaseWhenComparingKeys = true);


    StringPairArray (const StringPairArray& other);


    ~StringPairArray();


    StringPairArray& operator= (const StringPairArray& other);






    bool operator== (const StringPairArray& other) const;





    bool operator!= (const StringPairArray& other) const;
# 82 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_StringPairArray.h"
    const String& operator[] (StringRef key) const;





    String getValue (StringRef, const String& defaultReturnValue) const;


    bool containsKey (StringRef key) const noexcept;


    const StringArray& getAllKeys() const noexcept { return keys; }


    const StringArray& getAllValues() const noexcept { return values; }


    inline int size() const noexcept { return keys.size(); };







    void set (const String& key, const String& value);




    void addArray (const StringPairArray& other);



    void clear();




    void remove (StringRef key);




    void remove (int index);




    void setIgnoresCase (bool shouldIgnoreCase);





    String getDescription() const;
# 147 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_StringPairArray.h"
    void minimiseStorageOverheads();


private:

    StringArray keys, values;
    bool ignoreCase;


};
# 253 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_TextDiff.h" 1
# 43 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_TextDiff.h"
class TextDiff
{
public:

    TextDiff (const String& original,
              const String& target);
# 57 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_TextDiff.h"
    String appliedTo (String text) const;


    struct Change
    {
        String insertedText;

        int start;
        int length;



        bool isDeletion() const noexcept;


        String appliedTo (const String& original) const noexcept;
    };




    Array<Change> changes;
};
# 254 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_LocalisedStrings.h" 1
# 78 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_LocalisedStrings.h"
class LocalisedStrings
{
public:






    LocalisedStrings (const String& fileContents, bool ignoreCaseOfKeys);






    LocalisedStrings (const File& fileToLoad, bool ignoreCaseOfKeys);

    LocalisedStrings (const LocalisedStrings&);
    LocalisedStrings& operator= (const LocalisedStrings&);


    ~LocalisedStrings();
# 113 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_LocalisedStrings.h"
    static void setCurrentMappings (LocalisedStrings* newTranslations);






    static LocalisedStrings* getCurrentMappings();
# 131 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_LocalisedStrings.h"
    static String translateWithCurrentMappings (const String& text);
# 142 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_LocalisedStrings.h"
    static String translateWithCurrentMappings (const char* text);





    String translate (const String& text) const;




    String translate (const String& text, const String& resultIfNotFound) const;
# 162 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_LocalisedStrings.h"
    String getLanguageName() const { return languageName; }
# 173 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_LocalisedStrings.h"
    const StringArray& getCountryCodes() const { return countryCodes; }


    const StringPairArray& getMappings() const { return translations; }
# 187 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_LocalisedStrings.h"
    void addStrings (const LocalisedStrings&);





    void setFallback (LocalisedStrings* fallbackStrings);

private:

    String languageName;
    StringArray countryCodes;
    StringPairArray translations;
    ScopedPointer<LocalisedStrings> fallback;
    friend struct ContainerDeletePolicy<LocalisedStrings>;

    void loadFromText (const String&, bool ignoreCase);


};
# 231 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_LocalisedStrings.h"
         String translate (const String& stringLiteral);




         String translate (const char* stringLiteral);




         String translate (CharPointer_UTF8 stringLiteral);




         String translate (const String& stringLiteral, const String& resultIfNotFound);
# 255 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_Base64.h" 1
# 39 "..\\..\\..\\JUCE\\modules\\juce_core/text/juce_Base64.h"
struct Base64
{




    static bool convertToBase64 (OutputStream& base64Result, const void* sourceData, size_t sourceDataSize);





    static bool convertFromBase64 (OutputStream& binaryOutput, StringRef base64TextInput);


    static String toBase64 (const void* sourceData, size_t sourceDataSize);


    static String toBase64 (const String& textToEncode);
};
# 256 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/misc/juce_Result.h" 1
# 63 "..\\..\\..\\JUCE\\modules\\juce_core/misc/juce_Result.h"
class Result
{
public:


    static Result ok() noexcept { return Result(); }





    static Result fail (const String& errorMessage) noexcept;



    bool wasOk() const noexcept;





    bool failed() const noexcept;




    operator bool() const noexcept;




    bool operator!() const noexcept;




    const String& getErrorMessage() const noexcept;


    Result (const Result&);
    Result& operator= (const Result&);


    Result (Result&&) noexcept;
    Result& operator= (Result&&) noexcept;


    bool operator== (const Result& other) const noexcept;
    bool operator!= (const Result& other) const noexcept;

private:
    String errorMessage;



    Result() noexcept;
    explicit Result (const String&) noexcept;


    operator int() const;
    operator void*() const;
};
# 257 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Variant.h" 1
# 48 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Variant.h"
class var
{
public:




    struct NativeFunctionArgs
    {
        NativeFunctionArgs (const var& thisObject, const var* args, int numArgs) noexcept;

        const var& thisObject;
        const var* arguments;
        int numArguments;

        NativeFunctionArgs (const NativeFunctionArgs&) = delete; NativeFunctionArgs& operator= (const NativeFunctionArgs&) = delete;
    };


    using NativeFunction = std::function<var (const NativeFunctionArgs&)>;






    var() noexcept;


    ~var() noexcept;



    static const var null;


    var (const var& valueToCopy);
    var (int value) noexcept;
    var (int64 value) noexcept;
    var (bool value) noexcept;
    var (double value) noexcept;
    var (const char* value);
    var (const wchar_t* value);
    var (const String& value);
    var (const Array<var>& value);
    var (const StringArray& value);
    var (ReferenceCountedObject* object);
    var (NativeFunction method) noexcept;
    var (const void* binaryData, size_t dataSize);
    var (const MemoryBlock& binaryData);

    var& operator= (const var& valueToCopy);
    var& operator= (int value);
    var& operator= (int64 value);
    var& operator= (bool value);
    var& operator= (double value);
    var& operator= (const char* value);
    var& operator= (const wchar_t* value);
    var& operator= (const String& value);
    var& operator= (const MemoryBlock& value);
    var& operator= (const Array<var>& value);
    var& operator= (ReferenceCountedObject* object);
    var& operator= (NativeFunction method);


    var (var&&) noexcept;
    var (String&&);
    var (MemoryBlock&&);
    var (Array<var>&&);
    var& operator= (var&&) noexcept;
    var& operator= (String&&);


    void swapWith (var& other) noexcept;


    static var undefined() noexcept;


    operator int() const noexcept;
    operator int64() const noexcept;
    operator bool() const noexcept;
    operator float() const noexcept;
    operator double() const noexcept;
    operator String() const;
    String toString() const;







    Array<var>* getArray() const noexcept;







    MemoryBlock* getBinaryData() const noexcept;

    ReferenceCountedObject* getObject() const noexcept;
    DynamicObject* getDynamicObject() const noexcept;


    bool isVoid() const noexcept;
    bool isUndefined() const noexcept;
    bool isInt() const noexcept;
    bool isInt64() const noexcept;
    bool isBool() const noexcept;
    bool isDouble() const noexcept;
    bool isString() const noexcept;
    bool isObject() const noexcept;
    bool isArray() const noexcept;
    bool isBinaryData() const noexcept;
    bool isMethod() const noexcept;






    bool equals (const var& other) const noexcept;





    bool equalsWithSameType (const var& other) const noexcept;


    bool hasSameTypeAs (const var& other) const noexcept;





    var clone() const noexcept;





    int size() const;
# 202 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Variant.h"
    const var& operator[] (int arrayIndex) const;
# 211 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Variant.h"
    var& operator[] (int arrayIndex);
# 220 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Variant.h"
    void append (const var& valueToAppend);
# 229 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_Variant.h"
    void insert (int index, const var& value);






    void remove (int index);







    void resize (int numArrayElementsWanted);





    int indexOf (const var& value) const;



    const var& operator[] (const Identifier& propertyName) const;

    const var& operator[] (const char* propertyName) const;


    var getProperty (const Identifier& propertyName, const var& defaultReturnValue) const;


    var call (const Identifier& method) const;

    var call (const Identifier& method, const var& arg1) const;

    var call (const Identifier& method, const var& arg1, const var& arg2) const;

    var call (const Identifier& method, const var& arg1, const var& arg2, const var& arg3);

    var call (const Identifier& method, const var& arg1, const var& arg2, const var& arg3, const var& arg4) const;

    var call (const Identifier& method, const var& arg1, const var& arg2, const var& arg3, const var& arg4, const var& arg5) const;

    var invoke (const Identifier& method, const var* arguments, int numArguments) const;

    NativeFunction getNativeFunction() const;






    void writeToStream (OutputStream& output) const;






    static var readFromStream (InputStream& input);

private:

    class VariantType; friend class VariantType;
    class VariantType_Void; friend class VariantType_Void;
    class VariantType_Undefined; friend class VariantType_Undefined;
    class VariantType_Int; friend class VariantType_Int;
    class VariantType_Int64; friend class VariantType_Int64;
    class VariantType_Double; friend class VariantType_Double;
    class VariantType_Bool; friend class VariantType_Bool;
    class VariantType_String; friend class VariantType_String;
    class VariantType_Object; friend class VariantType_Object;
    class VariantType_Array; friend class VariantType_Array;
    class VariantType_Binary; friend class VariantType_Binary;
    class VariantType_Method; friend class VariantType_Method;

    union ValueUnion
    {
        int intValue;
        int64 int64Value;
        bool boolValue;
        double doubleValue;
        char stringValue [sizeof (String)];
        ReferenceCountedObject* objectValue;
        MemoryBlock* binaryValue;
        NativeFunction* methodValue;
    };

    const VariantType* type;
    ValueUnion value;

    Array<var>* convertToArray();
    var (const VariantType&) noexcept;
};


         bool operator== (const var&, const var&) noexcept;

         bool operator!= (const var&, const var&) noexcept;
         bool operator== (const var&, const String&);
         bool operator!= (const var&, const String&);
         bool operator== (const var&, const char*);
         bool operator!= (const var&, const char*);



template <typename Type>
struct VariantConverter
{
    static Type fromVar (const var& v) { return static_cast<Type> (v); }
    static var toVar (const Type& t) { return t; }
};


template <>
struct VariantConverter<String>
{
    static String fromVar (const var& v) { return v.toString(); }
    static var toVar (const String& s) { return s; }
};
# 258 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_NamedValueSet.h" 1
# 41 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_NamedValueSet.h"
class NamedValueSet
{
public:

    NamedValueSet() noexcept;


    NamedValueSet (const NamedValueSet&);


    NamedValueSet& operator= (const NamedValueSet&);


    NamedValueSet (NamedValueSet&&) noexcept;
    NamedValueSet& operator= (NamedValueSet&&) noexcept;



    ~NamedValueSet() noexcept;

    bool operator== (const NamedValueSet&) const;
    bool operator!= (const NamedValueSet&) const;


    struct NamedValue
    {
        NamedValue() noexcept {}
        NamedValue (const Identifier& n, const var& v) : name (n), value (v) {}
        NamedValue (const NamedValue& other) : name (other.name), value (other.value) {}


        NamedValue (NamedValue&& other) noexcept
        : name (static_cast<Identifier&&> (other.name)),
          value (static_cast<var&&> (other.value))
        {
        }

        NamedValue (Identifier&& n, var&& v) noexcept
        : name (static_cast<Identifier&&> (n)),
          value (static_cast<var&&> (v))
        {
        }

        NamedValue& operator= (NamedValue&& other) noexcept
        {
            name = static_cast<Identifier&&> (other.name);
            value = static_cast<var&&> (other.value);
            return *this;
        }


        bool operator== (const NamedValue& other) const noexcept { return name == other.name && value == other.value; }
        bool operator!= (const NamedValue& other) const noexcept { return ! operator== (other); }

        Identifier name;
        var value;
    };

    NamedValueSet::NamedValue* begin() { return values.begin(); }
    NamedValueSet::NamedValue* end() { return values.end(); }




    int size() const noexcept;


    bool isEmpty() const noexcept;





    const var& operator[] (const Identifier& name) const noexcept;




    var getWithDefault (const Identifier& name, const var& defaultReturnValue) const;





    bool set (const Identifier& name, const var& newValue);






    bool set (const Identifier& name, var&& newValue);



    bool contains (const Identifier& name) const noexcept;





    bool remove (const Identifier& name);




    Identifier getName (int index) const noexcept;







    var* getVarPointer (const Identifier& name) const noexcept;




    const var& getValueAt (int index) const noexcept;




    var* getVarPointerAt (int index) const noexcept;


    int indexOf (const Identifier& name) const noexcept;


    void clear();



    void setFromXmlAttributes (const XmlElement& xml);




    void copyToXmlAttributes (XmlElement& xml) const;

private:

    Array<NamedValue> values;
};
# 259 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_DynamicObject.h" 1
# 46 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_DynamicObject.h"
class DynamicObject : public ReferenceCountedObject
{
public:

    DynamicObject();
    DynamicObject (const DynamicObject&);
    ~DynamicObject();

    typedef ReferenceCountedObjectPtr<DynamicObject> Ptr;





    virtual bool hasProperty (const Identifier& propertyName) const;




    virtual const var& getProperty (const Identifier& propertyName) const;


    virtual void setProperty (const Identifier& propertyName, const var& newValue);


    virtual void removeProperty (const Identifier& propertyName);
# 80 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_DynamicObject.h"
    virtual bool hasMethod (const Identifier& methodName) const;
# 90 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_DynamicObject.h"
    virtual var invokeMethod (Identifier methodName,
                              const var::NativeFunctionArgs& args);







    void setMethod (Identifier methodName, var::NativeFunction function);



    void clear();


    NamedValueSet& getProperties() noexcept { return properties; }


    void cloneAllProperties();







    virtual Ptr clone();







    virtual void writeAsJSON (OutputStream&, int indentLevel, bool allOnOneLine);

private:

    NamedValueSet properties;







};
# 260 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_HashMap.h" 1
# 41 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_HashMap.h"
struct DefaultHashFunctions
{

    int generateHash (const int key, const int upperLimit) const noexcept { return std::abs (key) % upperLimit; }

    int generateHash (const int64 key, const int upperLimit) const noexcept { return std::abs ((int) key) % upperLimit; }

    int generateHash (const String& key, const int upperLimit) const noexcept { return (int) (((uint32) key.hashCode()) % (uint32) upperLimit); }

    int generateHash (const var& key, const int upperLimit) const noexcept { return generateHash (key.toString(), upperLimit); }

    int generateHash (const void* key, const int upperLimit) const noexcept { return (int)(((pointer_sized_uint) key) % ((pointer_sized_uint) upperLimit)); }
};
# 98 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_HashMap.h"
template <typename KeyType,
          typename ValueType,
          class HashFunctionType = DefaultHashFunctions,
          class TypeOfCriticalSectionToUse = DummyCriticalSection>
class HashMap
{
private:
    typedef typename TypeHelpers::ParameterType<KeyType>::type KeyTypeParameter;
    typedef typename TypeHelpers::ParameterType<ValueType>::type ValueTypeParameter;

public:
# 120 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_HashMap.h"
    explicit HashMap (int numberOfSlots = defaultHashTableSize,
                      HashFunctionType hashFunction = HashFunctionType())
       : hashFunctionToUse (hashFunction), totalNumItems (0)
    {
        hashSlots.insertMultiple (0, nullptr, numberOfSlots);
    }


    ~HashMap()
    {
        clear();
    }






    void clear()
    {
        const ScopedLockType sl (getLock());

        for (int i = hashSlots.size(); --i >= 0;)
        {
            HashEntry* h = hashSlots.getUnchecked(i);

            while (h != nullptr)
            {
                const ScopedPointer<HashEntry> deleter (h);
                h = h->nextEntry;
            }

            hashSlots.set (i, nullptr);
        }

        totalNumItems = 0;
    }



    inline int size() const noexcept
    {
        return totalNumItems;
    }





    inline ValueType operator[] (KeyTypeParameter keyToLookFor) const
    {
        const ScopedLockType sl (getLock());

        for (const HashEntry* entry = hashSlots.getUnchecked (generateHashFor (keyToLookFor)); entry != nullptr; entry = entry->nextEntry)
            if (entry->key == keyToLookFor)
                return entry->value;

        return ValueType();
    }



    bool contains (KeyTypeParameter keyToLookFor) const
    {
        const ScopedLockType sl (getLock());

        for (const HashEntry* entry = hashSlots.getUnchecked (generateHashFor (keyToLookFor)); entry != nullptr; entry = entry->nextEntry)
            if (entry->key == keyToLookFor)
                return true;

        return false;
    }


    bool containsValue (ValueTypeParameter valueToLookFor) const
    {
        const ScopedLockType sl (getLock());

        for (int i = getNumSlots(); --i >= 0;)
            for (const HashEntry* entry = hashSlots.getUnchecked(i); entry != nullptr; entry = entry->nextEntry)
                if (entry->value == valueToLookFor)
                    return true;

        return false;
    }






    void set (KeyTypeParameter newKey, ValueTypeParameter newValue)
    {
        const ScopedLockType sl (getLock());
        const int hashIndex = generateHashFor (newKey);

        HashEntry* const firstEntry = hashSlots.getUnchecked (hashIndex);

        for (HashEntry* entry = firstEntry; entry != nullptr; entry = entry->nextEntry)
        {
            if (entry->key == newKey)
            {
                entry->value = newValue;
                return;
            }
        }

        hashSlots.set (hashIndex, new HashEntry (newKey, newValue, firstEntry));
        ++totalNumItems;

        if (totalNumItems > (getNumSlots() * 3) / 2)
            remapTable (getNumSlots() * 2);
    }


    void remove (KeyTypeParameter keyToRemove)
    {
        const ScopedLockType sl (getLock());
        const int hashIndex = generateHashFor (keyToRemove);
        HashEntry* entry = hashSlots.getUnchecked (hashIndex);
        HashEntry* previous = nullptr;

        while (entry != nullptr)
        {
            if (entry->key == keyToRemove)
            {
                const ScopedPointer<HashEntry> deleter (entry);

                entry = entry->nextEntry;

                if (previous != nullptr)
                    previous->nextEntry = entry;
                else
                    hashSlots.set (hashIndex, entry);

                --totalNumItems;
            }
            else
            {
                previous = entry;
                entry = entry->nextEntry;
            }
        }
    }


    void removeValue (ValueTypeParameter valueToRemove)
    {
        const ScopedLockType sl (getLock());

        for (int i = getNumSlots(); --i >= 0;)
        {
            HashEntry* entry = hashSlots.getUnchecked(i);
            HashEntry* previous = nullptr;

            while (entry != nullptr)
            {
                if (entry->value == valueToRemove)
                {
                    const ScopedPointer<HashEntry> deleter (entry);

                    entry = entry->nextEntry;

                    if (previous != nullptr)
                        previous->nextEntry = entry;
                    else
                        hashSlots.set (i, entry);

                    --totalNumItems;
                }
                else
                {
                    previous = entry;
                    entry = entry->nextEntry;
                }
            }
        }
    }





    void remapTable (int newNumberOfSlots)
    {
        HashMap newTable (newNumberOfSlots);

        for (int i = getNumSlots(); --i >= 0;)
            for (const HashEntry* entry = hashSlots.getUnchecked(i); entry != nullptr; entry = entry->nextEntry)
                newTable.set (entry->key, entry->value);

        swapWith (newTable);
    }





    inline int getNumSlots() const noexcept
    {
        return hashSlots.size();
    }



    template <class OtherHashMapType>
    void swapWith (OtherHashMapType& otherHashMap) noexcept
    {
        const ScopedLockType lock1 (getLock());
        const typename OtherHashMapType::ScopedLockType lock2 (otherHashMap.getLock());

        hashSlots.swapWith (otherHashMap.hashSlots);
        std::swap (totalNumItems, otherHashMap.totalNumItems);
    }






    inline const TypeOfCriticalSectionToUse& getLock() const noexcept { return lock; }


    typedef typename TypeOfCriticalSectionToUse::ScopedLockType ScopedLockType;

private:

    class HashEntry
    {
    public:
        HashEntry (KeyTypeParameter k, ValueTypeParameter val, HashEntry* const next)
            : key (k), value (val), nextEntry (next)
        {}

        const KeyType key;
        ValueType value;
        HashEntry* nextEntry;

        HashEntry (const HashEntry&) = delete; HashEntry& operator= (const HashEntry&) = delete;
    };

public:
# 385 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_HashMap.h"
    struct Iterator
    {
        Iterator (const HashMap& hashMapToIterate) noexcept
            : hashMap (hashMapToIterate), entry (nullptr), index (0)
        {}

        Iterator (const Iterator& other) noexcept
            : hashMap (other.hashMap), entry (other.entry), index (other.index)
        {}





        bool next() noexcept
        {
            if (entry != nullptr)
                entry = entry->nextEntry;

            while (entry == nullptr)
            {
                if (index >= hashMap.getNumSlots())
                    return false;

                entry = hashMap.hashSlots.getUnchecked (index++);
            }

            return true;
        }




        KeyType getKey() const
        {
            return entry != nullptr ? entry->key : KeyType();
        }




        ValueType getValue() const
        {
            return entry != nullptr ? entry->value : ValueType();
        }


        void reset() noexcept
        {
            entry = nullptr;
            index = 0;
        }

        Iterator& operator++() noexcept { next(); return *this; }
        ValueType operator*() const { return getValue(); }
        bool operator!= (const Iterator& other) const noexcept { return entry != other.entry || index != other.index; }
        void resetToEnd() noexcept { index = hashMap.getNumSlots(); }

    private:

        const HashMap& hashMap;
        HashEntry* entry;
        int index;


    };


    Iterator begin() const noexcept { Iterator i (*this); i.next(); return i; }


    Iterator end() const noexcept { Iterator i (*this); i.resetToEnd(); return i; }

private:

    enum { defaultHashTableSize = 101 };
    friend struct Iterator;

    HashFunctionType hashFunctionToUse;
    Array<HashEntry*> hashSlots;
    int totalNumItems;
    TypeOfCriticalSectionToUse lock;

    int generateHashFor (KeyTypeParameter key) const
    {
        const int hash = hashFunctionToUse.generateHash (key, getNumSlots());
#pragma warning(push)
# 471 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_HashMap.h"
#pragma warning(disable: 4127)
# 471 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_HashMap.h"
 do { ; } while (false)
# 471 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_HashMap.h"
#pragma warning(pop)
# 471 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_HashMap.h"
;
        return hash;
    }

    HashMap (const HashMap&) = delete; HashMap& operator= (const HashMap&) = delete;
};
# 261 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/time/juce_RelativeTime.h" 1
# 43 "..\\..\\..\\JUCE\\modules\\juce_core/time/juce_RelativeTime.h"
class RelativeTime
{
public:






    explicit RelativeTime (double seconds = 0.0) noexcept;


    RelativeTime (const RelativeTime& other) noexcept;


    RelativeTime& operator= (const RelativeTime& other) noexcept;


    ~RelativeTime() noexcept;





    static RelativeTime milliseconds (int milliseconds) noexcept;




    static RelativeTime milliseconds (int64 milliseconds) noexcept;




    static RelativeTime seconds (double seconds) noexcept;




    static RelativeTime minutes (double numberOfMinutes) noexcept;




    static RelativeTime hours (double numberOfHours) noexcept;




    static RelativeTime days (double numberOfDays) noexcept;




    static RelativeTime weeks (double numberOfWeeks) noexcept;





    int64 inMilliseconds() const noexcept;




    double inSeconds() const noexcept { return numSeconds; }




    double inMinutes() const noexcept;




    double inHours() const noexcept;




    double inDays() const noexcept;




    double inWeeks() const noexcept;
# 145 "..\\..\\..\\JUCE\\modules\\juce_core/time/juce_RelativeTime.h"
    String getDescription (const String& returnValueForZeroTime = "0") const;




    RelativeTime operator+= (RelativeTime timeToAdd) noexcept;

    RelativeTime operator-= (RelativeTime timeToSubtract) noexcept;


    RelativeTime operator+= (double secondsToAdd) noexcept;

    RelativeTime operator-= (double secondsToSubtract) noexcept;

private:

    double numSeconds;
};



bool operator== (RelativeTime t1, RelativeTime t2) noexcept;

bool operator!= (RelativeTime t1, RelativeTime t2) noexcept;

bool operator> (RelativeTime t1, RelativeTime t2) noexcept;

bool operator< (RelativeTime t1, RelativeTime t2) noexcept;

bool operator>= (RelativeTime t1, RelativeTime t2) noexcept;

bool operator<= (RelativeTime t1, RelativeTime t2) noexcept;



RelativeTime operator+ (RelativeTime t1, RelativeTime t2) noexcept;

RelativeTime operator- (RelativeTime t1, RelativeTime t2) noexcept;
# 262 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/time/juce_Time.h" 1
# 43 "..\\..\\..\\JUCE\\modules\\juce_core/time/juce_Time.h"
class Time
{
public:
# 56 "..\\..\\..\\JUCE\\modules\\juce_core/time/juce_Time.h"
    Time() noexcept;
# 66 "..\\..\\..\\JUCE\\modules\\juce_core/time/juce_Time.h"
    explicit Time (int64 millisecondsSinceEpoch) noexcept;
# 80 "..\\..\\..\\JUCE\\modules\\juce_core/time/juce_Time.h"
    Time (int year,
          int month,
          int day,
          int hours,
          int minutes,
          int seconds = 0,
          int milliseconds = 0,
          bool useLocalTime = true) noexcept;


    Time (const Time& other) noexcept;


    ~Time() noexcept;


    Time& operator= (const Time& other) noexcept;
# 106 "..\\..\\..\\JUCE\\modules\\juce_core/time/juce_Time.h"
    static Time __stdcall getCurrentTime() noexcept;






    int64 toMilliseconds() const noexcept { return millisSinceEpoch; }




    int getYear() const noexcept;





    int getMonth() const noexcept;






    String getMonthName (bool threeLetterVersion) const;




    int getDayOfMonth() const noexcept;




    int getDayOfWeek() const noexcept;




    int getDayOfYear() const noexcept;





    String getWeekdayName (bool threeLetterVersion) const;





    int getHours() const noexcept;





    bool isAfternoon() const noexcept;






    int getHoursInAmPmFormat() const noexcept;


    int getMinutes() const noexcept;


    int getSeconds() const noexcept;
# 186 "..\\..\\..\\JUCE\\modules\\juce_core/time/juce_Time.h"
    int getMilliseconds() const noexcept;


    bool isDaylightSavingTime() const noexcept;



    String getTimeZone() const noexcept;


    int getUTCOffsetSeconds() const noexcept;





    String getUTCOffsetString (bool includeDividerCharacters) const;
# 217 "..\\..\\..\\JUCE\\modules\\juce_core/time/juce_Time.h"
    String toString (bool includeDate,
                     bool includeTime,
                     bool includeSeconds = true,
                     bool use24HourClock = false) const noexcept;
# 253 "..\\..\\..\\JUCE\\modules\\juce_core/time/juce_Time.h"
    String formatted (const String& format) const;
# 262 "..\\..\\..\\JUCE\\modules\\juce_core/time/juce_Time.h"
    String toISO8601 (bool includeDividerCharacters) const;


    static Time fromISO8601 (StringRef iso8601) noexcept;



    Time& operator+= (RelativeTime delta) noexcept;

    Time& operator-= (RelativeTime delta) noexcept;







    bool setSystemTimeToThisTime() const;
# 288 "..\\..\\..\\JUCE\\modules\\juce_core/time/juce_Time.h"
    static String getWeekdayName (int dayNumber, bool threeLetterVersion);







    static String getMonthName (int monthNumber, bool threeLetterVersion);
# 308 "..\\..\\..\\JUCE\\modules\\juce_core/time/juce_Time.h"
    static int64 currentTimeMillis() noexcept;
# 322 "..\\..\\..\\JUCE\\modules\\juce_core/time/juce_Time.h"
    static uint32 getMillisecondCounter() noexcept;
# 331 "..\\..\\..\\JUCE\\modules\\juce_core/time/juce_Time.h"
    static double getMillisecondCounterHiRes() noexcept;





    static void waitForMillisecondCounter (uint32 targetTime) noexcept;
# 348 "..\\..\\..\\JUCE\\modules\\juce_core/time/juce_Time.h"
    static uint32 getApproximateMillisecondCounter() noexcept;
# 361 "..\\..\\..\\JUCE\\modules\\juce_core/time/juce_Time.h"
    static int64 getHighResolutionTicks() noexcept;






    static int64 getHighResolutionTicksPerSecond() noexcept;






    static double highResolutionTicksToSeconds (int64 ticks) noexcept;






    static int64 secondsToHighResolutionTicks (double seconds) noexcept;


    static Time getCompilationDate();

private:

    int64 millisSinceEpoch;
};



         Time operator+ (Time time, RelativeTime delta) noexcept;

         Time operator+ (RelativeTime delta, Time time) noexcept;


         Time operator- (Time time, RelativeTime delta) noexcept;

         const RelativeTime operator- (Time time1, Time time2) noexcept;


         bool operator== (Time time1, Time time2) noexcept;

         bool operator!= (Time time1, Time time2) noexcept;

         bool operator< (Time time1, Time time2) noexcept;

         bool operator<= (Time time1, Time time2) noexcept;

         bool operator> (Time time1, Time time2) noexcept;

         bool operator>= (Time time1, Time time2) noexcept;
# 263 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/streams/juce_InputStream.h" 1
# 43 "..\\..\\..\\JUCE\\modules\\juce_core/streams/juce_InputStream.h"
class InputStream
{
public:

    virtual ~InputStream() {}
# 59 "..\\..\\..\\JUCE\\modules\\juce_core/streams/juce_InputStream.h"
    virtual int64 getTotalLength() = 0;





    int64 getNumBytesRemaining();


    virtual bool isExhausted() = 0;
# 85 "..\\..\\..\\JUCE\\modules\\juce_core/streams/juce_InputStream.h"
    virtual int read (void* destBuffer, int maxBytesToRead) = 0;





    virtual char readByte();






    virtual bool readBool();






    virtual short readShort();






    virtual short readShortBigEndian();
# 123 "..\\..\\..\\JUCE\\modules\\juce_core/streams/juce_InputStream.h"
    virtual int readInt();
# 134 "..\\..\\..\\JUCE\\modules\\juce_core/streams/juce_InputStream.h"
    virtual int readIntBigEndian();
# 145 "..\\..\\..\\JUCE\\modules\\juce_core/streams/juce_InputStream.h"
    virtual int64 readInt64();
# 156 "..\\..\\..\\JUCE\\modules\\juce_core/streams/juce_InputStream.h"
    virtual int64 readInt64BigEndian();






    virtual float readFloat();






    virtual float readFloatBigEndian();






    virtual double readDouble();






    virtual double readDoubleBigEndian();






    virtual int readCompressedInt();
# 202 "..\\..\\..\\JUCE\\modules\\juce_core/streams/juce_InputStream.h"
    virtual String readNextLine();
# 211 "..\\..\\..\\JUCE\\modules\\juce_core/streams/juce_InputStream.h"
    virtual String readString();






    virtual String readEntireStreamAsString();
# 228 "..\\..\\..\\JUCE\\modules\\juce_core/streams/juce_InputStream.h"
    virtual size_t readIntoMemoryBlock (MemoryBlock& destBlock,
                                        ssize_t maxNumBytesToRead = -1);





    virtual int64 getPosition() = 0;
# 249 "..\\..\\..\\JUCE\\modules\\juce_core/streams/juce_InputStream.h"
    virtual bool setPosition (int64 newPosition) = 0;







    virtual void skipNextBytes (int64 numBytesToSkip);


protected:

    InputStream() noexcept {}

private:
    InputStream (const InputStream&) = delete; InputStream& operator= (const InputStream&) = delete;
};
# 264 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/streams/juce_OutputStream.h" 1
# 44 "..\\..\\..\\JUCE\\modules\\juce_core/streams/juce_OutputStream.h"
class OutputStream
{
protected:

    OutputStream();

public:





    virtual ~OutputStream();




    virtual void flush() = 0;
# 70 "..\\..\\..\\JUCE\\modules\\juce_core/streams/juce_OutputStream.h"
    virtual bool setPosition (int64 newPosition) = 0;





    virtual int64 getPosition() = 0;
# 89 "..\\..\\..\\JUCE\\modules\\juce_core/streams/juce_OutputStream.h"
    virtual bool write (const void* dataToWrite,
                        size_t numberOfBytes) = 0;






    virtual bool writeByte (char byte);






    virtual bool writeBool (bool boolValue);






    virtual bool writeShort (short value);






    virtual bool writeShortBigEndian (short value);





    virtual bool writeInt (int value);





    virtual bool writeIntBigEndian (int value);





    virtual bool writeInt64 (int64 value);





    virtual bool writeInt64BigEndian (int64 value);






    virtual bool writeFloat (float value);






    virtual bool writeFloatBigEndian (float value);






    virtual bool writeDouble (double value);






    virtual bool writeDoubleBigEndian (double value);




    virtual bool writeRepeatedByte (uint8 byte, size_t numTimesToRepeat);
# 188 "..\\..\\..\\JUCE\\modules\\juce_core/streams/juce_OutputStream.h"
    virtual bool writeCompressedInt (int value);
# 203 "..\\..\\..\\JUCE\\modules\\juce_core/streams/juce_OutputStream.h"
    virtual bool writeString (const String& text);
# 214 "..\\..\\..\\JUCE\\modules\\juce_core/streams/juce_OutputStream.h"
    virtual bool writeText (const String& text,
                            bool asUTF16,
                            bool writeUTF16ByteOrderMark);
# 226 "..\\..\\..\\JUCE\\modules\\juce_core/streams/juce_OutputStream.h"
    virtual int64 writeFromInputStream (InputStream& source, int64 maxNumBytesToWrite);





    void setNewLineString (const String& newLineString);


    const String& getNewLineString() const noexcept { return newLineString; }

private:

    String newLineString;

    OutputStream (const OutputStream&) = delete; OutputStream& operator= (const OutputStream&) = delete;
};



         OutputStream& __stdcall operator<< (OutputStream& stream, int number);


         OutputStream& __stdcall operator<< (OutputStream& stream, int64 number);


         OutputStream& __stdcall operator<< (OutputStream& stream, double number);


         OutputStream& __stdcall operator<< (OutputStream& stream, char character);


         OutputStream& __stdcall operator<< (OutputStream& stream, const char* text);


         OutputStream& __stdcall operator<< (OutputStream& stream, const MemoryBlock& data);


         OutputStream& __stdcall operator<< (OutputStream& stream, const File& fileToRead);


         OutputStream& __stdcall operator<< (OutputStream& stream, InputStream& streamToRead);
# 276 "..\\..\\..\\JUCE\\modules\\juce_core/streams/juce_OutputStream.h"
         OutputStream& __stdcall operator<< (OutputStream& stream, const NewLine&);
# 265 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/streams/juce_BufferedInputStream.h" 1
# 43 "..\\..\\..\\JUCE\\modules\\juce_core/streams/juce_BufferedInputStream.h"
class BufferedInputStream : public InputStream
{
public:
# 54 "..\\..\\..\\JUCE\\modules\\juce_core/streams/juce_BufferedInputStream.h"
    BufferedInputStream (InputStream* sourceStream,
                         int bufferSize,
                         bool deleteSourceWhenDestroyed);







    BufferedInputStream (InputStream& sourceStream, int bufferSize);






    ~BufferedInputStream();



    int64 getTotalLength() override;
    int64 getPosition() override;
    bool setPosition (int64 newPosition) override;
    int read (void* destBuffer, int maxBytesToRead) override;
    String readString() override;
    bool isExhausted() override;


private:

    OptionalScopedPointer<InputStream> source;
    int bufferSize;
    int64 position, lastReadPos, bufferStart, bufferOverlap;
    HeapBlock<char> buffer;
    void ensureBuffered();

    BufferedInputStream (const BufferedInputStream&) = delete; BufferedInputStream& operator= (const BufferedInputStream&) = delete;
};
# 266 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/streams/juce_MemoryInputStream.h" 1
# 42 "..\\..\\..\\JUCE\\modules\\juce_core/streams/juce_MemoryInputStream.h"
class MemoryInputStream : public InputStream
{
public:
# 56 "..\\..\\..\\JUCE\\modules\\juce_core/streams/juce_MemoryInputStream.h"
    MemoryInputStream (const void* sourceData,
                       size_t sourceDataSize,
                       bool keepInternalCopyOfData);
# 69 "..\\..\\..\\JUCE\\modules\\juce_core/streams/juce_MemoryInputStream.h"
    MemoryInputStream (const MemoryBlock& data,
                       bool keepInternalCopyOfData);


    ~MemoryInputStream();


    const void* getData() const noexcept { return data; }


    size_t getDataSize() const noexcept { return dataSize; }


    int64 getPosition() override;
    bool setPosition (int64 pos) override;
    int64 getTotalLength() override;
    bool isExhausted() override;
    int read (void* destBuffer, int maxBytesToRead) override;

private:

    const void* data;
    size_t dataSize, position;
    HeapBlock<char> internalCopy;

    void createInternalCopy();

    MemoryInputStream (const MemoryInputStream&) = delete; MemoryInputStream& operator= (const MemoryInputStream&) = delete;
};
# 267 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/streams/juce_MemoryOutputStream.h" 1
# 42 "..\\..\\..\\JUCE\\modules\\juce_core/streams/juce_MemoryOutputStream.h"
class MemoryOutputStream : public OutputStream
{
public:




    MemoryOutputStream (size_t initialSize = 256);
# 63 "..\\..\\..\\JUCE\\modules\\juce_core/streams/juce_MemoryOutputStream.h"
    MemoryOutputStream (MemoryBlock& memoryBlockToWriteTo,
                        bool appendToExistingBlockContent);






    MemoryOutputStream (void* destBuffer, size_t destBufferSize);




    ~MemoryOutputStream();





    const void* getData() const noexcept;




    size_t getDataSize() const noexcept { return size; }


    void reset() noexcept;




    void preallocate (size_t bytesToPreallocate);


    bool appendUTF8Char (juce_wchar character);


    String toUTF8() const;




    String toString() const;


    MemoryBlock getMemoryBlock() const;






    void flush() override;

    bool write (const void*, size_t) override;
    int64 getPosition() override { return (int64) position; }
    bool setPosition (int64) override;
    int64 writeFromInputStream (InputStream&, int64 maxNumBytesToWrite) override;
    bool writeRepeatedByte (uint8 byte, size_t numTimesToRepeat) override;

private:

    MemoryBlock* const blockToUse;
    MemoryBlock internalBlock;
    void* externalData;
    size_t position, size, availableSize;

    void trimExternalBlockSize();
    char* prepareToWrite (size_t);

    MemoryOutputStream (const MemoryOutputStream&) = delete; MemoryOutputStream& operator= (const MemoryOutputStream&) = delete;
};


OutputStream& __stdcall operator<< (OutputStream& stream, const MemoryOutputStream& streamToRead);
# 268 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/streams/juce_SubregionStream.h" 1
# 41 "..\\..\\..\\JUCE\\modules\\juce_core/streams/juce_SubregionStream.h"
class SubregionStream : public InputStream
{
public:
# 62 "..\\..\\..\\JUCE\\modules\\juce_core/streams/juce_SubregionStream.h"
    SubregionStream (InputStream* sourceStream,
                     int64 startPositionInSourceStream,
                     int64 lengthOfSourceStream,
                     bool deleteSourceWhenDestroyed);






    ~SubregionStream();



    int64 getTotalLength() override;
    int64 getPosition() override;
    bool setPosition (int64 newPosition) override;
    int read (void* destBuffer, int maxBytesToRead) override;
    bool isExhausted() override;

private:

    OptionalScopedPointer<InputStream> source;
    const int64 startPositionInSourceStream, lengthOfSourceStream;

    SubregionStream (const SubregionStream&) = delete; SubregionStream& operator= (const SubregionStream&) = delete;
};
# 269 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/streams/juce_InputSource.h" 1
# 44 "..\\..\\..\\JUCE\\modules\\juce_core/streams/juce_InputSource.h"
class InputSource
{
public:

    InputSource() noexcept {}


    virtual ~InputSource() {}







    virtual InputStream* createInputStream() = 0;







    virtual InputStream* createInputStreamFor (const String& relatedItemPath) = 0;



    virtual int64 hashCode() const = 0;


private:


};
# 270 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_File.h" 1
# 47 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_File.h"
class File
{
public:
# 58 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_File.h"
    File() noexcept {}
# 70 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_File.h"
    File (const String& absolutePath);


    File (const File&);


    ~File() noexcept {}
# 88 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_File.h"
    File& operator= (const String& newAbsolutePath);


    File& operator= (const File& otherFile);


    File (File&&) noexcept;
    File& operator= (File&&) noexcept;
# 104 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_File.h"
    static const File nonexistent;
# 113 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_File.h"
    bool exists() const;







    bool existsAsFile() const;







    bool isDirectory() const;





    int64 getSize() const;






    static String descriptionOfSizeInBytes (int64 bytes);
# 156 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_File.h"
    const String& getFullPathName() const noexcept { return fullPath; }
# 171 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_File.h"
    String getFileName() const;
# 188 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_File.h"
    String getRelativePathFrom (const File& directoryToBeRelativeTo) const;
# 199 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_File.h"
    String getFileExtension() const;
# 212 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_File.h"
    bool hasFileExtension (StringRef extensionToTest) const;
# 224 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_File.h"
    File withFileExtension (StringRef newExtension) const;







    String getFileNameWithoutExtension() const;







    int hashCode() const;






    int64 hashCode64() const;
# 264 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_File.h"
    File getChildFile (StringRef relativeOrAbsolutePath) const;







    File getSiblingFile (StringRef siblingFileName) const;






    File getParentDirectory() const;
# 290 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_File.h"
    bool isAChildOf (const File& potentialParentDirectory) const;
# 310 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_File.h"
    File getNonexistentChildFile (const String& prefix,
                                  const String& suffix,
                                  bool putNumbersInBrackets = true) const;
# 323 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_File.h"
    File getNonexistentSibling (bool putNumbersInBrackets = true) const;



    bool operator== (const File&) const;

    bool operator!= (const File&) const;

    bool operator< (const File&) const;

    bool operator> (const File&) const;
# 343 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_File.h"
    bool hasWriteAccess() const;
# 354 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_File.h"
    bool setReadOnly (bool shouldBeReadOnly,
                      bool applyRecursively = false) const;






    bool setExecutePermission (bool shouldBeExecutable) const;




    bool isHidden() const;







    uint64 getFileIdentifier() const;







    Time getLastModificationTime() const;






    Time getLastAccessTime() const;






    Time getCreationTime() const;







    bool setLastModificationTime (Time newTime) const;







    bool setLastAccessTime (Time newTime) const;







    bool setCreationTime (Time newTime) const;







    String getVersion() const;
# 446 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_File.h"
    Result create() const;
# 457 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_File.h"
    Result createDirectory() const;
# 468 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_File.h"
    bool deleteFile() const;
# 479 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_File.h"
    bool deleteRecursively() const;







    bool moveToTrash() const;
# 503 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_File.h"
    bool moveFileTo (const File& targetLocation) const;
# 513 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_File.h"
    bool copyFileTo (const File& targetLocation) const;
# 525 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_File.h"
    bool replaceFileIn (const File& targetLocation) const;
# 540 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_File.h"
    bool copyDirectoryTo (const File& newDirectory) const;




    enum TypesOfFileToFind
    {
        findDirectories = 1,
        findFiles = 2,
        findFilesAndDirectories = 3,
        ignoreHiddenFiles = 4
    };
# 570 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_File.h"
    int findChildFiles (Array<File>& results,
                        int whatToLookFor,
                        bool searchRecursively,
                        const String& wildCardPattern = "*") const;
# 591 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_File.h"
    int getNumberOfChildFiles (int whatToLookFor,
                               const String& wildCardPattern = "*") const;




    bool containsSubDirectories() const;
# 606 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_File.h"
    FileInputStream* createInputStream() const;
# 618 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_File.h"
    FileOutputStream* createOutputStream (size_t bufferSize = 0x8000) const;
# 631 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_File.h"
    bool loadFileAsData (MemoryBlock& result) const;
# 640 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_File.h"
    String loadFileAsString() const;




    void readLines (StringArray& destLines) const;
# 654 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_File.h"
    bool appendData (const void* dataToAppend,
                     size_t numberOfBytes) const;
# 671 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_File.h"
    bool replaceWithData (const void* dataToWrite,
                          size_t numberOfBytes) const;
# 686 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_File.h"
    bool appendText (const String& textToAppend,
                     bool asUnicode = false,
                     bool writeUnicodeHeaderBytes = false) const;
# 706 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_File.h"
    bool replaceWithText (const String& textToWrite,
                          bool asUnicode = false,
                          bool writeUnicodeHeaderBytes = false) const;




    bool hasIdenticalContentTo (const File& other) const;
# 722 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_File.h"
    static void findFileSystemRoots (Array<File>& results);




    String getVolumeLabel() const;




    int getVolumeSerialNumber() const;






    int64 getBytesFreeOnVolume() const;






    int64 getVolumeTotalSize() const;


    bool isOnCDRomDrive() const;






    bool isOnHardDisk() const;





    bool isOnRemovableDrive() const;
# 776 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_File.h"
    bool startAsProcess (const String& parameters = String()) const;




    void revealToUser() const;




    enum SpecialLocationType
    {

        userHomeDirectory,





        userDocumentsDirectory,


        userDesktopDirectory,


        userMusicDirectory,


        userMoviesDirectory,


        userPicturesDirectory,






        userApplicationDataDirectory,
# 824 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_File.h"
        commonApplicationDataDirectory,






        commonDocumentsDirectory,




        tempDirectory,
# 849 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_File.h"
        currentExecutableFile,
# 859 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_File.h"
        currentApplicationFile,






        invokedExecutableFile,


        hostApplicationPath,



        windowsSystemDirectory,






        globalApplicationsDirectory
    };






    static File __stdcall getSpecialLocation (const SpecialLocationType type);






    static File createTempFile (StringRef fileNameEnding);





    static File getCurrentWorkingDirectory();
# 910 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_File.h"
    bool setAsCurrentWorkingDirectory() const;





    static const juce_wchar separator;




    static const String separatorString;
# 935 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_File.h"
    static String createLegalFileName (const String& fileNameToFix);
# 944 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_File.h"
    static String createLegalPathName (const String& pathNameToFix);


    static bool areFileNamesCaseSensitive();


    static bool isAbsolutePath (StringRef path);






    static File createFileWithoutCheckingPath (const String& absolutePath) noexcept;


    static String addTrailingSeparator (const String& path);



    bool createSymbolicLink (const File& linkFileToCreate, bool overwriteExisting) const;


    bool isSymbolicLink() const;




    File getLinkedTarget() const;



    bool createShortcut (const String& description, const File& linkFileToCreate) const;


    bool isShortcut() const;
# 997 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_File.h"
    struct NaturalFileComparator
    {
        NaturalFileComparator (bool shouldPutFoldersFirst) noexcept : foldersFirst (shouldPutFoldersFirst) {}

        int compareElements (const File& firstFile, const File& secondFile) const
        {
            if (foldersFirst && (firstFile.isDirectory() != secondFile.isDirectory()))
                return firstFile.isDirectory() ? -1 : 1;




            return firstFile.getFullPathName().compareNatural (secondFile.getFullPathName(), false);

        }

        bool foldersFirst;
    };

private:

    String fullPath;

    static String parseAbsolutePath (const String&);
    String getPathUpToLastSlash() const;

    Result createDirectoryInternal (const String&) const;
    bool copyInternal (const File&) const;
    bool moveInternal (const File&) const;
    bool replaceInternal (const File&) const;
    bool setFileTimesInternal (int64 m, int64 a, int64 c) const;
    void getFileTimesInternal (int64& m, int64& a, int64& c) const;
    bool setFileReadOnlyInternal (bool) const;
    bool setFileExecutableInternal (bool) const;
};
# 271 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_DirectoryIterator.h" 1
# 48 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_DirectoryIterator.h"
class DirectoryIterator
{
public:
# 74 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_DirectoryIterator.h"
    DirectoryIterator (const File& directory,
                       bool isRecursive,
                       const String& wildCard = "*",
                       int whatToLookFor = File::findFiles);


    ~DirectoryIterator();






    bool next();
# 101 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_DirectoryIterator.h"
    bool next (bool* isDirectory,
               bool* isHidden,
               int64* fileSize,
               Time* modTime,
               Time* creationTime,
               bool* isReadOnly);





    const File& getFile() const;






    float getEstimatedProgress() const;

private:

    class NativeIterator
    {
    public:
        NativeIterator (const File& directory, const String& wildCard);
        ~NativeIterator();

        bool next (String& filenameFound,
                   bool* isDirectory, bool* isHidden, int64* fileSize,
                   Time* modTime, Time* creationTime, bool* isReadOnly);

        class Pimpl;

    private:
        friend class DirectoryIterator;
        friend struct ContainerDeletePolicy<Pimpl>;
        ScopedPointer<Pimpl> pimpl;

        NativeIterator (const NativeIterator&) = delete; NativeIterator& operator= (const NativeIterator&) = delete;
    };

    friend struct ContainerDeletePolicy<NativeIterator::Pimpl>;
    StringArray wildCards;
    NativeIterator fileFinder;
    String wildCard, path;
    int index;
    mutable int totalNumFiles;
    const int whatToLookFor;
    const bool isRecursive;
    bool hasBeenAdvanced;
    ScopedPointer<DirectoryIterator> subIterator;
    File currentFile;

    static StringArray parseWildcards (const String& pattern);
    static bool fileMatches (const StringArray& wildCards, const String& filename);

    DirectoryIterator (const DirectoryIterator&) = delete; DirectoryIterator& operator= (const DirectoryIterator&) = delete;
};
# 272 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_FileInputStream.h" 1
# 41 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_FileInputStream.h"
class FileInputStream : public InputStream
{
public:







    explicit FileInputStream (const File& fileToRead);


    ~FileInputStream();



    const File& getFile() const noexcept { return file; }





    const Result& getStatus() const noexcept { return status; }




    bool failedToOpen() const noexcept { return status.failed(); }




    bool openedOk() const noexcept { return status.wasOk(); }



    int64 getTotalLength() override;
    int read (void*, int) override;
    bool isExhausted() override;
    int64 getPosition() override;
    bool setPosition (int64) override;

private:

    const File file;
    void* fileHandle;
    int64 currentPosition;
    Result status;

    void openHandle();
    size_t readInternal (void*, size_t);

    FileInputStream (const FileInputStream&) = delete; FileInputStream& operator= (const FileInputStream&) = delete;
};
# 273 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_FileOutputStream.h" 1
# 41 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_FileOutputStream.h"
class FileOutputStream : public OutputStream
{
public:
# 62 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_FileOutputStream.h"
    FileOutputStream (const File& fileToWriteTo,
                      size_t bufferSizeToUse = 16384);


    ~FileOutputStream();




    const File& getFile() const { return file; }





    const Result& getStatus() const noexcept { return status; }




    bool failedToOpen() const noexcept { return status.failed(); }




    bool openedOk() const noexcept { return status.wasOk(); }





    Result truncate();


    void flush() override;
    int64 getPosition() override;
    bool setPosition (int64) override;
    bool write (const void*, size_t) override;
    bool writeRepeatedByte (uint8 byte, size_t numTimesToRepeat) override;


private:

    File file;
    void* fileHandle;
    Result status;
    int64 currentPosition;
    size_t bufferSize, bytesInBuffer;
    HeapBlock<char> buffer;

    void openHandle();
    void closeHandle();
    void flushInternal();
    bool flushBuffer();
    int64 setPositionInternal (int64);
    ssize_t writeInternal (const void*, size_t);

    FileOutputStream (const FileOutputStream&) = delete; FileOutputStream& operator= (const FileOutputStream&) = delete;
};
# 274 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_FileSearchPath.h" 1
# 41 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_FileSearchPath.h"
class FileSearchPath
{
public:


    FileSearchPath();
# 55 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_FileSearchPath.h"
    FileSearchPath (const String& path);


    FileSearchPath (const FileSearchPath&);


    FileSearchPath& operator= (const FileSearchPath&);


    ~FileSearchPath();






    FileSearchPath& operator= (const String& path);





    int getNumPaths() const;





    File operator[] (int index) const;


    String toString() const;







    void add (const File& directoryToAdd,
              int insertIndex = -1);





    bool addIfNotAlreadyThere (const File& directoryToAdd);


    void remove (int indexToRemove);




    void addPath (const FileSearchPath&);
# 118 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_FileSearchPath.h"
    void removeRedundantPaths();


    void removeNonExistentPaths();
# 137 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_FileSearchPath.h"
    int findChildFiles (Array<File>& results,
                        int whatToLookFor,
                        bool searchRecursively,
                        const String& wildCardPattern = "*") const;
# 158 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_FileSearchPath.h"
    bool isFileInPath (const File& fileToCheck,
                       bool checkRecursively) const;

private:

    StringArray directories;

    void init (const String&);


};
# 275 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_MemoryMappedFile.h" 1
# 39 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_MemoryMappedFile.h"
class MemoryMappedFile
{
public:

    enum AccessMode
    {
        readOnly,
        readWrite

    };
# 67 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_MemoryMappedFile.h"
    MemoryMappedFile (const File& file, AccessMode mode, bool exclusive = false);
# 85 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_MemoryMappedFile.h"
    MemoryMappedFile (const File& file,
                      const Range<int64>& fileRange,
                      AccessMode mode,
                      bool exclusive = false);


    ~MemoryMappedFile();




    void* getData() const noexcept { return address; }




    size_t getSize() const noexcept { return (size_t) range.getLength(); }


    Range<int64> getRange() const noexcept { return range; }

private:

    void* address;
    Range<int64> range;


    void* fileHandle;




    void openInternal (const File&, AccessMode, bool);

    MemoryMappedFile (const MemoryMappedFile&) = delete; MemoryMappedFile& operator= (const MemoryMappedFile&) = delete;
};
# 276 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_TemporaryFile.h" 1
# 73 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_TemporaryFile.h"
class TemporaryFile
{
public:

    enum OptionFlags
    {
        useHiddenFile = 1,

        putNumbersInBrackets = 2


    };
# 94 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_TemporaryFile.h"
    TemporaryFile (const String& suffix = String(),
                   int optionFlags = 0);
# 112 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_TemporaryFile.h"
    TemporaryFile (const File& targetFile,
                   int optionFlags = 0);
# 122 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_TemporaryFile.h"
    TemporaryFile (const File& targetFile,
                   const File& temporaryFile);







    ~TemporaryFile();



    const File& getFile() const noexcept { return temporaryFile; }


    const File& getTargetFile() const noexcept { return targetFile; }
# 156 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_TemporaryFile.h"
    bool overwriteTargetFileWithTemporary() const;




    bool deleteTemporaryFile() const;


private:

    const File temporaryFile, targetFile;

    TemporaryFile (const TemporaryFile&) = delete; TemporaryFile& operator= (const TemporaryFile&) = delete;
};
# 277 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_FileFilter.h" 1
# 44 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_FileFilter.h"
class FileFilter
{
public:





    FileFilter (const String& filterDescription);


    virtual ~FileFilter();



    const String& getDescription() const noexcept;





    virtual bool isFileSuitable (const File& file) const = 0;




    virtual bool isDirectorySuitable (const File& file) const = 0;


protected:

    String description;
};
# 278 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_WildcardFileFilter.h" 1
# 44 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_WildcardFileFilter.h"
class WildcardFileFilter : public FileFilter
{
public:
# 62 "..\\..\\..\\JUCE\\modules\\juce_core/files/juce_WildcardFileFilter.h"
    WildcardFileFilter (const String& fileWildcardPatterns,
                        const String& directoryWildcardPatterns,
                        const String& description);


    ~WildcardFileFilter();



    bool isFileSuitable (const File& file) const override;


    bool isDirectorySuitable (const File& file) const override;

private:

    StringArray fileWildcards, directoryWildcards;


};
# 279 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/streams/juce_FileInputSource.h" 1
# 41 "..\\..\\..\\JUCE\\modules\\juce_core/streams/juce_FileInputSource.h"
class FileInputSource : public InputSource
{
public:






    FileInputSource (const File& file, bool useFileTimeInHashGeneration = false);


    ~FileInputSource();

    InputStream* createInputStream();
    InputStream* createInputStreamFor (const String& relatedItemPath);
    int64 hashCode() const;

private:

    const File file;
    bool useFileTimeInHashGeneration;

    FileInputSource (const FileInputSource&) = delete; FileInputSource& operator= (const FileInputSource&) = delete;
};
# 280 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/logging/juce_FileLogger.h" 1
# 41 "..\\..\\..\\JUCE\\modules\\juce_core/logging/juce_FileLogger.h"
class FileLogger : public Logger
{
public:
# 61 "..\\..\\..\\JUCE\\modules\\juce_core/logging/juce_FileLogger.h"
    FileLogger (const File& fileToWriteTo,
                const String& welcomeMessage,
                const int64 maxInitialFileSizeBytes = 128 * 1024);


    ~FileLogger();



    const File& getLogFile() const noexcept { return logFile; }
# 84 "..\\..\\..\\JUCE\\modules\\juce_core/logging/juce_FileLogger.h"
    static FileLogger* createDefaultAppLogger (const String& logFileSubDirectoryName,
                                               const String& logFileName,
                                               const String& welcomeMessage,
                                               const int64 maxInitialFileSizeBytes = 128 * 1024);
# 105 "..\\..\\..\\JUCE\\modules\\juce_core/logging/juce_FileLogger.h"
    static FileLogger* createDateStampedLogger (const String& logFileSubDirectoryName,
                                                const String& logFileNameRoot,
                                                const String& logFileNameSuffix,
                                                const String& welcomeMessage);
# 121 "..\\..\\..\\JUCE\\modules\\juce_core/logging/juce_FileLogger.h"
    static File getSystemLogFileFolder();


    void logMessage (const String&);





    static void trimFileSize (const File& file, int64 maxFileSize);

private:

    File logFile;
    CriticalSection logLock;

    FileLogger (const FileLogger&) = delete; FileLogger& operator= (const FileLogger&) = delete;
};
# 281 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/javascript/juce_JSON.h" 1
# 45 "..\\..\\..\\JUCE\\modules\\juce_core/javascript/juce_JSON.h"
class JSON
{
public:
# 63 "..\\..\\..\\JUCE\\modules\\juce_core/javascript/juce_JSON.h"
    static Result parse (const String& text, var& parsedResult);
# 74 "..\\..\\..\\JUCE\\modules\\juce_core/javascript/juce_JSON.h"
    static var parse (const String& text);
# 85 "..\\..\\..\\JUCE\\modules\\juce_core/javascript/juce_JSON.h"
    static var parse (const File& file);
# 96 "..\\..\\..\\JUCE\\modules\\juce_core/javascript/juce_JSON.h"
    static var parse (InputStream& input);







    static String toString (const var& objectToFormat,
                            bool allOnOneLine = false);






    static var fromString (StringRef);






    static void writeToStream (OutputStream& output,
                               const var& objectToFormat,
                               bool allOnOneLine = false);


    static String escapeString (StringRef);





    static Result parseQuotedString (String::CharPointerType& text, var& result);

private:

    JSON() = delete;
};
# 282 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/javascript/juce_Javascript.h" 1
# 49 "..\\..\\..\\JUCE\\modules\\juce_core/javascript/juce_Javascript.h"
class JavascriptEngine
{
public:




    JavascriptEngine();


    ~JavascriptEngine();







    Result execute (const String& javascriptCode);
# 76 "..\\..\\..\\JUCE\\modules\\juce_core/javascript/juce_Javascript.h"
    var evaluate (const String& javascriptCode,
                  Result* errorMessage = nullptr);





    var callFunction (const Identifier& function,
                      const var::NativeFunctionArgs& args,
                      Result* errorMessage = nullptr);






    void registerNativeObject (const Identifier& objectName, DynamicObject* object);






    RelativeTime maximumExecutionTime;


    const NamedValueSet& getRootObjectProperties() const noexcept;

private:
    struct RootObject;
    const ReferenceCountedObjectPtr<RootObject> root;
    void prepareTimeout() const noexcept;

    JavascriptEngine (const JavascriptEngine&) = delete; JavascriptEngine& operator= (const JavascriptEngine&) = delete;
};
# 283 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_BigInteger.h" 1
# 45 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_BigInteger.h"
class BigInteger
{
public:


    BigInteger();




    BigInteger (uint32 value);





    BigInteger (int32 value);





    BigInteger (int64 value);


    BigInteger (const BigInteger&);


    BigInteger (BigInteger&&) noexcept;
    BigInteger& operator= (BigInteger&&) noexcept;



    ~BigInteger();



    BigInteger& operator= (const BigInteger&);


    void swapWith (BigInteger&) noexcept;





    bool operator[] (int bit) const noexcept;


    bool isZero() const noexcept;


    bool isOne() const noexcept;




    int toInteger() const noexcept;




    int64 toInt64() const noexcept;



    void clear() noexcept;


    void clearBit (int bitNumber) noexcept;


    void setBit (int bitNumber);


    void setBit (int bitNumber, bool shouldBeSet);







    void setRange (int startBit, int numBits, bool shouldBeSet);


    void insertBit (int bitNumber, bool shouldBeSet);






    BigInteger getBitRange (int startBit, int numBits) const;
# 147 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_BigInteger.h"
    uint32 getBitRangeAsInt (int startBit, int numBits) const noexcept;






    void setBitRangeAsInt (int startBit, int numBits, uint32 valueToSet);






    void shiftBits (int howManyBitsLeft, int startBit);


    int countNumberOfSetBits() const noexcept;






    int findNextSetBit (int startIndex) const noexcept;






    int findNextClearBit (int startIndex) const noexcept;




    int getHighestBit() const noexcept;





    bool isNegative() const noexcept;




    void setNegative (bool shouldBeNegative) noexcept;




    void negate() noexcept;




    BigInteger& operator+= (const BigInteger&);
    BigInteger& operator-= (const BigInteger&);
    BigInteger& operator*= (const BigInteger&);
    BigInteger& operator/= (const BigInteger&);
    BigInteger& operator|= (const BigInteger&);
    BigInteger& operator&= (const BigInteger&);
    BigInteger& operator^= (const BigInteger&);
    BigInteger& operator%= (const BigInteger&);
    BigInteger& operator<<= (int numBitsToShift);
    BigInteger& operator>>= (int numBitsToShift);
    BigInteger& operator++();
    BigInteger& operator--();
    BigInteger operator++ (int);
    BigInteger operator-- (int);

    BigInteger operator-() const;
    BigInteger operator+ (const BigInteger&) const;
    BigInteger operator- (const BigInteger&) const;
    BigInteger operator* (const BigInteger&) const;
    BigInteger operator/ (const BigInteger&) const;
    BigInteger operator| (const BigInteger&) const;
    BigInteger operator& (const BigInteger&) const;
    BigInteger operator^ (const BigInteger&) const;
    BigInteger operator% (const BigInteger&) const;
    BigInteger operator<< (int numBitsToShift) const;
    BigInteger operator>> (int numBitsToShift) const;

    bool operator== (const BigInteger&) const noexcept;
    bool operator!= (const BigInteger&) const noexcept;
    bool operator< (const BigInteger&) const noexcept;
    bool operator<= (const BigInteger&) const noexcept;
    bool operator> (const BigInteger&) const noexcept;
    bool operator>= (const BigInteger&) const noexcept;
# 246 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_BigInteger.h"
    int compare (const BigInteger& other) const noexcept;
# 255 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_BigInteger.h"
    int compareAbsolute (const BigInteger& other) const noexcept;







    void divideBy (const BigInteger& divisor, BigInteger& remainder);


    BigInteger findGreatestCommonDivisor (BigInteger other) const;




    void exponentModulo (const BigInteger& exponent, const BigInteger& modulus);




    void inverseModulo (const BigInteger& modulus);






    void montgomeryMultiplication (const BigInteger& other, const BigInteger& modulus,
                                   const BigInteger& modulusp, int k);





    void extendedEuclidean (const BigInteger& a, const BigInteger& b,
                            BigInteger& xOut, BigInteger& yOut);
# 300 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_BigInteger.h"
    String toString (int base, int minimumNumCharacters = 1) const;






    void parseString (StringRef text, int base);
# 317 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_BigInteger.h"
    MemoryBlock toMemoryBlock() const;
# 326 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_BigInteger.h"
    void loadFromMemoryBlock (const MemoryBlock& data);

private:

    enum { numPreallocatedInts = 4 };
    HeapBlock<uint32> heapAllocation;
    uint32 preallocated[numPreallocatedInts];
    size_t allocatedSize;
    int highestBit;
    bool negative;

    uint32* getValues() const noexcept;
    uint32* ensureSize (size_t);
    void shiftLeft (int bits, int startBit);
    void shiftRight (int bits, int startBit);


};


OutputStream& __stdcall operator<< (OutputStream& stream, const BigInteger& value);




 typedef BigInteger BitArray;
# 284 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_Expression.h" 1
# 50 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_Expression.h"
class Expression
{
public:


    Expression();


    ~Expression();


    Expression (const Expression&);


    Expression& operator= (const Expression&);


    Expression (Expression&&) noexcept;
    Expression& operator= (Expression&&) noexcept;



    explicit Expression (double constant);




    Expression (const String& stringToParse, String& parseError);


    String toString() const;


    Expression operator+ (const Expression&) const;

    Expression operator- (const Expression&) const;

    Expression operator* (const Expression&) const;

    Expression operator/ (const Expression&) const;

    Expression operator-() const;


    static Expression symbol (const String& symbol);


    static Expression function (const String& functionName, const Array<Expression>& parameters);
# 108 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_Expression.h"
    static Expression parse (String::CharPointerType& stringToParse, String& parseError);





    class Scope
    {
    public:
        Scope();
        virtual ~Scope();


        virtual String getScopeUID() const;







        virtual Expression getSymbolValue (const String& symbol) const;





        virtual double evaluateFunction (const String& functionName,
                                         const double* parameters, int numParameters) const;





        class Visitor
        {
        public:
            virtual ~Visitor() {}
            virtual void visit (const Scope&) = 0;
        };
# 156 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_Expression.h"
        virtual void visitRelativeScope (const String& scopeName, Visitor& visitor) const;
    };







    double evaluate() const;






    double evaluate (const Scope& scope) const;




    double evaluate (const Scope& scope, String& evaluationError) const;
# 188 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_Expression.h"
    Expression adjustedToGiveNewResult (double targetValue, const Scope& scope) const;


    struct Symbol
    {
        Symbol (const String& scopeUID, const String& symbolName);
        bool operator== (const Symbol&) const noexcept;
        bool operator!= (const Symbol&) const noexcept;

        String scopeUID;
        String symbolName;
    };


    Expression withRenamedSymbol (const Symbol& oldSymbol, const String& newName, const Scope& scope) const;
# 212 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_Expression.h"
    bool referencesSymbol (const Symbol& symbol, const Scope& scope) const;


    bool usesAnySymbols() const;


    void findReferencedSymbols (Array<Symbol>& results, const Scope& scope) const;





    enum Type
    {
        constantType,
        functionType,
        operatorType,
        symbolType
    };


    Type getType() const noexcept;


    String getSymbolOrFunction() const;




    int getNumInputs() const;




    Expression getInput (int index) const;

private:

    class Term;
    struct Helpers;
    friend class Term;
    friend struct Helpers;
    friend struct ContainerDeletePolicy<Term>;
    friend class ReferenceCountedObjectPtr<Term>;
    ReferenceCountedObjectPtr<Term> term;

    explicit Expression (Term*);
};
# 285 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_Random.h" 1
# 41 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_Random.h"
class Random
{
public:
# 53 "..\\..\\..\\JUCE\\modules\\juce_core/maths/juce_Random.h"
    explicit Random (int64 seedValue) noexcept;




    Random();


    ~Random() noexcept;




    int nextInt() noexcept;





    int nextInt (int maxValue) noexcept;




    int nextInt (Range<int> range) noexcept;




    int64 nextInt64() noexcept;




    float nextFloat() noexcept;




    double nextDouble() noexcept;


    bool nextBool() noexcept;




    BigInteger nextLargeNumber (const BigInteger& maximumValue);


    void fillBitsRandomly (void* bufferToFill, size_t sizeInBytes);


    void fillBitsRandomly (BigInteger& arrayToChange, int startBit, int numBits);



    void setSeed (int64 newSeed) noexcept;


    int64 getSeed() const noexcept { return seed; }





    void combineSeed (int64 seedValue) noexcept;







    void setSeedRandomly();







    static Random& getSystemRandom() noexcept;

private:

    int64 seed;


};
# 286 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/misc/juce_RuntimePermissions.h" 1
# 70 "..\\..\\..\\JUCE\\modules\\juce_core/misc/juce_RuntimePermissions.h"
class RuntimePermissions
{
public:

    enum PermissionID
    {




        recordAudio = 1,





        bluetoothMidi = 2,
    };




    typedef std::function<void (bool)> Callback;
# 116 "..\\..\\..\\JUCE\\modules\\juce_core/misc/juce_RuntimePermissions.h"
    static void request (PermissionID permission, Callback callback);




    static bool isRequired (PermissionID permission);







    static bool isGranted (PermissionID permission);
};
# 287 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/misc/juce_Uuid.h" 1
# 45 "..\\..\\..\\JUCE\\modules\\juce_core/misc/juce_Uuid.h"
class Uuid
{
public:


    Uuid();


    ~Uuid() noexcept;


    Uuid (const Uuid&) noexcept;


    Uuid& operator= (const Uuid&) noexcept;



    bool isNull() const noexcept;


    static Uuid null() noexcept;

    bool operator== (const Uuid&) const noexcept;
    bool operator!= (const Uuid&) const noexcept;
# 79 "..\\..\\..\\JUCE\\modules\\juce_core/misc/juce_Uuid.h"
    String toString() const;




    String toDashedString() const;




    Uuid (const String& uuidString);




    Uuid& operator= (const String& uuidString);
# 103 "..\\..\\..\\JUCE\\modules\\juce_core/misc/juce_Uuid.h"
    const uint8* getRawData() const noexcept { return uuid; }




    Uuid (const uint8* rawData) noexcept;


    Uuid& operator= (const uint8* rawData) noexcept;


private:

    uint8 uuid[16];
    String getHexRegion (int, int) const;


};
# 288 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/misc/juce_WindowsRegistry.h" 1
# 40 "..\\..\\..\\JUCE\\modules\\juce_core/misc/juce_WindowsRegistry.h"
class WindowsRegistry
{
public:



    enum WoW64Mode
    {


        WoW64_Default = 0,


        WoW64_64bit = 0x100,


        WoW64_32bit = 0x200
    };






    static String __stdcall getValue (const String& regValuePath,
                                          const String& defaultValue = String(),
                                          WoW64Mode mode = WoW64_Default);






    static uint32 __stdcall getBinaryValue (const String& regValuePath, MemoryBlock& resultData, WoW64Mode mode = WoW64_Default);




    static bool __stdcall setValue (const String& regValuePath, const String& value, WoW64Mode mode = WoW64_Default);




    static bool __stdcall setValue (const String& regValuePath, uint32 value, WoW64Mode mode = WoW64_Default);




    static bool __stdcall setValue (const String& regValuePath, uint64 value, WoW64Mode mode = WoW64_Default);




    static bool __stdcall setValue (const String& regValuePath, const MemoryBlock& value, WoW64Mode mode = WoW64_Default);


    static bool __stdcall valueExists (const String& regValuePath, WoW64Mode mode = WoW64_Default);


    static bool __stdcall keyExists (const String& regValuePath, WoW64Mode mode = WoW64_Default);


    static void __stdcall deleteValue (const String& regValuePath, WoW64Mode mode = WoW64_Default);


    static void __stdcall deleteKey (const String& regKeyPath, WoW64Mode mode = WoW64_Default);
# 124 "..\\..\\..\\JUCE\\modules\\juce_core/misc/juce_WindowsRegistry.h"
    static bool __stdcall registerFileAssociation (const String& fileExtension,
                                                       const String& symbolicDescription,
                                                       const String& fullDescription,
                                                       const File& targetExecutable,
                                                       int iconResourceNumber,
                                                       bool registerForCurrentUserOnly,
                                                       WoW64Mode mode = WoW64_Default);


    __declspec(deprecated) static String getValueWow64 (const String&, const String& defaultValue = String());
    __declspec(deprecated) static bool valueExistsWow64 (const String&);
    __declspec(deprecated) static bool keyExistsWow64 (const String&);

private:
    WindowsRegistry() = delete;
    WindowsRegistry (const WindowsRegistry&) = delete; WindowsRegistry& operator= (const WindowsRegistry&) = delete;
};
# 289 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/system/juce_SystemStats.h" 1
# 39 "..\\..\\..\\JUCE\\modules\\juce_core/system/juce_SystemStats.h"
class SystemStats
{
public:




    static String getJUCEVersion();



    enum OperatingSystemType
    {
        UnknownOS = 0,

        MacOSX = 0x0100,

        Windows = 0x0200,

        Linux = 0x0400,
        Android = 0x0800,
        iOS = 0x1000,

        MacOSX_10_4 = MacOSX | 4,
        MacOSX_10_5 = MacOSX | 5,
        MacOSX_10_6 = MacOSX | 6,
        MacOSX_10_7 = MacOSX | 7,
        MacOSX_10_8 = MacOSX | 8,
        MacOSX_10_9 = MacOSX | 9,
        MacOSX_10_10 = MacOSX | 10,
        MacOSX_10_11 = MacOSX | 11,
        MacOSX_10_12 = MacOSX | 12,

        Win2000 = Windows | 1,
        WinXP = Windows | 2,
        WinVista = Windows | 3,
        Windows7 = Windows | 4,
        Windows8_0 = Windows | 5,
        Windows8_1 = Windows | 6,
        Windows10 = Windows | 7
    };






    static OperatingSystemType getOperatingSystemType();






    static String getOperatingSystemName();


    static bool isOperatingSystem64Bit();




    static String getEnvironmentVariable (const String& name, const String& defaultValue);





    static String getLogonName();





    static String getFullUserName();


    static String getComputerName();




    static String getUserLanguage();




    static String getUserRegion();






    static String getDisplayLanguage();





    static String getDeviceDescription();





    static int getNumCpus() noexcept;





    static int getCpuSpeedInMegaherz();




    static String getCpuVendor();

    static bool hasMMX() noexcept;
    static bool has3DNow() noexcept;
    static bool hasSSE() noexcept;
    static bool hasSSE2() noexcept;
    static bool hasSSE3() noexcept;
    static bool hasSSSE3() noexcept;
    static bool hasSSE41() noexcept;
    static bool hasSSE42() noexcept;
    static bool hasAVX() noexcept;
    static bool hasAVX2() noexcept;






    static int getMemorySizeInMegabytes();




    static int getPageSize();






    static String getStackBacktrace();


    typedef void (*CrashHandlerFunction)();







    static void setApplicationCrashHandler (CrashHandlerFunction);





    static bool isRunningInAppExtensionSandbox() noexcept;

private:

    SystemStats();

    SystemStats (const SystemStats&) = delete; SystemStats& operator= (const SystemStats&) = delete;
};
# 290 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_ChildProcess.h" 1
# 42 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_ChildProcess.h"
class ChildProcess
{
public:




    ChildProcess();




    ~ChildProcess();


    enum StreamFlags
    {
        wantStdOut = 1,
        wantStdErr = 2
    };
# 72 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_ChildProcess.h"
    bool start (const String& command, int streamFlags = wantStdOut | wantStdErr);
# 83 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_ChildProcess.h"
    bool start (const StringArray& arguments, int streamFlags = wantStdOut | wantStdErr);


    bool isRunning() const;





    int readProcessOutput (void* destBuffer, int numBytesToRead);




    String readAllProcessOutput();


    bool waitForProcessToFinish (int timeoutMs) const;


    uint32 getExitCode() const;





    bool kill();

private:

    class ActiveProcess;
    friend struct ContainerDeletePolicy<ActiveProcess>;
    ScopedPointer<ActiveProcess> activeProcess;

    ChildProcess (const ChildProcess&) = delete; ChildProcess& operator= (const ChildProcess&) = delete;
};
# 291 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_DynamicLibrary.h" 1
# 41 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_DynamicLibrary.h"
class DynamicLibrary
{
public:



    DynamicLibrary() noexcept : handle (nullptr) {}



    DynamicLibrary (const String& name) : handle (nullptr) { open (name); }




    ~DynamicLibrary() { close(); }
# 65 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_DynamicLibrary.h"
    bool open (const String& name);


    void close();




    void* getFunction (const String& functionName) noexcept;




    void* getNativeHandle() const noexcept { return handle; }

private:
    void* handle;

    DynamicLibrary (const DynamicLibrary&) = delete; DynamicLibrary& operator= (const DynamicLibrary&) = delete;
};
# 292 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_HighResolutionTimer.h" 1
# 48 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_HighResolutionTimer.h"
class HighResolutionTimer
{
protected:



    HighResolutionTimer();

public:

    virtual ~HighResolutionTimer();
# 69 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_HighResolutionTimer.h"
    virtual void hiResTimerCallback() = 0;
# 81 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_HighResolutionTimer.h"
    void startTimer (int intervalInMilliseconds);







    void stopTimer();




    bool isTimerRunning() const noexcept;




    int getTimerInterval() const noexcept;

private:
    struct Pimpl;
    friend struct Pimpl;
    friend struct ContainerDeletePolicy<Pimpl>;
    ScopedPointer<Pimpl> pimpl;

    HighResolutionTimer (const HighResolutionTimer&) = delete; HighResolutionTimer& operator= (const HighResolutionTimer&) = delete;
};
# 293 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_InterProcessLock.h" 1
# 41 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_InterProcessLock.h"
class InterProcessLock
{
public:




    explicit InterProcessLock (const String& name);




    ~InterProcessLock();
# 64 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_InterProcessLock.h"
    bool enter (int timeOutMillisecs = -1);


    void exit();
# 78 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_InterProcessLock.h"
    class ScopedLockType
    {
    public:
# 95 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_InterProcessLock.h"
        explicit ScopedLockType (InterProcessLock& l) : ipLock (l) { lockWasSuccessful = l.enter(); }
# 104 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_InterProcessLock.h"
        inline ~ScopedLockType() { ipLock.exit(); }


        bool isLocked() const noexcept { return lockWasSuccessful; }

    private:

        InterProcessLock& ipLock;
        bool lockWasSuccessful;

        ScopedLockType (const ScopedLockType&) = delete; ScopedLockType& operator= (const ScopedLockType&) = delete;
    };

private:

    class Pimpl;
    friend struct ContainerDeletePolicy<Pimpl>;
    ScopedPointer<Pimpl> pimpl;

    CriticalSection lock;
    String name;

    InterProcessLock (const InterProcessLock&) = delete; InterProcessLock& operator= (const InterProcessLock&) = delete;
};
# 294 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_Process.h" 1
# 43 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_Process.h"
class Process
{
public:

    enum ProcessPriority
    {
        LowPriority = 0,
        NormalPriority = 1,
        HighPriority = 2,
        RealtimePriority = 3
    };






    static void __stdcall setPriority (const ProcessPriority priority);
# 70 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_Process.h"
    static void __stdcall terminate();





    static bool __stdcall isForegroundProcess();




    static void __stdcall makeForegroundProcess();


    static void __stdcall hide();







    static void __stdcall raisePrivilege();






    static void __stdcall lowerPrivilege();



    static bool __stdcall isRunningUnderDebugger() noexcept;




    static bool __stdcall openDocument (const String& documentURL, const String& parameters);


    static bool __stdcall openEmailWithAttachments (const String& targetEmailAddress,
                                                        const String& emailSubject,
                                                        const String& bodyText,
                                                        const StringArray& filesToAttach);
# 131 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_Process.h"
    static void* __stdcall getCurrentModuleInstanceHandle() noexcept;
# 140 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_Process.h"
    static void __stdcall setCurrentModuleInstanceHandle (void* newHandle) noexcept;
# 158 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_Process.h"
private:
    Process();
    Process (const Process&) = delete; Process& operator= (const Process&) = delete;
};
# 295 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_SpinLock.h" 1
# 48 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_SpinLock.h"
class SpinLock
{
public:
    inline SpinLock() noexcept {}
    inline ~SpinLock() noexcept {}
# 63 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_SpinLock.h"
    void enter() const noexcept;


    inline bool tryEnter() const noexcept
    {
        return lock.compareAndSetBool (1, 0);
    }


    inline void exit() const noexcept
    {
#pragma warning(push)
# 74 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_SpinLock.h"
#pragma warning(disable: 4127)
# 74 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_SpinLock.h"
 do { ; } while (false)
# 74 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_SpinLock.h"
#pragma warning(pop)
# 74 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_SpinLock.h"
;
        lock = 0;
    }



    typedef GenericScopedLock <SpinLock> ScopedLockType;


    typedef GenericScopedUnlock <SpinLock> ScopedUnlockType;

private:

    mutable Atomic<int> lock;

    SpinLock (const SpinLock&) = delete; SpinLock& operator= (const SpinLock&) = delete;
};
# 296 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_WaitableEvent.h" 1
# 43 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_WaitableEvent.h"
class WaitableEvent
{
public:
# 55 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_WaitableEvent.h"
    explicit WaitableEvent (bool manualReset = false) noexcept;






    ~WaitableEvent() noexcept;
# 79 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_WaitableEvent.h"
    bool wait (int timeOutMilliseconds = -1) const noexcept;
# 97 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_WaitableEvent.h"
    void signal() const noexcept;





    void reset() const noexcept;


private:


    void* handle;






    WaitableEvent (const WaitableEvent&) = delete; WaitableEvent& operator= (const WaitableEvent&) = delete;
};
# 297 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_Thread.h" 1
# 49 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_Thread.h"
class Thread
{
public:
# 65 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_Thread.h"
    explicit Thread (const String& threadName, size_t threadStackSize = 0);
# 74 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_Thread.h"
    virtual ~Thread();
# 85 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_Thread.h"
    virtual void run() = 0;
# 97 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_Thread.h"
    void startThread();
# 106 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_Thread.h"
    void startThread (int priority);
# 128 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_Thread.h"
    bool stopThread (int timeOutMilliseconds);



    bool isThreadRunning() const;
# 146 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_Thread.h"
    void signalThreadShouldExit();
# 155 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_Thread.h"
    bool threadShouldExit() const { return shouldExit; }







    static bool currentThreadShouldExit();
# 173 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_Thread.h"
    bool waitForThreadToExit (int timeOutMilliseconds) const;
# 182 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_Thread.h"
    bool setPriority (int priority);
# 191 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_Thread.h"
    static bool setCurrentThreadPriority (int priority);
# 201 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_Thread.h"
    void setAffinityMask (uint32 affinityMask);





    static void __stdcall setCurrentThreadAffinityMask (uint32 affinityMask);



    static void __stdcall sleep (int milliseconds);


    static void __stdcall yield();
# 226 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_Thread.h"
    bool wait (int timeOutMilliseconds) const;







    void notify() const;





    typedef void* ThreadID;
# 249 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_Thread.h"
    static ThreadID __stdcall getCurrentThreadId();






    static Thread* __stdcall getCurrentThread();
# 267 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_Thread.h"
    ThreadID getThreadId() const noexcept { return threadId; }





    const String& getThreadName() const { return threadName; }




    static void __stdcall setCurrentThreadName (const String& newThreadName);


private:

    const String threadName;
    void* volatile threadHandle;
    ThreadID threadId;
    CriticalSection startStopLock;
    WaitableEvent startSuspensionEvent, defaultEvent;
    int threadPriority;
    size_t threadStackSize;
    uint32 affinityMask;
    bool volatile shouldExit;


    friend void juce_threadEntryPoint (void*);


    void launchThread();
    void closeThreadHandle();
    void killThread();
    void threadEntryPoint();
    static bool setThreadPriority (void*, int);

    Thread (const Thread&) = delete; Thread& operator= (const Thread&) = delete;
};
# 298 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_ThreadLocalValue.h" 1
# 59 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_ThreadLocalValue.h"
template <typename Type>
class ThreadLocalValue
{
public:

    ThreadLocalValue() noexcept
    {
    }




    ~ThreadLocalValue()
    {
# 81 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_ThreadLocalValue.h"
    }






    Type& operator*() const noexcept { return get(); }






    operator Type*() const noexcept { return &get(); }






    Type* operator->() const noexcept { return &get(); }


    ThreadLocalValue& operator= (const Type& newValue) { get() = newValue; return *this; }






    Type& get() const noexcept
    {
# 152 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_ThreadLocalValue.h"
        static __declspec(thread) Type object;
        return object;

    }




    void releaseCurrentThreadStorage()
    {
# 174 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_ThreadLocalValue.h"
    }

private:
# 196 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_ThreadLocalValue.h"
    ThreadLocalValue (const ThreadLocalValue&) = delete; ThreadLocalValue& operator= (const ThreadLocalValue&) = delete;
};
# 299 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_ThreadPool.h" 1
# 34 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_ThreadPool.h"
class ThreadPool;
class ThreadPoolThread;
# 52 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_ThreadPool.h"
class ThreadPoolJob
{
public:




    explicit ThreadPoolJob (const String& name);


    virtual ~ThreadPoolJob();





    String getJobName() const;




    void setJobName (const String& newName);




    enum JobStatus
    {
        jobHasFinished = 0,


        jobNeedsRunningAgain

    };
# 101 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_ThreadPool.h"
    virtual JobStatus runJob() = 0;




    bool isRunning() const noexcept { return isActive; }
# 115 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_ThreadPool.h"
    bool shouldExit() const noexcept { return shouldStop; }






    void signalJobShouldExit();





    static ThreadPoolJob* getCurrentThreadPoolJob();


private:
    friend class ThreadPool;
    friend class ThreadPoolThread;
    String jobName;
    ThreadPool* pool;
    bool shouldStop, isActive, shouldBeDeleted;

    ThreadPoolJob (const ThreadPoolJob&) = delete; ThreadPoolJob& operator= (const ThreadPoolJob&) = delete;
};
# 151 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_ThreadPool.h"
class ThreadPool
{
public:
# 164 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_ThreadPool.h"
    ThreadPool (int numberOfThreads, size_t threadStackSize = 0);







    ThreadPool();







    ~ThreadPool();






    class JobSelector
    {
    public:
        virtual ~JobSelector() {}






        virtual bool isJobSuitable (ThreadPoolJob* job) = 0;
    };
# 216 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_ThreadPool.h"
    void addJob (ThreadPoolJob* job,
                 bool deleteJobWhenFinished);
# 236 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_ThreadPool.h"
    bool removeJob (ThreadPoolJob* job,
                    bool interruptIfRunning,
                    int timeOutMilliseconds);
# 251 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_ThreadPool.h"
    bool removeAllJobs (bool interruptRunningJobs,
                        int timeOutMilliseconds,
                        JobSelector* selectedJobsToRemove = nullptr);


    int getNumJobs() const;


    int getNumThreads() const;






    ThreadPoolJob* getJob (int index) const;





    bool contains (const ThreadPoolJob* job) const;



    bool isJobRunning (const ThreadPoolJob* job) const;
# 286 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_ThreadPool.h"
    bool waitForJobToFinish (const ThreadPoolJob* job,
                             int timeOutMilliseconds) const;




    StringArray getNamesOfAllJobs (bool onlyReturnActiveJobs) const;






    bool setThreadPriorities (int newPriority);


private:

    Array <ThreadPoolJob*> jobs;

    class ThreadPoolThread;
    friend class ThreadPoolJob;
    friend class ThreadPoolThread;
    friend struct ContainerDeletePolicy<ThreadPoolThread>;
    OwnedArray<ThreadPoolThread> threads;

    CriticalSection lock;
    WaitableEvent jobFinishedSignal;

    bool runNextJob (ThreadPoolThread&);
    ThreadPoolJob* pickNextJobToRun();
    void addToDeleteList (OwnedArray<ThreadPoolJob>&, ThreadPoolJob*) const;
    void createThreads (int numThreads, size_t threadStackSize = 0);
    void stopThreads();



    void removeAllJobs (bool, int, bool);

    ThreadPool (const ThreadPool&) = delete; ThreadPool& operator= (const ThreadPool&) = delete;
};
# 300 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_TimeSliceThread.h" 1
# 34 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_TimeSliceThread.h"
class TimeSliceThread;
# 49 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_TimeSliceThread.h"
class TimeSliceClient
{
public:

    virtual ~TimeSliceClient() {}
# 70 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_TimeSliceThread.h"
    virtual int useTimeSlice() = 0;


private:
    friend class TimeSliceThread;
    Time nextCallTime;
};
# 86 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_TimeSliceThread.h"
class TimeSliceThread : public Thread
{
public:







    explicit TimeSliceThread (const String& threadName);
# 105 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_TimeSliceThread.h"
    ~TimeSliceThread();







    void addTimeSliceClient (TimeSliceClient* client, int millisecondsBeforeStarting = 0);






    void removeTimeSliceClient (TimeSliceClient* client);





    void moveToFrontOfQueue (TimeSliceClient* client);


    int getNumClients() const;


    TimeSliceClient* getClient (int index) const;



    void run() override;



private:
    CriticalSection callbackLock, listLock;
    Array <TimeSliceClient*> clients;
    TimeSliceClient* clientBeingCalled;

    TimeSliceClient* getNextClient (int index) const;

    TimeSliceThread (const TimeSliceThread&) = delete; TimeSliceThread& operator= (const TimeSliceThread&) = delete;
};
# 301 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_ReadWriteLock.h" 1
# 54 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_ReadWriteLock.h"
class ReadWriteLock
{
public:




    ReadWriteLock() noexcept;




    ~ReadWriteLock() noexcept;
# 76 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_ReadWriteLock.h"
    void enterRead() const noexcept;
# 86 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_ReadWriteLock.h"
    bool tryEnterRead() const noexcept;
# 98 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_ReadWriteLock.h"
    void exitRead() const noexcept;
# 108 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_ReadWriteLock.h"
    void enterWrite() const noexcept;
# 118 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_ReadWriteLock.h"
    bool tryEnterWrite() const noexcept;
# 130 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_ReadWriteLock.h"
    void exitWrite() const noexcept;


private:

    SpinLock accessLock;
    WaitableEvent waitEvent;
    mutable int numWaitingWriters, numWriters;
    mutable Thread::ThreadID writerThreadId;

    struct ThreadRecursionCount
    {
        Thread::ThreadID threadID;
        int count;
    };

    mutable Array <ThreadRecursionCount> readerThreads;

    bool tryEnterWriteInternal (Thread::ThreadID) const noexcept;

    ReadWriteLock (const ReadWriteLock&) = delete; ReadWriteLock& operator= (const ReadWriteLock&) = delete;
};
# 302 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_ScopedReadLock.h" 1
# 58 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_ScopedReadLock.h"
class ScopedReadLock
{
public:
# 72 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_ScopedReadLock.h"
    inline explicit ScopedReadLock (const ReadWriteLock& lock) noexcept : lock_ (lock) { lock.enterRead(); }
# 81 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_ScopedReadLock.h"
    inline ~ScopedReadLock() noexcept { lock_.exitRead(); }


private:

    const ReadWriteLock& lock_;

    ScopedReadLock (const ScopedReadLock&) = delete; ScopedReadLock& operator= (const ScopedReadLock&) = delete;
};
# 303 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_ScopedWriteLock.h" 1
# 58 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_ScopedWriteLock.h"
class ScopedWriteLock
{
public:
# 72 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_ScopedWriteLock.h"
    inline explicit ScopedWriteLock (const ReadWriteLock& lock) noexcept : lock_ (lock) { lock.enterWrite(); }
# 81 "..\\..\\..\\JUCE\\modules\\juce_core/threads/juce_ScopedWriteLock.h"
    inline ~ScopedWriteLock() noexcept { lock_.exitWrite(); }


private:

    const ReadWriteLock& lock_;

    ScopedWriteLock (const ScopedWriteLock&) = delete; ScopedWriteLock& operator= (const ScopedWriteLock&) = delete;
};
# 304 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_IPAddress.h" 1
# 39 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_IPAddress.h"
class IPAddress
{
public:


    static void findAllAddresses (Array<IPAddress>& results);



    IPAddress() noexcept;


    explicit IPAddress (const uint8 bytes[4]) noexcept;


    IPAddress (uint8 address1, uint8 address2, uint8 address3, uint8 address4) noexcept;




    explicit IPAddress (uint32 asNativeEndian32Bit) noexcept;


    explicit IPAddress (const String& address);


    String toString() const;


    static IPAddress any() noexcept;


    static IPAddress broadcast() noexcept;


    static IPAddress local() noexcept;

    bool operator== (const IPAddress& other) const noexcept;
    bool operator!= (const IPAddress& other) const noexcept;


    uint8 address[4];
};
# 305 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_MACAddress.h" 1
# 39 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_MACAddress.h"
class MACAddress
{
public:


    static void findAllAddresses (Array<MACAddress>& results);



    MACAddress() noexcept;


    MACAddress (const MACAddress&) noexcept;


    MACAddress& operator= (const MACAddress&) noexcept;


    explicit MACAddress (const uint8 bytes[6]) noexcept;





    explicit MACAddress (StringRef address);


    const uint8* getBytes() const noexcept { return address; }


    String toString() const;


    String toString (StringRef separator) const;






    int64 toInt64() const noexcept;


    bool isNull() const noexcept;

    bool operator== (const MACAddress&) const noexcept;
    bool operator!= (const MACAddress&) const noexcept;


private:
    uint8 address[6];
};
# 306 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_NamedPipe.h" 1
# 43 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_NamedPipe.h"
class NamedPipe
{
public:


    NamedPipe();


    ~NamedPipe();





    bool openExisting (const String& pipeName);






    bool createNewPipe (const String& pipeName, bool mustNotExist = false);


    void close();


    bool isOpen() const;


    String getName() const;
# 88 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_NamedPipe.h"
    int read (void* destBuffer, int maxBytesToRead, int timeOutMilliseconds);




    int write (const void* sourceBuffer, int numBytesToWrite, int timeOutMilliseconds);

private:

    class Pimpl;
    ScopedPointer<Pimpl> pimpl;
    String currentPipeName;
    ReadWriteLock lock;

    bool openInternal (const String& pipeName, bool createPipe, bool mustNotExist);

    NamedPipe (const NamedPipe&) = delete; NamedPipe& operator= (const NamedPipe&) = delete;
};
# 307 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_Socket.h" 1
# 44 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_Socket.h"
class StreamingSocket
{
public:
# 57 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_Socket.h"
    StreamingSocket();


    ~StreamingSocket();







    bool bindToPort (int localPortNumber);
# 80 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_Socket.h"
    bool bindToPort (int localPortNumber, const String& localAddress);






    int getBoundPort() const noexcept;
# 97 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_Socket.h"
    bool connect (const String& remoteHostname,
                  int remotePortNumber,
                  int timeOutMillisecs = 3000);


    bool isConnected() const noexcept { return connected; }


    void close();


    const String& getHostName() const noexcept { return hostName; }


    int getPort() const noexcept { return portNumber; }


    bool isLocal() const noexcept;


    int getRawSocketHandle() const noexcept { return handle; }
# 131 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_Socket.h"
    int waitUntilReady (bool readyForReading,
                        int timeoutMsecs) const;
# 144 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_Socket.h"
    int read (void* destBuffer, int maxBytesToRead,
              bool blockUntilSpecifiedAmountHasArrived);
# 154 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_Socket.h"
    int write (const void* sourceBuffer, int numBytesToWrite);
# 170 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_Socket.h"
    bool createListener (int portNumber, const String& localHostName = String());
# 181 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_Socket.h"
    StreamingSocket* waitForNextConnection() const;

private:

    String hostName;
    int volatile portNumber, handle;
    bool connected, isListener;
    mutable CriticalSection readLock;

    StreamingSocket (const String& hostname, int portNumber, int handle);

    StreamingSocket (const StreamingSocket&) = delete; StreamingSocket& operator= (const StreamingSocket&) = delete;
};
# 205 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_Socket.h"
class DatagramSocket
{
public:
# 218 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_Socket.h"
    DatagramSocket (bool enableBroadcasting = false);



    ~DatagramSocket();
# 233 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_Socket.h"
    bool bindToPort (int localPortNumber);
# 245 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_Socket.h"
    bool bindToPort (int localPortNumber, const String& localAddress);







    int getBoundPort() const noexcept;


    int getRawSocketHandle() const noexcept { return handle; }
# 270 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_Socket.h"
    int waitUntilReady (bool readyForReading,
                        int timeoutMsecs) const;
# 283 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_Socket.h"
    int read (void* destBuffer, int maxBytesToRead,
              bool blockUntilSpecifiedAmountHasArrived);
# 297 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_Socket.h"
    int read (void* destBuffer, int maxBytesToRead,
              bool blockUntilSpecifiedAmountHasArrived,
              String& senderIPAddress, int& senderPortNumber);
# 308 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_Socket.h"
    int write (const String& remoteHostname, int remotePortNumber,
               const void* sourceBuffer, int numBytesToWrite);
# 323 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_Socket.h"
    void shutdown();






    bool joinMulticast (const String& multicastIPAddress);





    bool leaveMulticast (const String& multicastIPAddress);
# 347 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_Socket.h"
    bool setEnablePortReuse (bool enabled);

private:

    int handle;
    bool isBound;
    String lastBindAddress, lastServerHost;
    int lastServerPort;
    void* lastServerAddress;
    mutable CriticalSection readLock;

    DatagramSocket (const DatagramSocket&) = delete; DatagramSocket& operator= (const DatagramSocket&) = delete;
};
# 308 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_URL.h" 1
# 34 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_URL.h"
class WebInputStream;







class URL
{
public:


    URL();






    URL (const String& url);


    URL (const URL& other);


    ~URL();


    URL& operator= (const URL& other);





    bool operator== (const URL&) const;
    bool operator!= (const URL&) const;
# 79 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_URL.h"
    String toString (bool includeGetParameters) const;


    bool isEmpty() const noexcept;


    bool isWellFormed() const;





    String getDomain() const;





    String getSubPath() const;






    String getScheme() const;




    int getPort() const;







    URL withNewDomainAndPath (const String& newFullPath) const;







    URL withNewSubPath (const String& newPath) const;
# 138 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_URL.h"
    URL getChildURL (const String& subPath) const;
# 151 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_URL.h"
    URL withParameter (const String& parameterName,
                       const String& parameterValue) const;





    URL withParameters (const StringPairArray& parametersToAdd) const;
# 171 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_URL.h"
    URL withFileToUpload (const String& parameterName,
                          const File& fileToUpload,
                          const String& mimeType) const;
# 184 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_URL.h"
    URL withDataToUpload (const String& parameterName,
                          const String& filename,
                          const MemoryBlock& fileContentToUpload,
                          const String& mimeType) const;
# 199 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_URL.h"
    const StringArray& getParameterNames() const noexcept { return parameterNames; }
# 213 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_URL.h"
    const StringArray& getParameterValues() const noexcept { return parameterValues; }
# 227 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_URL.h"
    URL withPOSTData (const String& postData) const;
# 241 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_URL.h"
    URL withPOSTData (const MemoryBlock& postData) const;


    String getPostData() const noexcept { return postData.toString(); }


    const MemoryBlock& getPostDataAsMemoryBlock() const noexcept { return postData; }






    bool launchInDefaultBrowser() const;






    static bool isProbablyAWebsiteURL (const String& possibleURL);





    static bool isProbablyAnEmailAddress (const String& possibleEmailAddress);







    typedef bool (OpenStreamProgressCallback) (void* context, int bytesSent, int totalBytes);
# 317 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_URL.h"
    WebInputStream* createInputStream (bool doPostLikeRequest,
                                       OpenStreamProgressCallback* progressCallback = nullptr,
                                       void* progressCallbackContext = nullptr,
                                       String extraHeaders = String(),
                                       int connectionTimeOutMs = 0,
                                       StringPairArray* responseHeaders = nullptr,
                                       int* statusCode = nullptr,
                                       int numRedirectsToFollow = 5,
                                       String httpRequestCmd = String()) const;






    class DownloadTask
    {
    public:
        struct Listener
        {
            virtual ~Listener();



            virtual void finished (DownloadTask* task, bool success) = 0;




            virtual void progress (DownloadTask* task, int64 bytesDownloaded, int64 totalLength);
        };




        virtual ~DownloadTask();



        inline int64 getTotalLength() const { return contentLength; }


        inline int64 getLengthDownloaded() const { return downloaded; }


        inline bool isFinished() const { return finished; }






        inline int statusCode() const { return httpCode; }


        inline bool hadError() const { return error; }

    protected:
        int64 contentLength, downloaded;
        bool finished, error;
        int httpCode;

        DownloadTask ();

    private:
        friend class URL;

        static DownloadTask* createFallbackDownloader (const URL&, const File&, const String&, Listener*);

    public:




    private:
        DownloadTask (const DownloadTask&) = delete; DownloadTask& operator= (const DownloadTask&) = delete;
    };
# 405 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_URL.h"
    DownloadTask* downloadToFile (const File& targetLocation,
                                  String extraHeaders = String(),
                                  DownloadTask::Listener* listener = nullptr);
# 423 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_URL.h"
    bool readEntireBinaryStream (MemoryBlock& destData,
                                 bool usePostCommand = false) const;
# 440 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_URL.h"
    String readEntireTextStream (bool usePostCommand = false) const;
# 458 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_URL.h"
    XmlElement* readEntireXmlStream (bool usePostCommand = false) const;
# 479 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_URL.h"
    static String addEscapeChars (const String& stringToAddEscapeCharsTo,
                                  bool isParameter,
                                  bool roundBracketsAreLegal = true);
# 492 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_URL.h"
    static String removeEscapeChars (const String& stringToRemoveEscapeCharsFrom);





    static URL createWithoutParsing (const String& url);

private:

    friend class WebInputStream;

    String url;
    MemoryBlock postData;
    StringArray parameterNames, parameterValues;

    struct Upload : public ReferenceCountedObject
    {
        Upload (const String&, const String&, const String&, const File&, MemoryBlock*);
        String parameterName, filename, mimeType;
        File file;
        ScopedPointer<MemoryBlock> data;

        Upload (const Upload&) = delete; Upload& operator= (const Upload&) = delete;
    };

    friend struct ContainerDeletePolicy<Upload>;
    ReferenceCountedArray<Upload> filesToUpload;

    URL (const String&, int);
    void addParameter (const String&, const String&);
    void createHeadersAndPostData (String&, MemoryBlock&) const;
    URL withUpload (Upload*) const;


};
# 309 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_WebInputStream.h" 1
# 38 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_WebInputStream.h"
class WebInputStream : public InputStream
{
 public:
    class Listener
    {
    public:
        virtual ~Listener() {}

        virtual bool postDataSendProgress (WebInputStream& , int , int ) { return true; }
    };
# 56 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_WebInputStream.h"
    WebInputStream (const URL& url, const bool usePost);

    ~WebInputStream();
# 69 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_WebInputStream.h"
    WebInputStream& withExtraHeaders (const String& extraHeaders);
# 81 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_WebInputStream.h"
    WebInputStream& withCustomRequestCommand (const String& customRequestCommand);
# 90 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_WebInputStream.h"
    WebInputStream& withConnectionTimeout (int timeoutInMs);
# 100 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_WebInputStream.h"
    WebInputStream& withNumRedirectsToFollow (int numRedirects);


    StringPairArray getRequestHeaders() const;
# 114 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_WebInputStream.h"
    StringPairArray getResponseHeaders();
# 125 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_WebInputStream.h"
    int getStatusCode();
# 145 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_WebInputStream.h"
    bool connect (Listener* listener);


    bool isError() const;


    void cancel();
# 166 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_WebInputStream.h"
    int64 getTotalLength() override;
# 183 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_WebInputStream.h"
    int read (void* destBuffer, int maxBytesToRead) override;


    bool isExhausted() override;




    int64 getPosition() override;
# 206 "..\\..\\..\\JUCE\\modules\\juce_core/network/juce_WebInputStream.h"
    bool setPosition (int64 wantedPos) override;

 private:
    static void createHeadersAndPostData (const URL&, String&, MemoryBlock&);
    static StringPairArray parseHttpHeaders (const String& headerData);

    class Pimpl;
    friend class Pimpl;

    Pimpl* const pimpl;
    bool hasCalledConnect;

    WebInputStream (const WebInputStream&) = delete; WebInputStream& operator= (const WebInputStream&) = delete;
};
# 310 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/time/juce_PerformanceCounter.h" 1
# 56 "..\\..\\..\\JUCE\\modules\\juce_core/time/juce_PerformanceCounter.h"
class PerformanceCounter
{
public:
# 68 "..\\..\\..\\JUCE\\modules\\juce_core/time/juce_PerformanceCounter.h"
    PerformanceCounter (const String& counterName,
                        int runsPerPrintout = 100,
                        const File& loggingFile = File());


    ~PerformanceCounter();





    void start() noexcept;
# 88 "..\\..\\..\\JUCE\\modules\\juce_core/time/juce_PerformanceCounter.h"
    bool stop();







    void printStatistics();


    struct Statistics
    {
        Statistics() noexcept;

        void clear() noexcept;
        String toString() const;

        void addResult (double elapsed) noexcept;

        String name;
        double averageSeconds;
        double maximumSeconds;
        double minimumSeconds;
        double totalSeconds;
        int64 numRuns;
    };


    Statistics getStatisticsAndReset();

private:

    Statistics stats;
    int64 runsPerPrint, startTime;
    File outputFile;

    PerformanceCounter (const PerformanceCounter&) = delete; PerformanceCounter& operator= (const PerformanceCounter&) = delete;
};
# 311 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/unit_tests/juce_UnitTest.h" 1
# 34 "..\\..\\..\\JUCE\\modules\\juce_core/unit_tests/juce_UnitTest.h"
class UnitTestRunner;
# 75 "..\\..\\..\\JUCE\\modules\\juce_core/unit_tests/juce_UnitTest.h"
class UnitTest
{
public:


    explicit UnitTest (const String& name);


    virtual ~UnitTest();


    const String& getName() const noexcept { return name; }





    void performTest (UnitTestRunner* runner);


    static Array<UnitTest*>& getAllTests();





    virtual void initialise();




    virtual void shutdown();






    virtual void runTest() = 0;






    void beginTest (const String& testName);
# 141 "..\\..\\..\\JUCE\\modules\\juce_core/unit_tests/juce_UnitTest.h"
    void expect (bool testResult, const String& failureMessage = String());





    template <class ValueType>
    void expectEquals (ValueType actual, ValueType expected, String failureMessage = String())
    {
        bool result = actual == expected;
        expectResultAndPrint (actual, expected, result, "", failureMessage);
    }




    template <class ValueType>
    void expectNotEquals (ValueType value, ValueType valueToCompareTo, String failureMessage = String())
    {
        bool result = value != valueToCompareTo;
        expectResultAndPrint (value, valueToCompareTo, result, "unequal to", failureMessage);
    }




    template <class ValueType>
    void expectGreaterThan (ValueType value, ValueType valueToCompareTo, String failureMessage = String())
    {
        bool result = value > valueToCompareTo;
        expectResultAndPrint (value, valueToCompareTo, result, "greater than", failureMessage);
    }




    template <class ValueType>
    void expectLessThan (ValueType value, ValueType valueToCompareTo, String failureMessage = String())
    {
        bool result = value < valueToCompareTo;
        expectResultAndPrint (value, valueToCompareTo, result, "less than", failureMessage);
    }




    template <class ValueType>
    void expectGreaterOrEqual (ValueType value, ValueType valueToCompareTo, String failureMessage = String())
    {
        bool result = value >= valueToCompareTo;
        expectResultAndPrint (value, valueToCompareTo, result, "greater or equal to", failureMessage);
    }




    template <class ValueType>
    void expectLessOrEqual (ValueType value, ValueType valueToCompareTo, String failureMessage = String())
    {
        bool result = value <= valueToCompareTo;
        expectResultAndPrint (value, valueToCompareTo, result, "less or equal to", failureMessage);
    }





    template <class ValueType>
    void expectWithinAbsoluteError (ValueType actual, ValueType expected, ValueType maxAbsoluteError, String failureMessage = String())
    {
        const ValueType diff = std::abs (actual - expected);
        const bool result = diff <= maxAbsoluteError;

        expectResultAndPrint (actual, expected, result, " within " + String (maxAbsoluteError) + " of" , failureMessage);
    }
# 262 "..\\..\\..\\JUCE\\modules\\juce_core/unit_tests/juce_UnitTest.h"
    void logMessage (const String& message);
# 278 "..\\..\\..\\JUCE\\modules\\juce_core/unit_tests/juce_UnitTest.h"
    Random getRandom() const;

private:

    template <class ValueType>
    void expectResultAndPrint (ValueType value, ValueType valueToCompareTo, bool result,
                               String compDescription, String failureMessage)
    {
        if (! result)
        {
            if (failureMessage.isNotEmpty())
                failureMessage << " -- ";

            failureMessage << "Expected value" << (compDescription.isEmpty() ? "" : " ")
                           << compDescription << ": " << valueToCompareTo
                           << ", Actual value: " << value;
        }

        expect (result, failureMessage);
    }


    const String name;
    UnitTestRunner* runner;

    UnitTest (const UnitTest&) = delete; UnitTest& operator= (const UnitTest&) = delete;
};
# 319 "..\\..\\..\\JUCE\\modules\\juce_core/unit_tests/juce_UnitTest.h"
class UnitTestRunner
{
public:


    UnitTestRunner();


    virtual ~UnitTestRunner();
# 337 "..\\..\\..\\JUCE\\modules\\juce_core/unit_tests/juce_UnitTest.h"
    void runTests (const Array<UnitTest*>& tests, int64 randomSeed = 0);







    void runAllTests (int64 randomSeed = 0);




    void setAssertOnFailure (bool shouldAssert) noexcept;




    void setPassesAreLogged (bool shouldDisplayPasses) noexcept;
# 364 "..\\..\\..\\JUCE\\modules\\juce_core/unit_tests/juce_UnitTest.h"
    struct TestResult
    {

        String unitTestName;

        String subcategoryName;


        int passes;

        int failures;


        StringArray messages;
    };




    int getNumResults() const noexcept;




    const TestResult* getResult (int index) const noexcept;

protected:



    virtual void resultsUpdated();





    virtual void logMessage (const String& message);




    virtual bool shouldAbortTests();

private:

    friend class UnitTest;

    UnitTest* currentTest;
    String currentSubCategory;
    OwnedArray <TestResult, CriticalSection> results;
    bool assertOnFailure, logPasses;
    Random randomForTest;

    void beginNewTest (UnitTest* test, const String& subCategory);
    void endTest();

    void addPass();
    void addFail (const String& failureMessage);

    UnitTestRunner (const UnitTestRunner&) = delete; UnitTestRunner& operator= (const UnitTestRunner&) = delete;
};
# 312 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/xml/juce_XmlDocument.h" 1
# 71 "..\\..\\..\\JUCE\\modules\\juce_core/xml/juce_XmlDocument.h"
class XmlDocument
{
public:




    XmlDocument (const String& documentText);




    XmlDocument (const File& file);


    ~XmlDocument();
# 108 "..\\..\\..\\JUCE\\modules\\juce_core/xml/juce_XmlDocument.h"
    XmlElement* getDocumentElement (bool onlyReadOuterDocumentElement = false);





    const String& getLastParseError() const noexcept;
# 127 "..\\..\\..\\JUCE\\modules\\juce_core/xml/juce_XmlDocument.h"
    void setInputSource (InputSource* newSource) noexcept;
# 136 "..\\..\\..\\JUCE\\modules\\juce_core/xml/juce_XmlDocument.h"
    void setEmptyTextElementsIgnored (bool shouldBeIgnored) noexcept;






    static XmlElement* parse (const File& file);





    static XmlElement* parse (const String& xmlData);



private:
    String originalText;
    String::CharPointerType input;
    bool outOfData, errorOccurred;

    String lastError, dtdText;
    StringArray tokenisedDTD;
    bool needToLoadDTD, ignoreEmptyTextElements;
    ScopedPointer<InputSource> inputSource;

    XmlElement* parseDocumentElement (String::CharPointerType, bool outer);
    void setLastError (const String&, bool carryOn);
    bool parseHeader();
    bool parseDTD();
    void skipNextWhiteSpace();
    juce_wchar readNextChar() noexcept;
    XmlElement* readNextElement (bool alsoParseSubElements);
    void readChildElements (XmlElement&);
    void readQuotedString (String&);
    void readEntity (String&);

    String getFileContents (const String&) const;
    String expandEntity (const String&);
    String expandExternalEntity (const String&);
    String getParameterEntity (const String&);

    XmlDocument (const XmlDocument&) = delete; XmlDocument& operator= (const XmlDocument&) = delete;
};
# 313 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/xml/juce_XmlElement.h" 1
# 144 "..\\..\\..\\JUCE\\modules\\juce_core/xml/juce_XmlElement.h"
class XmlElement
{
public:


    explicit XmlElement (const String& tagName);


    explicit XmlElement (const char* tagName);


    explicit XmlElement (const Identifier& tagName);


    explicit XmlElement (StringRef tagName);


    XmlElement (String::CharPointerType tagNameBegin, String::CharPointerType tagNameEnd);


    XmlElement (const XmlElement&);


    XmlElement& operator= (const XmlElement&);


    XmlElement (XmlElement&&) noexcept;
    XmlElement& operator= (XmlElement&&) noexcept;



    ~XmlElement() noexcept;
# 189 "..\\..\\..\\JUCE\\modules\\juce_core/xml/juce_XmlElement.h"
    bool isEquivalentTo (const XmlElement* other,
                         bool ignoreOrderOfAttributes) const noexcept;
# 210 "..\\..\\..\\JUCE\\modules\\juce_core/xml/juce_XmlElement.h"
    String createDocument (StringRef dtdToUse,
                           bool allOnOneLine = false,
                           bool includeXmlHeader = true,
                           StringRef encodingType = "UTF-8",
                           int lineWrapLength = 60) const;
# 231 "..\\..\\..\\JUCE\\modules\\juce_core/xml/juce_XmlElement.h"
    void writeToStream (OutputStream& output,
                        StringRef dtdToUse,
                        bool allOnOneLine = false,
                        bool includeXmlHeader = true,
                        StringRef encodingType = "UTF-8",
                        int lineWrapLength = 60) const;
# 257 "..\\..\\..\\JUCE\\modules\\juce_core/xml/juce_XmlElement.h"
    bool writeToFile (const File& destinationFile,
                      StringRef dtdToUse,
                      StringRef encodingType = "UTF-8",
                      int lineWrapLength = 60) const;






    const String& getTagName() const noexcept { return tagName; }


    String getNamespace() const;


    String getTagNameWithoutNamespace() const;





    bool hasTagName (StringRef possibleTagName) const noexcept;





    bool hasTagNameIgnoringNamespace (StringRef possibleTagName) const;







    int getNumAttributes() const noexcept;
# 302 "..\\..\\..\\JUCE\\modules\\juce_core/xml/juce_XmlElement.h"
    const String& getAttributeName (int attributeIndex) const noexcept;
# 311 "..\\..\\..\\JUCE\\modules\\juce_core/xml/juce_XmlElement.h"
    const String& getAttributeValue (int attributeIndex) const noexcept;





    bool hasAttribute (StringRef attributeName) const noexcept;




    const String& getStringAttribute (StringRef attributeName) const noexcept;






    String getStringAttribute (StringRef attributeName, const String& defaultReturnValue) const;
# 339 "..\\..\\..\\JUCE\\modules\\juce_core/xml/juce_XmlElement.h"
    bool compareAttribute (StringRef attributeName,
                           StringRef stringToCompareAgainst,
                           bool ignoreCase = false) const noexcept;
# 353 "..\\..\\..\\JUCE\\modules\\juce_core/xml/juce_XmlElement.h"
    int getIntAttribute (StringRef attributeName, int defaultReturnValue = 0) const;
# 365 "..\\..\\..\\JUCE\\modules\\juce_core/xml/juce_XmlElement.h"
    double getDoubleAttribute (StringRef attributeName, double defaultReturnValue = 0.0) const;
# 377 "..\\..\\..\\JUCE\\modules\\juce_core/xml/juce_XmlElement.h"
    bool getBoolAttribute (StringRef attributeName, bool defaultReturnValue = false) const;
# 392 "..\\..\\..\\JUCE\\modules\\juce_core/xml/juce_XmlElement.h"
    void setAttribute (const Identifier& attributeName, const String& newValue);
# 406 "..\\..\\..\\JUCE\\modules\\juce_core/xml/juce_XmlElement.h"
    void setAttribute (const Identifier& attributeName, int newValue);
# 420 "..\\..\\..\\JUCE\\modules\\juce_core/xml/juce_XmlElement.h"
    void setAttribute (const Identifier& attributeName, double newValue);






    void removeAttribute (const Identifier& attributeName) noexcept;


    void removeAllAttributes() noexcept;
# 439 "..\\..\\..\\JUCE\\modules\\juce_core/xml/juce_XmlElement.h"
    XmlElement* getFirstChildElement() const noexcept { return firstChildElement; }
# 467 "..\\..\\..\\JUCE\\modules\\juce_core/xml/juce_XmlElement.h"
    inline XmlElement* getNextElement() const noexcept { return nextListItem; }
# 477 "..\\..\\..\\JUCE\\modules\\juce_core/xml/juce_XmlElement.h"
    XmlElement* getNextElementWithTagName (StringRef requiredTagName) const;




    int getNumChildElements() const noexcept;
# 492 "..\\..\\..\\JUCE\\modules\\juce_core/xml/juce_XmlElement.h"
    XmlElement* getChildElement (int index) const noexcept;







    XmlElement* getChildByName (StringRef tagNameToLookFor) const noexcept;
# 509 "..\\..\\..\\JUCE\\modules\\juce_core/xml/juce_XmlElement.h"
    XmlElement* getChildByAttribute (StringRef attributeName,
                                     StringRef attributeValue) const noexcept;
# 526 "..\\..\\..\\JUCE\\modules\\juce_core/xml/juce_XmlElement.h"
    void addChildElement (XmlElement* newChildElement) noexcept;
# 539 "..\\..\\..\\JUCE\\modules\\juce_core/xml/juce_XmlElement.h"
    void insertChildElement (XmlElement* newChildElement,
                             int indexToInsertAt) noexcept;
# 554 "..\\..\\..\\JUCE\\modules\\juce_core/xml/juce_XmlElement.h"
    void prependChildElement (XmlElement* newChildElement) noexcept;
# 570 "..\\..\\..\\JUCE\\modules\\juce_core/xml/juce_XmlElement.h"
    XmlElement* createNewChildElement (StringRef tagName);
# 579 "..\\..\\..\\JUCE\\modules\\juce_core/xml/juce_XmlElement.h"
    bool replaceChildElement (XmlElement* currentChildElement,
                              XmlElement* newChildNode) noexcept;







    void removeChildElement (XmlElement* childToRemove,
                             bool shouldDeleteTheChild) noexcept;




    void deleteAllChildElements() noexcept;




    void deleteAllChildElementsWithTagName (StringRef tagName) noexcept;


    bool containsChildElement (const XmlElement* possibleChild) const noexcept;
# 614 "..\\..\\..\\JUCE\\modules\\juce_core/xml/juce_XmlElement.h"
    XmlElement* findParentElementOf (const XmlElement* childToSearchFor) noexcept;
# 639 "..\\..\\..\\JUCE\\modules\\juce_core/xml/juce_XmlElement.h"
    template <class ElementComparator>
    void sortChildElements (ElementComparator& comparator,
                            bool retainOrderOfEquivalentItems = false)
    {
        const int num = getNumChildElements();

        if (num > 1)
        {
            HeapBlock<XmlElement*> elems ((size_t) num);
            getChildElementsAsArray (elems);
            sortArray (comparator, (XmlElement**) elems, 0, num - 1, retainOrderOfEquivalentItems);
            reorderChildElements (elems, num);
        }
    }
# 662 "..\\..\\..\\JUCE\\modules\\juce_core/xml/juce_XmlElement.h"
    bool isTextElement() const noexcept;
# 680 "..\\..\\..\\JUCE\\modules\\juce_core/xml/juce_XmlElement.h"
    const String& getText() const noexcept;







    void setText (const String& newText);
# 703 "..\\..\\..\\JUCE\\modules\\juce_core/xml/juce_XmlElement.h"
    String getAllSubText() const;
# 713 "..\\..\\..\\JUCE\\modules\\juce_core/xml/juce_XmlElement.h"
    String getChildElementAllSubText (StringRef childTagName,
                                      const String& defaultReturnValue) const;




    void addTextElement (const String& text);




    void deleteAllTextElements() noexcept;


    static XmlElement* createTextElement (const String& text);


    static bool isValidXmlName (StringRef possibleName) noexcept;


private:
    struct XmlAttributeNode
    {
        XmlAttributeNode (const XmlAttributeNode&) noexcept;
        XmlAttributeNode (const Identifier&, const String&) noexcept;
        XmlAttributeNode (String::CharPointerType, String::CharPointerType);

        LinkedListPointer<XmlAttributeNode> nextListItem;
        Identifier name;
        String value;

    private:
        XmlAttributeNode& operator= (const XmlAttributeNode&) = delete;
    };

    friend class XmlDocument;
    friend class LinkedListPointer<XmlAttributeNode>;
    friend class LinkedListPointer<XmlElement>;
    friend class LinkedListPointer<XmlElement>::Appender;
    friend class NamedValueSet;

    LinkedListPointer<XmlElement> nextListItem;
    LinkedListPointer<XmlElement> firstChildElement;
    LinkedListPointer<XmlAttributeNode> attributes;
    String tagName;

    XmlElement (int) noexcept;
    void copyChildrenAndAttributesFrom (const XmlElement&);
    void writeElementAsText (OutputStream&, int indentationLevel, int lineWrapLength) const;
    void getChildElementsAsArray (XmlElement**) const noexcept;
    void reorderChildElements (XmlElement**, int) noexcept;
    XmlAttributeNode* getAttribute (StringRef) const noexcept;




    XmlElement (const wchar_t*) = delete;


};
# 314 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/zip/juce_GZIPCompressorOutputStream.h" 1
# 45 "..\\..\\..\\JUCE\\modules\\juce_core/zip/juce_GZIPCompressorOutputStream.h"
class GZIPCompressorOutputStream : public OutputStream
{
public:
# 63 "..\\..\\..\\JUCE\\modules\\juce_core/zip/juce_GZIPCompressorOutputStream.h"
    GZIPCompressorOutputStream (OutputStream* destStream,
                                int compressionLevel = -1,
                                bool deleteDestStreamWhenDestroyed = false,
                                int windowBits = 0);


    ~GZIPCompressorOutputStream();







    void flush() override;

    int64 getPosition() override;
    bool setPosition (int64) override;
    bool write (const void*, size_t) override;




    enum WindowBitsValues
    {
        windowBitsRaw = -15,
        windowBitsGZIP = 15 + 16
    };

private:

    OptionalScopedPointer<OutputStream> destStream;

    class GZIPCompressorHelper;
    friend struct ContainerDeletePolicy<GZIPCompressorHelper>;
    ScopedPointer<GZIPCompressorHelper> helper;

    GZIPCompressorOutputStream (const GZIPCompressorOutputStream&) = delete; GZIPCompressorOutputStream& operator= (const GZIPCompressorOutputStream&) = delete;
};
# 315 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/zip/juce_GZIPDecompressorInputStream.h" 1
# 45 "..\\..\\..\\JUCE\\modules\\juce_core/zip/juce_GZIPDecompressorInputStream.h"
class GZIPDecompressorInputStream : public InputStream
{
public:
    enum Format
    {
        zlibFormat = 0,
        deflateFormat,
        gzipFormat
    };
# 67 "..\\..\\..\\JUCE\\modules\\juce_core/zip/juce_GZIPDecompressorInputStream.h"
    GZIPDecompressorInputStream (InputStream* sourceStream,
                                 bool deleteSourceWhenDestroyed,
                                 Format sourceFormat = zlibFormat,
                                 int64 uncompressedStreamLength = -1);






    GZIPDecompressorInputStream (InputStream& sourceStream);


    ~GZIPDecompressorInputStream();


    int64 getPosition() override;
    bool setPosition (int64 pos) override;
    int64 getTotalLength() override;
    bool isExhausted() override;
    int read (void* destBuffer, int maxBytesToRead) override;

private:

    OptionalScopedPointer<InputStream> sourceStream;
    const int64 uncompressedStreamLength;
    const Format format;
    bool isEof;
    int activeBufferSize;
    int64 originalSourcePos, currentPos;
    HeapBlock<uint8> buffer;

    class GZIPDecompressHelper;
    friend struct ContainerDeletePolicy<GZIPDecompressHelper>;
    ScopedPointer<GZIPDecompressHelper> helper;






    GZIPDecompressorInputStream (const GZIPDecompressorInputStream&) = delete; GZIPDecompressorInputStream& operator= (const GZIPDecompressorInputStream&) = delete;
};
# 316 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/zip/juce_ZipFile.h" 1
# 42 "..\\..\\..\\JUCE\\modules\\juce_core/zip/juce_ZipFile.h"
class ZipFile
{
public:

    explicit ZipFile (const File& file);
# 55 "..\\..\\..\\JUCE\\modules\\juce_core/zip/juce_ZipFile.h"
    ZipFile (InputStream* inputStream, bool deleteStreamWhenDestroyed);





    explicit ZipFile (InputStream& inputStream);






    explicit ZipFile (InputSource* inputSource);


    ~ZipFile();







    struct ZipEntry
    {

        String filename;


        int64 uncompressedSize;


        Time fileTime;
    };



    int getNumEntries() const noexcept;





    const ZipEntry* getEntry (int index) const noexcept;







    int getIndexOfFileName (const String& fileName) const noexcept;
# 116 "..\\..\\..\\JUCE\\modules\\juce_core/zip/juce_ZipFile.h"
    const ZipEntry* getEntry (const String& fileName) const noexcept;


    void sortEntriesByFilename();
# 135 "..\\..\\..\\JUCE\\modules\\juce_core/zip/juce_ZipFile.h"
    InputStream* createStreamForEntry (int index);
# 150 "..\\..\\..\\JUCE\\modules\\juce_core/zip/juce_ZipFile.h"
    InputStream* createStreamForEntry (const ZipEntry& entry);
# 162 "..\\..\\..\\JUCE\\modules\\juce_core/zip/juce_ZipFile.h"
    Result uncompressTo (const File& targetDirectory,
                         bool shouldOverwriteFiles = true);
# 176 "..\\..\\..\\JUCE\\modules\\juce_core/zip/juce_ZipFile.h"
    Result uncompressEntry (int index,
                            const File& targetDirectory,
                            bool shouldOverwriteFiles = true);
# 187 "..\\..\\..\\JUCE\\modules\\juce_core/zip/juce_ZipFile.h"
    class Builder
    {
    public:

        Builder();


        ~Builder();
# 204 "..\\..\\..\\JUCE\\modules\\juce_core/zip/juce_ZipFile.h"
        void addFile (const File& fileToAdd, int compressionLevel,
                      const String& storedPathName = String());
# 219 "..\\..\\..\\JUCE\\modules\\juce_core/zip/juce_ZipFile.h"
        void addEntry (InputStream* streamToRead, int compressionLevel,
                       const String& storedPathName, Time fileModificationTime);





        bool writeToStream (OutputStream& target, double* progress) const;


    private:
        class Item;
        friend struct ContainerDeletePolicy<Item>;
        OwnedArray<Item> items;

        Builder (const Builder&) = delete; Builder& operator= (const Builder&) = delete;
    };

private:

    class ZipInputStream;
    class ZipEntryHolder;
    friend class ZipInputStream;
    friend class ZipEntryHolder;

    OwnedArray<ZipEntryHolder> entries;
    CriticalSection lock;
    InputStream* inputStream;
    ScopedPointer<InputStream> streamToDelete;
    ScopedPointer<InputSource> inputSource;
# 262 "..\\..\\..\\JUCE\\modules\\juce_core/zip/juce_ZipFile.h"
    void init();

    ZipFile (const ZipFile&) = delete; ZipFile& operator= (const ZipFile&) = delete;
};
# 317 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_PropertySet.h" 1
# 45 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_PropertySet.h"
class PropertySet
{
public:





    PropertySet (bool ignoreCaseOfKeyNames = false);


    PropertySet (const PropertySet& other);


    PropertySet& operator= (const PropertySet& other);


    virtual ~PropertySet();
# 74 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_PropertySet.h"
    String getValue (StringRef keyName, const String& defaultReturnValue = String()) const noexcept;
# 85 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_PropertySet.h"
    int getIntValue (StringRef keyName, int defaultReturnValue = 0) const noexcept;
# 96 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_PropertySet.h"
    double getDoubleValue (StringRef keyName, double defaultReturnValue = 0.0) const noexcept;
# 110 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_PropertySet.h"
    bool getBoolValue (StringRef keyName, bool defaultReturnValue = false) const noexcept;
# 123 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_PropertySet.h"
    XmlElement* getXmlValue (StringRef keyName) const;







    void setValue (const String& keyName, const var& value);
# 140 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_PropertySet.h"
    void setValue (const String& keyName, const XmlElement* xml);




    void addAllPropertiesFrom (const PropertySet& source);





    void removeValue (StringRef keyName);


    bool containsKey (StringRef keyName) const noexcept;


    void clear();



    StringPairArray& getAllProperties() noexcept { return properties; }


    const CriticalSection& getLock() const noexcept { return lock; }






    XmlElement* createXml (const String& nodeName) const;





    void restoreFromXml (const XmlElement& xml);
# 192 "..\\..\\..\\JUCE\\modules\\juce_core/containers/juce_PropertySet.h"
    void setFallbackPropertySet (PropertySet* fallbackProperties) noexcept;




    PropertySet* getFallbackPropertySet() const noexcept { return fallbackProperties; }

protected:

    virtual void propertyChanged();

private:
    StringPairArray properties;
    PropertySet* fallbackProperties;
    CriticalSection lock;
    bool ignoreCaseOfKeys;


};
# 318 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_SharedResourcePointer.h" 1
# 87 "..\\..\\..\\JUCE\\modules\\juce_core/memory/juce_SharedResourcePointer.h"
template <typename SharedObjectType>
class SharedResourcePointer
{
public:






    SharedResourcePointer()
    {
        initialise();
    }

    SharedResourcePointer (const SharedResourcePointer&)
    {
        initialise();
    }





    ~SharedResourcePointer()
    {
        SharedObjectHolder& holder = getSharedObjectHolder();
        const SpinLock::ScopedLockType sl (holder.lock);

        if (--(holder.refCount) == 0)
            holder.sharedInstance = nullptr;
    }


    operator SharedObjectType*() const noexcept { return sharedObject; }


    SharedObjectType& get() const noexcept { return *sharedObject; }




    SharedObjectType& getObject() const noexcept { return *sharedObject; }

    SharedObjectType* operator->() const noexcept { return sharedObject; }

private:
    struct SharedObjectHolder : public ReferenceCountedObject
    {
        SpinLock lock;
        ScopedPointer<SharedObjectType> sharedInstance;
        int refCount;
    };

    static SharedObjectHolder& getSharedObjectHolder() noexcept
    {
        static void* holder [(sizeof (SharedObjectHolder) + sizeof(void*) - 1) / sizeof(void*)] = { 0 };
        return *reinterpret_cast<SharedObjectHolder*> (holder);
    }

    SharedObjectType* sharedObject;

    void initialise()
    {
        SharedObjectHolder& holder = getSharedObjectHolder();
        const SpinLock::ScopedLockType sl (holder.lock);

        if (++(holder.refCount) == 1)
            holder.sharedInstance = new SharedObjectType();

        sharedObject = holder.sharedInstance;
    }



    SharedResourcePointer& operator= (const SharedResourcePointer&) = delete;


};
# 319 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h" 2
# 348 "..\\..\\..\\JUCE\\modules\\juce_core/juce_core.h"
  struct this_will_fail_to_link_if_some_of_your_compile_units_are_built_in_release_mode
  { this_will_fail_to_link_if_some_of_your_compile_units_are_built_in_release_mode() noexcept; };
  static this_will_fail_to_link_if_some_of_your_compile_units_are_built_in_release_mode compileUnitMismatchSentinel;



}


#pragma warning(pop)
# 18 "C:\\Users\\Cathy\\OneDrive\\JUCE Terrain\\Source/../JuceLibraryCode/JuceHeader.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_cryptography/juce_cryptography.h" 1
# 55 "..\\..\\..\\JUCE\\modules\\juce_cryptography/juce_cryptography.h"
namespace juce
{


# 1 "..\\..\\..\\JUCE\\modules\\juce_cryptography/encryption/juce_BlowFish.h" 1
# 34 "..\\..\\..\\JUCE\\modules\\juce_cryptography/encryption/juce_BlowFish.h"
class BlowFish
{
public:





    BlowFish (const void* keyData, int keyBytes);


    BlowFish (const BlowFish&);


    BlowFish& operator= (const BlowFish&) noexcept;


    ~BlowFish() noexcept;



    void encrypt (uint32& data1, uint32& data2) const noexcept;


    void decrypt (uint32& data1, uint32& data2) const noexcept;



    void encrypt (MemoryBlock& data) const;


    void decrypt (MemoryBlock& data) const;
# 83 "..\\..\\..\\JUCE\\modules\\juce_cryptography/encryption/juce_BlowFish.h"
    int encrypt (void* buffer, size_t sizeOfMsg, size_t bufferSize) const noexcept;
# 92 "..\\..\\..\\JUCE\\modules\\juce_cryptography/encryption/juce_BlowFish.h"
    int decrypt (void* buffer, size_t bytes) const noexcept;

private:

    static int pad (void*, size_t, size_t) noexcept;
    static int unpad (const void*, size_t) noexcept;

    bool apply (void*, size_t, void (BlowFish::*op) (uint32&, uint32&) const noexcept) const;


    uint32 p[18];
    HeapBlock<uint32> s[4];

    uint32 F (uint32) const noexcept;


};
# 58 "..\\..\\..\\JUCE\\modules\\juce_cryptography/juce_cryptography.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_cryptography/encryption/juce_Primes.h" 1
# 37 "..\\..\\..\\JUCE\\modules\\juce_cryptography/encryption/juce_Primes.h"
class Primes
{
public:
# 50 "..\\..\\..\\JUCE\\modules\\juce_cryptography/encryption/juce_Primes.h"
    static BigInteger createProbablePrime (int bitLength,
                                           int certainty,
                                           const int* randomSeeds = 0,
                                           int numRandomSeeds = 0);
# 63 "..\\..\\..\\JUCE\\modules\\juce_cryptography/encryption/juce_Primes.h"
    static bool isProbablyPrime (const BigInteger& number, int certainty);


private:
    Primes();

    Primes (const Primes&) = delete; Primes& operator= (const Primes&) = delete;
};
# 59 "..\\..\\..\\JUCE\\modules\\juce_cryptography/juce_cryptography.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_cryptography/encryption/juce_RSAKey.h" 1
# 92 "..\\..\\..\\JUCE\\modules\\juce_cryptography/encryption/juce_RSAKey.h"
class RSAKey
{
public:





    RSAKey();





    explicit RSAKey (const String& stringRepresentation);


    ~RSAKey();

    bool operator== (const RSAKey& other) const noexcept;
    bool operator!= (const RSAKey& other) const noexcept;





    String toString() const;




    bool isValid() const noexcept;
# 139 "..\\..\\..\\JUCE\\modules\\juce_cryptography/encryption/juce_RSAKey.h"
    bool applyToValue (BigInteger& value) const;
# 155 "..\\..\\..\\JUCE\\modules\\juce_cryptography/encryption/juce_RSAKey.h"
    static void createKeyPair (RSAKey& publicKey,
                               RSAKey& privateKey,
                               int numBits,
                               const int* randomSeeds = nullptr,
                               int numRandomSeeds = 0);


protected:

    BigInteger part1, part2;

private:

    static BigInteger findBestCommonDivisor (const BigInteger& p, const BigInteger& q);


};
# 60 "..\\..\\..\\JUCE\\modules\\juce_cryptography/juce_cryptography.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_cryptography/hashing/juce_MD5.h" 1
# 39 "..\\..\\..\\JUCE\\modules\\juce_cryptography/hashing/juce_MD5.h"
class MD5
{
public:


    MD5() noexcept;


    MD5 (const MD5&) noexcept;


    MD5& operator= (const MD5&) noexcept;



    explicit MD5 (const MemoryBlock&) noexcept;


    MD5 (const void* data, size_t numBytes) noexcept;







    MD5 (InputStream& input, int64 numBytesToRead = -1);


    explicit MD5 (const File&);






    explicit MD5 (CharPointer_UTF8 utf8Text) noexcept;


    ~MD5() noexcept;



    MemoryBlock getRawChecksumData() const;


    const uint8* getChecksumDataArray() const noexcept { return result; }


    String toHexString() const;
# 97 "..\\..\\..\\JUCE\\modules\\juce_cryptography/hashing/juce_MD5.h"
    static MD5 fromUTF32 (StringRef);


    bool operator== (const MD5&) const noexcept;
    bool operator!= (const MD5&) const noexcept;


private:

    uint8 result [16];

    void processData (const void*, size_t) noexcept;
    void processStream (InputStream&, int64);



    explicit MD5 (const String&) = delete;


};
# 61 "..\\..\\..\\JUCE\\modules\\juce_cryptography/juce_cryptography.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_cryptography/hashing/juce_SHA256.h" 1
# 39 "..\\..\\..\\JUCE\\modules\\juce_cryptography/hashing/juce_SHA256.h"
class SHA256
{
public:





    SHA256() noexcept;


    ~SHA256() noexcept;


    SHA256 (const SHA256& other) noexcept;


    SHA256& operator= (const SHA256& other) noexcept;



    explicit SHA256 (const MemoryBlock& data);


    SHA256 (const void* data, size_t numBytes);







    SHA256 (InputStream& input, int64 maxBytesToRead = -1);





    explicit SHA256 (const File& file);






    explicit SHA256 (CharPointer_UTF8 utf8Text) noexcept;



    MemoryBlock getRawData() const;


    String toHexString() const;


    bool operator== (const SHA256&) const noexcept;
    bool operator!= (const SHA256&) const noexcept;


private:

    uint8 result [32];
    void process (const void*, size_t);


};
# 62 "..\\..\\..\\JUCE\\modules\\juce_cryptography/juce_cryptography.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_cryptography/hashing/juce_Whirlpool.h" 1
# 45 "..\\..\\..\\JUCE\\modules\\juce_cryptography/hashing/juce_Whirlpool.h"
class Whirlpool
{
public:





    Whirlpool() noexcept;


    ~Whirlpool() noexcept;


    Whirlpool (const Whirlpool& other) noexcept;


    Whirlpool& operator= (const Whirlpool& other) noexcept;



    explicit Whirlpool (const MemoryBlock&);


    Whirlpool (const void* data, size_t numBytes);







    Whirlpool (InputStream& input, int64 maxBytesToRead = -1);





    explicit Whirlpool (const File& file);






    explicit Whirlpool (CharPointer_UTF8 utf8Text) noexcept;



    MemoryBlock getRawData() const;


    String toHexString() const;


    bool operator== (const Whirlpool&) const noexcept;
    bool operator!= (const Whirlpool&) const noexcept;


private:

    uint8 result [64];
    void process (const void*, size_t);


};
# 63 "..\\..\\..\\JUCE\\modules\\juce_cryptography/juce_cryptography.h" 2


}
# 19 "C:\\Users\\Cathy\\OneDrive\\JUCE Terrain\\Source/../JuceLibraryCode/JuceHeader.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_data_structures/juce_data_structures.h" 1
# 53 "..\\..\\..\\JUCE\\modules\\juce_data_structures/juce_data_structures.h"
# 1 "..\\..\\..\\JUCE\\modules\\juce_events/juce_events.h" 1
# 62 "..\\..\\..\\JUCE\\modules\\juce_events/juce_events.h"
namespace juce
{


# 1 "..\\..\\..\\JUCE\\modules\\juce_events/messages/juce_MessageManager.h" 1
# 34 "..\\..\\..\\JUCE\\modules\\juce_events/messages/juce_MessageManager.h"
class MessageManagerLock;
class ThreadPoolJob;
class ActionListener;
class ActionBroadcaster;




typedef void* (MessageCallbackFunction) (void* userData);
# 51 "..\\..\\..\\JUCE\\modules\\juce_events/messages/juce_MessageManager.h"
class MessageManager
{
public:


    static MessageManager* getInstance();


    static MessageManager* getInstanceWithoutCreating() noexcept;




    static void deleteInstance();
# 74 "..\\..\\..\\JUCE\\modules\\juce_events/messages/juce_MessageManager.h"
    void runDispatchLoop();
# 83 "..\\..\\..\\JUCE\\modules\\juce_events/messages/juce_MessageManager.h"
    void stopDispatchLoop();



    bool hasStopMessageBeenSent() const noexcept { return quitMessagePosted; }







    bool runDispatchLoopUntil (int millisecondsToRunFor);







    static void callAsync (std::function<void(void)>);
# 124 "..\\..\\..\\JUCE\\modules\\juce_events/messages/juce_MessageManager.h"
    void* callFunctionOnMessageThread (MessageCallbackFunction* callback, void* userData);


    bool isThisTheMessageThread() const noexcept;






    void setCurrentThreadAsMessageThread();






    Thread::ThreadID getCurrentMessageThread() const noexcept { return messageThreadId; }
# 150 "..\\..\\..\\JUCE\\modules\\juce_events/messages/juce_MessageManager.h"
    bool currentThreadHasLockedMessageManager() const noexcept;
# 159 "..\\..\\..\\JUCE\\modules\\juce_events/messages/juce_MessageManager.h"
    static void broadcastMessage (const String& messageText);
# 168 "..\\..\\..\\JUCE\\modules\\juce_events/messages/juce_MessageManager.h"
    void registerBroadcastListener (ActionListener* listener);


    void deregisterBroadcastListener (ActionListener* listener);






    class MessageBase : public ReferenceCountedObject
    {
    public:
        MessageBase() noexcept {}
        virtual ~MessageBase() {}

        virtual void messageCallback() = 0;
        bool post();

        typedef ReferenceCountedObjectPtr<MessageBase> Ptr;

        MessageBase (const MessageBase&) = delete; MessageBase& operator= (const MessageBase&) = delete;
    };




    void deliverBroadcastMessage (const String&);
    ~MessageManager() noexcept;


private:

    MessageManager() noexcept;

    static MessageManager* instance;

    friend class MessageBase;
    class QuitMessage;
    friend class QuitMessage;
    friend class MessageManagerLock;

    ScopedPointer<ActionBroadcaster> broadcaster;
    bool quitMessagePosted, quitMessageReceived;
    Thread::ThreadID messageThreadId;
    Thread::ThreadID volatile threadWithLock;
    CriticalSection lockingLock;

    static bool postMessageToSystemQueue (MessageBase*);
    static void* exitModalLoopCallback (void*);
    static void doPlatformSpecificInitialisation();
    static void doPlatformSpecificShutdown();
    static bool dispatchNextMessageOnSystemQueue (bool returnIfNoPendingMessages);

    MessageManager (const MessageManager&) = delete; MessageManager& operator= (const MessageManager&) = delete;
};
# 261 "..\\..\\..\\JUCE\\modules\\juce_events/messages/juce_MessageManager.h"
class MessageManagerLock
{
public:
# 306 "..\\..\\..\\JUCE\\modules\\juce_events/messages/juce_MessageManager.h"
    MessageManagerLock (Thread* threadToCheckForExitSignal = nullptr);







    MessageManagerLock (ThreadPoolJob* jobToCheckForExitSignal);
# 323 "..\\..\\..\\JUCE\\modules\\juce_events/messages/juce_MessageManager.h"
    ~MessageManagerLock() noexcept;





    bool lockWasGained() const noexcept { return locked; }

private:
    class BlockingMessage;
    friend class ReferenceCountedObjectPtr<BlockingMessage>;
    ReferenceCountedObjectPtr<BlockingMessage> blockingMessage;
    bool locked;

    bool attemptLock (Thread*, ThreadPoolJob*);

    MessageManagerLock (const MessageManagerLock&) = delete; MessageManagerLock& operator= (const MessageManagerLock&) = delete;
};
# 65 "..\\..\\..\\JUCE\\modules\\juce_events/juce_events.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_events/messages/juce_Message.h" 1
# 34 "..\\..\\..\\JUCE\\modules\\juce_events/messages/juce_Message.h"
class MessageListener;
# 49 "..\\..\\..\\JUCE\\modules\\juce_events/messages/juce_Message.h"
class Message : public MessageManager::MessageBase
{
public:


    Message() noexcept;
    ~Message();

    typedef ReferenceCountedObjectPtr<Message> Ptr;


private:
    friend class MessageListener;
    WeakReference<MessageListener> recipient;
    void messageCallback() override;



    Message (const Message&) = delete; Message& operator= (const Message&) = delete;
};
# 66 "..\\..\\..\\JUCE\\modules\\juce_events/juce_events.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_events/messages/juce_MessageListener.h" 1
# 41 "..\\..\\..\\JUCE\\modules\\juce_events/messages/juce_MessageListener.h"
class MessageListener
{
public:

    MessageListener() noexcept;


    virtual ~MessageListener();
# 57 "..\\..\\..\\JUCE\\modules\\juce_events/messages/juce_MessageListener.h"
    virtual void handleMessage (const Message& message) = 0;
# 70 "..\\..\\..\\JUCE\\modules\\juce_events/messages/juce_MessageListener.h"
    void postMessage (Message* message) const;

private:
    WeakReference<MessageListener>::Master masterReference;
    friend class WeakReference<MessageListener>;
};
# 67 "..\\..\\..\\JUCE\\modules\\juce_events/juce_events.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_events/messages/juce_CallbackMessage.h" 1
# 52 "..\\..\\..\\JUCE\\modules\\juce_events/messages/juce_CallbackMessage.h"
class CallbackMessage : public MessageManager::MessageBase
{
public:

    CallbackMessage() noexcept {}


    ~CallbackMessage() {}
# 70 "..\\..\\..\\JUCE\\modules\\juce_events/messages/juce_CallbackMessage.h"
    virtual void messageCallback() = 0;

private:


    CallbackMessage (const CallbackMessage&) = delete; CallbackMessage& operator= (const CallbackMessage&) = delete;
};
# 68 "..\\..\\..\\JUCE\\modules\\juce_events/juce_events.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_events/messages/juce_DeletedAtShutdown.h" 1
# 46 "..\\..\\..\\JUCE\\modules\\juce_events/messages/juce_DeletedAtShutdown.h"
class DeletedAtShutdown
{
protected:

    DeletedAtShutdown();






    virtual ~DeletedAtShutdown();


public:





    static void deleteAll();

private:
    static Array <DeletedAtShutdown*>& getObjects();

    DeletedAtShutdown (const DeletedAtShutdown&) = delete; DeletedAtShutdown& operator= (const DeletedAtShutdown&) = delete;
};
# 69 "..\\..\\..\\JUCE\\modules\\juce_events/juce_events.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_events/messages/juce_NotificationType.h" 1
# 39 "..\\..\\..\\JUCE\\modules\\juce_events/messages/juce_NotificationType.h"
enum NotificationType
{
    dontSendNotification = 0,
    sendNotification = 1,
    sendNotificationSync,
    sendNotificationAsync,
};
# 70 "..\\..\\..\\JUCE\\modules\\juce_events/juce_events.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_events/messages/juce_ApplicationBase.h" 1
# 91 "..\\..\\..\\JUCE\\modules\\juce_events/messages/juce_ApplicationBase.h"
class JUCEApplicationBase
{
protected:

    JUCEApplicationBase();

public:

    virtual ~JUCEApplicationBase();



    static JUCEApplicationBase* getInstance() noexcept { return appInstance; }



    virtual const String getApplicationName() = 0;


    virtual const String getApplicationVersion() = 0;
# 121 "..\\..\\..\\JUCE\\modules\\juce_events/messages/juce_ApplicationBase.h"
    virtual bool moreThanOneInstanceAllowed() = 0;
# 142 "..\\..\\..\\JUCE\\modules\\juce_events/messages/juce_ApplicationBase.h"
    virtual void initialise (const String& commandLineParameters) = 0;
# 156 "..\\..\\..\\JUCE\\modules\\juce_events/messages/juce_ApplicationBase.h"
    virtual void shutdown() = 0;





    virtual void anotherInstanceStarted (const String& commandLine) = 0;
# 176 "..\\..\\..\\JUCE\\modules\\juce_events/messages/juce_ApplicationBase.h"
    virtual void systemRequestedQuit() = 0;




    virtual void suspended() = 0;




    virtual void resumed() = 0;
# 196 "..\\..\\..\\JUCE\\modules\\juce_events/messages/juce_ApplicationBase.h"
    virtual void unhandledException (const std::exception*,
                                     const String& sourceFilename,
                                     int lineNumber) = 0;
# 214 "..\\..\\..\\JUCE\\modules\\juce_events/messages/juce_ApplicationBase.h"
    static void quit();





    static StringArray __stdcall getCommandLineParameterArray();




    static String __stdcall getCommandLineParameters();
# 236 "..\\..\\..\\JUCE\\modules\\juce_events/messages/juce_ApplicationBase.h"
    void setApplicationReturnValue (int newReturnValue) noexcept;




    int getApplicationReturnValue() const noexcept { return appReturnValue; }




    static bool isStandaloneApp() noexcept { return createInstance != nullptr; }







    bool isInitialising() const noexcept { return stillInitialising; }





    static int main();
    static int main (int argc, const char* argv[], void*);

    static void appWillTerminateByForce();
    typedef JUCEApplicationBase* (*CreateInstanceFunction)();
    static CreateInstanceFunction createInstance;

    virtual bool initialiseApp();
    int shutdownApp();
    static void __stdcall sendUnhandledException (const std::exception*, const char* sourceFile, int lineNumber);
    bool sendCommandLineToPreexistingInstance();


private:

    static JUCEApplicationBase* appInstance;
    int appReturnValue;
    bool stillInitialising;

    struct MultipleInstanceHandler;
    friend struct MultipleInstanceHandler;
    friend struct ContainerDeletePolicy<MultipleInstanceHandler>;
    ScopedPointer<MultipleInstanceHandler> multipleInstanceHandler;

    JUCEApplicationBase (const JUCEApplicationBase&) = delete; JUCEApplicationBase& operator= (const JUCEApplicationBase&) = delete;
};
# 71 "..\\..\\..\\JUCE\\modules\\juce_events/juce_events.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_events/messages/juce_Initialisation.h" 1
# 47 "..\\..\\..\\JUCE\\modules\\juce_events/messages/juce_Initialisation.h"
         void __stdcall initialiseJuce_GUI();
# 57 "..\\..\\..\\JUCE\\modules\\juce_events/messages/juce_Initialisation.h"
         void __stdcall shutdownJuce_GUI();
# 76 "..\\..\\..\\JUCE\\modules\\juce_events/messages/juce_Initialisation.h"
class ScopedJuceInitialiser_GUI
{
public:

    ScopedJuceInitialiser_GUI();


    ~ScopedJuceInitialiser_GUI();
};
# 72 "..\\..\\..\\JUCE\\modules\\juce_events/juce_events.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_events/messages/juce_MountedVolumeListChangeDetector.h" 1
# 46 "..\\..\\..\\JUCE\\modules\\juce_events/messages/juce_MountedVolumeListChangeDetector.h"
class MountedVolumeListChangeDetector
{
public:
    MountedVolumeListChangeDetector();
    virtual ~MountedVolumeListChangeDetector();


    virtual void mountedVolumeListChanged() = 0;

private:
    struct Pimpl;
    friend struct ContainerDeletePolicy<Pimpl>;
    ScopedPointer<Pimpl> pimpl;

    MountedVolumeListChangeDetector (const MountedVolumeListChangeDetector&) = delete; MountedVolumeListChangeDetector& operator= (const MountedVolumeListChangeDetector&) = delete;
};
# 73 "..\\..\\..\\JUCE\\modules\\juce_events/juce_events.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_events/broadcasters/juce_ActionBroadcaster.h" 1
# 43 "..\\..\\..\\JUCE\\modules\\juce_events/broadcasters/juce_ActionBroadcaster.h"
class ActionBroadcaster
{
public:


    ActionBroadcaster();


    virtual ~ActionBroadcaster();





    void addActionListener (ActionListener* listener);




    void removeActionListener (ActionListener* listener);


    void removeAllActionListeners();





    void sendActionMessage (const String& message) const;


private:

    friend class WeakReference<ActionBroadcaster>;
    WeakReference<ActionBroadcaster>::Master masterReference;

    class ActionMessage;
    friend class ActionMessage;

    SortedSet<ActionListener*> actionListeners;
    CriticalSection actionListenerLock;

    ActionBroadcaster (const ActionBroadcaster&) = delete; ActionBroadcaster& operator= (const ActionBroadcaster&) = delete;
};
# 74 "..\\..\\..\\JUCE\\modules\\juce_events/juce_events.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_events/broadcasters/juce_ActionListener.h" 1
# 41 "..\\..\\..\\JUCE\\modules\\juce_events/broadcasters/juce_ActionListener.h"
class ActionListener
{
public:

    virtual ~ActionListener() {}






    virtual void actionListenerCallback (const String& message) = 0;
};
# 75 "..\\..\\..\\JUCE\\modules\\juce_events/juce_events.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_events/broadcasters/juce_AsyncUpdater.h" 1
# 45 "..\\..\\..\\JUCE\\modules\\juce_events/broadcasters/juce_AsyncUpdater.h"
class AsyncUpdater
{
public:


    AsyncUpdater();




    virtual ~AsyncUpdater();
# 69 "..\\..\\..\\JUCE\\modules\\juce_events/broadcasters/juce_AsyncUpdater.h"
    void triggerAsyncUpdate();
# 80 "..\\..\\..\\JUCE\\modules\\juce_events/broadcasters/juce_AsyncUpdater.h"
    void cancelPendingUpdate() noexcept;
# 92 "..\\..\\..\\JUCE\\modules\\juce_events/broadcasters/juce_AsyncUpdater.h"
    void handleUpdateNowIfNeeded();


    bool isUpdatePending() const noexcept;







    virtual void handleAsyncUpdate() = 0;

private:

    class AsyncUpdaterMessage;
    friend class ReferenceCountedObjectPtr<AsyncUpdaterMessage>;
    ReferenceCountedObjectPtr<AsyncUpdaterMessage> activeMessage;

    AsyncUpdater (const AsyncUpdater&) = delete; AsyncUpdater& operator= (const AsyncUpdater&) = delete;
};
# 76 "..\\..\\..\\JUCE\\modules\\juce_events/juce_events.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_events/broadcasters/juce_ChangeListener.h" 1
# 34 "..\\..\\..\\JUCE\\modules\\juce_events/broadcasters/juce_ChangeListener.h"
class ChangeBroadcaster;
# 50 "..\\..\\..\\JUCE\\modules\\juce_events/broadcasters/juce_ChangeListener.h"
class ChangeListener
{
public:

    virtual ~ChangeListener() {}




    virtual void changeListenerCallback (ChangeBroadcaster* source) = 0;







};
# 77 "..\\..\\..\\JUCE\\modules\\juce_events/juce_events.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_events/broadcasters/juce_ChangeBroadcaster.h" 1
# 41 "..\\..\\..\\JUCE\\modules\\juce_events/broadcasters/juce_ChangeBroadcaster.h"
class ChangeBroadcaster
{
public:


    ChangeBroadcaster() noexcept;


    virtual ~ChangeBroadcaster();





    void addChangeListener (ChangeListener* listener);




    void removeChangeListener (ChangeListener* listener);


    void removeAllChangeListeners();
# 72 "..\\..\\..\\JUCE\\modules\\juce_events/broadcasters/juce_ChangeBroadcaster.h"
    void sendChangeMessage();
# 81 "..\\..\\..\\JUCE\\modules\\juce_events/broadcasters/juce_ChangeBroadcaster.h"
    void sendSynchronousChangeMessage();






    void dispatchPendingMessages();

private:

    class ChangeBroadcasterCallback : public AsyncUpdater
    {
    public:
        ChangeBroadcasterCallback();
        void handleAsyncUpdate() override;

        ChangeBroadcaster* owner;
    };

    friend class ChangeBroadcasterCallback;
    ChangeBroadcasterCallback broadcastCallback;
    ListenerList <ChangeListener> changeListeners;

    void callListeners();

    ChangeBroadcaster (const ChangeBroadcaster&) = delete; ChangeBroadcaster& operator= (const ChangeBroadcaster&) = delete;
};
# 78 "..\\..\\..\\JUCE\\modules\\juce_events/juce_events.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_events/timers/juce_Timer.h" 1
# 58 "..\\..\\..\\JUCE\\modules\\juce_events/timers/juce_Timer.h"
class Timer
{
protected:




    Timer() noexcept;






    Timer (const Timer&) noexcept;

public:


    virtual ~Timer();







    virtual void timerCallback() = 0;
# 97 "..\\..\\..\\JUCE\\modules\\juce_events/timers/juce_Timer.h"
    void startTimer (int intervalInMilliseconds) noexcept;




    void startTimerHz (int timerFrequencyHz) noexcept;
# 114 "..\\..\\..\\JUCE\\modules\\juce_events/timers/juce_Timer.h"
    void stopTimer() noexcept;



    bool isTimerRunning() const noexcept { return timerPeriodMs > 0; }




    int getTimerInterval() const noexcept { return timerPeriodMs; }






    static void __stdcall callPendingTimersSynchronously();

private:
    class TimerThread;
    friend class TimerThread;
    int timerCountdownMs, timerPeriodMs;
    Timer* previousTimer, *nextTimer;

    Timer& operator= (const Timer&) = delete;
};
# 79 "..\\..\\..\\JUCE\\modules\\juce_events/juce_events.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_events/timers/juce_MultiTimer.h" 1
# 52 "..\\..\\..\\JUCE\\modules\\juce_events/timers/juce_MultiTimer.h"
class MultiTimer
{
protected:





    MultiTimer() noexcept;






    MultiTimer (const MultiTimer&) noexcept;

public:


    virtual ~MultiTimer();
# 81 "..\\..\\..\\JUCE\\modules\\juce_events/timers/juce_MultiTimer.h"
    virtual void timerCallback (int timerID) = 0;
# 97 "..\\..\\..\\JUCE\\modules\\juce_events/timers/juce_MultiTimer.h"
    void startTimer (int timerID, int intervalInMilliseconds) noexcept;
# 108 "..\\..\\..\\JUCE\\modules\\juce_events/timers/juce_MultiTimer.h"
    void stopTimer (int timerID) noexcept;





    bool isTimerRunning (int timerID) const noexcept;





    int getTimerInterval (int timerID) const noexcept;



private:
    SpinLock timerListLock;
    OwnedArray<Timer> timers;

    Timer* getCallback (int) const noexcept;
    MultiTimer& operator= (const MultiTimer&);
};
# 80 "..\\..\\..\\JUCE\\modules\\juce_events/juce_events.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_events/interprocess/juce_InterprocessConnection.h" 1
# 34 "..\\..\\..\\JUCE\\modules\\juce_events/interprocess/juce_InterprocessConnection.h"
class InterprocessConnectionServer;
class MemoryBlock;
# 56 "..\\..\\..\\JUCE\\modules\\juce_events/interprocess/juce_InterprocessConnection.h"
class InterprocessConnection
{
public:
# 76 "..\\..\\..\\JUCE\\modules\\juce_events/interprocess/juce_InterprocessConnection.h"
    InterprocessConnection (bool callbacksOnMessageThread = true,
                            uint32 magicMessageHeaderNumber = 0xf2b49e2c);


    virtual ~InterprocessConnection();
# 94 "..\\..\\..\\JUCE\\modules\\juce_events/interprocess/juce_InterprocessConnection.h"
    bool connectToSocket (const String& hostName,
                          int portNumber,
                          int timeOutMillisecs);
# 110 "..\\..\\..\\JUCE\\modules\\juce_events/interprocess/juce_InterprocessConnection.h"
    bool connectToPipe (const String& pipeName, int pipeReceiveMessageTimeoutMs);
# 124 "..\\..\\..\\JUCE\\modules\\juce_events/interprocess/juce_InterprocessConnection.h"
    bool createPipe (const String& pipeName, int pipeReceiveMessageTimeoutMs, bool mustNotExist = false);


    void disconnect();


    bool isConnected() const;


    StreamingSocket* getSocket() const noexcept { return socket; }


    NamedPipe* getPipe() const noexcept { return pipe; }




    String getConnectedHostName() const;
# 152 "..\\..\\..\\JUCE\\modules\\juce_events/interprocess/juce_InterprocessConnection.h"
    bool sendMessage (const MemoryBlock& message);
# 161 "..\\..\\..\\JUCE\\modules\\juce_events/interprocess/juce_InterprocessConnection.h"
    virtual void connectionMade() = 0;







    virtual void connectionLost() = 0;
# 182 "..\\..\\..\\JUCE\\modules\\juce_events/interprocess/juce_InterprocessConnection.h"
    virtual void messageReceived (const MemoryBlock& message) = 0;


private:

    WeakReference<InterprocessConnection>::Master masterReference;
    friend class WeakReference<InterprocessConnection>;
    CriticalSection pipeAndSocketLock;
    ScopedPointer<StreamingSocket> socket;
    ScopedPointer<NamedPipe> pipe;
    bool callbackConnectionState;
    const bool useMessageThread;
    const uint32 magicMessageHeader;
    int pipeReceiveMessageTimeout;

    friend class InterprocessConnectionServer;
    void initialiseWithSocket (StreamingSocket*);
    void initialiseWithPipe (NamedPipe*);
    void deletePipeAndSocket();
    void connectionMadeInt();
    void connectionLostInt();
    void deliverDataInt (const MemoryBlock&);
    bool readNextMessageInt();

    struct ConnectionThread;
    friend struct ConnectionThread;
    friend struct ContainerDeletePolicy<ConnectionThread>;
    ScopedPointer<ConnectionThread> thread;
    void runThread();
    int writeData (void*, int);

    InterprocessConnection (const InterprocessConnection&) = delete; InterprocessConnection& operator= (const InterprocessConnection&) = delete;
};
# 81 "..\\..\\..\\JUCE\\modules\\juce_events/juce_events.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_events/interprocess/juce_InterprocessConnectionServer.h" 1
# 46 "..\\..\\..\\JUCE\\modules\\juce_events/interprocess/juce_InterprocessConnectionServer.h"
class InterprocessConnectionServer : private Thread
{
public:



    InterprocessConnectionServer();


    ~InterprocessConnectionServer();
# 75 "..\\..\\..\\JUCE\\modules\\juce_events/interprocess/juce_InterprocessConnectionServer.h"
    bool beginWaitingForSocket (int portNumber, const String& bindAddress = String());





    void stop();

protected:
# 93 "..\\..\\..\\JUCE\\modules\\juce_events/interprocess/juce_InterprocessConnectionServer.h"
    virtual InterprocessConnection* createConnectionObject() = 0;


private:

    ScopedPointer<StreamingSocket> socket;

    void run() override;

    InterprocessConnectionServer (const InterprocessConnectionServer&) = delete; InterprocessConnectionServer& operator= (const InterprocessConnectionServer&) = delete;
};
# 82 "..\\..\\..\\JUCE\\modules\\juce_events/juce_events.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_events/interprocess/juce_ConnectedChildProcess.h" 1
# 53 "..\\..\\..\\JUCE\\modules\\juce_events/interprocess/juce_ConnectedChildProcess.h"
class ChildProcessSlave
{
public:



    ChildProcessSlave();


    virtual ~ChildProcessSlave();
# 80 "..\\..\\..\\JUCE\\modules\\juce_events/interprocess/juce_ConnectedChildProcess.h"
    bool initialiseFromCommandLine (const String& commandLine,
                                    const String& commandLineUniqueID,
                                    int timeoutMs = 0);







    virtual void handleMessageFromMaster (const MemoryBlock&) = 0;




    virtual void handleConnectionMade();






    virtual void handleConnectionLost();






    bool sendMessageToMaster (const MemoryBlock&);

private:
    struct Connection;
    friend struct Connection;
    friend struct ContainerDeletePolicy<Connection>;
    ScopedPointer<Connection> connection;

    ChildProcessSlave (const ChildProcessSlave&) = delete; ChildProcessSlave& operator= (const ChildProcessSlave&) = delete;
};
# 138 "..\\..\\..\\JUCE\\modules\\juce_events/interprocess/juce_ConnectedChildProcess.h"
class ChildProcessMaster
{
public:



    ChildProcessMaster();


    virtual ~ChildProcessMaster();
# 164 "..\\..\\..\\JUCE\\modules\\juce_events/interprocess/juce_ConnectedChildProcess.h"
    bool launchSlaveProcess (const File& executableToLaunch,
                             const String& commandLineUniqueID,
                             int timeoutMs = 0,
                             int streamFlags = ChildProcess::wantStdOut | ChildProcess::wantStdErr);




    virtual void handleMessageFromSlave (const MemoryBlock&) = 0;




    virtual void handleConnectionLost();






    bool sendMessageToSlave (const MemoryBlock&);

private:
    ChildProcess childProcess;

    struct Connection;
    friend struct Connection;
    friend struct ContainerDeletePolicy<Connection>;
    ScopedPointer<Connection> connection;

    ChildProcessMaster (const ChildProcessMaster&) = delete; ChildProcessMaster& operator= (const ChildProcessMaster&) = delete;
};
# 83 "..\\..\\..\\JUCE\\modules\\juce_events/juce_events.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_events/native/juce_ScopedXLock.h" 1
# 84 "..\\..\\..\\JUCE\\modules\\juce_events/juce_events.h" 2






}
# 53 "..\\..\\..\\JUCE\\modules\\juce_data_structures/juce_data_structures.h" 2


namespace juce
{


# 1 "..\\..\\..\\JUCE\\modules\\juce_data_structures/undomanager/juce_UndoableAction.h" 1
# 36 "..\\..\\..\\JUCE\\modules\\juce_data_structures/undomanager/juce_UndoableAction.h"
class UndoableAction
{
protected:

    UndoableAction() noexcept {}

public:

    virtual ~UndoableAction() {}
# 58 "..\\..\\..\\JUCE\\modules\\juce_data_structures/undomanager/juce_UndoableAction.h"
    virtual bool perform() = 0;
# 71 "..\\..\\..\\JUCE\\modules\\juce_data_structures/undomanager/juce_UndoableAction.h"
    virtual bool undo() = 0;
# 86 "..\\..\\..\\JUCE\\modules\\juce_data_structures/undomanager/juce_UndoableAction.h"
    virtual int getSizeInUnits() { return 10; }
# 95 "..\\..\\..\\JUCE\\modules\\juce_data_structures/undomanager/juce_UndoableAction.h"
    virtual UndoableAction* createCoalescedAction (UndoableAction* nextAction) { ignoreUnused (nextAction); return nullptr; }
};
# 58 "..\\..\\..\\JUCE\\modules\\juce_data_structures/juce_data_structures.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_data_structures/undomanager/juce_UndoManager.h" 1
# 49 "..\\..\\..\\JUCE\\modules\\juce_data_structures/undomanager/juce_UndoManager.h"
class UndoManager : public ChangeBroadcaster
{
public:
# 66 "..\\..\\..\\JUCE\\modules\\juce_data_structures/undomanager/juce_UndoManager.h"
    UndoManager (int maxNumberOfUnitsToKeep = 30000,
                 int minimumTransactionsToKeep = 30);


    ~UndoManager();



    void clearUndoHistory();




    int getNumberOfUnitsTakenUpByStoredCommands() const;
# 95 "..\\..\\..\\JUCE\\modules\\juce_data_structures/undomanager/juce_UndoManager.h"
    void setMaxNumberOfStoredUnits (int maxNumberOfUnitsToKeep,
                                    int minimumTransactionsToKeep);
# 106 "..\\..\\..\\JUCE\\modules\\juce_data_structures/undomanager/juce_UndoManager.h"
    bool perform (UndoableAction* action);
# 118 "..\\..\\..\\JUCE\\modules\\juce_data_structures/undomanager/juce_UndoManager.h"
    bool perform (UndoableAction* action, const String& actionName);







    void beginNewTransaction() noexcept;
# 137 "..\\..\\..\\JUCE\\modules\\juce_data_structures/undomanager/juce_UndoManager.h"
    void beginNewTransaction (const String& actionName) noexcept;







    void setCurrentTransactionName (const String& newName) noexcept;




    String getCurrentTransactionName() const noexcept;





    bool canUndo() const noexcept;




    String getUndoDescription() const;





    bool undo();
# 182 "..\\..\\..\\JUCE\\modules\\juce_data_structures/undomanager/juce_UndoManager.h"
    bool undoCurrentTransactionOnly();
# 192 "..\\..\\..\\JUCE\\modules\\juce_data_structures/undomanager/juce_UndoManager.h"
    void getActionsInCurrentTransaction (Array<const UndoableAction*>& actionsFound) const;





    int getNumActionsInCurrentTransaction() const;




    Time getTimeOfUndoTransaction() const;




    Time getTimeOfRedoTransaction() const;





    bool canRedo() const noexcept;




    String getRedoDescription() const;





    bool redo();


private:

    struct ActionSet;
    friend struct ContainerDeletePolicy<ActionSet>;
    OwnedArray<ActionSet> transactions, stashedFutureTransactions;
    String newTransactionName;
    int totalUnitsStored, maxNumUnitsToKeep, minimumTransactionsToKeep, nextIndex;
    bool newTransaction, reentrancyCheck;
    ActionSet* getCurrentSet() const noexcept;
    ActionSet* getNextSet() const noexcept;
    void moveFutureTransactionsToStash();
    void restoreStashedFutureTransactions();
    void dropOldTransactionsIfTooLarge();

    UndoManager (const UndoManager&) = delete; UndoManager& operator= (const UndoManager&) = delete;
};
# 59 "..\\..\\..\\JUCE\\modules\\juce_data_structures/juce_data_structures.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_data_structures/values/juce_Value.h" 1
# 48 "..\\..\\..\\JUCE\\modules\\juce_data_structures/values/juce_Value.h"
class Value
{
public:


    Value();







    Value (const Value& other);


    explicit Value (const var& initialValue);


    Value (Value&&) noexcept;
    Value& operator= (Value&&) noexcept;



    ~Value();



    var getValue() const;


    operator var() const;




    String toString() const;
# 93 "..\\..\\..\\JUCE\\modules\\juce_data_structures/values/juce_Value.h"
    void setValue (const var& newValue);
# 102 "..\\..\\..\\JUCE\\modules\\juce_data_structures/values/juce_Value.h"
    Value& operator= (const var& newValue);
# 112 "..\\..\\..\\JUCE\\modules\\juce_data_structures/values/juce_Value.h"
    void referTo (const Value& valueToReferTo);



    bool refersToSameSourceAs (const Value& other) const;





    bool operator== (const Value& other) const;





    bool operator!= (const Value& other) const;





    class Listener
    {
    public:
        Listener() {}
        virtual ~Listener() {}







        virtual void valueChanged (Value& value) = 0;
    };
# 160 "..\\..\\..\\JUCE\\modules\\juce_data_structures/values/juce_Value.h"
    void addListener (Listener* listener);


    void removeListener (Listener* listener);
# 174 "..\\..\\..\\JUCE\\modules\\juce_data_structures/values/juce_Value.h"
    class ValueSource : public ReferenceCountedObject,
                                    private AsyncUpdater
    {
    public:
        ValueSource();
        virtual ~ValueSource();


        virtual var getValue() const = 0;




        virtual void setValue (const var& newValue) = 0;







        void sendChangeMessage (bool dispatchSynchronously);

    protected:

        friend class Value;
        SortedSet<Value*> valuesWithListeners;

    private:
        void handleAsyncUpdate() override;

        ValueSource (const ValueSource&) = delete; ValueSource& operator= (const ValueSource&) = delete;
    };




    explicit Value (ValueSource* valueSource);


    ValueSource& getValueSource() noexcept { return *value; }


private:

    friend class ValueSource;
    ReferenceCountedObjectPtr<ValueSource> value;
    ListenerList<Listener> listeners;

    void callListeners();
    void removeFromListenerList();



    Value& operator= (const Value&) = delete;



    explicit Value (void*) = delete;
};


OutputStream& __stdcall operator<< (OutputStream&, const Value&);


typedef Value::Listener ValueListener;
# 60 "..\\..\\..\\JUCE\\modules\\juce_data_structures/juce_data_structures.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_data_structures/values/juce_ValueTree.h" 1
# 69 "..\\..\\..\\JUCE\\modules\\juce_data_structures/values/juce_ValueTree.h"
class ValueTree
{
public:
# 81 "..\\..\\..\\JUCE\\modules\\juce_data_structures/values/juce_ValueTree.h"
    ValueTree() noexcept;





    explicit ValueTree (const Identifier& type);


    ValueTree (const ValueTree&) noexcept;


    ValueTree& operator= (const ValueTree&);


    ValueTree (ValueTree&&) noexcept;



    ~ValueTree();





    bool operator== (const ValueTree&) const noexcept;





    bool operator!= (const ValueTree&) const noexcept;







    bool isEquivalentTo (const ValueTree&) const;






    bool isValid() const noexcept { return object != nullptr; }


    ValueTree createCopy() const;






    Identifier getType() const noexcept;




    bool hasType (const Identifier& typeName) const noexcept;







    const var& getProperty (const Identifier& name) const noexcept;






    var getProperty (const Identifier& name, const var& defaultReturnValue) const;





    const var* getPropertyPointer (const Identifier& name) const noexcept;






    const var& operator[] (const Identifier& name) const noexcept;
# 179 "..\\..\\..\\JUCE\\modules\\juce_data_structures/values/juce_ValueTree.h"
    ValueTree& setProperty (const Identifier& name, const var& newValue, UndoManager* undoManager);


    bool hasProperty (const Identifier& name) const noexcept;





    void removeProperty (const Identifier& name, UndoManager* undoManager);





    void removeAllProperties (UndoManager* undoManager);




    int getNumProperties() const noexcept;







    Identifier getPropertyName (int index) const noexcept;







    Value getPropertyAsValue (const Identifier& name, UndoManager* undoManager);





    void copyPropertiesFrom (const ValueTree& source, UndoManager* undoManager);





    int getNumChildren() const noexcept;





    ValueTree getChild (int index) const;






    ValueTree getChildWithName (const Identifier& type) const;
# 249 "..\\..\\..\\JUCE\\modules\\juce_data_structures/values/juce_ValueTree.h"
    ValueTree getOrCreateChildWithName (const Identifier& type, UndoManager* undoManager);
# 259 "..\\..\\..\\JUCE\\modules\\juce_data_structures/values/juce_ValueTree.h"
    ValueTree getChildWithProperty (const Identifier& propertyName, const var& propertyValue) const;
# 272 "..\\..\\..\\JUCE\\modules\\juce_data_structures/values/juce_ValueTree.h"
    void addChild (const ValueTree& child, int index, UndoManager* undoManager);





    void removeChild (const ValueTree& child, UndoManager* undoManager);





    void removeChild (int childIndex, UndoManager* undoManager);





    void removeAllChildren (UndoManager* undoManager);
# 305 "..\\..\\..\\JUCE\\modules\\juce_data_structures/values/juce_ValueTree.h"
    void moveChild (int currentIndex, int newIndex, UndoManager* undoManager);




    bool isAChildOf (const ValueTree& possibleParent) const noexcept;




    int indexOf (const ValueTree& child) const noexcept;





    ValueTree getParent() const noexcept;




    ValueTree getRoot() const noexcept;







    ValueTree getSibling (int delta) const noexcept;


    struct Iterator
    {
        Iterator (const ValueTree&, bool isEnd) noexcept;
        Iterator& operator++() noexcept;

        bool operator!= (const Iterator&) const noexcept;
        ValueTree operator*() const;

    private:
        void* internal;
    };


    Iterator begin() const noexcept;


    Iterator end() const noexcept;
# 365 "..\\..\\..\\JUCE\\modules\\juce_data_structures/values/juce_ValueTree.h"
    XmlElement* createXml() const;






    static ValueTree fromXml (const XmlElement& xml);




    String toXmlString() const;
# 387 "..\\..\\..\\JUCE\\modules\\juce_data_structures/values/juce_ValueTree.h"
    void writeToStream (OutputStream& output) const;


    static ValueTree readFromStream (InputStream& input);


    static ValueTree readFromData (const void* data, size_t numBytes);




    static ValueTree readFromGZIPData (const void* data, size_t numBytes);







    class Listener
    {
    public:

        virtual ~Listener() {}
# 423 "..\\..\\..\\JUCE\\modules\\juce_data_structures/values/juce_ValueTree.h"
        virtual void valueTreePropertyChanged (ValueTree& treeWhosePropertyHasChanged,
                                               const Identifier& property) = 0;
# 433 "..\\..\\..\\JUCE\\modules\\juce_data_structures/values/juce_ValueTree.h"
        virtual void valueTreeChildAdded (ValueTree& parentTree,
                                          ValueTree& childWhichHasBeenAdded) = 0;
# 443 "..\\..\\..\\JUCE\\modules\\juce_data_structures/values/juce_ValueTree.h"
        virtual void valueTreeChildRemoved (ValueTree& parentTree,
                                            ValueTree& childWhichHasBeenRemoved,
                                            int indexFromWhichChildWasRemoved) = 0;
# 454 "..\\..\\..\\JUCE\\modules\\juce_data_structures/values/juce_ValueTree.h"
        virtual void valueTreeChildOrderChanged (ValueTree& parentTreeWhoseChildrenHaveMoved,
                                                 int oldIndex, int newIndex) = 0;







        virtual void valueTreeParentChanged (ValueTree& treeWhoseParentHasChanged) = 0;





        virtual void valueTreeRedirected (ValueTree& treeWhichHasBeenChanged);
    };
# 486 "..\\..\\..\\JUCE\\modules\\juce_data_structures/values/juce_ValueTree.h"
    void addListener (Listener* listener);


    void removeListener (Listener* listener);




    ValueTree& setPropertyExcludingListener (Listener* listenerToExclude,
                                             const Identifier& name, const var& newValue,
                                             UndoManager* undoManager);




    void sendPropertyChangeMessage (const Identifier& property);
# 525 "..\\..\\..\\JUCE\\modules\\juce_data_structures/values/juce_ValueTree.h"
    template <typename ElementComparator>
    void sort (ElementComparator& comparator, UndoManager* undoManager, bool retainOrderOfEquivalentItems)
    {
        if (object != nullptr)
        {
            OwnedArray<ValueTree> sortedList;
            createListOfChildren (sortedList);
            ComparatorAdapter<ElementComparator> adapter (comparator);
            sortedList.sort (adapter, retainOrderOfEquivalentItems);
            reorderChildren (sortedList, undoManager);
        }
    }






    static const ValueTree invalid;





    int getReferenceCount() const noexcept;

private:

    class SharedObject;
    friend class SharedObject;

    ReferenceCountedObjectPtr<SharedObject> object;
    ListenerList<Listener> listeners;

    template <typename ElementComparator>
    struct ComparatorAdapter
    {
        ComparatorAdapter (ElementComparator& comp) noexcept : comparator (comp) {}

        int compareElements (const ValueTree* const first, const ValueTree* const second)
        {
            return comparator.compareElements (*first, *second);
        }

    private:
        ElementComparator& comparator;
        ComparatorAdapter (const ComparatorAdapter&) = delete; ComparatorAdapter& operator= (const ComparatorAdapter&) = delete;
    };

    void createListOfChildren (OwnedArray<ValueTree>&) const;
    void reorderChildren (const OwnedArray<ValueTree>&, UndoManager*);

    explicit ValueTree (SharedObject*) noexcept;
};
# 61 "..\\..\\..\\JUCE\\modules\\juce_data_structures/juce_data_structures.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_data_structures/values/juce_ValueTreeSynchroniser.h" 1
# 43 "..\\..\\..\\JUCE\\modules\\juce_data_structures/values/juce_ValueTreeSynchroniser.h"
class ValueTreeSynchroniser : private ValueTree::Listener
{
public:






    ValueTreeSynchroniser (const ValueTree& tree);


    virtual ~ValueTreeSynchroniser();






    virtual void stateChanged (const void* encodedChange, size_t encodedChangeSize) = 0;






    void sendFullSyncCallback();







    static bool applyChange (ValueTree& target,
                             const void* encodedChangeData, size_t encodedChangeDataSize,
                             UndoManager* undoManager);


    const ValueTree& getRoot() noexcept { return valueTree; }

private:
    ValueTree valueTree;

    void valueTreePropertyChanged (ValueTree&, const Identifier&) override;
    void valueTreeChildAdded (ValueTree&, ValueTree&) override;
    void valueTreeChildRemoved (ValueTree&, ValueTree&, int) override;
    void valueTreeChildOrderChanged (ValueTree&, int, int) override;
    void valueTreeParentChanged (ValueTree&) override;

    ValueTreeSynchroniser (const ValueTreeSynchroniser&) = delete; ValueTreeSynchroniser& operator= (const ValueTreeSynchroniser&) = delete;
};
# 62 "..\\..\\..\\JUCE\\modules\\juce_data_structures/juce_data_structures.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_data_structures/values/juce_CachedValue.h" 1
# 55 "..\\..\\..\\JUCE\\modules\\juce_data_structures/values/juce_CachedValue.h"
template <typename Type>
class CachedValue : private ValueTree::Listener
{
public:





    CachedValue();
# 76 "..\\..\\..\\JUCE\\modules\\juce_data_structures/values/juce_CachedValue.h"
    CachedValue (ValueTree& tree, const Identifier& propertyID,
                 UndoManager* undoManager);
# 89 "..\\..\\..\\JUCE\\modules\\juce_data_structures/values/juce_CachedValue.h"
    CachedValue (ValueTree& tree, const Identifier& propertyID,
                 UndoManager* undoManager, const Type& defaultToUse);







    operator Type() const noexcept { return cachedValue; }




    Type get() const noexcept { return cachedValue; }


    Type& operator*() noexcept { return cachedValue; }




    Type* operator->() noexcept { return &cachedValue; }




    template <typename OtherType>
    bool operator== (const OtherType& other) const { return cachedValue == other; }




    template <typename OtherType>
    bool operator!= (const OtherType& other) const { return cachedValue != other; }



    Value getPropertyAsValue();




    bool isUsingDefault() const;


    Type getDefault() const { return defaultValue; }



    CachedValue& operator= (const Type& newValue);


    void setValue (const Type& newValue, UndoManager* undoManagerToUse);




    void resetToDefault();




    void resetToDefault (UndoManager* undoManagerToUse);


    void setDefault (const Type& value) { defaultValue = value; }



    void referTo (ValueTree& tree, const Identifier& property, UndoManager* um);




    void referTo (ValueTree& tree, const Identifier& property, UndoManager* um, const Type& defaultVal);







    void forceUpdateOfCachedValue();



    ValueTree& getValueTree() noexcept { return targetTree; }


    const Identifier& getPropertyID() const noexcept { return targetProperty; }

private:

    ValueTree targetTree;
    Identifier targetProperty;
    UndoManager* undoManager;
    Type defaultValue;
    Type cachedValue;


    void referToWithDefault (ValueTree&, const Identifier&, UndoManager*, const Type&);
    Type getTypedValue() const;

    void valueTreePropertyChanged (ValueTree& changedTree, const Identifier& changedProperty) override;
    void valueTreeChildAdded (ValueTree&, ValueTree&) override {}
    void valueTreeChildRemoved (ValueTree&, ValueTree&, int) override {}
    void valueTreeChildOrderChanged (ValueTree&, int, int) override {}
    void valueTreeParentChanged (ValueTree&) override {}

    CachedValue (const CachedValue&) = delete; CachedValue& operator= (const CachedValue&) = delete;
};



template <typename Type>
inline CachedValue<Type>::CachedValue() : undoManager (nullptr) {}

template <typename Type>
inline CachedValue<Type>::CachedValue (ValueTree& v, const Identifier& i, UndoManager* um)
    : targetTree (v), targetProperty (i), undoManager (um),
      defaultValue(), cachedValue (getTypedValue())
{
    targetTree.addListener (this);
}

template <typename Type>
inline CachedValue<Type>::CachedValue (ValueTree& v, const Identifier& i, UndoManager* um, const Type& defaultToUse)
    : targetTree (v), targetProperty (i), undoManager (um),
      defaultValue (defaultToUse), cachedValue (getTypedValue())
{
    targetTree.addListener (this);
}

template <typename Type>
inline Value CachedValue<Type>::getPropertyAsValue()
{
    return targetTree.getPropertyAsValue (targetProperty, undoManager);
}

template <typename Type>
inline bool CachedValue<Type>::isUsingDefault() const
{
    return ! targetTree.hasProperty (targetProperty);
}

template <typename Type>
inline CachedValue<Type>& CachedValue<Type>::operator= (const Type& newValue)
{
    setValue (newValue, undoManager);
    return *this;
}

template <typename Type>
inline void CachedValue<Type>::setValue (const Type& newValue, UndoManager* undoManagerToUse)
{
    if (cachedValue != newValue || isUsingDefault())
    {
        cachedValue = newValue;
        targetTree.setProperty (targetProperty, VariantConverter<Type>::toVar (newValue), undoManagerToUse);
    }
}

template <typename Type>
inline void CachedValue<Type>::resetToDefault()
{
    resetToDefault (undoManager);
}

template <typename Type>
inline void CachedValue<Type>::resetToDefault (UndoManager* undoManagerToUse)
{
    targetTree.removeProperty (targetProperty, undoManagerToUse);
    forceUpdateOfCachedValue();
}

template <typename Type>
inline void CachedValue<Type>::referTo (ValueTree& v, const Identifier& i, UndoManager* um)
{
    referToWithDefault (v, i, um, Type());
}

template <typename Type>
inline void CachedValue<Type>::referTo (ValueTree& v, const Identifier& i, UndoManager* um, const Type& defaultVal)
{
    referToWithDefault (v, i, um, defaultVal);
}

template <typename Type>
inline void CachedValue<Type>::forceUpdateOfCachedValue()
{
    cachedValue = getTypedValue();
}

template <typename Type>
inline void CachedValue<Type>::referToWithDefault (ValueTree& v, const Identifier& i, UndoManager* um, const Type& defaultVal)
{
    targetTree.removeListener (this);
    targetTree = v;
    targetProperty = i;
    undoManager = um;
    defaultValue = defaultVal;
    cachedValue = getTypedValue();
    targetTree.addListener (this);
}

template <typename Type>
inline Type CachedValue<Type>::getTypedValue() const
{
    if (const var* property = targetTree.getPropertyPointer (targetProperty))
        return VariantConverter<Type>::fromVar (*property);

    return defaultValue;
}

template <typename Type>
inline void CachedValue<Type>::valueTreePropertyChanged (ValueTree& changedTree, const Identifier& changedProperty)
{
    if (changedProperty == targetProperty && targetTree == changedTree)
        forceUpdateOfCachedValue();
}
# 63 "..\\..\\..\\JUCE\\modules\\juce_data_structures/juce_data_structures.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_data_structures/app_properties/juce_PropertiesFile.h" 1
# 43 "..\\..\\..\\JUCE\\modules\\juce_data_structures/app_properties/juce_PropertiesFile.h"
class PropertiesFile : public PropertySet,
                                  public ChangeBroadcaster,
                                  private Timer
{
public:

    enum StorageFormat
    {
        storeAsBinary,
        storeAsCompressedBinary,
        storeAsXML
    };


    struct Options
    {



        Options();



        String applicationName;
# 76 "..\\..\\..\\JUCE\\modules\\juce_data_structures/app_properties/juce_PropertiesFile.h"
        String filenameSuffix;




        String folderName;
# 101 "..\\..\\..\\JUCE\\modules\\juce_data_structures/app_properties/juce_PropertiesFile.h"
        String osxLibrarySubFolder;




        bool commonToAllUsers;





        bool ignoreCaseOfKeyNames;


        bool doNotSave;
# 125 "..\\..\\..\\JUCE\\modules\\juce_data_structures/app_properties/juce_PropertiesFile.h"
        int millisecondsBeforeSaving;





        StorageFormat storageFormat;
# 140 "..\\..\\..\\JUCE\\modules\\juce_data_structures/app_properties/juce_PropertiesFile.h"
        InterProcessLock* processLock;
# 159 "..\\..\\..\\JUCE\\modules\\juce_data_structures/app_properties/juce_PropertiesFile.h"
        File getDefaultFile() const;
    };






    explicit PropertiesFile (const Options& options);





    PropertiesFile (const File& file,
                    const Options& options);




    ~PropertiesFile();






    bool isValidFile() const noexcept { return loadedOk; }
# 197 "..\\..\\..\\JUCE\\modules\\juce_data_structures/app_properties/juce_PropertiesFile.h"
    bool saveIfNeeded();
# 207 "..\\..\\..\\JUCE\\modules\\juce_data_structures/app_properties/juce_PropertiesFile.h"
    bool save();





    bool needsToBeSaved() const;




    void setNeedsToBeSaved (bool needsToBeSaved);


    bool reload();



    const File& getFile() const noexcept { return file; }


protected:

    void propertyChanged() override;

private:

    File file;
    Options options;
    bool loadedOk, needsWriting;

    typedef const ScopedPointer<InterProcessLock::ScopedLockType> ProcessScopedLock;
    InterProcessLock::ScopedLockType* createProcessLock() const;

    void timerCallback() override;
    bool saveAsXml();
    bool saveAsBinary();
    bool loadAsXml();
    bool loadAsBinary();
    bool loadAsBinary (InputStream&);

    PropertiesFile (const PropertiesFile&) = delete; PropertiesFile& operator= (const PropertiesFile&) = delete;
};
# 64 "..\\..\\..\\JUCE\\modules\\juce_data_structures/juce_data_structures.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_data_structures/app_properties/juce_ApplicationProperties.h" 1
# 48 "..\\..\\..\\JUCE\\modules\\juce_data_structures/app_properties/juce_ApplicationProperties.h"
class ApplicationProperties
{
public:







    ApplicationProperties();


    ~ApplicationProperties();





    void setStorageParameters (const PropertiesFile::Options& options);




    const PropertiesFile::Options& getStorageParameters() const noexcept { return options; }
# 86 "..\\..\\..\\JUCE\\modules\\juce_data_structures/app_properties/juce_ApplicationProperties.h"
    PropertiesFile* getUserSettings();
# 102 "..\\..\\..\\JUCE\\modules\\juce_data_structures/app_properties/juce_ApplicationProperties.h"
    PropertiesFile* getCommonSettings (bool returnUserPropsIfReadOnly);






    bool saveIfNeeded();







    void closeFiles();


private:

    PropertiesFile::Options options;
    ScopedPointer<PropertiesFile> userProps, commonProps;
    int commonSettingsAreReadOnly;

    void openFiles();

    ApplicationProperties (const ApplicationProperties&) = delete; ApplicationProperties& operator= (const ApplicationProperties&) = delete;
};
# 65 "..\\..\\..\\JUCE\\modules\\juce_data_structures/juce_data_structures.h" 2


}
# 20 "C:\\Users\\Cathy\\OneDrive\\JUCE Terrain\\Source/../JuceLibraryCode/JuceHeader.h" 2


# 1 "..\\..\\..\\JUCE\\modules\\juce_graphics/juce_graphics.h" 1
# 91 "..\\..\\..\\JUCE\\modules\\juce_graphics/juce_graphics.h"
namespace juce
{

class Image;
class AffineTransform;
class Path;
class Font;
class Graphics;
class FillType;
class LowLevelGraphicsContext;


# 1 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_AffineTransform.h" 1
# 40 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_AffineTransform.h"
class AffineTransform
{
public:


    AffineTransform() noexcept;


    AffineTransform (const AffineTransform& other) noexcept;
# 58 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_AffineTransform.h"
    AffineTransform (float mat00, float mat01, float mat02,
                     float mat10, float mat11, float mat12) noexcept;


    AffineTransform& operator= (const AffineTransform& other) noexcept;


    bool operator== (const AffineTransform& other) const noexcept;


    bool operator!= (const AffineTransform& other) const noexcept;






    static const AffineTransform identity;




    template <typename ValueType>
    void transformPoint (ValueType& x, ValueType& y) const noexcept
    {
        const ValueType oldX = x;
        x = static_cast<ValueType> (mat00 * oldX + mat01 * y + mat02);
        y = static_cast<ValueType> (mat10 * oldX + mat11 * y + mat12);
    }






    template <typename ValueType>
    void transformPoints (ValueType& x1, ValueType& y1,
                          ValueType& x2, ValueType& y2) const noexcept
    {
        const ValueType oldX1 = x1, oldX2 = x2;
        x1 = static_cast<ValueType> (mat00 * oldX1 + mat01 * y1 + mat02);
        y1 = static_cast<ValueType> (mat10 * oldX1 + mat11 * y1 + mat12);
        x2 = static_cast<ValueType> (mat00 * oldX2 + mat01 * y2 + mat02);
        y2 = static_cast<ValueType> (mat10 * oldX2 + mat11 * y2 + mat12);
    }






    template <typename ValueType>
    void transformPoints (ValueType& x1, ValueType& y1,
                          ValueType& x2, ValueType& y2,
                          ValueType& x3, ValueType& y3) const noexcept
    {
        const ValueType oldX1 = x1, oldX2 = x2, oldX3 = x3;
        x1 = static_cast<ValueType> (mat00 * oldX1 + mat01 * y1 + mat02);
        y1 = static_cast<ValueType> (mat10 * oldX1 + mat11 * y1 + mat12);
        x2 = static_cast<ValueType> (mat00 * oldX2 + mat01 * y2 + mat02);
        y2 = static_cast<ValueType> (mat10 * oldX2 + mat11 * y2 + mat12);
        x3 = static_cast<ValueType> (mat00 * oldX3 + mat01 * y3 + mat02);
        y3 = static_cast<ValueType> (mat10 * oldX3 + mat11 * y3 + mat12);
    }



    AffineTransform translated (float deltaX,
                                float deltaY) const noexcept;


    template <typename PointType>
    AffineTransform translated (PointType delta) const noexcept
    {
        return translated ((float) delta.x, (float) delta.y);
    }


    static AffineTransform translation (float deltaX,
                                        float deltaY) noexcept;


    template <typename PointType>
    static AffineTransform translation (PointType delta) noexcept
    {
        return translation ((float) delta.x, (float) delta.y);
    }


    AffineTransform withAbsoluteTranslation (float translationX,
                                             float translationY) const noexcept;






    AffineTransform rotated (float angleInRadians) const noexcept;






    AffineTransform rotated (float angleInRadians,
                             float pivotX,
                             float pivotY) const noexcept;


    static AffineTransform rotation (float angleInRadians) noexcept;


    static AffineTransform rotation (float angleInRadians,
                                     float pivotX,
                                     float pivotY) noexcept;




    AffineTransform scaled (float factorX,
                            float factorY) const noexcept;




    AffineTransform scaled (float factor) const noexcept;




    AffineTransform scaled (float factorX, float factorY,
                            float pivotX, float pivotY) const noexcept;


    static AffineTransform scale (float factorX,
                                  float factorY) noexcept;


    static AffineTransform scale (float factor) noexcept;


    static AffineTransform scale (float factorX, float factorY,
                                  float pivotX, float pivotY) noexcept;




    AffineTransform sheared (float shearX, float shearY) const noexcept;


    static AffineTransform shear (float shearX, float shearY) noexcept;




    static AffineTransform verticalFlip (float height) noexcept;






    AffineTransform inverted() const noexcept;







    static AffineTransform fromTargetPoints (float x00, float y00,
                                             float x10, float y10,
                                             float x01, float y01) noexcept;


    static AffineTransform fromTargetPoints (float sourceX1, float sourceY1, float targetX1, float targetY1,
                                             float sourceX2, float sourceY2, float targetX2, float targetY2,
                                             float sourceX3, float sourceY3, float targetX3, float targetY3) noexcept;



    AffineTransform followedBy (const AffineTransform& other) const noexcept;


    bool isIdentity() const noexcept;


    bool isSingularity() const noexcept;



    bool isOnlyTranslation() const noexcept;




    float getTranslationX() const noexcept { return mat02; }




    float getTranslationY() const noexcept { return mat12; }





    float getScaleFactor() const noexcept;
# 274 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_AffineTransform.h"
    float mat00, mat01, mat02;
    float mat10, mat11, mat12;
};
# 102 "..\\..\\..\\JUCE\\modules\\juce_graphics/juce_graphics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Point.h" 1
# 38 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Point.h"
template <typename ValueType>
class Point
{
public:

    Point() noexcept : x(), y() {}


    Point (const Point& other) noexcept : x (other.x), y (other.y) {}


    Point (ValueType initialX, ValueType initialY) noexcept : x (initialX), y (initialY) {}



    Point& operator= (const Point& other) noexcept { x = other.x; y = other.y; return *this; }

    inline bool operator== (Point other) const noexcept { return x == other.x && y == other.y; }
    inline bool operator!= (Point other) const noexcept { return x != other.x || y != other.y; }


    bool isOrigin() const noexcept { return x == ValueType() && y == ValueType(); }


    inline bool isFinite() const noexcept { return juce_isfinite(x) && juce_isfinite(y); }


    inline ValueType getX() const noexcept { return x; }


    inline ValueType getY() const noexcept { return y; }


    inline void setX (ValueType newX) noexcept { x = newX; }


    inline void setY (ValueType newY) noexcept { y = newY; }


    Point withX (ValueType newX) const noexcept { return Point (newX, y); }


    Point withY (ValueType newY) const noexcept { return Point (x, newY); }


    void setXY (ValueType newX, ValueType newY) noexcept { x = newX; y = newY; }


    void addXY (ValueType xToAdd, ValueType yToAdd) noexcept { x += xToAdd; y += yToAdd; }



    Point translated (ValueType deltaX, ValueType deltaY) const noexcept { return Point (x + deltaX, y + deltaY); }


    Point operator+ (Point other) const noexcept { return Point (x + other.x, y + other.y); }


    Point& operator+= (Point other) noexcept { x += other.x; y += other.y; return *this; }


    Point operator- (Point other) const noexcept { return Point (x - other.x, y - other.y); }


    Point& operator-= (Point other) noexcept { x -= other.x; y -= other.y; return *this; }


    template <typename OtherType>
    Point operator* (Point<OtherType> other) const noexcept { return Point ((ValueType) (x * other.x), (ValueType) (y * other.y)); }


    template <typename OtherType>
    Point& operator*= (Point<OtherType> other) noexcept { *this = *this * other; return *this; }


    template <typename OtherType>
    Point operator/ (Point<OtherType> other) const noexcept { return Point ((ValueType) (x / other.x), (ValueType) (y / other.y)); }


    template <typename OtherType>
    Point& operator/= (Point<OtherType> other) noexcept { *this = *this / other; return *this; }


    template <typename FloatType>
    Point operator* (FloatType multiplier) const noexcept { return Point ((ValueType) (x * multiplier), (ValueType) (y * multiplier)); }


    template <typename FloatType>
    Point operator/ (FloatType divisor) const noexcept { return Point ((ValueType) (x / divisor), (ValueType) (y / divisor)); }


    template <typename FloatType>
    Point& operator*= (FloatType multiplier) noexcept { x = (ValueType) (x * multiplier); y = (ValueType) (y * multiplier); return *this; }


    template <typename FloatType>
    Point& operator/= (FloatType divisor) noexcept { x = (ValueType) (x / divisor); y = (ValueType) (y / divisor); return *this; }


    Point operator-() const noexcept { return Point (-x, -y); }



    typedef typename TypeHelpers::SmallestFloatType<ValueType>::type FloatType;



    ValueType getDistanceFromOrigin() const noexcept { return juce_hypot (x, y); }


    ValueType getDistanceFrom (Point other) const noexcept { return juce_hypot (x - other.x, y - other.y); }


    ValueType getDistanceSquaredFromOrigin() const noexcept { return x * x + y * y; }


    ValueType getDistanceSquaredFrom (Point other) const noexcept { return (*this - other).getDistanceSquaredFromOrigin(); }
# 163 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Point.h"
    FloatType getAngleToPoint (Point other) const noexcept
    {
        return static_cast<FloatType> (std::atan2 (static_cast<FloatType> (other.x - x),
                                                   static_cast<FloatType> (y - other.y)));
    }




    Point rotatedAboutOrigin (ValueType angleRadians) const noexcept
    {
        return Point (x * std::cos (angleRadians) - y * std::sin (angleRadians),
                      x * std::sin (angleRadians) + y * std::cos (angleRadians));
    }





    Point<FloatType> getPointOnCircumference (float radius, float angle) const noexcept
    {
        return Point<FloatType> (static_cast<FloatType> (x + radius * std::sin (angle)),
                                 static_cast<FloatType> (y - radius * std::cos (angle)));
    }






    Point<FloatType> getPointOnCircumference (float radiusX, float radiusY, float angle) const noexcept
    {
        return Point<FloatType> (static_cast<FloatType> (x + radiusX * std::sin (angle)),
                                 static_cast<FloatType> (y - radiusY * std::cos (angle)));
    }


    FloatType getDotProduct (Point other) const noexcept { return x * other.x + y * other.y; }







    void applyTransform (const AffineTransform& transform) noexcept { transform.transformPoint (x, y); }


    Point transformedBy (const AffineTransform& transform) const noexcept
    {
        return Point (static_cast<ValueType> (transform.mat00 * x + transform.mat01 * y + transform.mat02),
                      static_cast<ValueType> (transform.mat10 * x + transform.mat11 * y + transform.mat12));
    }



    Point<int> toInt() const noexcept { return Point<int> (static_cast<int> (x), static_cast<int> (y)); }


    Point<float> toFloat() const noexcept { return Point<float> (static_cast<float> (x), static_cast<float> (y)); }


    Point<double> toDouble() const noexcept { return Point<double> (static_cast<double> (x), static_cast<double> (y)); }


    Point<int> roundToInt() const noexcept { return Point<int> (juce::roundToInt (x), juce::roundToInt (y)); }


    String toString() const { return String (x) + ", " + String (y); }


    ValueType x;
    ValueType y;
};


template <typename ValueType>
Point<ValueType> operator* (ValueType value, Point<ValueType> p) noexcept { return p * value; }
# 103 "..\\..\\..\\JUCE\\modules\\juce_graphics/juce_graphics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Line.h" 1
# 43 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Line.h"
template <typename ValueType>
class Line
{
public:


    Line() noexcept {}


    Line (const Line& other) noexcept
        : start (other.start), end (other.end)
    {
    }


    Line (ValueType startX, ValueType startY, ValueType endX, ValueType endY) noexcept
        : start (startX, startY), end (endX, endY)
    {
    }


    Line (Point<ValueType> startPoint,
          Point<ValueType> endPoint) noexcept
        : start (startPoint), end (endPoint)
    {
    }


    Line& operator= (const Line& other) noexcept
    {
        start = other.start;
        end = other.end;
        return *this;
    }


    ~Line() noexcept {}



    inline ValueType getStartX() const noexcept { return start.x; }


    inline ValueType getStartY() const noexcept { return start.y; }


    inline ValueType getEndX() const noexcept { return end.x; }


    inline ValueType getEndY() const noexcept { return end.y; }


    inline Point<ValueType> getStart() const noexcept { return start; }


    inline Point<ValueType> getEnd() const noexcept { return end; }


    void setStart (ValueType newStartX, ValueType newStartY) noexcept { start.setXY (newStartX, newStartY); }


    void setEnd (ValueType newEndX, ValueType newEndY) noexcept { end.setXY (newEndX, newEndY); }


    void setStart (const Point<ValueType> newStart) noexcept { start = newStart; }


    void setEnd (const Point<ValueType> newEnd) noexcept { end = newEnd; }


    Line reversed() const noexcept { return Line (end, start); }


    void applyTransform (const AffineTransform& transform) noexcept
    {
        start.applyTransform (transform);
        end.applyTransform (transform);
    }



    ValueType getLength() const noexcept { return start.getDistanceFrom (end); }


    ValueType getLengthSquared() const noexcept { return start.getDistanceSquaredFrom (end); }


    bool isVertical() const noexcept { return start.x == end.x; }


    bool isHorizontal() const noexcept { return start.y == end.y; }






    typename Point<ValueType>::FloatType getAngle() const noexcept { return start.getAngleToPoint (end); }






    static Line fromStartAndAngle (Point<ValueType> startPoint, ValueType length, ValueType angle) noexcept
    {
        return Line (startPoint, startPoint.getPointOnCircumference (length, angle));
    }



    Line<float> toFloat() const noexcept { return Line<float> (start.toFloat(), end.toFloat()); }


    Line<double> toDouble() const noexcept { return Line<double> (start.toDouble(), end.toDouble()); }



    bool operator== (Line other) const noexcept { return start == other.start && end == other.end; }


    bool operator!= (Line other) const noexcept { return start != other.start || end != other.end; }







    Point<ValueType> getIntersection (Line line) const noexcept
    {
        Point<ValueType> p;
        findIntersection (start, end, line.start, line.end, p);
        return p;
    }
# 191 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Line.h"
    bool intersects (Line line, Point<ValueType>& intersection) const noexcept
    {
        return findIntersection (start, end, line.start, line.end, intersection);
    }


    bool intersects (Line other) const noexcept
    {
        Point<ValueType> ignored;
        return findIntersection (start, end, other.start, other.end, ignored);
    }
# 211 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Line.h"
    Point<ValueType> getPointAlongLine (ValueType distanceFromStart) const noexcept
    {
        return start + (end - start) * (distanceFromStart / getLength());
    }
# 229 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Line.h"
    Point<ValueType> getPointAlongLine (ValueType distanceFromStart,
                                        ValueType perpendicularDistance) const noexcept
    {
        const Point<ValueType> delta (end - start);
        const double length = juce_hypot ((double) delta.x,
                                          (double) delta.y);
        if (length <= 0)
            return start;

        return Point<ValueType> (start.x + static_cast<ValueType> ((delta.x * distanceFromStart - delta.y * perpendicularDistance) / length),
                                 start.y + static_cast<ValueType> ((delta.y * distanceFromStart + delta.x * perpendicularDistance) / length));
    }
# 252 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Line.h"
    Point<ValueType> getPointAlongLineProportionally (typename Point<ValueType>::FloatType proportionOfLength) const noexcept
    {
        return start + Point<ValueType> ((end - start) * proportionOfLength);
    }
# 268 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Line.h"
    ValueType getDistanceFromPoint (Point<ValueType> targetPoint,
                                    Point<ValueType>& pointOnLine) const noexcept
    {
        const Point<ValueType> delta (end - start);
        const double length = delta.x * delta.x + delta.y * delta.y;

        if (length > 0)
        {
            const double prop = ((targetPoint.x - start.x) * delta.x
                               + (targetPoint.y - start.y) * delta.y) / length;

            if (prop >= 0 && prop <= 1.0)
            {
                pointOnLine = start + delta * static_cast<ValueType> (prop);
                return targetPoint.getDistanceFrom (pointOnLine);
            }
        }

        const float fromStart = targetPoint.getDistanceFrom (start);
        const float fromEnd = targetPoint.getDistanceFrom (end);

        if (fromStart < fromEnd)
        {
            pointOnLine = start;
            return fromStart;
        }
        else
        {
            pointOnLine = end;
            return fromEnd;
        }
    }
# 309 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Line.h"
    ValueType findNearestProportionalPositionTo (Point<ValueType> point) const noexcept
    {
        const Point<ValueType> delta (end - start);
        const double length = delta.x * delta.x + delta.y * delta.y;

        return length <= 0 ? 0
                           : jlimit (ValueType(), static_cast<ValueType> (1),
                                     static_cast<ValueType> ((((point.x - start.x) * delta.x
                                                             + (point.y - start.y) * delta.y) / length)));
    }




    Point<ValueType> findNearestPointTo (Point<ValueType> point) const noexcept
    {
        return getPointAlongLineProportionally (findNearestProportionalPositionTo (point));
    }







    bool isPointAbove (Point<ValueType> point) const noexcept
    {
        return start.x != end.x
                && point.y < ((end.y - start.y)
                                    * (point.x - start.x)) / (end.x - start.x) + start.y;
    }







    Line withShortenedStart (ValueType distanceToShortenBy) const noexcept
    {
        return Line (getPointAlongLine (jmin (distanceToShortenBy, getLength())), end);
    }






    Line withShortenedEnd (ValueType distanceToShortenBy) const noexcept
    {
        const ValueType length = getLength();
        return Line (start, getPointAlongLine (length - jmin (distanceToShortenBy, length)));
    }

private:

    Point<ValueType> start, end;

    static bool findIntersection (const Point<ValueType> p1, const Point<ValueType> p2,
                                  const Point<ValueType> p3, const Point<ValueType> p4,
                                  Point<ValueType>& intersection) noexcept
    {
        if (p2 == p3)
        {
            intersection = p2;
            return true;
        }

        const Point<ValueType> d1 (p2 - p1);
        const Point<ValueType> d2 (p4 - p3);
        const ValueType divisor = d1.x * d2.y - d2.x * d1.y;

        if (divisor == 0)
        {
            if (! (d1.isOrigin() || d2.isOrigin()))
            {
                if (d1.y == 0 && d2.y != 0)
                {
                    const ValueType along = (p1.y - p3.y) / d2.y;
                    intersection = p1.withX (p3.x + along * d2.x);
                    return along >= 0 && along <= static_cast<ValueType> (1);
                }

                if (d2.y == 0 && d1.y != 0)
                {
                    const ValueType along = (p3.y - p1.y) / d1.y;
                    intersection = p3.withX (p1.x + along * d1.x);
                    return along >= 0 && along <= static_cast<ValueType> (1);
                }

                if (d1.x == 0 && d2.x != 0)
                {
                    const ValueType along = (p1.x - p3.x) / d2.x;
                    intersection = p1.withY (p3.y + along * d2.y);
                    return along >= 0 && along <= static_cast<ValueType> (1);
                }

                if (d2.x == 0 && d1.x != 0)
                {
                    const ValueType along = (p3.x - p1.x) / d1.x;
                    intersection = p3.withY (p1.y + along * d1.y);
                    return along >= 0 && along <= static_cast<ValueType> (1);
                }
            }

            intersection = (p2 + p3) / static_cast<ValueType> (2);
            return false;
        }

        const ValueType along1 = ((p1.y - p3.y) * d2.x - (p1.x - p3.x) * d2.y) / divisor;
        intersection = p1 + d1 * along1;

        if (along1 < 0 || along1 > static_cast<ValueType> (1))
            return false;

        const ValueType along2 = ((p1.y - p3.y) * d1.x - (p1.x - p3.x) * d1.y) / divisor;
        return along2 >= 0 && along2 <= static_cast<ValueType> (1);
    }
};
# 104 "..\\..\\..\\JUCE\\modules\\juce_graphics/juce_graphics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Rectangle.h" 1
# 35 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Rectangle.h"
template <typename ValueType>
class Rectangle
{
public:




    Rectangle() noexcept
      : w(), h()
    {
    }


    Rectangle (const Rectangle& other) noexcept
      : pos (other.pos), w (other.w), h (other.h)
    {
    }


    Rectangle (ValueType initialX, ValueType initialY,
               ValueType width, ValueType height) noexcept
      : pos (initialX, initialY),
        w (width), h (height)
    {
    }


    Rectangle (ValueType width, ValueType height) noexcept
      : w (width), h (height)
    {
    }


    Rectangle (Point<ValueType> corner1, Point<ValueType> corner2) noexcept
      : pos (jmin (corner1.x, corner2.x),
             jmin (corner1.y, corner2.y)),
        w (corner1.x - corner2.x),
        h (corner1.y - corner2.y)
    {
        if (w < ValueType()) w = -w;
        if (h < ValueType()) h = -h;
    }





    static Rectangle leftTopRightBottom (ValueType left, ValueType top,
                                         ValueType right, ValueType bottom) noexcept
    {
        return Rectangle (left, top, right - left, bottom - top);
    }

    Rectangle& operator= (const Rectangle& other) noexcept
    {
        pos = other.pos;
        w = other.w; h = other.h;
        return *this;
    }


    ~Rectangle() noexcept {}



    bool isEmpty() const noexcept { return w <= ValueType() || h <= ValueType(); }


    inline bool isFinite() const noexcept { return pos.isFinite() && juce_isfinite(w) && juce_isfinite(h); }


    inline ValueType getX() const noexcept { return pos.x; }


    inline ValueType getY() const noexcept { return pos.y; }


    inline ValueType getWidth() const noexcept { return w; }


    inline ValueType getHeight() const noexcept { return h; }


    inline ValueType getRight() const noexcept { return pos.x + w; }


    inline ValueType getBottom() const noexcept { return pos.y + h; }


    ValueType getCentreX() const noexcept { return pos.x + w / (ValueType) 2; }


    ValueType getCentreY() const noexcept { return pos.y + h / (ValueType) 2; }


    Point<ValueType> getCentre() const noexcept { return Point<ValueType> (pos.x + w / (ValueType) 2,
                                                                                               pos.y + h / (ValueType) 2); }




    ValueType getAspectRatio (bool widthOverHeight = true) const noexcept { return widthOverHeight ? w / h : h / w; }



    inline Point<ValueType> getPosition() const noexcept { return pos; }


    inline void setPosition (Point<ValueType> newPos) noexcept { pos = newPos; }


    inline void setPosition (ValueType newX, ValueType newY) noexcept { pos.setXY (newX, newY); }


    Point<ValueType> getTopLeft() const noexcept { return pos; }


    Point<ValueType> getTopRight() const noexcept { return Point<ValueType> (pos.x + w, pos.y); }


    Point<ValueType> getBottomLeft() const noexcept { return Point<ValueType> (pos.x, pos.y + h); }


    Point<ValueType> getBottomRight() const noexcept { return Point<ValueType> (pos.x + w, pos.y + h); }


    Range<ValueType> getHorizontalRange() const noexcept { return Range<ValueType>::withStartAndLength (pos.x, w); }


    Range<ValueType> getVerticalRange() const noexcept { return Range<ValueType>::withStartAndLength (pos.y, h); }


    void setSize (ValueType newWidth, ValueType newHeight) noexcept { w = newWidth; h = newHeight; }


    void setBounds (ValueType newX, ValueType newY,
                    ValueType newWidth, ValueType newHeight) noexcept { pos.x = newX; pos.y = newY; w = newWidth; h = newHeight; }


    inline void setX (ValueType newX) noexcept { pos.x = newX; }


    inline void setY (ValueType newY) noexcept { pos.y = newY; }


    inline void setWidth (ValueType newWidth) noexcept { w = newWidth; }


    inline void setHeight (ValueType newHeight) noexcept { h = newHeight; }


    inline void setCentre (ValueType newCentreX, ValueType newCentreY) noexcept { pos.x = newCentreX - w / (ValueType) 2;
                                                                                                      pos.y = newCentreY - h / (ValueType) 2; }


    inline void setCentre (Point<ValueType> newCentre) noexcept { setCentre (newCentre.x, newCentre.y); }


    void setHorizontalRange (Range<ValueType> range) noexcept { pos.x = range.getStart(); w = range.getLength(); }


    void setVerticalRange (Range<ValueType> range) noexcept { pos.y = range.getStart(); h = range.getLength(); }


    Rectangle withX (ValueType newX) const noexcept { return Rectangle (newX, pos.y, w, h); }


    Rectangle withY (ValueType newY) const noexcept { return Rectangle (pos.x, newY, w, h); }


    Rectangle withRightX (ValueType newRightX) const noexcept { return Rectangle (newRightX - w, pos.y, w, h); }


    Rectangle withBottomY (ValueType newBottomY) const noexcept { return Rectangle (pos.x, newBottomY - h, w, h); }


    Rectangle withPosition (ValueType newX, ValueType newY) const noexcept { return Rectangle (newX, newY, w, h); }


    Rectangle withPosition (Point<ValueType> newPos) const noexcept { return Rectangle (newPos.x, newPos.y, w, h); }


    Rectangle withZeroOrigin() const noexcept { return Rectangle (w, h); }


    Rectangle withCentre (Point<ValueType> newCentre) const noexcept { return Rectangle (newCentre.x - w / (ValueType) 2,
                                                                                                                        newCentre.y - h / (ValueType) 2, w, h); }


    Rectangle withWidth (ValueType newWidth) const noexcept { return Rectangle (pos.x, pos.y, newWidth, h); }


    Rectangle withHeight (ValueType newHeight) const noexcept { return Rectangle (pos.x, pos.y, w, newHeight); }


    Rectangle withSize (ValueType newWidth, ValueType newHeight) const noexcept { return Rectangle (pos.x, pos.y, newWidth, newHeight); }


    Rectangle withSizeKeepingCentre (ValueType newWidth, ValueType newHeight) const noexcept { return Rectangle (pos.x + (w - newWidth) / (ValueType) 2,
                                                                                                                        pos.y + (h - newHeight) / (ValueType) 2, newWidth, newHeight); }





    void setLeft (ValueType newLeft) noexcept { w = jmax (ValueType(), pos.x + w - newLeft); pos.x = newLeft; }





    Rectangle withLeft (ValueType newLeft) const noexcept { return Rectangle (newLeft, pos.y, jmax (ValueType(), pos.x + w - newLeft), h); }





    void setTop (ValueType newTop) noexcept { h = jmax (ValueType(), pos.y + h - newTop); pos.y = newTop; }





    Rectangle withTop (ValueType newTop) const noexcept { return Rectangle (pos.x, newTop, w, jmax (ValueType(), pos.y + h - newTop)); }





    void setRight (ValueType newRight) noexcept { pos.x = jmin (pos.x, newRight); w = newRight - pos.x; }





    Rectangle withRight (ValueType newRight) const noexcept { return Rectangle (jmin (pos.x, newRight), pos.y, jmax (ValueType(), newRight - pos.x), h); }





    void setBottom (ValueType newBottom) noexcept { pos.y = jmin (pos.y, newBottom); h = newBottom - pos.y; }





    Rectangle withBottom (ValueType newBottom) const noexcept { return Rectangle (pos.x, jmin (pos.y, newBottom), w, jmax (ValueType(), newBottom - pos.y)); }


    Rectangle withTrimmedLeft (ValueType amountToRemove) const noexcept { return withLeft (pos.x + amountToRemove); }


    Rectangle withTrimmedRight (ValueType amountToRemove) const noexcept { return withWidth (w - amountToRemove); }


    Rectangle withTrimmedTop (ValueType amountToRemove) const noexcept { return withTop (pos.y + amountToRemove); }


    Rectangle withTrimmedBottom (ValueType amountToRemove) const noexcept { return withHeight (h - amountToRemove); }



    void translate (ValueType deltaX,
                    ValueType deltaY) noexcept
    {
        pos.x += deltaX;
        pos.y += deltaY;
    }


    Rectangle translated (ValueType deltaX,
                          ValueType deltaY) const noexcept
    {
        return Rectangle (pos.x + deltaX, pos.y + deltaY, w, h);
    }


    Rectangle operator+ (Point<ValueType> deltaPosition) const noexcept
    {
        return Rectangle (pos.x + deltaPosition.x, pos.y + deltaPosition.y, w, h);
    }


    Rectangle& operator+= (Point<ValueType> deltaPosition) noexcept
    {
        pos += deltaPosition;
        return *this;
    }


    Rectangle operator- (Point<ValueType> deltaPosition) const noexcept
    {
        return Rectangle (pos.x - deltaPosition.x, pos.y - deltaPosition.y, w, h);
    }


    Rectangle& operator-= (Point<ValueType> deltaPosition) noexcept
    {
        pos -= deltaPosition;
        return *this;
    }






    template <typename FloatType>
    Rectangle operator* (FloatType scaleFactor) const noexcept
    {
        Rectangle r (*this);
        r *= scaleFactor;
        return r;
    }






    template <typename FloatType>
    Rectangle operator*= (FloatType scaleFactor) noexcept
    {
        Rectangle<FloatType> (pos.x * scaleFactor,
                              pos.y * scaleFactor,
                              w * scaleFactor,
                              h * scaleFactor).copyWithRounding (*this);
        return *this;
    }






    template <typename FloatType>
    Rectangle operator*= (Point<FloatType> scaleFactor) noexcept
    {
        Rectangle<FloatType> (pos.x * scaleFactor.x,
                              pos.y * scaleFactor.y,
                              w * scaleFactor.x,
                              h * scaleFactor.y).copyWithRounding (*this);
        return *this;
    }


    template <typename FloatType>
    Rectangle operator/ (FloatType scaleFactor) const noexcept
    {
        Rectangle r (*this);
        r /= scaleFactor;
        return r;
    }


    template <typename FloatType>
    Rectangle operator/= (FloatType scaleFactor) noexcept
    {
        Rectangle<FloatType> (pos.x / scaleFactor,
                              pos.y / scaleFactor,
                              w / scaleFactor,
                              h / scaleFactor).copyWithRounding (*this);
        return *this;
    }


    template <typename FloatType>
    Rectangle operator/= (Point<FloatType> scaleFactor) noexcept
    {
        Rectangle<FloatType> (pos.x / scaleFactor.x,
                              pos.y / scaleFactor.y,
                              w / scaleFactor.x,
                              h / scaleFactor.y).copyWithRounding (*this);
        return *this;
    }






    void expand (ValueType deltaX,
                 ValueType deltaY) noexcept
    {
        const ValueType nw = jmax (ValueType(), w + deltaX * 2);
        const ValueType nh = jmax (ValueType(), h + deltaY * 2);
        setBounds (pos.x - deltaX, pos.y - deltaY, nw, nh);
    }






    Rectangle expanded (ValueType deltaX,
                        ValueType deltaY) const noexcept
    {
        const ValueType nw = jmax (ValueType(), w + deltaX * 2);
        const ValueType nh = jmax (ValueType(), h + deltaY * 2);
        return Rectangle (pos.x - deltaX, pos.y - deltaY, nw, nh);
    }






    Rectangle expanded (ValueType delta) const noexcept
    {
        return expanded (delta, delta);
    }






    void reduce (ValueType deltaX,
                 ValueType deltaY) noexcept
    {
        expand (-deltaX, -deltaY);
    }






    Rectangle reduced (ValueType deltaX,
                       ValueType deltaY) const noexcept
    {
        return expanded (-deltaX, -deltaY);
    }






    Rectangle reduced (ValueType delta) const noexcept
    {
        return reduced (delta, delta);
    }
# 490 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Rectangle.h"
    Rectangle removeFromTop (ValueType amountToRemove) noexcept
    {
        const Rectangle r (pos.x, pos.y, w, jmin (amountToRemove, h));
        pos.y += r.h; h -= r.h;
        return r;
    }
# 506 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Rectangle.h"
    Rectangle removeFromLeft (ValueType amountToRemove) noexcept
    {
        const Rectangle r (pos.x, pos.y, jmin (amountToRemove, w), h);
        pos.x += r.w; w -= r.w;
        return r;
    }
# 522 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Rectangle.h"
    Rectangle removeFromRight (ValueType amountToRemove) noexcept
    {
        amountToRemove = jmin (amountToRemove, w);
        const Rectangle r (pos.x + w - amountToRemove, pos.y, amountToRemove, h);
        w -= amountToRemove;
        return r;
    }
# 539 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Rectangle.h"
    Rectangle removeFromBottom (ValueType amountToRemove) noexcept
    {
        amountToRemove = jmin (amountToRemove, h);
        const Rectangle r (pos.x, pos.y + h - amountToRemove, w, amountToRemove);
        h -= amountToRemove;
        return r;
    }



    Point<ValueType> getConstrainedPoint (Point<ValueType> point) const noexcept
    {
        return Point<ValueType> (jlimit (pos.x, pos.x + w, point.x),
                                 jlimit (pos.y, pos.y + h, point.y));
    }






    template <typename FloatType>
    Point<ValueType> getRelativePoint (FloatType relativeX, FloatType relativeY) const noexcept
    {
        return Point<ValueType> (pos.x + static_cast<ValueType> (w * relativeX),
                                 pos.y + static_cast<ValueType> (h * relativeY));
    }


    template <typename FloatType>
    ValueType proportionOfWidth (FloatType proportion) const noexcept
    {
        return static_cast<ValueType> (w * proportion);
    }


    template <typename FloatType>
    ValueType proportionOfHeight (FloatType proportion) const noexcept
    {
        return static_cast<ValueType> (h * proportion);
    }





    template <typename FloatType>
    Rectangle getProportion (Rectangle<FloatType> proportionalRect) const noexcept
    {
        return Rectangle (pos.x + static_cast<ValueType> (w * proportionalRect.pos.x),
                          pos.y + static_cast<ValueType> (h * proportionalRect.pos.y),
                          proportionOfWidth (proportionalRect.w),
                          proportionOfHeight (proportionalRect.h));
    }



    bool operator== (const Rectangle& other) const noexcept { return pos == other.pos && w == other.w && h == other.h; }


    bool operator!= (const Rectangle& other) const noexcept { return pos != other.pos || w != other.w || h != other.h; }


    bool contains (ValueType xCoord, ValueType yCoord) const noexcept
    {
        return xCoord >= pos.x && yCoord >= pos.y && xCoord < pos.x + w && yCoord < pos.y + h;
    }


    bool contains (Point<ValueType> point) const noexcept
    {
        return point.x >= pos.x && point.y >= pos.y && point.x < pos.x + w && point.y < pos.y + h;
    }


    bool contains (const Rectangle& other) const noexcept
    {
        return pos.x <= other.pos.x && pos.y <= other.pos.y
            && pos.x + w >= other.pos.x + other.w && pos.y + h >= other.pos.y + other.h;
    }


    bool intersects (const Rectangle& other) const noexcept
    {
        return pos.x + w > other.pos.x
            && pos.y + h > other.pos.y
            && pos.x < other.pos.x + other.w
            && pos.y < other.pos.y + other.h
            && w > ValueType() && h > ValueType()
            && other.w > ValueType() && other.h > ValueType();
    }


    bool intersects (const Line<ValueType>& line) const noexcept
    {
        return contains (line.getStart()) || contains (line.getEnd())
                || line.intersects (Line<ValueType> (getTopLeft(), getTopRight()))
                || line.intersects (Line<ValueType> (getTopRight(), getBottomRight()))
                || line.intersects (Line<ValueType> (getBottomRight(), getBottomLeft()))
                || line.intersects (Line<ValueType> (getBottomLeft(), getTopLeft()));
    }




    Rectangle getIntersection (const Rectangle& other) const noexcept
    {
        const ValueType nx = jmax (pos.x, other.pos.x);
        const ValueType ny = jmax (pos.y, other.pos.y);
        const ValueType nw = jmin (pos.x + w, other.pos.x + other.w) - nx;
        const ValueType nh = jmin (pos.y + h, other.pos.y + other.h) - ny;

        if (nw >= ValueType() && nh >= ValueType())
            return Rectangle (nx, ny, nw, nh);

        return Rectangle();
    }





    bool intersectRectangle (ValueType& otherX, ValueType& otherY, ValueType& otherW, ValueType& otherH) const noexcept
    {
        const ValueType maxX (jmax (otherX, pos.x));
        otherW = jmin (otherX + otherW, pos.x + w) - maxX;

        if (otherW > ValueType())
        {
            const ValueType maxY (jmax (otherY, pos.y));
            otherH = jmin (otherY + otherH, pos.y + h) - maxY;

            if (otherH > ValueType())
            {
                otherX = maxX; otherY = maxY;
                return true;
            }
        }

        return false;
    }




    bool intersectRectangle (Rectangle<ValueType>& rectangleToClip) const noexcept
    {
        return intersectRectangle (rectangleToClip.pos.x, rectangleToClip.pos.y,
                                   rectangleToClip.w, rectangleToClip.h);
    }






    Rectangle getUnion (const Rectangle& other) const noexcept
    {
        if (other.isEmpty()) return *this;
        if (isEmpty()) return other;

        const ValueType newX = jmin (pos.x, other.pos.x);
        const ValueType newY = jmin (pos.y, other.pos.y);

        return Rectangle (newX, newY,
                          jmax (pos.x + w, other.pos.x + other.w) - newX,
                          jmax (pos.y + h, other.pos.y + other.h) - newY);
    }







    bool enlargeIfAdjacent (const Rectangle& other) noexcept
    {
        if (pos.x == other.pos.x && getRight() == other.getRight()
             && (other.getBottom() >= pos.y && other.pos.y <= getBottom()))
        {
            const ValueType newY = jmin (pos.y, other.pos.y);
            h = jmax (getBottom(), other.getBottom()) - newY;
            pos.y = newY;
            return true;
        }

        if (pos.y == other.pos.y && getBottom() == other.getBottom()
             && (other.getRight() >= pos.x && other.pos.x <= getRight()))
        {
            const ValueType newX = jmin (pos.x, other.pos.x);
            w = jmax (getRight(), other.getRight()) - newX;
            pos.x = newX;
            return true;
        }

        return false;
    }







    bool reduceIfPartlyContainedIn (const Rectangle& other) noexcept
    {
        int inside = 0;
        const ValueType otherR (other.getRight());
        if (pos.x >= other.pos.x && pos.x < otherR) inside = 1;
        const ValueType otherB (other.getBottom());
        if (pos.y >= other.pos.y && pos.y < otherB) inside |= 2;
        const ValueType r (pos.x + w);
        if (r >= other.pos.x && r < otherR) inside |= 4;
        const ValueType b (pos.y + h);
        if (b >= other.pos.y && b < otherB) inside |= 8;

        switch (inside)
        {
            case 1 + 2 + 8: w = r - otherR; pos.x = otherR; return true;
            case 1 + 2 + 4: h = b - otherB; pos.y = otherB; return true;
            case 2 + 4 + 8: w = other.pos.x - pos.x; return true;
            case 1 + 4 + 8: h = other.pos.y - pos.y; return true;
        }

        return false;
    }
# 773 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Rectangle.h"
    Rectangle constrainedWithin (const Rectangle& areaToFitWithin) const noexcept
    {
        const ValueType newW (jmin (w, areaToFitWithin.getWidth()));
        const ValueType newH (jmin (h, areaToFitWithin.getHeight()));

        return Rectangle (jlimit (areaToFitWithin.getX(), areaToFitWithin.getRight() - newW, pos.x),
                          jlimit (areaToFitWithin.getY(), areaToFitWithin.getBottom() - newH, pos.y),
                          newW, newH);
    }






    Rectangle transformedBy (const AffineTransform& transform) const noexcept
    {
        typedef typename TypeHelpers::SmallestFloatType<ValueType>::type FloatType;

        FloatType x1 = static_cast<FloatType> (pos.x), y1 = static_cast<FloatType> (pos.y);
        FloatType x2 = static_cast<FloatType> (pos.x + w), y2 = static_cast<FloatType> (pos.y);
        FloatType x3 = static_cast<FloatType> (pos.x), y3 = static_cast<FloatType> (pos.y + h);
        FloatType x4 = static_cast<FloatType> (x2), y4 = static_cast<FloatType> (y3);

        transform.transformPoints (x1, y1, x2, y2);
        transform.transformPoints (x3, y3, x4, y4);

        const FloatType rx1 = jmin (x1, x2, x3, x4);
        const FloatType rx2 = jmax (x1, x2, x3, x4);
        const FloatType ry1 = jmin (y1, y2, y3, y4);
        const FloatType ry2 = jmax (y1, y2, y3, y4);

        Rectangle r;
        Rectangle<FloatType> (rx1, ry1, rx2 - rx1, ry2 - ry1).copyWithRounding (r);
        return r;
    }





    Rectangle<int> getSmallestIntegerContainer() const noexcept
    {
        const int x1 = floorAsInt (pos.x);
        const int y1 = floorAsInt (pos.y);
        const int x2 = ceilAsInt (pos.x + w);
        const int y2 = ceilAsInt (pos.y + h);

        return Rectangle<int> (x1, y1, x2 - x1, y2 - y1);
    }






    Rectangle<int> toNearestInt() const noexcept
    {
        return Rectangle<int> (roundToInt (pos.x), roundToInt (pos.y),
                               roundToInt (w), roundToInt (h));
    }




    Rectangle<float> toFloat() const noexcept
    {
        return Rectangle<float> (static_cast<float> (pos.x), static_cast<float> (pos.y),
                                 static_cast<float> (w), static_cast<float> (h));
    }




    Rectangle<double> toDouble() const noexcept
    {
        return Rectangle<double> (static_cast<double> (pos.x), static_cast<double> (pos.y),
                                  static_cast<double> (w), static_cast<double> (h));
    }





    template <typename TargetType>
    Rectangle<TargetType> toType() const noexcept
    {
        Rectangle<TargetType> r;
        copyWithRounding (r);
        return r;
    }


    static Rectangle findAreaContainingPoints (const Point<ValueType>* const points, const int numPoints) noexcept
    {
        if (numPoints == 0)
            return Rectangle();

        ValueType minX (points[0].x);
        ValueType maxX (minX);
        ValueType minY (points[0].y);
        ValueType maxY (minY);

        for (int i = 1; i < numPoints; ++i)
        {
            minX = jmin (minX, points[i].x);
            maxX = jmax (maxX, points[i].x);
            minY = jmin (minY, points[i].y);
            maxY = jmax (maxY, points[i].y);
        }

        return Rectangle (minX, minY, maxX - minX, maxY - minY);
    }






    static bool intersectRectangles (ValueType& x1, ValueType& y1, ValueType& w1, ValueType& h1,
                                     const ValueType x2, const ValueType y2, const ValueType w2, const ValueType h2) noexcept
    {
        const ValueType x (jmax (x1, x2));
        w1 = jmin (x1 + w1, x2 + w2) - x;

        if (w1 > ValueType())
        {
            const ValueType y (jmax (y1, y2));
            h1 = jmin (y1 + h1, y2 + h2) - y;

            if (h1 > ValueType())
            {
                x1 = x; y1 = y;
                return true;
            }
        }

        return false;
    }
# 923 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Rectangle.h"
    String toString() const
    {
        String s;
        s.preallocateBytes (32);
        s << pos.x << ' ' << pos.y << ' ' << w << ' ' << h;
        return s;
    }
# 941 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Rectangle.h"
    static Rectangle fromString (StringRef stringVersion)
    {
        StringArray toks;
        toks.addTokens (stringVersion.text.findEndOfWhitespace(), ",; \t\r\n", "");

        return Rectangle (parseIntAfterSpace (toks[0]),
                          parseIntAfterSpace (toks[1]),
                          parseIntAfterSpace (toks[2]),
                          parseIntAfterSpace (toks[3]));
    }



    __declspec(deprecated) Rectangle transformed (const AffineTransform& t) const noexcept { return transformedBy (t); }


private:
    template <typename OtherType> friend class Rectangle;

    Point<ValueType> pos;
    ValueType w, h;

    static ValueType parseIntAfterSpace (StringRef s) noexcept
        { return static_cast<ValueType> (s.text.findEndOfWhitespace().getIntValue32()); }

    void copyWithRounding (Rectangle<int>& result) const noexcept { result = getSmallestIntegerContainer(); }
    void copyWithRounding (Rectangle<float>& result) const noexcept { result = toFloat(); }
    void copyWithRounding (Rectangle<double>& result) const noexcept { result = toDouble(); }

    static int floorAsInt (int n) noexcept { return n; }
    static int floorAsInt (float n) noexcept { return (int) std::floor (n); }
    static int floorAsInt (double n) noexcept { return (int) std::floor (n); }
    static int ceilAsInt (int n) noexcept { return n; }
    static int ceilAsInt (float n) noexcept { return (int) std::ceil (n); }
    static int ceilAsInt (double n) noexcept { return (int) std::ceil (n); }
};
# 105 "..\\..\\..\\JUCE\\modules\\juce_graphics/juce_graphics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_graphics/placement/juce_Justification.h" 1
# 38 "..\\..\\..\\JUCE\\modules\\juce_graphics/placement/juce_Justification.h"
class Justification
{
public:


    Justification (int justificationFlags) noexcept : flags (justificationFlags) {}


    Justification (const Justification& other) noexcept : flags (other.flags) {}


    Justification& operator= (const Justification& other) noexcept
    {
        flags = other.flags;
        return *this;
    }

    bool operator== (const Justification& other) const noexcept { return flags == other.flags; }
    bool operator!= (const Justification& other) const noexcept { return flags != other.flags; }



    inline int getFlags() const noexcept { return flags; }




    inline bool testFlags (int flagsToTest) const noexcept { return (flags & flagsToTest) != 0; }


    int getOnlyVerticalFlags() const noexcept { return flags & (top | bottom | verticallyCentred); }


    int getOnlyHorizontalFlags() const noexcept { return flags & (left | right | horizontallyCentred | horizontallyJustified); }







    template <typename ValueType>
    void applyToRectangle (ValueType& x, ValueType& y, ValueType w, ValueType h,
                           ValueType spaceX, ValueType spaceY, ValueType spaceW, ValueType spaceH) const noexcept
    {
        x = spaceX;
        if ((flags & horizontallyCentred) != 0) x += (spaceW - w) / (ValueType) 2;
        else if ((flags & right) != 0) x += spaceW - w;

        y = spaceY;
        if ((flags & verticallyCentred) != 0) y += (spaceH - h) / (ValueType) 2;
        else if ((flags & bottom) != 0) y += spaceH - h;
    }



    template <typename ValueType>
    const Rectangle<ValueType> appliedToRectangle (const Rectangle<ValueType>& areaToAdjust,
                                                   const Rectangle<ValueType>& targetSpace) const noexcept
    {
        ValueType x = areaToAdjust.getX(), y = areaToAdjust.getY();
        applyToRectangle (x, y, areaToAdjust.getWidth(), areaToAdjust.getHeight(),
                          targetSpace.getX(), targetSpace.getY(), targetSpace.getWidth(), targetSpace.getHeight());
        return areaToAdjust.withPosition (x, y);
    }



    enum Flags
    {


        left = 1,


        right = 2,



        horizontallyCentred = 4,



        top = 8,


        bottom = 16,



        verticallyCentred = 32,





        horizontallyJustified = 64,





        centred = 36,




        centredLeft = 33,




        centredRight = 34,




        centredTop = 12,




        centredBottom = 20,




        topLeft = 9,




        topRight = 10,




        bottomLeft = 17,




        bottomRight = 18
    };


private:

    int flags;
};
# 106 "..\\..\\..\\JUCE\\modules\\juce_graphics/juce_graphics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Path.h" 1
# 62 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Path.h"
class Path
{
public:


    Path();


    Path (const Path&);


    ~Path();


    Path& operator= (const Path&);


    Path (Path&&) noexcept;
    Path& operator= (Path&&) noexcept;


    bool operator== (const Path&) const noexcept;
    bool operator!= (const Path&) const noexcept;

    static const float defaultToleranceForTesting;
    static const float defaultToleranceForMeasurement;



    bool isEmpty() const noexcept;


    Rectangle<float> getBounds() const noexcept;




    Rectangle<float> getBoundsTransformed (const AffineTransform& transform) const noexcept;
# 114 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Path.h"
    bool contains (float x, float y,
                   float tolerance = defaultToleranceForTesting) const;
# 130 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Path.h"
    bool contains (const Point<float> point,
                   float tolerance = defaultToleranceForTesting) const;
# 143 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Path.h"
    bool intersectsLine (Line<float> line,
                         float tolerance = defaultToleranceForTesting);
# 158 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Path.h"
    Line<float> getClippedLine (Line<float> line, bool keepSectionOutsidePath) const;




    float getLength (const AffineTransform& transform = AffineTransform(),
                     float tolerance = defaultToleranceForMeasurement) const;






    Point<float> getPointAlongPath (float distanceFromStart,
                                    const AffineTransform& transform = AffineTransform(),
                                    float tolerance = defaultToleranceForMeasurement) const;





    float getNearestPoint (Point<float> targetPoint,
                           Point<float>& pointOnPath,
                           const AffineTransform& transform = AffineTransform(),
                           float tolerance = defaultToleranceForMeasurement) const;



    void clear() noexcept;
# 199 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Path.h"
    void startNewSubPath (float startX, float startY);
# 212 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Path.h"
    void startNewSubPath (const Point<float> start);
# 226 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Path.h"
    void closeSubPath();
# 237 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Path.h"
    void lineTo (float endX, float endY);
# 248 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Path.h"
    void lineTo (const Point<float> end);
# 259 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Path.h"
    void quadraticTo (float controlPointX,
                      float controlPointY,
                      float endPointX,
                      float endPointY);
# 273 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Path.h"
    void quadraticTo (const Point<float> controlPoint,
                      const Point<float> endPoint);
# 285 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Path.h"
    void cubicTo (float controlPoint1X,
                  float controlPoint1Y,
                  float controlPoint2X,
                  float controlPoint2Y,
                  float endPointX,
                  float endPointY);
# 301 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Path.h"
    void cubicTo (const Point<float> controlPoint1,
                  const Point<float> controlPoint2,
                  const Point<float> endPoint);



    Point<float> getCurrentPosition() const;






    void addRectangle (float x, float y, float width, float height);





    template <typename ValueType>
    void addRectangle (const Rectangle<ValueType>& rectangle)
    {
        addRectangle (static_cast<float> (rectangle.getX()), static_cast<float> (rectangle.getY()),
                      static_cast<float> (rectangle.getWidth()), static_cast<float> (rectangle.getHeight()));
    }





    void addRoundedRectangle (float x, float y, float width, float height,
                              float cornerSize);





    void addRoundedRectangle (float x, float y, float width, float height,
                              float cornerSizeX,
                              float cornerSizeY);





    void addRoundedRectangle (float x, float y, float width, float height,
                              float cornerSizeX, float cornerSizeY,
                              bool curveTopLeft, bool curveTopRight,
                              bool curveBottomLeft, bool curveBottomRight);





    template <typename ValueType>
    void addRoundedRectangle (const Rectangle<ValueType>& rectangle, float cornerSizeX, float cornerSizeY)
    {
        addRoundedRectangle (static_cast<float> (rectangle.getX()), static_cast<float> (rectangle.getY()),
                             static_cast<float> (rectangle.getWidth()), static_cast<float> (rectangle.getHeight()),
                             cornerSizeX, cornerSizeY);
    }





    template <typename ValueType>
    void addRoundedRectangle (const Rectangle<ValueType>& rectangle, float cornerSize)
    {
        addRoundedRectangle (rectangle, cornerSize, cornerSize);
    }
# 381 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Path.h"
    void addTriangle (float x1, float y1,
                      float x2, float y2,
                      float x3, float y3);
# 393 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Path.h"
    void addTriangle (Point<float> point1,
                      Point<float> point2,
                      Point<float> point3);
# 405 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Path.h"
    void addQuadrilateral (float x1, float y1,
                           float x2, float y2,
                           float x3, float y3,
                           float x4, float y4);





    void addEllipse (float x, float y, float width, float height);





    void addEllipse (Rectangle<float> area);
# 443 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Path.h"
    void addArc (float x, float y, float width, float height,
                 float fromRadians,
                 float toRadians,
                 bool startAsNewSubPath = false);
# 470 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Path.h"
    void addCentredArc (float centreX, float centreY,
                        float radiusX, float radiusY,
                        float rotationOfEllipse,
                        float fromRadians,
                        float toRadians,
                        bool startAsNewSubPath = false);
# 499 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Path.h"
    void addPieSegment (float x, float y,
                        float width, float height,
                        float fromRadians,
                        float toRadians,
                        float innerCircleProportionalSize);
# 523 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Path.h"
    void addPieSegment (Rectangle<float> segmentBounds,
                        float fromRadians,
                        float toRadians,
                        float innerCircleProportionalSize);
# 535 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Path.h"
    void addLineSegment (const Line<float>& line, float lineThickness);





    void addArrow (const Line<float>& line,
                   float lineThickness,
                   float arrowheadWidth,
                   float arrowheadLength);




    void addPolygon (const Point<float> centre,
                     int numberOfSides,
                     float radius,
                     float startAngle = 0.0f);




    void addStar (const Point<float> centre,
                  int numberOfPoints,
                  float innerRadius,
                  float outerRadius,
                  float startAngle = 0.0f);
# 573 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Path.h"
    void addBubble (const Rectangle<float>& bodyArea,
                    const Rectangle<float>& maximumArea,
                    const Point<float> arrowTipPosition,
                    const float cornerSize,
                    const float arrowBaseWidth);
# 586 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Path.h"
    void addPath (const Path& pathToAppend);
# 596 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Path.h"
    void addPath (const Path& pathToAppend,
                  const AffineTransform& transformToApply);






    void swapWithPath (Path&) noexcept;
# 616 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Path.h"
    void preallocateSpace (int numExtraCoordsToMakeSpaceFor);






    void applyTransform (const AffineTransform& transform) noexcept;
# 640 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Path.h"
    void scaleToFit (float x, float y, float width, float height,
                     bool preserveProportions) noexcept;
# 660 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Path.h"
    AffineTransform getTransformToScaleToFit (float x, float y, float width, float height,
                                              bool preserveProportions,
                                              Justification justificationType = Justification::centred) const;
# 678 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Path.h"
    AffineTransform getTransformToScaleToFit (const Rectangle<float>& area,
                                              bool preserveProportions,
                                              Justification justificationType = Justification::centred) const;






    Path createPathWithRoundedCorners (float cornerRadius) const;
# 705 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Path.h"
    void setUsingNonZeroWinding (bool isNonZeroWinding) noexcept;







    bool isUsingNonZeroWinding() const { return useNonZeroWinding; }







    class Iterator
    {
    public:

        Iterator (const Path& path) noexcept;
        ~Iterator() noexcept;
# 735 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Path.h"
        bool next() noexcept;


        enum PathElementType
        {
            startNewSubPath,
            lineTo,
            quadraticTo,
            cubicTo,
            closePath
        };

        PathElementType elementType;

        float x1, y1, x2, y2, x3, y3;


    private:
        const Path& path;
        size_t index;

        Iterator (const Iterator&) = delete; Iterator& operator= (const Iterator&) = delete;
    };
# 769 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Path.h"
    void loadPathFromStream (InputStream& source);
# 779 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_Path.h"
    void loadPathFromData (const void* data, size_t numberOfBytes);







    void writePathToStream (OutputStream& destination) const;





    String toString() const;




    void restoreFromString (StringRef stringVersion);

private:

    friend class PathFlatteningIterator;
    friend class Path::Iterator;
    ArrayAllocationBase<float, DummyCriticalSection> data;
    size_t numElements;

    struct PathBounds
    {
        PathBounds() noexcept;
        Rectangle<float> getRectangle() const noexcept;
        void reset() noexcept;
        void reset (float, float) noexcept;
        void extend (float, float) noexcept;
        void extend (float, float, float, float) noexcept;

        float pathXMin, pathXMax, pathYMin, pathYMax;
    };

    PathBounds bounds;
    bool useNonZeroWinding;

    static const float lineMarker;
    static const float moveMarker;
    static const float quadMarker;
    static const float cubicMarker;
    static const float closeSubPathMarker;


};
# 107 "..\\..\\..\\JUCE\\modules\\juce_graphics/juce_graphics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_RectangleList.h" 1
# 39 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_RectangleList.h"
template <typename ValueType>
class RectangleList
{
public:
    typedef Rectangle<ValueType> RectangleType;



    RectangleList() noexcept {}


    RectangleList (const RectangleList& other) : rects (other.rects)
    {
    }


    RectangleList (const RectangleType& rect)
    {
        addWithoutMerging (rect);
    }


    RectangleList& operator= (const RectangleList& other)
    {
        rects = other.rects;
        return *this;
    }


    RectangleList (RectangleList&& other) noexcept
        : rects (static_cast<Array<RectangleType>&&> (other.rects))
    {
    }

    RectangleList& operator= (RectangleList&& other) noexcept
    {
        rects = static_cast<Array<RectangleType>&&> (other.rects);
        return *this;
    }




    bool isEmpty() const noexcept { return rects.size() == 0; }


    int getNumRectangles() const noexcept { return rects.size(); }




    RectangleType getRectangle (int index) const noexcept { return rects[index]; }



    void clear()
    {
        rects.clearQuick();
    }
# 108 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_RectangleList.h"
    void add (const RectangleType& rect)
    {
#pragma warning(push)
# 110 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_RectangleList.h"
#pragma warning(disable: 4127)
# 110 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_RectangleList.h"
 do { ; } while (false)
# 110 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_RectangleList.h"
#pragma warning(pop)
# 110 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_RectangleList.h"
;

        if (! rect.isEmpty())
        {
            if (rects.size() == 0)
            {
                rects.add (rect);
            }
            else
            {
                bool anyOverlaps = false;

                for (int j = rects.size(); --j >= 0;)
                {
                    RectangleType& ourRect = rects.getReference (j);

                    if (rect.intersects (ourRect))
                    {
                        if (rect.contains (ourRect))
                            rects.remove (j);
                        else if (! ourRect.reduceIfPartlyContainedIn (rect))
                            anyOverlaps = true;
                    }
                }

                if (anyOverlaps && rects.size() > 0)
                {
                    RectangleList r (rect);

                    for (int i = rects.size(); --i >= 0;)
                    {
                        const RectangleType& ourRect = rects.getReference (i);

                        if (rect.intersects (ourRect))
                        {
                            r.subtract (ourRect);

                            if (r.rects.size() == 0)
                                return;
                        }
                    }

                    rects.addArray (r.rects);
                }
                else
                {
                    rects.add (rect);
                }
            }
        }
    }






    void add (ValueType x, ValueType y, ValueType width, ValueType height)
    {
        add (RectangleType (x, y, width, height));
    }
# 180 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_RectangleList.h"
    void addWithoutMerging (const RectangleType& rect)
    {
#pragma warning(push)
# 182 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_RectangleList.h"
#pragma warning(disable: 4127)
# 182 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_RectangleList.h"
 do { ; } while (false)
# 182 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_RectangleList.h"
#pragma warning(pop)
# 182 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_RectangleList.h"
;

        if (! rect.isEmpty())
            rects.add (rect);
    }






    void add (const RectangleList& other)
    {
        for (const RectangleType* r = other.begin(), * const e = other.end(); r != e; ++r)
            add (*r);
    }






    void subtract (const RectangleType& rect)
    {
        const int originalNumRects = rects.size();

        if (originalNumRects > 0)
        {
            const ValueType x1 = rect.getX();
            const ValueType y1 = rect.getY();
            const ValueType x2 = x1 + rect.getWidth();
            const ValueType y2 = y1 + rect.getHeight();

            for (int i = getNumRectangles(); --i >= 0;)
            {
                RectangleType& r = rects.getReference (i);

                const ValueType rx1 = r.getX();
                const ValueType ry1 = r.getY();
                const ValueType rx2 = rx1 + r.getWidth();
                const ValueType ry2 = ry1 + r.getHeight();

                if (! (x2 <= rx1 || x1 >= rx2 || y2 <= ry1 || y1 >= ry2))
                {
                    if (x1 > rx1 && x1 < rx2)
                    {
                        if (y1 <= ry1 && y2 >= ry2 && x2 >= rx2)
                        {
                            r.setWidth (x1 - rx1);
                        }
                        else
                        {
                            r.setX (x1);
                            r.setWidth (rx2 - x1);

                            rects.insert (++i, RectangleType (rx1, ry1, x1 - rx1, ry2 - ry1));
                            ++i;
                        }
                    }
                    else if (x2 > rx1 && x2 < rx2)
                    {
                        r.setX (x2);
                        r.setWidth (rx2 - x2);

                        if (y1 > ry1 || y2 < ry2 || x1 > rx1)
                        {
                            rects.insert (++i, RectangleType (rx1, ry1, x2 - rx1, ry2 - ry1));
                            ++i;
                        }
                    }
                    else if (y1 > ry1 && y1 < ry2)
                    {
                        if (x1 <= rx1 && x2 >= rx2 && y2 >= ry2)
                        {
                            r.setHeight (y1 - ry1);
                        }
                        else
                        {
                            r.setY (y1);
                            r.setHeight (ry2 - y1);

                            rects.insert (++i, RectangleType (rx1, ry1, rx2 - rx1, y1 - ry1));
                            ++i;
                        }
                    }
                    else if (y2 > ry1 && y2 < ry2)
                    {
                        r.setY (y2);
                        r.setHeight (ry2 - y2);

                        if (x1 > rx1 || x2 < rx2 || y1 > ry1)
                        {
                            rects.insert (++i, RectangleType (rx1, ry1, rx2 - rx1, y2 - ry1));
                            ++i;
                        }
                    }
                    else
                    {
                        rects.remove (i);
                    }
                }
            }
        }
    }
# 294 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_RectangleList.h"
    bool subtract (const RectangleList& otherList)
    {
        for (int i = otherList.rects.size(); --i >= 0 && rects.size() > 0;)
            subtract (otherList.rects.getReference (i));

        return rects.size() > 0;
    }
# 311 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_RectangleList.h"
    bool clipTo (const RectangleType& rect)
    {
#pragma warning(push)
# 313 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_RectangleList.h"
#pragma warning(disable: 4127)
# 313 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_RectangleList.h"
 do { ; } while (false)
# 313 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_RectangleList.h"
#pragma warning(pop)
# 313 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_RectangleList.h"
;

        bool notEmpty = false;

        if (rect.isEmpty())
        {
            clear();
        }
        else
        {
            for (int i = rects.size(); --i >= 0;)
            {
                RectangleType& r = rects.getReference (i);

                if (! rect.intersectRectangle (r))
                    rects.remove (i);
                else
                    notEmpty = true;
            }
        }

        return notEmpty;
    }
# 346 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_RectangleList.h"
    template <typename OtherValueType>
    bool clipTo (const RectangleList<OtherValueType>& other)
    {
        if (rects.size() == 0)
            return false;

        RectangleList result;

        for (int j = 0; j < rects.size(); ++j)
        {
            const RectangleType& rect = rects.getReference (j);

            for (const Rectangle<OtherValueType>* r = other.begin(), * const e = other.end(); r != e; ++r)
            {
                RectangleType clipped (r->template toType<ValueType>());

                if (rect.intersectRectangle (clipped))
                    result.rects.add (clipped);
            }
        }

        swapWith (result);
        return ! isEmpty();
    }
# 380 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_RectangleList.h"
    bool getIntersectionWith (const RectangleType& rect, RectangleList& destRegion) const
    {
#pragma warning(push)
# 382 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_RectangleList.h"
#pragma warning(disable: 4127)
# 382 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_RectangleList.h"
 do { ; } while (false)
# 382 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_RectangleList.h"
#pragma warning(pop)
# 382 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_RectangleList.h"
;

        destRegion.clear();

        if (! rect.isEmpty())
        {
            for (int i = rects.size(); --i >= 0;)
            {
                RectangleType r (rects.getReference (i));

                if (rect.intersectRectangle (r))
                    destRegion.rects.add (r);
            }
        }

        return destRegion.rects.size() > 0;
    }






    void swapWith (RectangleList& otherList) noexcept
    {
        rects.swapWith (otherList.rects);
    }





    bool containsPoint (Point<ValueType> point) const noexcept
    {
        for (const RectangleType* r = rects.begin(), * const e = rects.end(); r != e; ++r)
            if (r->contains (point))
                return true;

        return false;
    }




    bool containsPoint (ValueType x, ValueType y) const noexcept
    {
        return containsPoint (Point<ValueType> (x, y));
    }







    bool containsRectangle (const RectangleType& rectangleToCheck) const
    {
        if (rects.size() > 1)
        {
            RectangleList r (rectangleToCheck);

            for (int i = rects.size(); --i >= 0;)
            {
                r.subtract (rects.getReference (i));

                if (r.rects.size() == 0)
                    return true;
            }
        }
        else if (rects.size() > 0)
        {
            return rects.getReference (0).contains (rectangleToCheck);
        }

        return false;
    }







    bool intersectsRectangle (const RectangleType& rectangleToCheck) const noexcept
    {
        for (const RectangleType* r = rects.begin(), * const e = rects.end(); r != e; ++r)
            if (r->intersects (rectangleToCheck))
                return true;

        return false;
    }





    bool intersects (const RectangleList& other) const noexcept
    {
        for (const RectangleType* r = rects.begin(), * const e = rects.end(); r != e; ++r)
            if (other.intersectsRectangle (*r))
                return true;

        return false;
    }



    RectangleType getBounds() const noexcept
    {
        if (rects.size() <= 1)
        {
            if (rects.size() == 0)
                return RectangleType();

            return rects.getReference (0);
        }

        const RectangleType& r = rects.getReference (0);

        ValueType minX = r.getX();
        ValueType minY = r.getY();
        ValueType maxX = minX + r.getWidth();
        ValueType maxY = minY + r.getHeight();

        for (int i = rects.size(); --i > 0;)
        {
            const RectangleType& r2 = rects.getReference (i);

            minX = jmin (minX, r2.getX());
            minY = jmin (minY, r2.getY());
            maxX = jmax (maxX, r2.getRight());
            maxY = jmax (maxY, r2.getBottom());
        }

        return RectangleType (minX, minY, maxX - minX, maxY - minY);
    }







    void consolidate()
    {
        for (int i = 0; i < rects.size() - 1; ++i)
        {
            RectangleType& r = rects.getReference (i);
            const ValueType rx1 = r.getX();
            const ValueType ry1 = r.getY();
            const ValueType rx2 = rx1 + r.getWidth();
            const ValueType ry2 = ry1 + r.getHeight();

            for (int j = rects.size(); --j > i;)
            {
                RectangleType& r2 = rects.getReference (j);
                const ValueType jrx1 = r2.getX();
                const ValueType jry1 = r2.getY();
                const ValueType jrx2 = jrx1 + r2.getWidth();
                const ValueType jry2 = jry1 + r2.getHeight();



                if (jrx1 == rx2 || jrx2 == rx1)
                {
                    if (jry1 > ry1 && jry1 < ry2)
                    {
                        r.setHeight (jry1 - ry1);
                        rects.add (RectangleType (rx1, jry1, rx2 - rx1, ry2 - jry1));
                        i = -1;
                        break;
                    }

                    if (jry2 > ry1 && jry2 < ry2)
                    {
                        r.setHeight (jry2 - ry1);
                        rects.add (RectangleType (rx1, jry2, rx2 - rx1, ry2 - jry2));
                        i = -1;
                        break;
                    }
                    else if (ry1 > jry1 && ry1 < jry2)
                    {
                        r2.setHeight (ry1 - jry1);
                        rects.add (RectangleType (jrx1, ry1, jrx2 - jrx1, jry2 - ry1));
                        i = -1;
                        break;
                    }
                    else if (ry2 > jry1 && ry2 < jry2)
                    {
                        r2.setHeight (ry2 - jry1);
                        rects.add (RectangleType (jrx1, ry2, jrx2 - jrx1, jry2 - ry2));
                        i = -1;
                        break;
                    }
                }
            }
        }

        for (int i = 0; i < rects.size() - 1; ++i)
        {
            RectangleType& r = rects.getReference (i);

            for (int j = rects.size(); --j > i;)
            {
                if (r.enlargeIfAdjacent (rects.getReference (j)))
                {
                    rects.remove (j);
                    i = -1;
                    break;
                }
            }
        }
    }


    void offsetAll (Point<ValueType> offset) noexcept
    {
        for (RectangleType* r = rects.begin(), * const e = rects.end(); r != e; ++r)
            *r += offset;
    }


    void offsetAll (ValueType dx, ValueType dy) noexcept
    {
        offsetAll (Point<ValueType> (dx, dy));
    }


    template <typename ScaleType>
    void scaleAll (ScaleType scaleFactor) noexcept
    {
        for (RectangleType* r = rects.begin(), * const e = rects.end(); r != e; ++r)
            *r *= scaleFactor;
    }





    void transformAll (const AffineTransform& transform) noexcept
    {
        for (RectangleType* r = rects.begin(), * const e = rects.end(); r != e; ++r)
            *r = r->transformedBy (transform);
    }



    Path toPath() const
    {
        Path p;

        for (int i = 0; i < rects.size(); ++i)
            p.addRectangle (rects.getReference (i));

        return p;
    }



    const RectangleType* begin() const noexcept { return rects.begin(); }

    const RectangleType* end() const noexcept { return rects.end(); }







    void ensureStorageAllocated (int minNumRectangles)
    {
        rects.ensureStorageAllocated (minNumRectangles);
    }

private:

    Array<RectangleType> rects;
};
# 108 "..\\..\\..\\JUCE\\modules\\juce_graphics/juce_graphics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_graphics/colour/juce_PixelFormats.h" 1
# 31 "..\\..\\..\\JUCE\\modules\\juce_graphics/colour/juce_PixelFormats.h"
#pragma pack (push, 1)


class PixelRGB;
class PixelAlpha;

inline uint32 maskPixelComponents (uint32 x) noexcept
{
    return (x >> 8) & 0x00ff00ff;
}

inline uint32 clampPixelComponents (uint32 x) noexcept
{
    return (x | (0x01000100 - maskPixelComponents (x))) & 0x00ff00ff;
}
# 56 "..\\..\\..\\JUCE\\modules\\juce_graphics/colour/juce_PixelFormats.h"
class PixelARGB
{
public:

    PixelARGB() noexcept {}
    ~PixelARGB() noexcept {}

    PixelARGB (const uint8 a, const uint8 r, const uint8 g, const uint8 b) noexcept
    {
        components.b = b;
        components.g = g;
        components.r = r;
        components.a = a;
    }



    __forceinline uint32 getNativeARGB() const noexcept { return internal; }



    __forceinline uint32 getInARGBMaskOrder() const noexcept
    {



        return getNativeARGB();

    }



    inline uint32 getInARGBMemoryOrder() const noexcept
    {



        return (uint32) ((components.b << 24) | (components.g << 16) | (components.r << 8) | components.a);

    }



    __forceinline uint32 getEvenBytes() const noexcept { return 0x00ff00ff & internal; }



    __forceinline uint32 getOddBytes() const noexcept { return 0x00ff00ff & (internal >> 8); }


    __forceinline uint8 getAlpha() const noexcept { return components.a; }
    __forceinline uint8 getRed() const noexcept { return components.r; }
    __forceinline uint8 getGreen() const noexcept { return components.g; }
    __forceinline uint8 getBlue() const noexcept { return components.b; }
# 118 "..\\..\\..\\JUCE\\modules\\juce_graphics/colour/juce_PixelFormats.h"
    __forceinline uint8& getAlpha() noexcept { return components.a; }
    __forceinline uint8& getRed() noexcept { return components.r; }
    __forceinline uint8& getGreen() noexcept { return components.g; }
    __forceinline uint8& getBlue() noexcept { return components.b; }







    template <class Pixel>
    __forceinline void set (const Pixel& src) noexcept
    {
        internal = src.getNativeARGB();
    }



    void setARGB (const uint8 a, const uint8 r, const uint8 g, const uint8 b) noexcept
    {
        components.b = b;
        components.g = g;
        components.r = r;
        components.a = a;
    }







    template <class Pixel>
    __forceinline void blend (const Pixel& src) noexcept
    {
        uint32 rb = src.getEvenBytes();
        uint32 ag = src.getOddBytes();

        const uint32 alpha = 0x100 - (ag >> 16);

        rb += maskPixelComponents (getEvenBytes() * alpha);
        ag += maskPixelComponents (getOddBytes() * alpha);

        internal = clampPixelComponents (rb) | (clampPixelComponents (ag) << 8);
    }






    __forceinline void blend (const PixelRGB src) noexcept;







    template <class Pixel>
    __forceinline void blend (const Pixel& src, uint32 extraAlpha) noexcept
    {
        uint32 rb = maskPixelComponents (extraAlpha * src.getEvenBytes());
        uint32 ag = maskPixelComponents (extraAlpha * src.getOddBytes());

        const uint32 alpha = 0x100 - (ag >> 16);

        rb += maskPixelComponents (getEvenBytes() * alpha);
        ag += maskPixelComponents (getOddBytes() * alpha);

        internal = clampPixelComponents (rb) | (clampPixelComponents (ag) << 8);
    }




    template <class Pixel>
    __forceinline void tween (const Pixel& src, const uint32 amount) noexcept
    {
        uint32 dEvenBytes = getEvenBytes();
        dEvenBytes += (((src.getEvenBytes() - dEvenBytes) * amount) >> 8);
        dEvenBytes &= 0x00ff00ff;

        uint32 dOddBytes = getOddBytes();
        dOddBytes += (((src.getOddBytes() - dOddBytes) * amount) >> 8);
        dOddBytes &= 0x00ff00ff;
        dOddBytes <<= 8;

        dOddBytes |= dEvenBytes;
        internal = dOddBytes;
    }



    __forceinline void setAlpha (const uint8 newAlpha) noexcept
    {
        components.a = newAlpha;
    }


    __forceinline void multiplyAlpha (int multiplier) noexcept
    {


        ++multiplier;

        internal = ((((uint32) multiplier) * getOddBytes()) & 0xff00ff00)
                | (((((uint32) multiplier) * getEvenBytes()) >> 8) & 0x00ff00ff);
    }

    __forceinline void multiplyAlpha (const float multiplier) noexcept
    {
        multiplyAlpha ((int) (multiplier * 255.0f));
    }


    inline PixelARGB getUnpremultiplied() const noexcept { PixelARGB p (internal); p.unpremultiply(); return p; }


    __forceinline void premultiply() noexcept
    {
        const uint32 alpha = components.a;

        if (alpha < 0xff)
        {
            if (alpha == 0)
            {
                components.b = 0;
                components.g = 0;
                components.r = 0;
            }
            else
            {
                components.b = (uint8) ((components.b * alpha + 0x7f) >> 8);
                components.g = (uint8) ((components.g * alpha + 0x7f) >> 8);
                components.r = (uint8) ((components.r * alpha + 0x7f) >> 8);
            }
        }
    }


    __forceinline void unpremultiply() noexcept
    {
        const uint32 alpha = components.a;

        if (alpha < 0xff)
        {
            if (alpha == 0)
            {
                components.b = 0;
                components.g = 0;
                components.r = 0;
            }
            else
            {
                components.b = (uint8) jmin ((uint32) 0xffu, (components.b * 0xffu) / alpha);
                components.g = (uint8) jmin ((uint32) 0xffu, (components.g * 0xffu) / alpha);
                components.r = (uint8) jmin ((uint32) 0xffu, (components.r * 0xffu) / alpha);
            }
        }
    }

    __forceinline void desaturate() noexcept
    {
        if (components.a < 0xff && components.a > 0)
        {
            const int newUnpremultipliedLevel = (0xff * ((int) components.r + (int) components.g + (int) components.b) / (3 * components.a));

            components.r = components.g = components.b
                = (uint8) ((newUnpremultipliedLevel * components.a + 0x7f) >> 8);
        }
        else
        {
            components.r = components.g = components.b
                = (uint8) (((int) components.r + (int) components.g + (int) components.b) / 3);
        }
    }
# 309 "..\\..\\..\\JUCE\\modules\\juce_graphics/colour/juce_PixelFormats.h"
    enum { indexA = 3, indexR = 2, indexG = 1, indexB = 0 };



private:

    PixelARGB (const uint32 internalValue) noexcept
        : internal (internalValue)
    {
    }


    struct Components
    {
# 333 "..\\..\\..\\JUCE\\modules\\juce_graphics/colour/juce_PixelFormats.h"
        uint8 b, g, r, a;


    } ;

    union
    {
        uint32 internal;
        Components components;



    };
}



;
# 361 "..\\..\\..\\JUCE\\modules\\juce_graphics/colour/juce_PixelFormats.h"
class PixelRGB
{
public:

    PixelRGB() noexcept {}
    ~PixelRGB() noexcept {}






    __forceinline uint32 getNativeARGB() const noexcept
    {



        return (uint32) ((0xff << 24) | b | (g << 8) | (r << 16));

    }



    __forceinline uint32 getInARGBMaskOrder() const noexcept
    {



        return getNativeARGB();

    }



    inline uint32 getInARGBMemoryOrder() const noexcept
    {



        return (uint32) ((b << 24) | (g << 16) | (r << 8) | 0xff);

    }






    __forceinline uint32 getEvenBytes() const noexcept
    {



        return (uint32) (b | (r << 16));

    }






    __forceinline uint32 getOddBytes() const noexcept { return (uint32)0xff0000 | g; }


    __forceinline uint8 getAlpha() const noexcept { return 0xff; }
    __forceinline uint8 getRed() const noexcept { return r; }
    __forceinline uint8 getGreen() const noexcept { return g; }
    __forceinline uint8 getBlue() const noexcept { return b; }

    __forceinline uint8& getRed() noexcept { return r; }
    __forceinline uint8& getGreen() noexcept { return g; }
    __forceinline uint8& getBlue() noexcept { return b; }
# 442 "..\\..\\..\\JUCE\\modules\\juce_graphics/colour/juce_PixelFormats.h"
    template <class Pixel>
    __forceinline void set (const Pixel& src) noexcept
    {
        b = src.getBlue();
        g = src.getGreen();
        r = src.getRed();
    }


    void setARGB (const uint8, const uint8 red, const uint8 green, const uint8 blue) noexcept
    {
        r = red;
        g = green;
        b = blue;
    }







    template <class Pixel>
    __forceinline void blend (const Pixel& src) noexcept
    {
        const uint32 alpha = (uint32) (0x100 - src.getAlpha());


        uint32 rb = clampPixelComponents (src.getEvenBytes() + maskPixelComponents (getEvenBytes() * alpha));

        uint32 ag = clampPixelComponents (src.getOddBytes() + ((g * alpha) >> 8));

        g = (uint8) (ag & 0xff);





        r = (uint8) (rb >> 16);
        b = (uint8) (rb & 0xff);

    }

    __forceinline void blend (const PixelRGB src) noexcept
    {
        set (src);
    }






    template <class Pixel>
    __forceinline void blend (const Pixel& src, uint32 extraAlpha) noexcept
    {
        uint32 ag = maskPixelComponents (extraAlpha * src.getOddBytes());
        uint32 rb = maskPixelComponents (extraAlpha * src.getEvenBytes());

        const uint32 alpha = 0x100 - (ag >> 16);

        ag = clampPixelComponents (ag + (g * alpha >> 8));
        rb = clampPixelComponents (rb + maskPixelComponents (getEvenBytes() * alpha));

        g = (uint8) (ag & 0xff);





        r = (uint8) (rb >> 16);
        b = (uint8) (rb & 0xff);

    }




    template <class Pixel>
    __forceinline void tween (const Pixel& src, const uint32 amount) noexcept
    {
        uint32 dEvenBytes = getEvenBytes();
        dEvenBytes += (((src.getEvenBytes() - dEvenBytes) * amount) >> 8);

        uint32 dOddBytes = getOddBytes();
        dOddBytes += (((src.getOddBytes() - dOddBytes) * amount) >> 8);

        g = (uint8) (dOddBytes & 0xff);





        b = (uint8) (dEvenBytes & 0xff);
        r = (uint8) (dEvenBytes >> 16);

    }



    __forceinline void setAlpha (const uint8) noexcept {}


    __forceinline void multiplyAlpha (int) noexcept {}


    __forceinline void multiplyAlpha (float) noexcept {}


    __forceinline void premultiply() noexcept {}


    __forceinline void unpremultiply() noexcept {}

    __forceinline void desaturate() noexcept
    {
        r = g = b = (uint8) (((int) r + (int) g + (int) b) / 3);
    }






    enum { indexR = 2, indexG = 1, indexB = 0 };


private:

    PixelRGB (const uint32 internal) noexcept
    {





        r = (uint8) (internal >> 16);
        g = (uint8) (internal >> 8);
        b = (uint8) (internal);

    }





    uint8 b, g, r;


}



;

__forceinline void PixelARGB::blend (const PixelRGB src) noexcept
{
    set (src);
}
# 610 "..\\..\\..\\JUCE\\modules\\juce_graphics/colour/juce_PixelFormats.h"
class PixelAlpha
{
public:

    PixelAlpha() noexcept {}
    ~PixelAlpha() noexcept {}






    __forceinline uint32 getNativeARGB() const noexcept { return (uint32) ((a << 24) | (a << 16) | (a << 8) | a); }



    __forceinline uint32 getInARGBMaskOrder() const noexcept { return getNativeARGB(); }



    inline uint32 getInARGBMemoryOrder() const noexcept { return getNativeARGB(); }






    __forceinline uint32 getEvenBytes() const noexcept { return (uint32) ((a << 16) | a); }






    __forceinline uint32 getOddBytes() const noexcept { return (uint32) ((a << 16) | a); }


    __forceinline uint8 getAlpha() const noexcept { return a; }
    __forceinline uint8& getAlpha() noexcept { return a; }

    __forceinline uint8 getRed() const noexcept { return 0; }
    __forceinline uint8 getGreen() const noexcept { return 0; }
    __forceinline uint8 getBlue() const noexcept { return 0; }






    template <class Pixel>
    __forceinline void set (const Pixel& src) noexcept
    {
        a = src.getAlpha();
    }


    __forceinline void setARGB (const uint8 a_, const uint8 , const uint8 , const uint8 ) noexcept
    {
        a = a_;
    }







    template <class Pixel>
    __forceinline void blend (const Pixel& src) noexcept
    {
        const int srcA = src.getAlpha();
        a = (uint8) ((a * (0x100 - srcA) >> 8) + srcA);
    }






    template <class Pixel>
    __forceinline void blend (const Pixel& src, uint32 extraAlpha) noexcept
    {
        ++extraAlpha;
        const int srcAlpha = (int) ((extraAlpha * src.getAlpha()) >> 8);
        a = (uint8) ((a * (0x100 - srcAlpha) >> 8) + srcAlpha);
    }




    template <class Pixel>
    __forceinline void tween (const Pixel& src, const uint32 amount) noexcept
    {
        a += ((src.getAlpha() - a) * amount) >> 8;
    }



    __forceinline void setAlpha (const uint8 newAlpha) noexcept
    {
        a = newAlpha;
    }


    __forceinline void multiplyAlpha (int multiplier) noexcept
    {
        ++multiplier;
        a = (uint8) ((a * multiplier) >> 8);
    }

    __forceinline void multiplyAlpha (const float multiplier) noexcept
    {
        a = (uint8) (a * multiplier);
    }


    __forceinline void premultiply() noexcept {}


    __forceinline void unpremultiply() noexcept {}

    __forceinline void desaturate() noexcept {}



    enum { indexA = 0 };

private:

    PixelAlpha (const uint32 internal) noexcept
    {
        a = (uint8) (internal >> 24);
    }


    uint8 a;
}



;


#pragma pack (pop)
# 109 "..\\..\\..\\JUCE\\modules\\juce_graphics/juce_graphics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_graphics/colour/juce_Colour.h" 1
# 35 "..\\..\\..\\JUCE\\modules\\juce_graphics/colour/juce_Colour.h"
class Colour
{
public:


    Colour() noexcept;


    Colour (const Colour& other) noexcept;
# 55 "..\\..\\..\\JUCE\\modules\\juce_graphics/colour/juce_Colour.h"
    explicit Colour (uint32 argb) noexcept;


    Colour (uint8 red,
            uint8 green,
            uint8 blue) noexcept;


    static Colour fromRGB (uint8 red,
                           uint8 green,
                           uint8 blue) noexcept;


    Colour (uint8 red,
            uint8 green,
            uint8 blue,
            uint8 alpha) noexcept;


    static Colour fromRGBA (uint8 red,
                            uint8 green,
                            uint8 blue,
                            uint8 alpha) noexcept;






    Colour (uint8 red,
            uint8 green,
            uint8 blue,
            float alpha) noexcept;




    static Colour fromFloatRGBA (float red,
                                 float green,
                                 float blue,
                                 float alpha) noexcept;







    Colour (float hue,
            float saturation,
            float brightness,
            uint8 alpha) noexcept;






    Colour (float hue,
            float saturation,
            float brightness,
            float alpha) noexcept;




    Colour (PixelARGB argb) noexcept;



    Colour (PixelRGB rgb) noexcept;



    Colour (PixelAlpha alpha) noexcept;







    static Colour fromHSV (float hue,
                           float saturation,
                           float brightness,
                           float alpha) noexcept;


    ~Colour() noexcept;


    Colour& operator= (const Colour& other) noexcept;


    bool operator== (const Colour& other) const noexcept;

    bool operator!= (const Colour& other) const noexcept;





    uint8 getRed() const noexcept { return argb.getRed(); }




    uint8 getGreen() const noexcept { return argb.getGreen(); }




    uint8 getBlue() const noexcept { return argb.getBlue(); }




    float getFloatRed() const noexcept;




    float getFloatGreen() const noexcept;




    float getFloatBlue() const noexcept;



    const PixelARGB getPixelARGB() const noexcept;






    uint32 getARGB() const noexcept;






    uint8 getAlpha() const noexcept { return argb.getAlpha(); }





    float getFloatAlpha() const noexcept;





    bool isOpaque() const noexcept;





    bool isTransparent() const noexcept;


    Colour withAlpha (uint8 newAlpha) const noexcept;


    Colour withAlpha (float newAlpha) const noexcept;




    Colour withMultipliedAlpha (float alphaMultiplier) const noexcept;





    Colour overlaidWith (Colour foregroundColour) const noexcept;





    Colour interpolatedWith (Colour other, float proportionOfOther) const noexcept;





    float getHue() const noexcept;




    float getSaturation() const noexcept;




    float getBrightness() const noexcept;





    float getPerceivedBrightness() const noexcept;




    void getHSB (float& hue,
                 float& saturation,
                 float& brightness) const noexcept;



    Colour withHue (float newHue) const noexcept;


    Colour withSaturation (float newSaturation) const noexcept;




    Colour withBrightness (float newBrightness) const noexcept;





    Colour withRotatedHue (float amountToRotate) const noexcept;





    Colour withMultipliedSaturation (float multiplier) const noexcept;





    Colour withMultipliedBrightness (float amount) const noexcept;







    Colour brighter (float amountBrighter = 0.4f) const noexcept;






    Colour darker (float amountDarker = 0.4f) const noexcept;
# 325 "..\\..\\..\\JUCE\\modules\\juce_graphics/colour/juce_Colour.h"
    Colour contrasting (float amount = 1.0f) const noexcept;
# 334 "..\\..\\..\\JUCE\\modules\\juce_graphics/colour/juce_Colour.h"
    Colour contrasting (Colour targetColour, float minLuminosityDiff) const noexcept;





    static Colour contrasting (Colour colour1,
                               Colour colour2) noexcept;





    static Colour greyLevel (float brightness) noexcept;





    String toString() const;


    static Colour fromString (StringRef encodedColourString);


    String toDisplayString (bool includeAlphaValue) const;

private:

    PixelARGB argb;
};
# 110 "..\\..\\..\\JUCE\\modules\\juce_graphics/juce_graphics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_graphics/colour/juce_ColourGradient.h" 1
# 35 "..\\..\\..\\JUCE\\modules\\juce_graphics/colour/juce_ColourGradient.h"
class ColourGradient
{
public:
# 56 "..\\..\\..\\JUCE\\modules\\juce_graphics/colour/juce_ColourGradient.h"
    ColourGradient (Colour colour1, float x1, float y1,
                    Colour colour2, float x2, float y2,
                    bool isRadial);






    ColourGradient() noexcept;


    ~ColourGradient();







    void clearColours();
# 89 "..\\..\\..\\JUCE\\modules\\juce_graphics/colour/juce_ColourGradient.h"
    int addColour (double proportionAlongGradient,
                   Colour colour);


    void removeColour (int index);


    void multiplyOpacity (float multiplier) noexcept;



    int getNumColours() const noexcept;





    double getColourPosition (int index) const noexcept;




    Colour getColour (int index) const noexcept;




    void setColour (int index, Colour newColour) noexcept;




    Colour getColourAtPosition (double position) const noexcept;







    int createLookupTable (const AffineTransform& transform, HeapBlock<PixelARGB>& resultLookupTable) const;






    void createLookupTable (PixelARGB* resultLookupTable, int numEntries) const noexcept;


    bool isOpaque() const noexcept;


    bool isInvisible() const noexcept;


    Point<float> point1, point2;






    bool isRadial;

    bool operator== (const ColourGradient&) const noexcept;
    bool operator!= (const ColourGradient&) const noexcept;


private:

    struct ColourPoint
    {
        ColourPoint() noexcept {}

        ColourPoint (const double pos, Colour col) noexcept
            : position (pos), colour (col)
        {}

        bool operator== (const ColourPoint&) const noexcept;
        bool operator!= (const ColourPoint&) const noexcept;

        double position;
        Colour colour;
    };

    Array<ColourPoint> colours;


};
# 111 "..\\..\\..\\JUCE\\modules\\juce_graphics/juce_graphics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_graphics/colour/juce_Colours.h" 1
# 35 "..\\..\\..\\JUCE\\modules\\juce_graphics/colour/juce_Colours.h"
class Colours
{
public:
 static const Colour


    transparentBlack,
    transparentWhite,


    black,
    white,
    blue,
    grey,
    green,
    red,
    yellow,


    aliceblue, antiquewhite, aqua, aquamarine,
    azure, beige, bisque, blanchedalmond,
    blueviolet, brown, burlywood, cadetblue,
    chartreuse, chocolate, coral, cornflowerblue,
    cornsilk, crimson, cyan, darkblue,
    darkcyan, darkgoldenrod, darkgrey, darkgreen,
    darkkhaki, darkmagenta, darkolivegreen, darkorange,
    darkorchid, darkred, darksalmon, darkseagreen,
    darkslateblue, darkslategrey, darkturquoise, darkviolet,
    deeppink, deepskyblue, dimgrey, dodgerblue,
    firebrick, floralwhite, forestgreen, fuchsia,
    gainsboro, gold, goldenrod, greenyellow,
    honeydew, hotpink, indianred, indigo,
    ivory, khaki, lavender, lavenderblush,
    lemonchiffon, lightblue, lightcoral, lightcyan,
    lightgoldenrodyellow, lightgreen, lightgrey, lightpink,
    lightsalmon, lightseagreen, lightskyblue, lightslategrey,
    lightsteelblue, lightyellow, lime, limegreen,
    linen, magenta, maroon, mediumaquamarine,
    mediumblue, mediumorchid, mediumpurple, mediumseagreen,
    mediumslateblue, mediumspringgreen, mediumturquoise, mediumvioletred,
    midnightblue, mintcream, mistyrose, navajowhite,
    navy, oldlace, olive, olivedrab,
    orange, orangered, orchid, palegoldenrod,
    palegreen, paleturquoise, palevioletred, papayawhip,
    peachpuff, peru, pink, plum,
    powderblue, purple, rosybrown, royalblue,
    saddlebrown, salmon, sandybrown, seagreen,
    seashell, sienna, silver, skyblue,
    slateblue, slategrey, snow, springgreen,
    steelblue, tan, teal, thistle,
    tomato, turquoise, violet, wheat,
    whitesmoke, yellowgreen;
# 95 "..\\..\\..\\JUCE\\modules\\juce_graphics/colour/juce_Colours.h"
    static Colour findColourForName (const String& colourName,
                                              Colour defaultColour);

private:



    Colours();

    Colours (const Colours&) = delete; Colours& operator= (const Colours&) = delete;
};
# 112 "..\\..\\..\\JUCE\\modules\\juce_graphics/juce_graphics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_BorderSize.h" 1
# 38 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_BorderSize.h"
template <typename ValueType>
class BorderSize
{
public:




    BorderSize() noexcept
        : top(), left(), bottom(), right()
    {
    }


    BorderSize (const BorderSize& other) noexcept
        : top (other.top), left (other.left), bottom (other.bottom), right (other.right)
    {
    }


    BorderSize (ValueType topGap, ValueType leftGap, ValueType bottomGap, ValueType rightGap) noexcept
        : top (topGap), left (leftGap), bottom (bottomGap), right (rightGap)
    {
    }


    explicit BorderSize (ValueType allGaps) noexcept
        : top (allGaps), left (allGaps), bottom (allGaps), right (allGaps)
    {
    }



    ValueType getTop() const noexcept { return top; }


    ValueType getLeft() const noexcept { return left; }


    ValueType getBottom() const noexcept { return bottom; }


    ValueType getRight() const noexcept { return right; }


    ValueType getTopAndBottom() const noexcept { return top + bottom; }


    ValueType getLeftAndRight() const noexcept { return left + right; }


    bool isEmpty() const noexcept { return left + right + top + bottom == ValueType(); }



    void setTop (ValueType newTopGap) noexcept { top = newTopGap; }


    void setLeft (ValueType newLeftGap) noexcept { left = newLeftGap; }


    void setBottom (ValueType newBottomGap) noexcept { bottom = newBottomGap; }


    void setRight (ValueType newRightGap) noexcept { right = newRightGap; }



    Rectangle<ValueType> subtractedFrom (const Rectangle<ValueType>& original) const noexcept
    {
        return Rectangle<ValueType> (original.getX() + left,
                                     original.getY() + top,
                                     original.getWidth() - (left + right),
                                     original.getHeight() - (top + bottom));
    }


    void subtractFrom (Rectangle<ValueType>& rectangle) const noexcept
    {
        rectangle = subtractedFrom (rectangle);
    }


    Rectangle<ValueType> addedTo (const Rectangle<ValueType>& original) const noexcept
    {
        return Rectangle<ValueType> (original.getX() - left,
                                     original.getY() - top,
                                     original.getWidth() + (left + right),
                                     original.getHeight() + (top + bottom));
    }



    void addTo (Rectangle<ValueType>& rectangle) const noexcept
    {
        rectangle = addedTo (rectangle);
    }


    bool operator== (const BorderSize& other) const noexcept
    {
        return top == other.top && left == other.left && bottom == other.bottom && right == other.right;
    }

    bool operator!= (const BorderSize& other) const noexcept
    {
        return ! operator== (other);
    }

private:

    ValueType top, left, bottom, right;
};
# 113 "..\\..\\..\\JUCE\\modules\\juce_graphics/juce_graphics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_EdgeTable.h" 1
# 35 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_EdgeTable.h"
class EdgeTable
{
public:
# 48 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_EdgeTable.h"
    EdgeTable (const Rectangle<int>& clipLimits,
               const Path& pathToAdd,
               const AffineTransform& transform);


    explicit EdgeTable (const Rectangle<int>& rectangleToAdd);


    explicit EdgeTable (const RectangleList<int>& rectanglesToAdd);


    explicit EdgeTable (const RectangleList<float>& rectanglesToAdd);


    explicit EdgeTable (const Rectangle<float>& rectangleToAdd);


    EdgeTable (const EdgeTable&);


    EdgeTable& operator= (const EdgeTable&);


    ~EdgeTable();


    void clipToRectangle (const Rectangle<int>& r);
    void excludeRectangle (const Rectangle<int>& r);
    void clipToEdgeTable (const EdgeTable&);
    void clipLineToMask (int x, int y, const uint8* mask, int maskStride, int numPixels);
    bool isEmpty() noexcept;
    const Rectangle<int>& getMaximumBounds() const noexcept { return bounds; }
    void translate (float dx, int dy) noexcept;


    void multiplyLevels (float factor);






    void optimiseTable();
# 109 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_EdgeTable.h"
    template <class EdgeTableIterationCallback>
    void iterate (EdgeTableIterationCallback& iterationCallback) const noexcept
    {
        const int* lineStart = table;

        for (int y = 0; y < bounds.getHeight(); ++y)
        {
            const int* line = lineStart;
            lineStart += lineStrideElements;
            int numPoints = line[0];

            if (--numPoints > 0)
            {
                int x = *++line;
#pragma warning(push)
# 123 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_EdgeTable.h"
#pragma warning(disable: 4127)
# 123 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_EdgeTable.h"
 do { ; } while (false)
# 123 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_EdgeTable.h"
#pragma warning(pop)
# 123 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_EdgeTable.h"
;
                int levelAccumulator = 0;

                iterationCallback.setEdgeTableYPos (bounds.getY() + y);

                while (--numPoints >= 0)
                {
                    const int level = *++line;
#pragma warning(push)
# 131 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_EdgeTable.h"
#pragma warning(disable: 4127)
# 131 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_EdgeTable.h"
 do { ; } while (false)
# 131 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_EdgeTable.h"
#pragma warning(pop)
# 131 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_EdgeTable.h"
;
                    const int endX = *++line;
#pragma warning(push)
# 133 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_EdgeTable.h"
#pragma warning(disable: 4127)
# 133 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_EdgeTable.h"
 do { ; } while (false)
# 133 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_EdgeTable.h"
#pragma warning(pop)
# 133 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_EdgeTable.h"
;
                    const int endOfRun = (endX >> 8);

                    if (endOfRun == (x >> 8))
                    {


                        levelAccumulator += (endX - x) * level;
                    }
                    else
                    {


                        levelAccumulator += (0x100 - (x & 0xff)) * level;
                        levelAccumulator >>= 8;
                        x >>= 8;

                        if (levelAccumulator > 0)
                        {
                            if (levelAccumulator >= 255)
                                iterationCallback.handleEdgeTablePixelFull (x);
                            else
                                iterationCallback.handleEdgeTablePixel (x, levelAccumulator);
                        }


                        if (level > 0)
                        {
#pragma warning(push)
# 161 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_EdgeTable.h"
#pragma warning(disable: 4127)
# 161 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_EdgeTable.h"
 do { ; } while (false)
# 161 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_EdgeTable.h"
#pragma warning(pop)
# 161 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_EdgeTable.h"
;
                            const int numPix = endOfRun - ++x;

                            if (numPix > 0)
                                iterationCallback.handleEdgeTableLine (x, numPix, level);
                        }


                        levelAccumulator = (endX & 0xff) * level;
                    }

                    x = endX;
                }

                levelAccumulator >>= 8;

                if (levelAccumulator > 0)
                {
                    x >>= 8;
#pragma warning(push)
# 180 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_EdgeTable.h"
#pragma warning(disable: 4127)
# 180 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_EdgeTable.h"
 do { ; } while (false)
# 180 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_EdgeTable.h"
#pragma warning(pop)
# 180 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_EdgeTable.h"
;

                    if (levelAccumulator >= 255)
                        iterationCallback.handleEdgeTablePixelFull (x);
                    else
                        iterationCallback.handleEdgeTablePixel (x, levelAccumulator);
                }
            }
        }
    }

private:


    struct LineItem
    {
        int x, level;

        bool operator< (const LineItem& other) const noexcept { return x < other.x; }
    };

    HeapBlock<int> table;
    Rectangle<int> bounds;
    int maxEdgesPerLine, lineStrideElements;
    bool needToCheckEmptiness;

    void allocate();
    void clearLineSizes() noexcept;
    void addEdgePoint (int x, int y, int winding);
    void addEdgePointPair (int x1, int x2, int y, int winding);
    void remapTableForNumEdges (int newNumEdgesPerLine);
    void intersectWithEdgeTableLine (int y, const int* otherLine);
    void clipEdgeTableLineToRange (int* line, int x1, int x2) noexcept;
    void sanitiseLevels (bool useNonZeroWinding) noexcept;
    static void copyEdgeTableData (int* dest, int destLineStride, const int* src, int srcLineStride, int numLines) noexcept;


};
# 114 "..\\..\\..\\JUCE\\modules\\juce_graphics/juce_graphics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_PathIterator.h" 1
# 39 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_PathIterator.h"
class PathFlatteningIterator
{
public:
# 54 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_PathIterator.h"
    PathFlatteningIterator (const Path& path,
                            const AffineTransform& transform = AffineTransform(),
                            float tolerance = Path::defaultToleranceForMeasurement);


    ~PathFlatteningIterator();
# 69 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_PathIterator.h"
    bool next();

    float x1;
    float y1;
    float x2;
    float y2;






    bool closesSubPath;






    int subPathIndex;


    bool isLastInSubpath() const noexcept;

private:

    const Path& path;
    const AffineTransform transform;
    float* points;
    const float toleranceSquared;
    float subPathCloseX, subPathCloseY;
    const bool isIdentityTransform;

    HeapBlock<float> stackBase;
    float* stackPos;
    size_t index, stackSize;

    PathFlatteningIterator (const PathFlatteningIterator&) = delete; PathFlatteningIterator& operator= (const PathFlatteningIterator&) = delete;
};
# 115 "..\\..\\..\\JUCE\\modules\\juce_graphics/juce_graphics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_PathStrokeType.h" 1
# 39 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_PathStrokeType.h"
class PathStrokeType
{
public:


    enum JointStyle
    {
        mitered,




        curved,
        beveled

    };


    enum EndCapStyle
    {
        butt,
        square,

        rounded
    };



    explicit PathStrokeType (float strokeThickness) noexcept;







    PathStrokeType (float strokeThickness,
                    JointStyle jointStyle,
                    EndCapStyle endStyle = butt) noexcept;


    PathStrokeType (const PathStrokeType&) noexcept;


    PathStrokeType& operator= (const PathStrokeType&) noexcept;


    ~PathStrokeType() noexcept;
# 105 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_PathStrokeType.h"
    void createStrokedPath (Path& destPath,
                            const Path& sourcePath,
                            const AffineTransform& transform = AffineTransform(),
                            float extraAccuracy = 1.0f) const;
# 135 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_PathStrokeType.h"
    void createDashedStroke (Path& destPath,
                             const Path& sourcePath,
                             const float* dashLengths,
                             int numDashLengths,
                             const AffineTransform& transform = AffineTransform(),
                             float extraAccuracy = 1.0f) const;
# 162 "..\\..\\..\\JUCE\\modules\\juce_graphics/geometry/juce_PathStrokeType.h"
    void createStrokeWithArrowheads (Path& destPath,
                                     const Path& sourcePath,
                                     float arrowheadStartWidth, float arrowheadStartLength,
                                     float arrowheadEndWidth, float arrowheadEndLength,
                                     const AffineTransform& transform = AffineTransform(),
                                     float extraAccuracy = 1.0f) const;



    float getStrokeThickness() const noexcept { return thickness; }


    void setStrokeThickness (float newThickness) noexcept { thickness = newThickness; }


    JointStyle getJointStyle() const noexcept { return jointStyle; }


    void setJointStyle (JointStyle newStyle) noexcept { jointStyle = newStyle; }


    EndCapStyle getEndStyle() const noexcept { return endStyle; }


    void setEndStyle (EndCapStyle newStyle) noexcept { endStyle = newStyle; }



    bool operator== (const PathStrokeType&) const noexcept;


    bool operator!= (const PathStrokeType&) const noexcept;

private:

    float thickness;
    JointStyle jointStyle;
    EndCapStyle endStyle;


};
# 116 "..\\..\\..\\JUCE\\modules\\juce_graphics/juce_graphics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_graphics/placement/juce_RectanglePlacement.h" 1
# 37 "..\\..\\..\\JUCE\\modules\\juce_graphics/placement/juce_RectanglePlacement.h"
class RectanglePlacement
{
public:


    inline RectanglePlacement (int placementFlags) noexcept : flags (placementFlags) {}


    inline RectanglePlacement() noexcept : flags (centred) {}


    RectanglePlacement (const RectanglePlacement&) noexcept;


    RectanglePlacement& operator= (const RectanglePlacement&) noexcept;

    bool operator== (const RectanglePlacement&) const noexcept;
    bool operator!= (const RectanglePlacement&) const noexcept;



    enum Flags
    {


        xLeft = 1,


        xRight = 2,



        xMid = 4,




        yTop = 8,



        yBottom = 16,



        yMid = 32,





        stretchToFit = 64,
# 99 "..\\..\\..\\JUCE\\modules\\juce_graphics/placement/juce_RectanglePlacement.h"
        fillDestination = 128,




        onlyReduceInSize = 256,




        onlyIncreaseInSize = 512,



        doNotResize = (onlyIncreaseInSize | onlyReduceInSize),



        centred = 4 + 32
    };



    inline int getFlags() const noexcept { return flags; }





    inline bool testFlags (int flagsToTest) const noexcept { return (flags & flagsToTest) != 0; }
# 137 "..\\..\\..\\JUCE\\modules\\juce_graphics/placement/juce_RectanglePlacement.h"
    void applyTo (double& sourceX,
                  double& sourceY,
                  double& sourceW,
                  double& sourceH,
                  double destinationX,
                  double destinationY,
                  double destinationW,
                  double destinationH) const noexcept;




    template <typename ValueType>
    Rectangle<ValueType> appliedTo (const Rectangle<ValueType>& source,
                                    const Rectangle<ValueType>& destination) const noexcept
    {
        double x = source.getX(), y = source.getY(), w = source.getWidth(), h = source.getHeight();
        applyTo (x, y, w, h, static_cast<double> (destination.getX()), static_cast<double> (destination.getY()),
                 static_cast<double> (destination.getWidth()), static_cast<double> (destination.getHeight()));
        return Rectangle<ValueType> (static_cast<ValueType> (x), static_cast<ValueType> (y),
                                     static_cast<ValueType> (w), static_cast<ValueType> (h));
    }




    AffineTransform getTransformToFit (const Rectangle<float>& source,
                                       const Rectangle<float>& destination) const noexcept;


private:

    int flags;
};
# 117 "..\\..\\..\\JUCE\\modules\\juce_graphics/juce_graphics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_graphics/images/juce_ImageCache.h" 1
# 44 "..\\..\\..\\JUCE\\modules\\juce_graphics/images/juce_ImageCache.h"
class ImageCache
{
public:
# 62 "..\\..\\..\\JUCE\\modules\\juce_graphics/images/juce_ImageCache.h"
    static Image getFromFile (const File& file);
# 79 "..\\..\\..\\JUCE\\modules\\juce_graphics/images/juce_ImageCache.h"
    static Image getFromMemory (const void* imageData, int dataSize);
# 90 "..\\..\\..\\JUCE\\modules\\juce_graphics/images/juce_ImageCache.h"
    static Image getFromHashCode (int64 hashCode);
# 102 "..\\..\\..\\JUCE\\modules\\juce_graphics/images/juce_ImageCache.h"
    static void addImageToCache (const Image& image, int64 hashCode);




    static void setCacheTimeout (int millisecs);




    static void releaseUnusedImages();

private:

    class Pimpl;
    friend class Pimpl;

    ImageCache();
    ~ImageCache();

    ImageCache (const ImageCache&) = delete; ImageCache& operator= (const ImageCache&) = delete;
};
# 118 "..\\..\\..\\JUCE\\modules\\juce_graphics/juce_graphics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_graphics/images/juce_ImageConvolutionKernel.h" 1
# 35 "..\\..\\..\\JUCE\\modules\\juce_graphics/images/juce_ImageConvolutionKernel.h"
class ImageConvolutionKernel
{
public:






    ImageConvolutionKernel (int size);


    ~ImageConvolutionKernel();



    void clear();


    float getKernelValue (int x, int y) const noexcept;







    void setKernelValue (int x, int y, float value) noexcept;





    void setOverallSum (float desiredTotalSum);


    void rescaleAllValues (float multiplier);
# 80 "..\\..\\..\\JUCE\\modules\\juce_graphics/images/juce_ImageConvolutionKernel.h"
    void createGaussianBlur (float blurRadius);






    int getKernelSize() const { return size; }
# 98 "..\\..\\..\\JUCE\\modules\\juce_graphics/images/juce_ImageConvolutionKernel.h"
    void applyToImage (Image& destImage,
                       const Image& sourceImage,
                       const Rectangle<int>& destinationArea) const;

private:

    HeapBlock<float> values;
    const int size;

    ImageConvolutionKernel (const ImageConvolutionKernel&) = delete; ImageConvolutionKernel& operator= (const ImageConvolutionKernel&) = delete;
};
# 119 "..\\..\\..\\JUCE\\modules\\juce_graphics/juce_graphics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_graphics/images/juce_ImageFileFormat.h" 1
# 39 "..\\..\\..\\JUCE\\modules\\juce_graphics/images/juce_ImageFileFormat.h"
class ImageFileFormat
{
protected:


    ImageFileFormat() {}

public:

    virtual ~ImageFileFormat() {}






    virtual String getFormatName() = 0;
# 67 "..\\..\\..\\JUCE\\modules\\juce_graphics/images/juce_ImageFileFormat.h"
    virtual bool canUnderstand (InputStream& input) = 0;


    virtual bool usesFileExtension (const File& possibleFile) = 0;
# 83 "..\\..\\..\\JUCE\\modules\\juce_graphics/images/juce_ImageFileFormat.h"
    virtual Image decodeImage (InputStream& input) = 0;
# 93 "..\\..\\..\\JUCE\\modules\\juce_graphics/images/juce_ImageFileFormat.h"
    virtual bool writeImageToStream (const Image& sourceImage,
                                     OutputStream& destStream) = 0;







    static ImageFileFormat* findImageFormatForStream (InputStream& input);





    static ImageFileFormat* findImageFormatForFileExtension (const File& file);
# 118 "..\\..\\..\\JUCE\\modules\\juce_graphics/images/juce_ImageFileFormat.h"
    static Image loadFrom (InputStream& input);
# 127 "..\\..\\..\\JUCE\\modules\\juce_graphics/images/juce_ImageFileFormat.h"
    static Image loadFrom (const File& file);
# 136 "..\\..\\..\\JUCE\\modules\\juce_graphics/images/juce_ImageFileFormat.h"
    static Image loadFrom (const void* rawData,
                           size_t numBytesOfData);
};







class PNGImageFormat : public ImageFileFormat
{
public:

    PNGImageFormat();
    ~PNGImageFormat();


    String getFormatName() override;
    bool usesFileExtension (const File&) override;
    bool canUnderstand (InputStream&) override;
    Image decodeImage (InputStream&) override;
    bool writeImageToStream (const Image&, OutputStream&) override;
};
# 168 "..\\..\\..\\JUCE\\modules\\juce_graphics/images/juce_ImageFileFormat.h"
class JPEGImageFormat : public ImageFileFormat
{
public:

    JPEGImageFormat();
    ~JPEGImageFormat();







    void setQuality (float newQuality);


    String getFormatName() override;
    bool usesFileExtension (const File&) override;
    bool canUnderstand (InputStream&) override;
    Image decodeImage (InputStream&) override;
    bool writeImageToStream (const Image&, OutputStream&) override;

private:
    float quality;
};







class GIFImageFormat : public ImageFileFormat
{
public:

    GIFImageFormat();
    ~GIFImageFormat();


    String getFormatName() override;
    bool usesFileExtension (const File&) override;
    bool canUnderstand (InputStream&) override;
    Image decodeImage (InputStream&) override;
    bool writeImageToStream (const Image&, OutputStream&) override;
};
# 120 "..\\..\\..\\JUCE\\modules\\juce_graphics/juce_graphics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_graphics/fonts/juce_Typeface.h" 1
# 44 "..\\..\\..\\JUCE\\modules\\juce_graphics/fonts/juce_Typeface.h"
class Typeface : public ReferenceCountedObject
{
public:


    typedef ReferenceCountedObjectPtr<Typeface> Ptr;





    const String& getName() const noexcept { return name; }





    const String& getStyle() const noexcept { return style; }



    static Ptr createSystemTypefaceFor (const Font& font);





    static Ptr createSystemTypefaceFor (const void* fontFileData, size_t fontFileDataSize);



    virtual ~Typeface();





    virtual bool isSuitableForFont (const Font&) const { return true; }






    virtual float getAscent() const = 0;






    virtual float getDescent() const = 0;




    virtual float getHeightToPointsFactor() const = 0;





    virtual float getStringWidth (const String& text) = 0;





    virtual void getGlyphPositions (const String& text, Array <int>& glyphs, Array<float>& xOffsets) = 0;




    virtual bool getOutlineForGlyph (int glyphNumber, Path& path) = 0;


    virtual EdgeTable* getEdgeTableForGlyph (int glyphNumber, const AffineTransform& transform, float fontHeight);


    virtual bool isHinted() const { return false; }



    static void setTypefaceCacheSize (int numFontsToCache);


    static void clearTypefaceCache();




    static void scanFolderForFonts (const File& folder);





    void applyVerticalHintingTransform (float fontHeight, Path& path);

protected:

    String name, style;

    Typeface (const String& name, const String& style) noexcept;

    static Ptr getFallbackTypeface();

private:
    struct HintingParams;
    friend struct ContainerDeletePolicy<HintingParams>;
    ScopedPointer<HintingParams> hintingParams;
    CriticalSection hintingLock;

    Typeface (const Typeface&) = delete; Typeface& operator= (const Typeface&) = delete;
};
# 121 "..\\..\\..\\JUCE\\modules\\juce_graphics/juce_graphics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_graphics/fonts/juce_Font.h" 1
# 39 "..\\..\\..\\JUCE\\modules\\juce_graphics/fonts/juce_Font.h"
class Font
{
public:




    enum FontStyleFlags
    {
        plain = 0,
        bold = 1,
        italic = 2,
        underlined = 4
    };
# 63 "..\\..\\..\\JUCE\\modules\\juce_graphics/fonts/juce_Font.h"
    Font (float fontHeight, int styleFlags = plain);
# 74 "..\\..\\..\\JUCE\\modules\\juce_graphics/fonts/juce_Font.h"
    Font (const String& typefaceName, float fontHeight, int styleFlags);







    Font (const String& typefaceName, const String& typefaceStyle, float fontHeight);


    Font (const Font& other) noexcept;


    Font (const Typeface::Ptr& typeface);







    Font();


    Font (Font&& other) noexcept;
    Font& operator= (Font&& other) noexcept;



    Font& operator= (const Font& other) noexcept;

    bool operator== (const Font& other) const noexcept;
    bool operator!= (const Font& other) const noexcept;


    ~Font() noexcept;
# 125 "..\\..\\..\\JUCE\\modules\\juce_graphics/fonts/juce_Font.h"
    void setTypefaceName (const String& faceName);
# 138 "..\\..\\..\\JUCE\\modules\\juce_graphics/fonts/juce_Font.h"
    const String& getTypefaceName() const noexcept;





    const String& getTypefaceStyle() const noexcept;




    void setTypefaceStyle (const String& newStyle);




    Font withTypefaceStyle (const String& newStyle) const;


    StringArray getAvailableStyles() const;
# 170 "..\\..\\..\\JUCE\\modules\\juce_graphics/fonts/juce_Font.h"
    static const String& getDefaultSansSerifFontName();
# 179 "..\\..\\..\\JUCE\\modules\\juce_graphics/fonts/juce_Font.h"
    static const String& getDefaultSerifFontName();
# 188 "..\\..\\..\\JUCE\\modules\\juce_graphics/fonts/juce_Font.h"
    static const String& getDefaultMonospacedFontName();
# 197 "..\\..\\..\\JUCE\\modules\\juce_graphics/fonts/juce_Font.h"
    static const String& getDefaultStyle();


    static Typeface::Ptr getDefaultTypefaceForFont (const Font& font);



    Font withHeight (float height) const;


    Font withPointHeight (float heightInPoints) const;




    void setHeight (float newHeight);




    void setHeightWithoutChangingWidth (float newHeight);







    float getHeight() const noexcept;







    float getHeightInPoints() const;





    float getAscent() const;





    float getAscentInPoints() const;





    float getDescent() const;





    float getDescentInPoints() const;







    int getStyleFlags() const noexcept;





    Font withStyle (int styleFlags) const;





    void setStyleFlags (int newFlags);



    void setBold (bool shouldBeBold);




    Font boldened() const;


    bool isBold() const noexcept;


    void setItalic (bool shouldBeItalic);

    Font italicised() const;

    bool isItalic() const noexcept;


    void setUnderline (bool shouldBeUnderlined);

    bool isUnderlined() const noexcept;
# 311 "..\\..\\..\\JUCE\\modules\\juce_graphics/fonts/juce_Font.h"
    float getHorizontalScale() const noexcept;






    Font withHorizontalScale (float scaleFactor) const;





    void setHorizontalScale (float scaleFactor);





    static float getDefaultMinimumHorizontalScaleFactor() noexcept;





    static void setDefaultMinimumHorizontalScaleFactor (float newMinimumScaleFactor) noexcept;
# 346 "..\\..\\..\\JUCE\\modules\\juce_graphics/fonts/juce_Font.h"
    float getExtraKerningFactor() const noexcept;







    Font withExtraKerningFactor (float extraKerning) const;







    void setExtraKerningFactor (float extraKerning);



    void setSizeAndStyle (float newHeight,
                          int newStyleFlags,
                          float newHorizontalScale,
                          float newKerningAmount);


    void setSizeAndStyle (float newHeight,
                          const String& newStyle,
                          float newHorizontalScale,
                          float newKerningAmount);





    int getStringWidth (const String& text) const;




    float getStringWidthFloat (const String& text) const;






    void getGlyphPositions (const String& text, Array <int>& glyphs, Array <float>& xOffsets) const;







    Typeface* getTypeface() const;
# 410 "..\\..\\..\\JUCE\\modules\\juce_graphics/fonts/juce_Font.h"
    static void findFonts (Array<Font>& results);
# 419 "..\\..\\..\\JUCE\\modules\\juce_graphics/fonts/juce_Font.h"
    static StringArray findAllTypefaceNames();
# 428 "..\\..\\..\\JUCE\\modules\\juce_graphics/fonts/juce_Font.h"
    static StringArray findAllTypefaceStyles (const String& family);





    static const String& getFallbackFontName();




    static void setFallbackFontName (const String& name);




    static const String& getFallbackFontStyle();




    static void setFallbackFontStyle (const String& style);






    String toString() const;





    static Font fromString (const String& fontDescription);


private:

    class SharedFontInternal;
    ReferenceCountedObjectPtr<SharedFontInternal> font;
    void dupeInternalIfShared();
    void checkTypefaceSuitability();
    float getHeightToPointsFactor() const;


};
# 122 "..\\..\\..\\JUCE\\modules\\juce_graphics/juce_graphics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_graphics/fonts/juce_AttributedString.h" 1
# 39 "..\\..\\..\\JUCE\\modules\\juce_graphics/fonts/juce_AttributedString.h"
class AttributedString
{
public:

    AttributedString();


    explicit AttributedString (const String& text);

    AttributedString (const AttributedString&);
    AttributedString& operator= (const AttributedString&);

    AttributedString (AttributedString&&) noexcept;
    AttributedString& operator= (AttributedString&&) noexcept;



    ~AttributedString() noexcept;



    const String& getText() const noexcept { return text; }





    void setText (const String& newText);


    void append (const String& textToAppend);

    void append (const String& textToAppend, const Font& font);

    void append (const String& textToAppend, Colour colour);

    void append (const String& textToAppend, const Font& font, Colour colour);





    void append (const AttributedString& other);





    void clear();






    void draw (Graphics& g, const Rectangle<float>& area) const;





    Justification getJustification() const noexcept { return justification; }




    void setJustification (Justification newJustification) noexcept;





    enum WordWrap
    {
        none,
        byWord,
        byChar,
    };


    WordWrap getWordWrap() const noexcept { return wordWrap; }


    void setWordWrap (WordWrap newWordWrap) noexcept;





    enum ReadingDirection
    {
        natural,
        leftToRight,
        rightToLeft,
    };


    ReadingDirection getReadingDirection() const noexcept { return readingDirection; }


    void setReadingDirection (ReadingDirection newReadingDirection) noexcept;



    float getLineSpacing() const noexcept { return lineSpacing; }


    void setLineSpacing (float newLineSpacing) noexcept;



    class Attribute
    {
    public:
        Attribute() noexcept;
        ~Attribute() noexcept;
        Attribute (const Attribute&) noexcept;
        Attribute& operator= (const Attribute&) noexcept;

        Attribute (Attribute&&) noexcept;
        Attribute& operator= (Attribute&&) noexcept;



        Attribute (Range<int> range, const Font& font, Colour colour) noexcept;


        Range<int> range;


        Font font;


        Colour colour;

    private:

    };


    int getNumAttributes() const noexcept { return attributes.size(); }




    const Attribute& getAttribute (int index) const noexcept { return attributes.getReference (index); }



    void setColour (Range<int> range, Colour colour);


    void setColour (Colour colour);


    void setFont (Range<int> range, const Font& font);


    void setFont (const Font& font);

private:
    String text;
    float lineSpacing;
    Justification justification;
    WordWrap wordWrap;
    ReadingDirection readingDirection;
    Array<Attribute> attributes;


};
# 123 "..\\..\\..\\JUCE\\modules\\juce_graphics/juce_graphics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_graphics/fonts/juce_GlyphArrangement.h" 1
# 39 "..\\..\\..\\JUCE\\modules\\juce_graphics/fonts/juce_GlyphArrangement.h"
class PositionedGlyph
{
public:

    PositionedGlyph() noexcept;
    PositionedGlyph (const Font& font, juce_wchar character, int glyphNumber,
                     float anchorX, float baselineY, float width, bool isWhitespace);

    PositionedGlyph (const PositionedGlyph&);
    PositionedGlyph& operator= (const PositionedGlyph&);


    PositionedGlyph (PositionedGlyph&&) noexcept;
    PositionedGlyph& operator= (PositionedGlyph&&) noexcept;


    ~PositionedGlyph();


    juce_wchar getCharacter() const noexcept { return character; }

    bool isWhitespace() const noexcept { return whitespace; }


    float getLeft() const noexcept { return x; }

    float getRight() const noexcept { return x + w; }

    float getBaselineY() const noexcept { return y; }

    float getTop() const { return y - font.getAscent(); }

    float getBottom() const { return y + font.getDescent(); }

    Rectangle<float> getBounds() const { return Rectangle<float> (x, getTop(), w, font.getHeight()); }



    void moveBy (float deltaX, float deltaY);





    void draw (Graphics& g) const;




    void draw (Graphics& g, const AffineTransform& transform) const;




    void createPath (Path& path) const;


    bool hitTest (float x, float y) const;

private:

    friend class GlyphArrangement;
    Font font;
    juce_wchar character;
    int glyph;
    float x, y, w;
    bool whitespace;


};
# 121 "..\\..\\..\\JUCE\\modules\\juce_graphics/fonts/juce_GlyphArrangement.h"
class GlyphArrangement
{
public:


    GlyphArrangement();


    GlyphArrangement (const GlyphArrangement&);




    GlyphArrangement& operator= (const GlyphArrangement&);


    ~GlyphArrangement();



    int getNumGlyphs() const noexcept { return glyphs.size(); }







    PositionedGlyph& getGlyph (int index) const noexcept;



    void clear();
# 163 "..\\..\\..\\JUCE\\modules\\juce_graphics/fonts/juce_GlyphArrangement.h"
    void addLineOfText (const Font& font,
                        const String& text,
                        float x, float y);







    void addCurtailedLineOfText (const Font& font,
                                 const String& text,
                                 float x, float y,
                                 float maxWidthPixels,
                                 bool useEllipsis);
# 192 "..\\..\\..\\JUCE\\modules\\juce_graphics/fonts/juce_GlyphArrangement.h"
    void addJustifiedText (const Font& font,
                           const String& text,
                           float x, float y,
                           float maxLineWidth,
                           Justification horizontalLayout);
# 217 "..\\..\\..\\JUCE\\modules\\juce_graphics/fonts/juce_GlyphArrangement.h"
    void addFittedText (const Font& font,
                        const String& text,
                        float x, float y, float width, float height,
                        Justification layout,
                        int maximumLinesToUse,
                        float minimumHorizontalScale = 0.0f);


    void addGlyphArrangement (const GlyphArrangement&);


    void addGlyph (const PositionedGlyph&);







    void draw (const Graphics&) const;






    void draw (const Graphics&, const AffineTransform&) const;




    void createPath (Path& path) const;




    int findGlyphIndexAt (float x, float y) const;
# 265 "..\\..\\..\\JUCE\\modules\\juce_graphics/fonts/juce_GlyphArrangement.h"
    Rectangle<float> getBoundingBox (int startIndex, int numGlyphs, bool includeWhitespace) const;
# 275 "..\\..\\..\\JUCE\\modules\\juce_graphics/fonts/juce_GlyphArrangement.h"
    void moveRangeOfGlyphs (int startIndex, int numGlyphs,
                            float deltaX, float deltaY);







    void removeRangeOfGlyphs (int startIndex, int numGlyphs);
# 293 "..\\..\\..\\JUCE\\modules\\juce_graphics/fonts/juce_GlyphArrangement.h"
    void stretchRangeOfGlyphs (int startIndex, int numGlyphs,
                               float horizontalScaleFactor);
# 304 "..\\..\\..\\JUCE\\modules\\juce_graphics/fonts/juce_GlyphArrangement.h"
    void justifyGlyphs (int startIndex, int numGlyphs,
                        float x, float y, float width, float height,
                        Justification justification);


private:

    Array<PositionedGlyph> glyphs;

    int insertEllipsis (const Font&, float maxXPos, int startIndex, int endIndex);
    int fitLineIntoSpace (int start, int numGlyphs, float x, float y, float w, float h, const Font&,
                          Justification, float minimumHorizontalScale);
    void spreadOutLine (int start, int numGlyphs, float targetWidth);
    void splitLines (const String&, Font, int start, float x, float y, float w, float h, int maxLines,
                     float lineWidth, Justification, float minimumHorizontalScale);
    void addLinesWithLineBreaks (const String&, const Font&, float x, float y, float width, float height, Justification);
    void drawGlyphUnderline (const Graphics&, const PositionedGlyph&, int, const AffineTransform&) const;


};
# 124 "..\\..\\..\\JUCE\\modules\\juce_graphics/juce_graphics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_graphics/fonts/juce_TextLayout.h" 1
# 38 "..\\..\\..\\JUCE\\modules\\juce_graphics/fonts/juce_TextLayout.h"
class TextLayout
{
public:




    TextLayout();
    TextLayout (const TextLayout&);
    TextLayout& operator= (const TextLayout&);

    TextLayout (TextLayout&&) noexcept;
    TextLayout& operator= (TextLayout&&) noexcept;



    ~TextLayout();





    void createLayout (const AttributedString&, float maxWidth);




    void createLayout (const AttributedString&, float maxWidth, float maxHeight);







    void createLayoutWithBalancedLineLengths (const AttributedString&, float maxWidth);







    void createLayoutWithBalancedLineLengths (const AttributedString&, float maxWidth, float maxHeight);





    void draw (Graphics&, const Rectangle<float>& area) const;



    class Glyph
    {
    public:
        Glyph (int glyphCode, Point<float> anchor, float width) noexcept;
        Glyph (const Glyph&) noexcept;
        Glyph& operator= (const Glyph&) noexcept;
        ~Glyph() noexcept;


        int glyphCode;




        Point<float> anchor;

        float width;

    private:

    };



    class Run
    {
    public:
        Run() noexcept;
        Run (const Run&);
        Run (Range<int> stringRange, int numGlyphsToPreallocate);
        ~Run() noexcept;

        Font font;
        Colour colour;
        Array<Glyph> glyphs;
        Range<int> stringRange;

    private:
        Run& operator= (const Run&);

    };



    class Line
    {
    public:
        Line() noexcept;
        Line (const Line&);
        Line (Range<int> stringRange, Point<float> lineOrigin,
              float ascent, float descent, float leading, int numRunsToPreallocate);
        ~Line() noexcept;


        Range<float> getLineBoundsX() const noexcept;


        Range<float> getLineBoundsY() const noexcept;


        Rectangle<float> getLineBounds() const noexcept;

        OwnedArray<Run> runs;
        Range<int> stringRange;

        Point<float> lineOrigin;
        float ascent, descent, leading;

    private:
        Line& operator= (const Line&);

    };



    float getWidth() const noexcept { return width; }


    float getHeight() const noexcept { return height; }


    int getNumLines() const noexcept { return lines.size(); }


    Line& getLine (int index) const;



    void addLine (Line*);


    void ensureStorageAllocated (int numLinesNeeded);

private:
    OwnedArray<Line> lines;
    float width, height;
    Justification justification;

    void createStandardLayout (const AttributedString&);
    bool createNativeLayout (const AttributedString&);
    void recalculateSize();


};
# 125 "..\\..\\..\\JUCE\\modules\\juce_graphics/juce_graphics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_graphics/fonts/juce_CustomTypeface.h" 1
# 46 "..\\..\\..\\JUCE\\modules\\juce_graphics/fonts/juce_CustomTypeface.h"
class CustomTypeface : public Typeface
{
public:


    CustomTypeface();
# 62 "..\\..\\..\\JUCE\\modules\\juce_graphics/fonts/juce_CustomTypeface.h"
    explicit CustomTypeface (InputStream& serialisedTypefaceStream);


    ~CustomTypeface();



    void clear();
# 81 "..\\..\\..\\JUCE\\modules\\juce_graphics/fonts/juce_CustomTypeface.h"
    void setCharacteristics (const String& fontFamily, float ascent,
                             bool isBold, bool isItalic,
                             juce_wchar defaultCharacter) noexcept;
# 94 "..\\..\\..\\JUCE\\modules\\juce_graphics/fonts/juce_CustomTypeface.h"
    void setCharacteristics (const String& fontFamily, const String& fontStyle,
                             float ascent, juce_wchar defaultCharacter) noexcept;
# 105 "..\\..\\..\\JUCE\\modules\\juce_graphics/fonts/juce_CustomTypeface.h"
    void addGlyph (juce_wchar character, const Path& path, float width) noexcept;




    void addKerningPair (juce_wchar char1, juce_wchar char2, float extraAmount) noexcept;





    void addGlyphsFromOtherTypeface (Typeface& typefaceToCopy, juce_wchar characterStartIndex, int numCharacters) noexcept;
# 126 "..\\..\\..\\JUCE\\modules\\juce_graphics/fonts/juce_CustomTypeface.h"
    bool writeToStream (OutputStream& outputStream);



    float getAscent() const override;
    float getDescent() const override;
    float getHeightToPointsFactor() const override;
    float getStringWidth (const String&) override;
    void getGlyphPositions (const String&, Array <int>& glyphs, Array<float>& xOffsets) override;
    bool getOutlineForGlyph (int glyphNumber, Path&) override;
    EdgeTable* getEdgeTableForGlyph (int glyphNumber, const AffineTransform&, float fontHeight) override;

protected:

    juce_wchar defaultCharacter;
    float ascent;
# 150 "..\\..\\..\\JUCE\\modules\\juce_graphics/fonts/juce_CustomTypeface.h"
    virtual bool loadGlyphIfPossible (juce_wchar characterNeeded);

private:

    class GlyphInfo;
    friend struct ContainerDeletePolicy<GlyphInfo>;
    OwnedArray<GlyphInfo> glyphs;
    short lookupTable [128];

    GlyphInfo* findGlyph (const juce_wchar character, bool loadIfNeeded) noexcept;

    CustomTypeface (const CustomTypeface&) = delete; CustomTypeface& operator= (const CustomTypeface&) = delete;
};
# 126 "..\\..\\..\\JUCE\\modules\\juce_graphics/juce_graphics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_graphics/contexts/juce_GraphicsContext.h" 1
# 42 "..\\..\\..\\JUCE\\modules\\juce_graphics/contexts/juce_GraphicsContext.h"
class Graphics
{
public:
# 55 "..\\..\\..\\JUCE\\modules\\juce_graphics/contexts/juce_GraphicsContext.h"
    explicit Graphics (const Image& imageToDrawOnto);


    ~Graphics();
# 71 "..\\..\\..\\JUCE\\modules\\juce_graphics/contexts/juce_GraphicsContext.h"
    void setColour (Colour newColour);
# 82 "..\\..\\..\\JUCE\\modules\\juce_graphics/contexts/juce_GraphicsContext.h"
    void setOpacity (float newOpacity);



    void setGradientFill (const ColourGradient& gradient);





    void setTiledImageFill (const Image& imageToUse,
                            int anchorX, int anchorY,
                            float opacity);




    void setFillType (const FillType& newFill);
# 109 "..\\..\\..\\JUCE\\modules\\juce_graphics/contexts/juce_GraphicsContext.h"
    void setFont (const Font& newFont);






    void setFont (float newFontHeight);


    Font getCurrentFont() const;
# 133 "..\\..\\..\\JUCE\\modules\\juce_graphics/contexts/juce_GraphicsContext.h"
    void drawSingleLineText (const String& text,
                             int startX, int baselineY,
                             Justification justification = Justification::left) const;
# 145 "..\\..\\..\\JUCE\\modules\\juce_graphics/contexts/juce_GraphicsContext.h"
    void drawMultiLineText (const String& text,
                            int startX, int baselineY,
                            int maximumLineWidth) const;
# 158 "..\\..\\..\\JUCE\\modules\\juce_graphics/contexts/juce_GraphicsContext.h"
    void drawText (const String& text,
                   int x, int y, int width, int height,
                   Justification justificationType,
                   bool useEllipsesIfTooBig = true) const;
# 172 "..\\..\\..\\JUCE\\modules\\juce_graphics/contexts/juce_GraphicsContext.h"
    void drawText (const String& text,
                   Rectangle<int> area,
                   Justification justificationType,
                   bool useEllipsesIfTooBig = true) const;
# 186 "..\\..\\..\\JUCE\\modules\\juce_graphics/contexts/juce_GraphicsContext.h"
    void drawText (const String& text,
                   Rectangle<float> area,
                   Justification justificationType,
                   bool useEllipsesIfTooBig = true) const;
# 210 "..\\..\\..\\JUCE\\modules\\juce_graphics/contexts/juce_GraphicsContext.h"
    void drawFittedText (const String& text,
                         int x, int y, int width, int height,
                         Justification justificationFlags,
                         int maximumNumberOfLines,
                         float minimumHorizontalScale = 0.0f) const;
# 235 "..\\..\\..\\JUCE\\modules\\juce_graphics/contexts/juce_GraphicsContext.h"
    void drawFittedText (const String& text,
                         Rectangle<int> area,
                         Justification justificationFlags,
                         int maximumNumberOfLines,
                         float minimumHorizontalScale = 0.0f) const;







    void fillAll() const;






    void fillAll (Colour colourToUse) const;





    void fillRect (Rectangle<int> rectangle) const;




    void fillRect (Rectangle<float> rectangle) const;




    void fillRect (int x, int y, int width, int height) const;




    void fillRect (float x, float y, float width, float height) const;






    void fillRectList (const RectangleList<float>& rectangles) const;






    void fillRectList (const RectangleList<int>& rectangles) const;




    void fillRoundedRectangle (float x, float y, float width, float height,
                               float cornerSize) const;




    void fillRoundedRectangle (Rectangle<float> rectangle,
                               float cornerSize) const;


    void fillCheckerBoard (Rectangle<int> area,
                           int checkWidth, int checkHeight,
                           Colour colour1, Colour colour2) const;





    void drawRect (int x, int y, int width, int height, int lineThickness = 1) const;





    void drawRect (float x, float y, float width, float height, float lineThickness = 1.0f) const;





    void drawRect (Rectangle<int> rectangle, int lineThickness = 1) const;





    void drawRect (Rectangle<float> rectangle, float lineThickness = 1.0f) const;




    void drawRoundedRectangle (float x, float y, float width, float height,
                               float cornerSize, float lineThickness) const;




    void drawRoundedRectangle (Rectangle<float> rectangle,
                               float cornerSize, float lineThickness) const;





    void setPixel (int x, int y) const;






    void fillEllipse (float x, float y, float width, float height) const;





    void fillEllipse (Rectangle<float> area) const;




    void drawEllipse (float x, float y, float width, float height,
                      float lineThickness) const;




    void drawEllipse (Rectangle<float> area, float lineThickness) const;







    void drawLine (float startX, float startY, float endX, float endY) const;






    void drawLine (float startX, float startY, float endX, float endY, float lineThickness) const;






    void drawLine (const Line<float>& line) const;






    void drawLine (const Line<float>& line, float lineThickness) const;
# 414 "..\\..\\..\\JUCE\\modules\\juce_graphics/contexts/juce_GraphicsContext.h"
    void drawDashedLine (const Line<float>& line,
                         const float* dashLengths, int numDashLengths,
                         float lineThickness = 1.0f,
                         int dashIndexToStartFrom = 0) const;
# 426 "..\\..\\..\\JUCE\\modules\\juce_graphics/contexts/juce_GraphicsContext.h"
    void drawVerticalLine (int x, float top, float bottom) const;
# 435 "..\\..\\..\\JUCE\\modules\\juce_graphics/contexts/juce_GraphicsContext.h"
    void drawHorizontalLine (int y, float left, float right) const;



    void fillPath (const Path& path) const;


    void fillPath (const Path& path, const AffineTransform& transform) const;


    void strokePath (const Path& path,
                     const PathStrokeType& strokeType,
                     const AffineTransform& transform = AffineTransform()) const;
# 456 "..\\..\\..\\JUCE\\modules\\juce_graphics/contexts/juce_GraphicsContext.h"
    void drawArrow (const Line<float>& line,
                    float lineThickness,
                    float arrowheadWidth,
                    float arrowheadLength) const;







    enum ResamplingQuality
    {
        lowResamplingQuality = 0,
        mediumResamplingQuality = 1,
        highResamplingQuality = 2,
    };





    void setImageResamplingQuality (const ResamplingQuality newQuality);
# 491 "..\\..\\..\\JUCE\\modules\\juce_graphics/contexts/juce_GraphicsContext.h"
    void drawImageAt (const Image& imageToDraw, int topLeftX, int topLeftY,
                      bool fillAlphaChannelWithCurrentBrush = false) const;
# 519 "..\\..\\..\\JUCE\\modules\\juce_graphics/contexts/juce_GraphicsContext.h"
    void drawImage (const Image& imageToDraw,
                    int destX, int destY, int destWidth, int destHeight,
                    int sourceX, int sourceY, int sourceWidth, int sourceHeight,
                    bool fillAlphaChannelWithCurrentBrush = false) const;
# 541 "..\\..\\..\\JUCE\\modules\\juce_graphics/contexts/juce_GraphicsContext.h"
    void drawImageTransformed (const Image& imageToDraw,
                               const AffineTransform& transform,
                               bool fillAlphaChannelWithCurrentBrush = false) const;
# 558 "..\\..\\..\\JUCE\\modules\\juce_graphics/contexts/juce_GraphicsContext.h"
    void drawImage (const Image& imageToDraw, Rectangle<float> targetArea,
                    RectanglePlacement placementWithinTarget = RectanglePlacement::stretchToFit,
                    bool fillAlphaChannelWithCurrentBrush = false) const;
# 583 "..\\..\\..\\JUCE\\modules\\juce_graphics/contexts/juce_GraphicsContext.h"
    void drawImageWithin (const Image& imageToDraw,
                          int destX, int destY, int destWidth, int destHeight,
                          RectanglePlacement placementWithinTarget,
                          bool fillAlphaChannelWithCurrentBrush = false) const;





    Rectangle<int> getClipBounds() const;







    bool clipRegionIntersects (Rectangle<int> area) const;






    bool reduceClipRegion (int x, int y, int width, int height);






    bool reduceClipRegion (Rectangle<int> area);






    bool reduceClipRegion (const RectangleList<int>& clipRegion);






    bool reduceClipRegion (const Path& path, const AffineTransform& transform = AffineTransform());
# 641 "..\\..\\..\\JUCE\\modules\\juce_graphics/contexts/juce_GraphicsContext.h"
    bool reduceClipRegion (const Image& image, const AffineTransform& transform);


    void excludeClipRegion (Rectangle<int> rectangleToExclude);


    bool isClipEmpty() const;






    void saveState();




    void restoreState();





    class ScopedSaveState
    {
    public:
        ScopedSaveState (Graphics&);
        ~ScopedSaveState();

    private:
        Graphics& context;
        ScopedSaveState (const ScopedSaveState&) = delete; ScopedSaveState& operator= (const ScopedSaveState&) = delete;
    };
# 687 "..\\..\\..\\JUCE\\modules\\juce_graphics/contexts/juce_GraphicsContext.h"
    void beginTransparencyLayer (float layerOpacity);




    void endTransparencyLayer();
# 704 "..\\..\\..\\JUCE\\modules\\juce_graphics/contexts/juce_GraphicsContext.h"
    void setOrigin (Point<int> newOrigin);
# 716 "..\\..\\..\\JUCE\\modules\\juce_graphics/contexts/juce_GraphicsContext.h"
    void setOrigin (int newOriginX, int newOriginY);
# 726 "..\\..\\..\\JUCE\\modules\\juce_graphics/contexts/juce_GraphicsContext.h"
    void addTransform (const AffineTransform& transform);


    void resetToDefaultState();


    bool isVectorDevice() const;






    Graphics (LowLevelGraphicsContext&) noexcept;


    LowLevelGraphicsContext& getInternalContext() const noexcept { return context; }

private:

    LowLevelGraphicsContext& context;
    ScopedPointer<LowLevelGraphicsContext> contextToDelete;

    bool saveStatePending;
    void saveStateIfPending();

    Graphics (const Graphics&) = delete; Graphics& operator= (const Graphics&) = delete;
};
# 127 "..\\..\\..\\JUCE\\modules\\juce_graphics/juce_graphics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_graphics/contexts/juce_LowLevelGraphicsContext.h" 1
# 43 "..\\..\\..\\JUCE\\modules\\juce_graphics/contexts/juce_LowLevelGraphicsContext.h"
class LowLevelGraphicsContext
{
protected:

    LowLevelGraphicsContext();

public:
    virtual ~LowLevelGraphicsContext();


    virtual bool isVectorDevice() const = 0;







    virtual void setOrigin (Point<int>) = 0;
    virtual void addTransform (const AffineTransform&) = 0;
    virtual float getPhysicalPixelScaleFactor() = 0;

    virtual bool clipToRectangle (const Rectangle<int>&) = 0;
    virtual bool clipToRectangleList (const RectangleList<int>&) = 0;
    virtual void excludeClipRectangle (const Rectangle<int>&) = 0;
    virtual void clipToPath (const Path&, const AffineTransform&) = 0;
    virtual void clipToImageAlpha (const Image&, const AffineTransform&) = 0;

    virtual bool clipRegionIntersects (const Rectangle<int>&) = 0;
    virtual Rectangle<int> getClipBounds() const = 0;
    virtual bool isClipEmpty() const = 0;

    virtual void saveState() = 0;
    virtual void restoreState() = 0;

    virtual void beginTransparencyLayer (float opacity) = 0;
    virtual void endTransparencyLayer() = 0;


    virtual void setFill (const FillType&) = 0;
    virtual void setOpacity (float) = 0;
    virtual void setInterpolationQuality (Graphics::ResamplingQuality) = 0;


    virtual void fillRect (const Rectangle<int>&, bool replaceExistingContents) = 0;
    virtual void fillRect (const Rectangle<float>&) = 0;
    virtual void fillRectList (const RectangleList<float>&) = 0;
    virtual void fillPath (const Path&, const AffineTransform&) = 0;
    virtual void drawImage (const Image&, const AffineTransform&) = 0;
    virtual void drawLine (const Line<float>&) = 0;

    virtual void setFont (const Font&) = 0;
    virtual const Font& getFont() = 0;
    virtual void drawGlyph (int glyphNumber, const AffineTransform&) = 0;
    virtual bool drawTextLayout (const AttributedString&, const Rectangle<float>&) { return false; }
};
# 128 "..\\..\\..\\JUCE\\modules\\juce_graphics/juce_graphics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_graphics/images/juce_Image.h" 1
# 28 "..\\..\\..\\JUCE\\modules\\juce_graphics/images/juce_Image.h"
class ImageType;
class ImagePixelData;
# 54 "..\\..\\..\\JUCE\\modules\\juce_graphics/images/juce_Image.h"
class Image
{
public:



    enum PixelFormat
    {
        UnknownFormat,
        RGB,
        ARGB,
        SingleChannel
    };



    Image() noexcept;
# 86 "..\\..\\..\\JUCE\\modules\\juce_graphics/images/juce_Image.h"
    Image (PixelFormat format, int imageWidth, int imageHeight, bool clearImage);
# 101 "..\\..\\..\\JUCE\\modules\\juce_graphics/images/juce_Image.h"
    Image (PixelFormat format, int imageWidth, int imageHeight, bool clearImage, const ImageType& type);







    Image (const Image&) noexcept;







    Image& operator= (const Image&);


    Image (Image&&) noexcept;
    Image& operator= (Image&&) noexcept;



    ~Image();


    bool operator== (const Image& other) const noexcept { return image == other.image; }


    bool operator!= (const Image& other) const noexcept { return image != other.image; }







    inline bool isValid() const noexcept { return image != nullptr; }







    inline bool isNull() const noexcept { return image == nullptr; }






    static const Image null;




    int getWidth() const noexcept;


    int getHeight() const noexcept;




    Rectangle<int> getBounds() const noexcept;


    PixelFormat getFormat() const noexcept;


    bool isARGB() const noexcept;


    bool isRGB() const noexcept;


    bool isSingleChannel() const noexcept;


    bool hasAlphaChannel() const noexcept;







    void clear (const Rectangle<int>& area, Colour colourToClearTo = Colour (0x00000000));
# 199 "..\\..\\..\\JUCE\\modules\\juce_graphics/images/juce_Image.h"
    Image rescaled (int newWidth, int newHeight,
                    Graphics::ResamplingQuality quality = Graphics::mediumResamplingQuality) const;






    Image createCopy() const;
# 216 "..\\..\\..\\JUCE\\modules\\juce_graphics/images/juce_Image.h"
    Image convertedToFormat (PixelFormat newFormat) const;
# 229 "..\\..\\..\\JUCE\\modules\\juce_graphics/images/juce_Image.h"
    void duplicateIfShared();
# 242 "..\\..\\..\\JUCE\\modules\\juce_graphics/images/juce_Image.h"
    Image getClippedImage (const Rectangle<int>& area) const;
# 252 "..\\..\\..\\JUCE\\modules\\juce_graphics/images/juce_Image.h"
    Colour getPixelAt (int x, int y) const;
# 264 "..\\..\\..\\JUCE\\modules\\juce_graphics/images/juce_Image.h"
    void setPixelAt (int x, int y, Colour colour);
# 276 "..\\..\\..\\JUCE\\modules\\juce_graphics/images/juce_Image.h"
    void multiplyAlphaAt (int x, int y, float multiplier);
# 286 "..\\..\\..\\JUCE\\modules\\juce_graphics/images/juce_Image.h"
    void multiplyAllAlphas (float amountToMultiplyBy);



    void desaturate();
# 309 "..\\..\\..\\JUCE\\modules\\juce_graphics/images/juce_Image.h"
    class BitmapData
    {
    public:
        enum ReadWriteMode
        {
            readOnly,
            writeOnly,
            readWrite
        };

        BitmapData (Image& image, int x, int y, int w, int h, ReadWriteMode mode);
        BitmapData (const Image& image, int x, int y, int w, int h);
        BitmapData (const Image& image, ReadWriteMode mode);
        ~BitmapData();





        inline uint8* getLinePointer (int y) const noexcept { return data + y * lineStride; }





        inline uint8* getPixelPointer (int x, int y) const noexcept { return data + y * lineStride + x * pixelStride; }





        Colour getPixelColour (int x, int y) const noexcept;





        void setPixelColour (int x, int y, Colour colour) const noexcept;


        Rectangle<int> getBounds() const noexcept { return Rectangle<int> (width, height); }

        uint8* data;
        PixelFormat pixelFormat;
        int lineStride;
        int pixelStride;
        int width, height;



        class BitmapDataReleaser
        {
        protected:
            BitmapDataReleaser() {}
        public:
            virtual ~BitmapDataReleaser() {}
        };

        ScopedPointer<BitmapDataReleaser> dataReleaser;

    private:
        BitmapData (const BitmapData&) = delete; BitmapData& operator= (const BitmapData&) = delete;
    };



    void moveImageSection (int destX, int destY,
                           int sourceX, int sourceY,
                           int width, int height);
# 386 "..\\..\\..\\JUCE\\modules\\juce_graphics/images/juce_Image.h"
    void createSolidAreaMask (RectangleList<int>& result, float alphaThreshold) const;







    NamedValueSet* getProperties() const;





    LowLevelGraphicsContext* createLowLevelContext() const;






    int getReferenceCount() const noexcept;



    ImagePixelData* getPixelData() const noexcept { return image; }


    explicit Image (ImagePixelData*) noexcept;

private:

    ReferenceCountedObjectPtr<ImagePixelData> image;


};
# 435 "..\\..\\..\\JUCE\\modules\\juce_graphics/images/juce_Image.h"
class ImagePixelData : public ReferenceCountedObject
{
public:
    ImagePixelData (Image::PixelFormat, int width, int height);
    ~ImagePixelData();

    typedef ReferenceCountedObjectPtr<ImagePixelData> Ptr;


    virtual LowLevelGraphicsContext* createLowLevelContext() = 0;

    virtual Ptr clone() = 0;

    virtual ImageType* createType() const = 0;

    virtual void initialiseBitmapData (Image::BitmapData&, int x, int y, Image::BitmapData::ReadWriteMode) = 0;



    virtual int getSharedCount() const noexcept;



    const Image::PixelFormat pixelFormat;
    const int width, height;




    NamedValueSet userData;


    struct Listener
    {
        virtual ~Listener() {}

        virtual void imageDataChanged (ImagePixelData*) = 0;
        virtual void imageDataBeingDeleted (ImagePixelData*) = 0;
    };

    ListenerList<Listener> listeners;

    void sendDataChangeMessage();

private:
    ImagePixelData (const ImagePixelData&) = delete; ImagePixelData& operator= (const ImagePixelData&) = delete;
};
# 490 "..\\..\\..\\JUCE\\modules\\juce_graphics/images/juce_Image.h"
class ImageType
{
public:
    ImageType();
    virtual ~ImageType();


    virtual ImagePixelData::Ptr create (Image::PixelFormat format, int width, int height, bool shouldClearImage) const = 0;


    virtual int getTypeID() const = 0;





    virtual Image convert (const Image& source) const;
};






class SoftwareImageType : public ImageType
{
public:
    SoftwareImageType();
    ~SoftwareImageType();

    ImagePixelData::Ptr create (Image::PixelFormat, int width, int height, bool clearImage) const override;
    int getTypeID() const override;
};







class NativeImageType : public ImageType
{
public:
    NativeImageType();
    ~NativeImageType();

    ImagePixelData::Ptr create (Image::PixelFormat, int width, int height, bool clearImage) const override;
    int getTypeID() const override;
};
# 129 "..\\..\\..\\JUCE\\modules\\juce_graphics/juce_graphics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_graphics/colour/juce_FillType.h" 1
# 38 "..\\..\\..\\JUCE\\modules\\juce_graphics/colour/juce_FillType.h"
class FillType
{
public:


    FillType() noexcept;




    FillType (Colour colour) noexcept;




    FillType (const ColourGradient& gradient);





    FillType (const Image& image, const AffineTransform& transform) noexcept;


    FillType (const FillType&);


    FillType& operator= (const FillType&);


    FillType (FillType&&) noexcept;
    FillType& operator= (FillType&&) noexcept;



    ~FillType() noexcept;



    bool isColour() const noexcept { return gradient == nullptr && image.isNull(); }


    bool isGradient() const noexcept { return gradient != nullptr; }


    bool isTiledImage() const noexcept { return image.isValid(); }



    void setColour (Colour newColour) noexcept;


    void setGradient (const ColourGradient& newGradient);




    void setTiledImage (const Image& image, const AffineTransform& transform) noexcept;





    void setOpacity (float newOpacity) noexcept;




    float getOpacity() const noexcept { return colour.getFloatAlpha(); }


    bool isInvisible() const noexcept;




    FillType transformed (const AffineTransform& transform) const;







    Colour colour;






    ScopedPointer<ColourGradient> gradient;





    Image image;


    AffineTransform transform;


    bool operator== (const FillType&) const;
    bool operator!= (const FillType&) const;

private:

};
# 130 "..\\..\\..\\JUCE\\modules\\juce_graphics/juce_graphics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h" 1
# 29 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
#pragma warning(push)
#pragma warning(disable: 4127)


namespace RenderingHelpers
{




class TranslationOrTransform
{
public:
    TranslationOrTransform (Point<int> origin) noexcept
        : offset (origin), isOnlyTranslated (true), isRotated (false)
    {
    }

    TranslationOrTransform (const TranslationOrTransform& other) noexcept
        : complexTransform (other.complexTransform), offset (other.offset),
          isOnlyTranslated (other.isOnlyTranslated), isRotated (other.isRotated)
    {
    }

    AffineTransform getTransform() const noexcept
    {
        return isOnlyTranslated ? AffineTransform::translation (offset)
                                : complexTransform;
    }

    AffineTransform getTransformWith (const AffineTransform& userTransform) const noexcept
    {
        return isOnlyTranslated ? userTransform.translated (offset)
                                : userTransform.followedBy (complexTransform);
    }

    void setOrigin (Point<int> delta) noexcept
    {
        if (isOnlyTranslated)
            offset += delta;
        else
            complexTransform = AffineTransform::translation (delta)
                                               .followedBy (complexTransform);
    }

    void addTransform (const AffineTransform& t) noexcept
    {
        if (isOnlyTranslated && t.isOnlyTranslation())
        {
            const int tx = (int) (t.getTranslationX() * 256.0f);
            const int ty = (int) (t.getTranslationY() * 256.0f);

            if (((tx | ty) & 0xf8) == 0)
            {
                offset += Point<int> (tx >> 8, ty >> 8);
                return;
            }
        }

        complexTransform = getTransformWith (t);
        isOnlyTranslated = false;
        isRotated = (complexTransform.mat01 != 0 || complexTransform.mat10 != 0
                      || complexTransform.mat00 < 0 || complexTransform.mat11 < 0);
    }

    float getPhysicalPixelScaleFactor() const noexcept
    {
        return isOnlyTranslated ? 1.0f : std::abs (complexTransform.getScaleFactor());
    }

    void moveOriginInDeviceSpace (Point<int> delta) noexcept
    {
        if (isOnlyTranslated)
            offset += delta;
        else
            complexTransform = complexTransform.translated (delta);
    }

    Rectangle<int> translated (const Rectangle<int>& r) const noexcept
    {
#pragma warning(push)
# 109 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
#pragma warning(disable: 4127)
# 109 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
 do { ; } while (false)
# 109 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
#pragma warning(pop)
# 109 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
;
        return r + offset;
    }

    Rectangle<float> translated (const Rectangle<float>& r) const noexcept
    {
#pragma warning(push)
# 115 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
#pragma warning(disable: 4127)
# 115 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
 do { ; } while (false)
# 115 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
#pragma warning(pop)
# 115 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
;
        return r + offset.toFloat();
    }

    template <typename RectangleOrPoint>
    RectangleOrPoint transformed (const RectangleOrPoint& r) const noexcept
    {
#pragma warning(push)
# 122 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
#pragma warning(disable: 4127)
# 122 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
 do { ; } while (false)
# 122 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
#pragma warning(pop)
# 122 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
;
        return r.transformedBy (complexTransform);
    }

    template <typename Type>
    Rectangle<Type> deviceSpaceToUserSpace (const Rectangle<Type>& r) const noexcept
    {
        return isOnlyTranslated ? r - offset
                                : r.transformedBy (complexTransform.inverted());
    }

    AffineTransform complexTransform;
    Point<int> offset;
    bool isOnlyTranslated, isRotated;
};



template <class CachedGlyphType, class RenderTargetType>
class GlyphCache : private DeletedAtShutdown
{
public:
    GlyphCache()
    {
        reset();
    }

    ~GlyphCache()
    {
        getSingletonPointer() = nullptr;
    }

    static GlyphCache& getInstance()
    {
        GlyphCache*& g = getSingletonPointer();

        if (g == nullptr)
            g = new GlyphCache();

        return *g;
    }


    void reset()
    {
        const ScopedLock sl (lock);
        glyphs.clear();
        addNewGlyphSlots (120);
        hits.set (0);
        misses.set (0);
    }

    void drawGlyph (RenderTargetType& target, const Font& font, const int glyphNumber, Point<float> pos)
    {
        if (ReferenceCountedObjectPtr<CachedGlyphType> glyph = findOrCreateGlyph (font, glyphNumber))
        {
            glyph->lastAccessCount = ++accessCounter;
            glyph->draw (target, pos);
        }
    }

    ReferenceCountedObjectPtr<CachedGlyphType> findOrCreateGlyph (const Font& font, int glyphNumber)
    {
        const ScopedLock sl (lock);

        if (CachedGlyphType* g = findExistingGlyph (font, glyphNumber))
        {
            ++hits;
            return g;
        }

        ++misses;
        CachedGlyphType* g = getGlyphForReuse();
#pragma warning(push)
# 195 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
#pragma warning(disable: 4127)
# 195 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
 do { ; } while (false)
# 195 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
#pragma warning(pop)
# 195 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
;
        g->generate (font, glyphNumber);
        return g;
    }

private:
    friend struct ContainerDeletePolicy<CachedGlyphType>;
    ReferenceCountedArray<CachedGlyphType> glyphs;
    Atomic<int> accessCounter, hits, misses;
    CriticalSection lock;

    CachedGlyphType* findExistingGlyph (const Font& font, int glyphNumber) const
    {
        for (int i = 0; i < glyphs.size(); ++i)
        {
            CachedGlyphType* const g = glyphs.getUnchecked (i);

            if (g->glyph == glyphNumber && g->font == font)
                return g;
        }

        return nullptr;
    }

    CachedGlyphType* getGlyphForReuse()
    {
        if (hits.value + misses.value > glyphs.size() * 16)
        {
            if (misses.value * 2 > hits.value)
                addNewGlyphSlots (32);

            hits.set (0);
            misses.set (0);
        }

        if (CachedGlyphType* g = findLeastRecentlyUsedGlyph())
            return g;

        addNewGlyphSlots (32);
        return glyphs.getLast();
    }

    void addNewGlyphSlots (int num)
    {
        glyphs.ensureStorageAllocated (glyphs.size() + num);

        while (--num >= 0)
            glyphs.add (new CachedGlyphType());
    }

    CachedGlyphType* findLeastRecentlyUsedGlyph() const noexcept
    {
        CachedGlyphType* oldest = nullptr;
        int oldestCounter = std::numeric_limits<int>::max();

        for (int i = glyphs.size() - 1; --i >= 0;)
        {
            CachedGlyphType* const glyph = glyphs.getUnchecked(i);

            if (glyph->lastAccessCount <= oldestCounter
                 && glyph->getReferenceCount() == 1)
            {
                oldestCounter = glyph->lastAccessCount;
                oldest = glyph;
            }
        }

        return oldest;
    }

    static GlyphCache*& getSingletonPointer() noexcept
    {
        static GlyphCache* g = nullptr;
        return g;
    }

    GlyphCache (const GlyphCache&) = delete; GlyphCache& operator= (const GlyphCache&) = delete;
};



template <class RendererType>
class CachedGlyphEdgeTable : public ReferenceCountedObject
{
public:
    CachedGlyphEdgeTable() : glyph (0), lastAccessCount (0) {}

    void draw (RendererType& state, Point<float> pos) const
    {
        if (snapToIntegerCoordinate)
            pos.x = std::floor (pos.x + 0.5f);

        if (edgeTable != nullptr)
            state.fillEdgeTable (*edgeTable, pos.x, roundToInt (pos.y));
    }

    void generate (const Font& newFont, const int glyphNumber)
    {
        font = newFont;
        Typeface* const typeface = newFont.getTypeface();
        snapToIntegerCoordinate = typeface->isHinted();
        glyph = glyphNumber;

        const float fontHeight = font.getHeight();
        edgeTable = typeface->getEdgeTableForGlyph (glyphNumber,
                                                    AffineTransform::scale (fontHeight * font.getHorizontalScale(),
                                                                            fontHeight), fontHeight);
    }

    Font font;
    ScopedPointer<EdgeTable> edgeTable;
    int glyph, lastAccessCount;
    bool snapToIntegerCoordinate;

    CachedGlyphEdgeTable (const CachedGlyphEdgeTable&) = delete; CachedGlyphEdgeTable& operator= (const CachedGlyphEdgeTable&) = delete;
};





struct FloatRectangleRasterisingInfo
{
    FloatRectangleRasterisingInfo (const Rectangle<float>& area)
        : left (roundToInt (256.0f * area.getX())),
          top (roundToInt (256.0f * area.getY())),
          right (roundToInt (256.0f * area.getRight())),
          bottom (roundToInt (256.0f * area.getBottom()))
    {
        if ((top >> 8) == (bottom >> 8))
        {
            topAlpha = bottom - top;
            bottomAlpha = 0;
            totalTop = top >> 8;
            totalBottom = bottom = top = totalTop + 1;
        }
        else
        {
            if ((top & 255) == 0)
            {
                topAlpha = 0;
                top = totalTop = (top >> 8);
            }
            else
            {
                topAlpha = 255 - (top & 255);
                totalTop = (top >> 8);
                top = totalTop + 1;
            }

            bottomAlpha = bottom & 255;
            bottom >>= 8;
            totalBottom = bottom + (bottomAlpha != 0 ? 1 : 0);
        }

        if ((left >> 8) == (right >> 8))
        {
            leftAlpha = right - left;
            rightAlpha = 0;
            totalLeft = (left >> 8);
            totalRight = right = left = totalLeft + 1;
        }
        else
        {
            if ((left & 255) == 0)
            {
                leftAlpha = 0;
                left = totalLeft = (left >> 8);
            }
            else
            {
                leftAlpha = 255 - (left & 255);
                totalLeft = (left >> 8);
                left = totalLeft + 1;
            }

            rightAlpha = right & 255;
            right >>= 8;
            totalRight = right + (rightAlpha != 0 ? 1 : 0);
        }
    }

    template <class Callback>
    void iterate (Callback& callback) const
    {
        if (topAlpha != 0) callback (totalLeft, totalTop, totalRight - totalLeft, 1, topAlpha);
        if (bottomAlpha != 0) callback (totalLeft, bottom, totalRight - totalLeft, 1, bottomAlpha);
        if (leftAlpha != 0) callback (totalLeft, totalTop, 1, totalBottom - totalTop, leftAlpha);
        if (rightAlpha != 0) callback (right, totalTop, 1, totalBottom - totalTop, rightAlpha);

        callback (left, top, right - left, bottom - top, 255);
    }

    inline bool isOnePixelWide() const noexcept { return right - left == 1 && leftAlpha + rightAlpha == 0; }

    inline int getTopLeftCornerAlpha() const noexcept { return (topAlpha * leftAlpha) >> 8; }
    inline int getTopRightCornerAlpha() const noexcept { return (topAlpha * rightAlpha) >> 8; }
    inline int getBottomLeftCornerAlpha() const noexcept { return (bottomAlpha * leftAlpha) >> 8; }
    inline int getBottomRightCornerAlpha() const noexcept { return (bottomAlpha * rightAlpha) >> 8; }


    int left, top, right, bottom;
    int totalTop, totalLeft, totalBottom, totalRight;
    int topAlpha, leftAlpha, bottomAlpha, rightAlpha;
};



namespace GradientPixelIterators
{

    class Linear
    {
    public:
        Linear (const ColourGradient& gradient, const AffineTransform& transform,
                const PixelARGB* const colours, const int numColours)
            : lookupTable (colours),
              numEntries (numColours)
        {
#pragma warning(push)
# 414 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
#pragma warning(disable: 4127)
# 414 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
 do { ; } while (false)
# 414 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
#pragma warning(pop)
# 414 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
;
            Point<float> p1 (gradient.point1);
            Point<float> p2 (gradient.point2);

            if (! transform.isIdentity())
            {
                const Line<float> l (p2, p1);
                Point<float> p3 = l.getPointAlongLine (0.0f, 100.0f);

                p1.applyTransform (transform);
                p2.applyTransform (transform);
                p3.applyTransform (transform);

                p2 = Line<float> (p2, p3).findNearestPointTo (p1);
            }

            vertical = std::abs (p1.x - p2.x) < 0.001f;
            horizontal = std::abs (p1.y - p2.y) < 0.001f;

            if (vertical)
            {
                scale = roundToInt ((numEntries << (int) numScaleBits) / (double) (p2.y - p1.y));
                start = roundToInt (p1.y * (float) scale);
            }
            else if (horizontal)
            {
                scale = roundToInt ((numEntries << (int) numScaleBits) / (double) (p2.x - p1.x));
                start = roundToInt (p1.x * (float) scale);
            }
            else
            {
                grad = (p2.getY() - p1.y) / (double) (p1.x - p2.x);
                yTerm = p1.getY() - p1.x / grad;
                scale = roundToInt ((numEntries << (int) numScaleBits) / (yTerm * grad - (p2.y * grad - p2.x)));
                grad *= scale;
            }
        }

        __forceinline void setY (const int y) noexcept
        {
            if (vertical)
                linePix = lookupTable [jlimit (0, numEntries, (y * scale - start) >> (int) numScaleBits)];
            else if (! horizontal)
                start = roundToInt ((y - yTerm) * grad);
        }

        inline PixelARGB getPixel (const int x) const noexcept
        {
            return vertical ? linePix
                            : lookupTable [jlimit (0, numEntries, (x * scale - start) >> (int) numScaleBits)];
        }

    private:
        const PixelARGB* const lookupTable;
        const int numEntries;
        PixelARGB linePix;
        int start, scale;
        double grad, yTerm;
        bool vertical, horizontal;
        enum { numScaleBits = 12 };

        Linear (const Linear&) = delete; Linear& operator= (const Linear&) = delete;
    };



    class Radial
    {
    public:
        Radial (const ColourGradient& gradient, const AffineTransform&,
                const PixelARGB* const colours, const int numColours)
            : lookupTable (colours),
              numEntries (numColours),
              gx1 (gradient.point1.x),
              gy1 (gradient.point1.y)
        {
#pragma warning(push)
# 490 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
#pragma warning(disable: 4127)
# 490 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
 do { ; } while (false)
# 490 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
#pragma warning(pop)
# 490 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
;
            const Point<float> diff (gradient.point1 - gradient.point2);
            maxDist = diff.x * diff.x + diff.y * diff.y;
            invScale = numEntries / std::sqrt (maxDist);
#pragma warning(push)
# 494 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
#pragma warning(disable: 4127)
# 494 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
 do { ; } while (false)
# 494 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
#pragma warning(pop)
# 494 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
;
        }

        __forceinline void setY (const int y) noexcept
        {
            dy = y - gy1;
            dy *= dy;
        }

        inline PixelARGB getPixel (const int px) const noexcept
        {
            double x = px - gx1;
            x *= x;
            x += dy;

            return lookupTable [x >= maxDist ? numEntries : roundToInt (std::sqrt (x) * invScale)];
        }

    protected:
        const PixelARGB* const lookupTable;
        const int numEntries;
        const double gx1, gy1;
        double maxDist, invScale, dy;

        Radial (const Radial&) = delete; Radial& operator= (const Radial&) = delete;
    };



    class TransformedRadial : public Radial
    {
    public:
        TransformedRadial (const ColourGradient& gradient, const AffineTransform& transform,
                           const PixelARGB* const colours, const int numColours)
            : Radial (gradient, transform, colours, numColours),
              inverseTransform (transform.inverted())
        {
            tM10 = inverseTransform.mat10;
            tM00 = inverseTransform.mat00;
        }

        __forceinline void setY (const int y) noexcept
        {
            const float floatY = (float) y;
            lineYM01 = inverseTransform.mat01 * floatY + inverseTransform.mat02 - gx1;
            lineYM11 = inverseTransform.mat11 * floatY + inverseTransform.mat12 - gy1;
        }

        inline PixelARGB getPixel (const int px) const noexcept
        {
            double x = px;
            const double y = tM10 * x + lineYM11;
            x = tM00 * x + lineYM01;
            x *= x;
            x += y * y;

            if (x >= maxDist)
                return lookupTable [numEntries];

            return lookupTable [jmin (numEntries, roundToInt (std::sqrt (x) * invScale))];
        }

    private:
        double tM10, tM00, lineYM01, lineYM11;
        const AffineTransform inverseTransform;

        TransformedRadial (const TransformedRadial&) = delete; TransformedRadial& operator= (const TransformedRadial&) = delete;
    };
}
# 572 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
namespace EdgeTableFillers
{

    template <class PixelType, bool replaceExisting = false>
    class SolidColour
    {
    public:
        SolidColour (const Image::BitmapData& image, const PixelARGB colour)
            : destData (image), sourceColour (colour)
        {
            if (sizeof (PixelType) == 3 && destData.pixelStride == sizeof (PixelType))
            {
                areRGBComponentsEqual = sourceColour.getRed() == sourceColour.getGreen()
                                            && sourceColour.getGreen() == sourceColour.getBlue();
                filler[0].set (sourceColour);
                filler[1].set (sourceColour);
                filler[2].set (sourceColour);
                filler[3].set (sourceColour);
            }
            else
            {
                areRGBComponentsEqual = false;
            }
        }

        __forceinline void setEdgeTableYPos (const int y) noexcept
        {
            linePixels = (PixelType*) destData.getLinePointer (y);
        }

        __forceinline void handleEdgeTablePixel (const int x, const int alphaLevel) const noexcept
        {
            if (replaceExisting)
                getPixel (x)->set (sourceColour);
            else
                getPixel (x)->blend (sourceColour, (uint32) alphaLevel);
        }

        __forceinline void handleEdgeTablePixelFull (const int x) const noexcept
        {
            if (replaceExisting)
                getPixel (x)->set (sourceColour);
            else
                getPixel (x)->blend (sourceColour);
        }

        __forceinline void handleEdgeTableLine (const int x, const int width, const int alphaLevel) const noexcept
        {
            PixelARGB p (sourceColour);
            p.multiplyAlpha (alphaLevel);

            PixelType* dest = getPixel (x);

            if (replaceExisting || p.getAlpha() >= 0xff)
                replaceLine (dest, p, width);
            else
                blendLine (dest, p, width);
        }

        __forceinline void handleEdgeTableLineFull (const int x, const int width) const noexcept
        {
            PixelType* dest = getPixel (x);

            if (replaceExisting || sourceColour.getAlpha() >= 0xff)
                replaceLine (dest, sourceColour, width);
            else
                blendLine (dest, sourceColour, width);
        }

    private:
        const Image::BitmapData& destData;
        PixelType* linePixels;
        PixelARGB sourceColour;
        PixelRGB filler [4];
        bool areRGBComponentsEqual;

        __forceinline PixelType* getPixel (const int x) const noexcept
        {
            return addBytesToPointer (linePixels, x * destData.pixelStride);
        }

        inline void blendLine (PixelType* dest, const PixelARGB colour, int width) const noexcept
        {
            { const int destStride = destData.pixelStride; do { dest->blend (colour); dest = addBytesToPointer (dest, destStride); } while (--width > 0); }
        }

        __forceinline void replaceLine (PixelRGB* dest, const PixelARGB colour, int width) const noexcept
        {
            if (destData.pixelStride == sizeof (*dest))
            {
                if (areRGBComponentsEqual)
                {
                    memset (dest, colour.getRed(), (size_t) width * 3);
                }
                else
                {
                    if (width >> 5)
                    {
                        const int* const intFiller = reinterpret_cast<const int*> (filler);

                        while (width > 8 && (((pointer_sized_int) dest) & 7) != 0)
                        {
                            dest->set (colour);
                            ++dest;
                            --width;
                        }

                        while (width > 4)
                        {
                            int* d = reinterpret_cast<int*> (dest);
                            *d++ = intFiller[0];
                            *d++ = intFiller[1];
                            *d++ = intFiller[2];
                            dest = reinterpret_cast<PixelRGB*> (d);
                            width -= 4;
                        }
                    }

                    while (--width >= 0)
                    {
                        dest->set (colour);
                        ++dest;
                    }
                }
            }
            else
            {
                { const int destStride = destData.pixelStride; do { dest->set (colour); dest = addBytesToPointer (dest, destStride); } while (--width > 0); }
            }
        }

        __forceinline void replaceLine (PixelAlpha* dest, const PixelARGB colour, int width) const noexcept
        {
            if (destData.pixelStride == sizeof (*dest))
                memset (dest, colour.getAlpha(), (size_t) width);
            else
                { const int destStride = destData.pixelStride; do { dest->setAlpha (colour.getAlpha()); dest = addBytesToPointer (dest, destStride); } while (--width > 0); }
        }

        __forceinline void replaceLine (PixelARGB* dest, const PixelARGB colour, int width) const noexcept
        {
            { const int destStride = destData.pixelStride; do { dest->set (colour); dest = addBytesToPointer (dest, destStride); } while (--width > 0); }
        }

        SolidColour (const SolidColour&) = delete; SolidColour& operator= (const SolidColour&) = delete;
    };



    template <class PixelType, class GradientType>
    class Gradient : public GradientType
    {
    public:
        Gradient (const Image::BitmapData& dest, const ColourGradient& gradient, const AffineTransform& transform,
                  const PixelARGB* const colours, const int numColours)
            : GradientType (gradient, transform, colours, numColours - 1),
              destData (dest)
        {
        }

        __forceinline void setEdgeTableYPos (const int y) noexcept
        {
            linePixels = (PixelType*) destData.getLinePointer (y);
            GradientType::setY (y);
        }

        __forceinline void handleEdgeTablePixel (const int x, const int alphaLevel) const noexcept
        {
            getPixel (x)->blend (GradientType::getPixel (x), (uint32) alphaLevel);
        }

        __forceinline void handleEdgeTablePixelFull (const int x) const noexcept
        {
            getPixel (x)->blend (GradientType::getPixel (x));
        }

        void handleEdgeTableLine (int x, int width, const int alphaLevel) const noexcept
        {
            PixelType* dest = getPixel (x);

            if (alphaLevel < 0xff)
                { const int destStride = destData.pixelStride; do { dest->blend (GradientType::getPixel (x++), (uint32) alphaLevel); dest = addBytesToPointer (dest, destStride); } while (--width > 0); }
            else
                { const int destStride = destData.pixelStride; do { dest->blend (GradientType::getPixel (x++)); dest = addBytesToPointer (dest, destStride); } while (--width > 0); }
        }

        void handleEdgeTableLineFull (int x, int width) const noexcept
        {
            PixelType* dest = getPixel (x);
            { const int destStride = destData.pixelStride; do { dest->blend (GradientType::getPixel (x++)); dest = addBytesToPointer (dest, destStride); } while (--width > 0); }
        }

    private:
        const Image::BitmapData& destData;
        PixelType* linePixels;

        __forceinline PixelType* getPixel (const int x) const noexcept
        {
            return addBytesToPointer (linePixels, x * destData.pixelStride);
        }

        Gradient (const Gradient&) = delete; Gradient& operator= (const Gradient&) = delete;
    };



    template <class DestPixelType, class SrcPixelType, bool repeatPattern>
    class ImageFill
    {
    public:
        ImageFill (const Image::BitmapData& dest, const Image::BitmapData& src,
                   const int alpha, const int x, const int y)
            : destData (dest),
              srcData (src),
              extraAlpha (alpha + 1),
              xOffset (repeatPattern ? negativeAwareModulo (x, src.width) - src.width : x),
              yOffset (repeatPattern ? negativeAwareModulo (y, src.height) - src.height : y)
        {
        }

        __forceinline void setEdgeTableYPos (int y) noexcept
        {
            linePixels = (DestPixelType*) destData.getLinePointer (y);

            y -= yOffset;
            if (repeatPattern)
            {
#pragma warning(push)
# 799 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
#pragma warning(disable: 4127)
# 799 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
 do { ; } while (false)
# 799 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
#pragma warning(pop)
# 799 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
;
                y %= srcData.height;
            }

            sourceLineStart = (SrcPixelType*) srcData.getLinePointer (y);
        }

        __forceinline void handleEdgeTablePixel (const int x, int alphaLevel) const noexcept
        {
            alphaLevel = (alphaLevel * extraAlpha) >> 8;

            getDestPixel (x)->blend (*getSrcPixel (repeatPattern ? ((x - xOffset) % srcData.width) : (x - xOffset)), (uint32) alphaLevel);
        }

        __forceinline void handleEdgeTablePixelFull (const int x) const noexcept
        {
            getDestPixel (x)->blend (*getSrcPixel (repeatPattern ? ((x - xOffset) % srcData.width) : (x - xOffset)), (uint32) extraAlpha);
        }

        void handleEdgeTableLine (int x, int width, int alphaLevel) const noexcept
        {
            DestPixelType* dest = getDestPixel (x);
            alphaLevel = (alphaLevel * extraAlpha) >> 8;
            x -= xOffset;

            if (repeatPattern)
            {
                if (alphaLevel < 0xfe)
                    { const int destStride = destData.pixelStride; do { dest->blend (*getSrcPixel (x++ % srcData.width), (uint32) alphaLevel); dest = addBytesToPointer (dest, destStride); } while (--width > 0); }
                else
                    { const int destStride = destData.pixelStride; do { dest->blend (*getSrcPixel (x++ % srcData.width)); dest = addBytesToPointer (dest, destStride); } while (--width > 0); }
            }
            else
            {
#pragma warning(push)
# 833 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
#pragma warning(disable: 4127)
# 833 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
 do { ; } while (false)
# 833 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
#pragma warning(pop)
# 833 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
;

                if (alphaLevel < 0xfe)
                    { const int destStride = destData.pixelStride; do { dest->blend (*getSrcPixel (x++), (uint32) alphaLevel); dest = addBytesToPointer (dest, destStride); } while (--width > 0); }
                else
                    copyRow (dest, getSrcPixel (x), width);
            }
        }

        void handleEdgeTableLineFull (int x, int width) const noexcept
        {
            DestPixelType* dest = getDestPixel (x);
            x -= xOffset;

            if (repeatPattern)
            {
                if (extraAlpha < 0xfe)
                    { const int destStride = destData.pixelStride; do { dest->blend (*getSrcPixel (x++ % srcData.width), (uint32) extraAlpha); dest = addBytesToPointer (dest, destStride); } while (--width > 0); }
                else
                    { const int destStride = destData.pixelStride; do { dest->blend (*getSrcPixel (x++ % srcData.width)); dest = addBytesToPointer (dest, destStride); } while (--width > 0); }
            }
            else
            {
#pragma warning(push)
# 856 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
#pragma warning(disable: 4127)
# 856 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
 do { ; } while (false)
# 856 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
#pragma warning(pop)
# 856 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
;

                if (extraAlpha < 0xfe)
                    { const int destStride = destData.pixelStride; do { dest->blend (*getSrcPixel (x++), (uint32) extraAlpha); dest = addBytesToPointer (dest, destStride); } while (--width > 0); }
                else
                    copyRow (dest, getSrcPixel (x), width);
            }
        }

        void clipEdgeTableLine (EdgeTable& et, int x, int y, int width)
        {
#pragma warning(push)
# 867 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
#pragma warning(disable: 4127)
# 867 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
 do { ; } while (false)
# 867 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
#pragma warning(pop)
# 867 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
;
            SrcPixelType* s = (SrcPixelType*) srcData.getLinePointer (y - yOffset);
            uint8* mask = (uint8*) (s + x - xOffset);

            if (sizeof (SrcPixelType) == sizeof (PixelARGB))
                mask += PixelARGB::indexA;

            et.clipLineToMask (x, y, mask, sizeof (SrcPixelType), width);
        }

    private:
        const Image::BitmapData& destData;
        const Image::BitmapData& srcData;
        const int extraAlpha, xOffset, yOffset;
        DestPixelType* linePixels;
        SrcPixelType* sourceLineStart;

        __forceinline DestPixelType* getDestPixel (int const x) const noexcept
        {
            return addBytesToPointer (linePixels, x * destData.pixelStride);
        }

        __forceinline SrcPixelType const* getSrcPixel (int const x) const noexcept
        {
            return addBytesToPointer (sourceLineStart, x * srcData.pixelStride);
        }

        __forceinline void copyRow (DestPixelType* dest, SrcPixelType const* src, int width) const noexcept
        {
            const int destStride = destData.pixelStride;
            const int srcStride = srcData.pixelStride;

            if (destStride == srcStride
                 && srcData.pixelFormat == Image::RGB
                 && destData.pixelFormat == Image::RGB)
            {
                memcpy (dest, src, (size_t) (width * srcStride));
            }
            else
            {
                do
                {
                    dest->blend (*src);
                    dest = addBytesToPointer (dest, destStride);
                    src = addBytesToPointer (src, srcStride);
                } while (--width > 0);
            }
        }

        ImageFill (const ImageFill&) = delete; ImageFill& operator= (const ImageFill&) = delete;
    };



    template <class DestPixelType, class SrcPixelType, bool repeatPattern>
    class TransformedImageFill
    {
    public:
        TransformedImageFill (const Image::BitmapData& dest, const Image::BitmapData& src,
                              const AffineTransform& transform, const int alpha, const Graphics::ResamplingQuality q)
            : interpolator (transform,
                            q != Graphics::lowResamplingQuality ? 0.5f : 0.0f,
                            q != Graphics::lowResamplingQuality ? -128 : 0),
              destData (dest),
              srcData (src),
              extraAlpha (alpha + 1),
              quality (q),
              maxX (src.width - 1),
              maxY (src.height - 1),
              scratchSize (2048)
        {
            scratchBuffer.malloc (scratchSize);
        }

        __forceinline void setEdgeTableYPos (const int newY) noexcept
        {
            y = newY;
            linePixels = (DestPixelType*) destData.getLinePointer (newY);
        }

        __forceinline void handleEdgeTablePixel (const int x, const int alphaLevel) noexcept
        {
            SrcPixelType p;
            generate (&p, x, 1);

            getDestPixel (x)->blend (p, (uint32) (alphaLevel * extraAlpha) >> 8);
        }

        __forceinline void handleEdgeTablePixelFull (const int x) noexcept
        {
            SrcPixelType p;
            generate (&p, x, 1);

            getDestPixel (x)->blend (p, (uint32) extraAlpha);
        }

        void handleEdgeTableLine (const int x, int width, int alphaLevel) noexcept
        {
            if (width > (int) scratchSize)
            {
                scratchSize = (size_t) width;
                scratchBuffer.malloc (scratchSize);
            }

            SrcPixelType* span = scratchBuffer;
            generate (span, x, width);

            DestPixelType* dest = getDestPixel (x);
            alphaLevel *= extraAlpha;
            alphaLevel >>= 8;

            if (alphaLevel < 0xfe)
                { const int destStride = destData.pixelStride; do { dest->blend (*span++, (uint32) alphaLevel); dest = addBytesToPointer (dest, destStride); } while (--width > 0); }
            else
                { const int destStride = destData.pixelStride; do { dest->blend (*span++); dest = addBytesToPointer (dest, destStride); } while (--width > 0); }
        }

        __forceinline void handleEdgeTableLineFull (const int x, int width) noexcept
        {
            handleEdgeTableLine (x, width, 255);
        }

        void clipEdgeTableLine (EdgeTable& et, int x, int y_, int width)
        {
            if (width > (int) scratchSize)
            {
                scratchSize = (size_t) width;
                scratchBuffer.malloc (scratchSize);
            }

            y = y_;
            generate (scratchBuffer.getData(), x, width);

            et.clipLineToMask (x, y_,
                               reinterpret_cast<uint8*> (scratchBuffer.getData()) + SrcPixelType::indexA,
                               sizeof (SrcPixelType), width);
        }

    private:
        __forceinline DestPixelType* getDestPixel (const int x) const noexcept
        {
            return addBytesToPointer (linePixels, x * destData.pixelStride);
        }


        template <class PixelType>
        void generate (PixelType* dest, const int x, int numPixels) noexcept
        {
            this->interpolator.setStartOfLine ((float) x, (float) y, numPixels);

            do
            {
                int hiResX, hiResY;
                this->interpolator.next (hiResX, hiResY);

                int loResX = hiResX >> 8;
                int loResY = hiResY >> 8;

                if (repeatPattern)
                {
                    loResX = negativeAwareModulo (loResX, srcData.width);
                    loResY = negativeAwareModulo (loResY, srcData.height);
                }

                if (quality != Graphics::lowResamplingQuality)
                {
                    if (isPositiveAndBelow (loResX, maxX))
                    {
                        if (isPositiveAndBelow (loResY, maxY))
                        {

                            render4PixelAverage (dest, this->srcData.getPixelPointer (loResX, loResY),
                                                 hiResX & 255, hiResY & 255);
                            ++dest;
                            continue;
                        }

                        if (! repeatPattern)
                        {

                            if (loResY < 0)
                                render2PixelAverageX (dest, this->srcData.getPixelPointer (loResX, 0), hiResX & 255);
                            else
                                render2PixelAverageX (dest, this->srcData.getPixelPointer (loResX, maxY), hiResX & 255);

                            ++dest;
                            continue;
                        }
                    }
                    else
                    {
                        if (isPositiveAndBelow (loResY, maxY) && ! repeatPattern)
                        {

                            if (loResX < 0)
                                render2PixelAverageY (dest, this->srcData.getPixelPointer (0, loResY), hiResY & 255);
                            else
                                render2PixelAverageY (dest, this->srcData.getPixelPointer (maxX, loResY), hiResY & 255);

                            ++dest;
                            continue;
                        }
                    }
                }

                if (! repeatPattern)
                {
                    if (loResX < 0) loResX = 0;
                    if (loResY < 0) loResY = 0;
                    if (loResX > maxX) loResX = maxX;
                    if (loResY > maxY) loResY = maxY;
                }

                dest->set (*(const PixelType*) this->srcData.getPixelPointer (loResX, loResY));
                ++dest;

            } while (--numPixels > 0);
        }


        void render4PixelAverage (PixelARGB* const dest, const uint8* src, const int subPixelX, const int subPixelY) noexcept
        {
            uint32 c[4] = { 256 * 128, 256 * 128, 256 * 128, 256 * 128 };

            uint32 weight = (uint32) ((256 - subPixelX) * (256 - subPixelY));
            c[0] += weight * src[0];
            c[1] += weight * src[1];
            c[2] += weight * src[2];
            c[3] += weight * src[3];

            src += this->srcData.pixelStride;

            weight = (uint32) (subPixelX * (256 - subPixelY));
            c[0] += weight * src[0];
            c[1] += weight * src[1];
            c[2] += weight * src[2];
            c[3] += weight * src[3];

            src += this->srcData.lineStride;

            weight = (uint32) (subPixelX * subPixelY);
            c[0] += weight * src[0];
            c[1] += weight * src[1];
            c[2] += weight * src[2];
            c[3] += weight * src[3];

            src -= this->srcData.pixelStride;

            weight = (uint32) ((256 - subPixelX) * subPixelY);
            c[0] += weight * src[0];
            c[1] += weight * src[1];
            c[2] += weight * src[2];
            c[3] += weight * src[3];

            dest->setARGB ((uint8) (c[PixelARGB::indexA] >> 16),
                           (uint8) (c[PixelARGB::indexR] >> 16),
                           (uint8) (c[PixelARGB::indexG] >> 16),
                           (uint8) (c[PixelARGB::indexB] >> 16));
        }

        void render2PixelAverageX (PixelARGB* const dest, const uint8* src, const uint32 subPixelX) noexcept
        {
            uint32 c[4] = { 128, 128, 128, 128 };

            uint32 weight = 256 - subPixelX;
            c[0] += weight * src[0];
            c[1] += weight * src[1];
            c[2] += weight * src[2];
            c[3] += weight * src[3];

            src += this->srcData.pixelStride;

            weight = subPixelX;
            c[0] += weight * src[0];
            c[1] += weight * src[1];
            c[2] += weight * src[2];
            c[3] += weight * src[3];

            dest->setARGB ((uint8) (c[PixelARGB::indexA] >> 8),
                           (uint8) (c[PixelARGB::indexR] >> 8),
                           (uint8) (c[PixelARGB::indexG] >> 8),
                           (uint8) (c[PixelARGB::indexB] >> 8));
        }

        void render2PixelAverageY (PixelARGB* const dest, const uint8* src, const uint32 subPixelY) noexcept
        {
            uint32 c[4] = { 128, 128, 128, 128 };

            uint32 weight = 256 - subPixelY;
            c[0] += weight * src[0];
            c[1] += weight * src[1];
            c[2] += weight * src[2];
            c[3] += weight * src[3];

            src += this->srcData.lineStride;

            weight = subPixelY;
            c[0] += weight * src[0];
            c[1] += weight * src[1];
            c[2] += weight * src[2];
            c[3] += weight * src[3];

            dest->setARGB ((uint8) (c[PixelARGB::indexA] >> 8),
                           (uint8) (c[PixelARGB::indexR] >> 8),
                           (uint8) (c[PixelARGB::indexG] >> 8),
                           (uint8) (c[PixelARGB::indexB] >> 8));
        }


        void render4PixelAverage (PixelRGB* const dest, const uint8* src, const uint32 subPixelX, const uint32 subPixelY) noexcept
        {
            uint32 c[3] = { 256 * 128, 256 * 128, 256 * 128 };

            uint32 weight = (256 - subPixelX) * (256 - subPixelY);
            c[0] += weight * src[0];
            c[1] += weight * src[1];
            c[2] += weight * src[2];

            src += this->srcData.pixelStride;

            weight = subPixelX * (256 - subPixelY);
            c[0] += weight * src[0];
            c[1] += weight * src[1];
            c[2] += weight * src[2];

            src += this->srcData.lineStride;

            weight = subPixelX * subPixelY;
            c[0] += weight * src[0];
            c[1] += weight * src[1];
            c[2] += weight * src[2];

            src -= this->srcData.pixelStride;

            weight = (256 - subPixelX) * subPixelY;
            c[0] += weight * src[0];
            c[1] += weight * src[1];
            c[2] += weight * src[2];

            dest->setARGB ((uint8) 255,
                           (uint8) (c[PixelRGB::indexR] >> 16),
                           (uint8) (c[PixelRGB::indexG] >> 16),
                           (uint8) (c[PixelRGB::indexB] >> 16));
        }

        void render2PixelAverageX (PixelRGB* const dest, const uint8* src, const uint32 subPixelX) noexcept
        {
            uint32 c[3] = { 128, 128, 128 };

            const uint32 weight = 256 - subPixelX;
            c[0] += weight * src[0];
            c[1] += weight * src[1];
            c[2] += weight * src[2];

            src += this->srcData.pixelStride;

            c[0] += subPixelX * src[0];
            c[1] += subPixelX * src[1];
            c[2] += subPixelX * src[2];

            dest->setARGB ((uint8) 255,
                           (uint8) (c[PixelRGB::indexR] >> 8),
                           (uint8) (c[PixelRGB::indexG] >> 8),
                           (uint8) (c[PixelRGB::indexB] >> 8));
        }

        void render2PixelAverageY (PixelRGB* const dest, const uint8* src, const uint32 subPixelY) noexcept
        {
            uint32 c[3] = { 128, 128, 128 };

            const uint32 weight = 256 - subPixelY;
            c[0] += weight * src[0];
            c[1] += weight * src[1];
            c[2] += weight * src[2];

            src += this->srcData.lineStride;

            c[0] += subPixelY * src[0];
            c[1] += subPixelY * src[1];
            c[2] += subPixelY * src[2];

            dest->setARGB ((uint8) 255,
                           (uint8) (c[PixelRGB::indexR] >> 8),
                           (uint8) (c[PixelRGB::indexG] >> 8),
                           (uint8) (c[PixelRGB::indexB] >> 8));
        }


        void render4PixelAverage (PixelAlpha* const dest, const uint8* src, const uint32 subPixelX, const uint32 subPixelY) noexcept
        {
            uint32 c = 256 * 128;
            c += src[0] * ((256 - subPixelX) * (256 - subPixelY));
            src += this->srcData.pixelStride;
            c += src[0] * (subPixelX * (256 - subPixelY));
            src += this->srcData.lineStride;
            c += src[0] * (subPixelX * subPixelY);
            src -= this->srcData.pixelStride;

            c += src[0] * ((256 - subPixelX) * subPixelY);

            *((uint8*) dest) = (uint8) (c >> 16);
        }

        void render2PixelAverageX (PixelAlpha* const dest, const uint8* src, const uint32 subPixelX) noexcept
        {
            uint32 c = 128;
            c += src[0] * (256 - subPixelX);
            src += this->srcData.pixelStride;
            c += src[0] * subPixelX;
            *((uint8*) dest) = (uint8) (c >> 8);
        }

        void render2PixelAverageY (PixelAlpha* const dest, const uint8* src, const uint32 subPixelY) noexcept
        {
            uint32 c = 128;
            c += src[0] * (256 - subPixelY);
            src += this->srcData.lineStride;
            c += src[0] * subPixelY;
            *((uint8*) dest) = (uint8) (c >> 8);
        }


        class TransformedImageSpanInterpolator
        {
        public:
            TransformedImageSpanInterpolator (const AffineTransform& transform,
                                              const float offsetFloat, const int offsetInt) noexcept
                : inverseTransform (transform.inverted()),
                  pixelOffset (offsetFloat), pixelOffsetInt (offsetInt)
            {}

            void setStartOfLine (float sx, float sy, const int numPixels) noexcept
            {
#pragma warning(push)
# 1300 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
#pragma warning(disable: 4127)
# 1300 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
 do { ; } while (false)
# 1300 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
#pragma warning(pop)
# 1300 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
;

                sx += pixelOffset;
                sy += pixelOffset;
                float x1 = sx, y1 = sy;
                sx += (float) numPixels;
                inverseTransform.transformPoints (x1, y1, sx, sy);

                xBresenham.set ((int) (x1 * 256.0f), (int) (sx * 256.0f), numPixels, pixelOffsetInt);
                yBresenham.set ((int) (y1 * 256.0f), (int) (sy * 256.0f), numPixels, pixelOffsetInt);
            }

            void next (int& px, int& py) noexcept
            {
                px = xBresenham.n; xBresenham.stepToNext();
                py = yBresenham.n; yBresenham.stepToNext();
            }

        private:
            class BresenhamInterpolator
            {
            public:
                BresenhamInterpolator() noexcept {}

                void set (const int n1, const int n2, const int steps, const int offsetInt) noexcept
                {
                    numSteps = steps;
                    step = (n2 - n1) / numSteps;
                    remainder = modulo = (n2 - n1) % numSteps;
                    n = n1 + offsetInt;

                    if (modulo <= 0)
                    {
                        modulo += numSteps;
                        remainder += numSteps;
                        --step;
                    }

                    modulo -= numSteps;
                }

                __forceinline void stepToNext() noexcept
                {
                    modulo += remainder;
                    n += step;

                    if (modulo > 0)
                    {
                        modulo -= numSteps;
                        ++n;
                    }
                }

                int n;

            private:
                int numSteps, step, modulo, remainder;
            };

            const AffineTransform inverseTransform;
            BresenhamInterpolator xBresenham, yBresenham;
            const float pixelOffset;
            const int pixelOffsetInt;

            TransformedImageSpanInterpolator (const TransformedImageSpanInterpolator&) = delete; TransformedImageSpanInterpolator& operator= (const TransformedImageSpanInterpolator&) = delete;
        };


        TransformedImageSpanInterpolator interpolator;
        const Image::BitmapData& destData;
        const Image::BitmapData& srcData;
        const int extraAlpha;
        const Graphics::ResamplingQuality quality;
        const int maxX, maxY;
        int y;
        DestPixelType* linePixels;
        HeapBlock<SrcPixelType> scratchBuffer;
        size_t scratchSize;

        TransformedImageFill (const TransformedImageFill&) = delete; TransformedImageFill& operator= (const TransformedImageFill&) = delete;
    };



    template <class Iterator>
    void renderImageTransformed (Iterator& iter, const Image::BitmapData& destData, const Image::BitmapData& srcData,
                                 const int alpha, const AffineTransform& transform, Graphics::ResamplingQuality quality, bool tiledFill)
    {
        switch (destData.pixelFormat)
        {
        case Image::ARGB:
            switch (srcData.pixelFormat)
            {
            case Image::ARGB:
                if (tiledFill) { TransformedImageFill<PixelARGB, PixelARGB, true> r (destData, srcData, transform, alpha, quality); iter.iterate (r); }
                else { TransformedImageFill<PixelARGB, PixelARGB, false> r (destData, srcData, transform, alpha, quality); iter.iterate (r); }
                break;
            case Image::RGB:
                if (tiledFill) { TransformedImageFill<PixelARGB, PixelRGB, true> r (destData, srcData, transform, alpha, quality); iter.iterate (r); }
                else { TransformedImageFill<PixelARGB, PixelRGB, false> r (destData, srcData, transform, alpha, quality); iter.iterate (r); }
                break;
            default:
                if (tiledFill) { TransformedImageFill<PixelARGB, PixelAlpha, true> r (destData, srcData, transform, alpha, quality); iter.iterate (r); }
                else { TransformedImageFill<PixelARGB, PixelAlpha, false> r (destData, srcData, transform, alpha, quality); iter.iterate (r); }
                break;
            }
            break;

        case Image::RGB:
            switch (srcData.pixelFormat)
            {
            case Image::ARGB:
                if (tiledFill) { TransformedImageFill<PixelRGB, PixelARGB, true> r (destData, srcData, transform, alpha, quality); iter.iterate (r); }
                else { TransformedImageFill<PixelRGB, PixelARGB, false> r (destData, srcData, transform, alpha, quality); iter.iterate (r); }
                break;
            case Image::RGB:
                if (tiledFill) { TransformedImageFill<PixelRGB, PixelRGB, true> r (destData, srcData, transform, alpha, quality); iter.iterate (r); }
                else { TransformedImageFill<PixelRGB, PixelRGB, false> r (destData, srcData, transform, alpha, quality); iter.iterate (r); }
                break;
            default:
                if (tiledFill) { TransformedImageFill<PixelRGB, PixelAlpha, true> r (destData, srcData, transform, alpha, quality); iter.iterate (r); }
                else { TransformedImageFill<PixelRGB, PixelAlpha, false> r (destData, srcData, transform, alpha, quality); iter.iterate (r); }
                break;
            }
            break;

        default:
            switch (srcData.pixelFormat)
            {
            case Image::ARGB:
                if (tiledFill) { TransformedImageFill<PixelAlpha, PixelARGB, true> r (destData, srcData, transform, alpha, quality); iter.iterate (r); }
                else { TransformedImageFill<PixelAlpha, PixelARGB, false> r (destData, srcData, transform, alpha, quality); iter.iterate (r); }
                break;
            case Image::RGB:
                if (tiledFill) { TransformedImageFill<PixelAlpha, PixelRGB, true> r (destData, srcData, transform, alpha, quality); iter.iterate (r); }
                else { TransformedImageFill<PixelAlpha, PixelRGB, false> r (destData, srcData, transform, alpha, quality); iter.iterate (r); }
                break;
            default:
                if (tiledFill) { TransformedImageFill<PixelAlpha, PixelAlpha, true> r (destData, srcData, transform, alpha, quality); iter.iterate (r); }
                else { TransformedImageFill<PixelAlpha, PixelAlpha, false> r (destData, srcData, transform, alpha, quality); iter.iterate (r); }
                break;
            }
            break;
        }
    }

    template <class Iterator>
    void renderImageUntransformed (Iterator& iter, const Image::BitmapData& destData, const Image::BitmapData& srcData, const int alpha, int x, int y, bool tiledFill)
    {
        switch (destData.pixelFormat)
        {
        case Image::ARGB:
            switch (srcData.pixelFormat)
            {
            case Image::ARGB:
                if (tiledFill) { ImageFill<PixelARGB, PixelARGB, true> r (destData, srcData, alpha, x, y); iter.iterate (r); }
                else { ImageFill<PixelARGB, PixelARGB, false> r (destData, srcData, alpha, x, y); iter.iterate (r); }
                break;
            case Image::RGB:
                if (tiledFill) { ImageFill<PixelARGB, PixelRGB, true> r (destData, srcData, alpha, x, y); iter.iterate (r); }
                else { ImageFill<PixelARGB, PixelRGB, false> r (destData, srcData, alpha, x, y); iter.iterate (r); }
                break;
            default:
                if (tiledFill) { ImageFill<PixelARGB, PixelAlpha, true> r (destData, srcData, alpha, x, y); iter.iterate (r); }
                else { ImageFill<PixelARGB, PixelAlpha, false> r (destData, srcData, alpha, x, y); iter.iterate (r); }
                break;
            }
            break;

        case Image::RGB:
            switch (srcData.pixelFormat)
            {
            case Image::ARGB:
                if (tiledFill) { ImageFill<PixelRGB, PixelARGB, true> r (destData, srcData, alpha, x, y); iter.iterate (r); }
                else { ImageFill<PixelRGB, PixelARGB, false> r (destData, srcData, alpha, x, y); iter.iterate (r); }
                break;
            case Image::RGB:
                if (tiledFill) { ImageFill<PixelRGB, PixelRGB, true> r (destData, srcData, alpha, x, y); iter.iterate (r); }
                else { ImageFill<PixelRGB, PixelRGB, false> r (destData, srcData, alpha, x, y); iter.iterate (r); }
                break;
            default:
                if (tiledFill) { ImageFill<PixelRGB, PixelAlpha, true> r (destData, srcData, alpha, x, y); iter.iterate (r); }
                else { ImageFill<PixelRGB, PixelAlpha, false> r (destData, srcData, alpha, x, y); iter.iterate (r); }
                break;
            }
            break;

        default:
            switch (srcData.pixelFormat)
            {
            case Image::ARGB:
                if (tiledFill) { ImageFill<PixelAlpha, PixelARGB, true> r (destData, srcData, alpha, x, y); iter.iterate (r); }
                else { ImageFill<PixelAlpha, PixelARGB, false> r (destData, srcData, alpha, x, y); iter.iterate (r); }
                break;
            case Image::RGB:
                if (tiledFill) { ImageFill<PixelAlpha, PixelRGB, true> r (destData, srcData, alpha, x, y); iter.iterate (r); }
                else { ImageFill<PixelAlpha, PixelRGB, false> r (destData, srcData, alpha, x, y); iter.iterate (r); }
                break;
            default:
                if (tiledFill) { ImageFill<PixelAlpha, PixelAlpha, true> r (destData, srcData, alpha, x, y); iter.iterate (r); }
                else { ImageFill<PixelAlpha, PixelAlpha, false> r (destData, srcData, alpha, x, y); iter.iterate (r); }
                break;
            }
            break;
        }
    }

    template <class Iterator, class DestPixelType>
    void renderSolidFill (Iterator& iter, const Image::BitmapData& destData, const PixelARGB fillColour, const bool replaceContents, DestPixelType*)
    {
        if (replaceContents)
        {
            EdgeTableFillers::SolidColour<DestPixelType, true> r (destData, fillColour);
            iter.iterate (r);
        }
        else
        {
            EdgeTableFillers::SolidColour<DestPixelType, false> r (destData, fillColour);
            iter.iterate (r);
        }
    }

    template <class Iterator, class DestPixelType>
    void renderGradient (Iterator& iter, const Image::BitmapData& destData, const ColourGradient& g, const AffineTransform& transform,
                         const PixelARGB* const lookupTable, const int numLookupEntries, const bool isIdentity, DestPixelType*)
    {
        if (g.isRadial)
        {
            if (isIdentity)
            {
                EdgeTableFillers::Gradient<DestPixelType, GradientPixelIterators::Radial> renderer (destData, g, transform, lookupTable, numLookupEntries);
                iter.iterate (renderer);
            }
            else
            {
                EdgeTableFillers::Gradient<DestPixelType, GradientPixelIterators::TransformedRadial> renderer (destData, g, transform, lookupTable, numLookupEntries);
                iter.iterate (renderer);
            }
        }
        else
        {
            EdgeTableFillers::Gradient<DestPixelType, GradientPixelIterators::Linear> renderer (destData, g, transform, lookupTable, numLookupEntries);
            iter.iterate (renderer);
        }
    }
}


template <class SavedStateType>
struct ClipRegions
{
    class Base : public SingleThreadedReferenceCountedObject
    {
    public:
        Base() {}
        virtual ~Base() {}

        typedef ReferenceCountedObjectPtr<Base> Ptr;

        virtual Ptr clone() const = 0;
        virtual Ptr applyClipTo (const Ptr& target) const = 0;

        virtual Ptr clipToRectangle (const Rectangle<int>&) = 0;
        virtual Ptr clipToRectangleList (const RectangleList<int>&) = 0;
        virtual Ptr excludeClipRectangle (const Rectangle<int>&) = 0;
        virtual Ptr clipToPath (const Path&, const AffineTransform&) = 0;
        virtual Ptr clipToEdgeTable (const EdgeTable& et) = 0;
        virtual Ptr clipToImageAlpha (const Image&, const AffineTransform&, const Graphics::ResamplingQuality) = 0;
        virtual void translate (Point<int> delta) = 0;

        virtual bool clipRegionIntersects (const Rectangle<int>&) const = 0;
        virtual Rectangle<int> getClipBounds() const = 0;

        virtual void fillRectWithColour (SavedStateType&, const Rectangle<int>&, const PixelARGB colour, bool replaceContents) const = 0;
        virtual void fillRectWithColour (SavedStateType&, const Rectangle<float>&, const PixelARGB colour) const = 0;
        virtual void fillAllWithColour (SavedStateType&, const PixelARGB colour, bool replaceContents) const = 0;
        virtual void fillAllWithGradient (SavedStateType&, ColourGradient&, const AffineTransform&, bool isIdentity) const = 0;
        virtual void renderImageTransformed (SavedStateType&, const Image&, const int alpha, const AffineTransform&, Graphics::ResamplingQuality, bool tiledFill) const = 0;
        virtual void renderImageUntransformed (SavedStateType&, const Image&, const int alpha, int x, int y, bool tiledFill) const = 0;
    };


    class EdgeTableRegion : public Base
    {
    public:
        EdgeTableRegion (const EdgeTable& e) : edgeTable (e) {}
        EdgeTableRegion (const Rectangle<int>& r) : edgeTable (r) {}
        EdgeTableRegion (const Rectangle<float>& r) : edgeTable (r) {}
        EdgeTableRegion (const RectangleList<int>& r) : edgeTable (r) {}
        EdgeTableRegion (const RectangleList<float>& r) : edgeTable (r) {}
        EdgeTableRegion (const Rectangle<int>& bounds, const Path& p, const AffineTransform& t) : edgeTable (bounds, p, t) {}
        EdgeTableRegion (const EdgeTableRegion& other) : Base(), edgeTable (other.edgeTable) {}

        typedef typename Base::Ptr Ptr;

        Ptr clone() const { return new EdgeTableRegion (*this); }
        Ptr applyClipTo (const Ptr& target) const { return target->clipToEdgeTable (edgeTable); }

        Ptr clipToRectangle (const Rectangle<int>& r)
        {
            edgeTable.clipToRectangle (r);
            return edgeTable.isEmpty() ? nullptr : this;
        }

        Ptr clipToRectangleList (const RectangleList<int>& r)
        {
            RectangleList<int> inverse (edgeTable.getMaximumBounds());

            if (inverse.subtract (r))
                for (const Rectangle<int>* i = inverse.begin(), * const e = inverse.end(); i != e; ++i)
                    edgeTable.excludeRectangle (*i);

            return edgeTable.isEmpty() ? nullptr : this;
        }

        Ptr excludeClipRectangle (const Rectangle<int>& r)
        {
            edgeTable.excludeRectangle (r);
            return edgeTable.isEmpty() ? nullptr : this;
        }

        Ptr clipToPath (const Path& p, const AffineTransform& transform)
        {
            EdgeTable et (edgeTable.getMaximumBounds(), p, transform);
            edgeTable.clipToEdgeTable (et);
            return edgeTable.isEmpty() ? nullptr : this;
        }

        Ptr clipToEdgeTable (const EdgeTable& et)
        {
            edgeTable.clipToEdgeTable (et);
            return edgeTable.isEmpty() ? nullptr : this;
        }

        Ptr clipToImageAlpha (const Image& image, const AffineTransform& transform, const Graphics::ResamplingQuality quality)
        {
            const Image::BitmapData srcData (image, Image::BitmapData::readOnly);

            if (transform.isOnlyTranslation())
            {

                const int tx = (int) (transform.getTranslationX() * 256.0f);
                const int ty = (int) (transform.getTranslationY() * 256.0f);

                if (quality == Graphics::lowResamplingQuality || ((tx | ty) & 224) == 0)
                {
                    const int imageX = ((tx + 128) >> 8);
                    const int imageY = ((ty + 128) >> 8);

                    if (image.getFormat() == Image::ARGB)
                        straightClipImage (srcData, imageX, imageY, (PixelARGB*) 0);
                    else
                        straightClipImage (srcData, imageX, imageY, (PixelAlpha*) 0);

                    return edgeTable.isEmpty() ? nullptr : this;
                }
            }

            if (transform.isSingularity())
                return Ptr();

            {
                Path p;
                p.addRectangle (0, 0, (float) srcData.width, (float) srcData.height);
                EdgeTable et2 (edgeTable.getMaximumBounds(), p, transform);
                edgeTable.clipToEdgeTable (et2);
            }

            if (! edgeTable.isEmpty())
            {
                if (image.getFormat() == Image::ARGB)
                    transformedClipImage (srcData, transform, quality, (PixelARGB*) 0);
                else
                    transformedClipImage (srcData, transform, quality, (PixelAlpha*) 0);
            }

            return edgeTable.isEmpty() ? nullptr : this;
        }

        void translate (Point<int> delta)
        {
            edgeTable.translate ((float) delta.x, delta.y);
        }

        bool clipRegionIntersects (const Rectangle<int>& r) const
        {
            return edgeTable.getMaximumBounds().intersects (r);
        }

        Rectangle<int> getClipBounds() const
        {
            return edgeTable.getMaximumBounds();
        }

        void fillRectWithColour (SavedStateType& state, const Rectangle<int>& area, const PixelARGB colour, bool replaceContents) const
        {
            const Rectangle<int> totalClip (edgeTable.getMaximumBounds());
            const Rectangle<int> clipped (totalClip.getIntersection (area));

            if (! clipped.isEmpty())
            {
                EdgeTableRegion et (clipped);
                et.edgeTable.clipToEdgeTable (edgeTable);
                state.fillWithSolidColour (et.edgeTable, colour, replaceContents);
            }
        }

        void fillRectWithColour (SavedStateType& state, const Rectangle<float>& area, const PixelARGB colour) const
        {
            const Rectangle<float> totalClip (edgeTable.getMaximumBounds().toFloat());
            const Rectangle<float> clipped (totalClip.getIntersection (area));

            if (! clipped.isEmpty())
            {
                EdgeTableRegion et (clipped);
                et.edgeTable.clipToEdgeTable (edgeTable);
                state.fillWithSolidColour (et.edgeTable, colour, false);
            }
        }

        void fillAllWithColour (SavedStateType& state, const PixelARGB colour, bool replaceContents) const
        {
            state.fillWithSolidColour (edgeTable, colour, replaceContents);
        }

        void fillAllWithGradient (SavedStateType& state, ColourGradient& gradient, const AffineTransform& transform, bool isIdentity) const
        {
            state.fillWithGradient (edgeTable, gradient, transform, isIdentity);
        }

        void renderImageTransformed (SavedStateType& state, const Image& src, const int alpha, const AffineTransform& transform, Graphics::ResamplingQuality quality, bool tiledFill) const
        {
            state.renderImageTransformed (edgeTable, src, alpha, transform, quality, tiledFill);
        }

        void renderImageUntransformed (SavedStateType& state, const Image& src, const int alpha, int x, int y, bool tiledFill) const
        {
            state.renderImageUntransformed (edgeTable, src, alpha, x, y, tiledFill);
        }

        EdgeTable edgeTable;

    private:
        template <class SrcPixelType>
        void transformedClipImage (const Image::BitmapData& srcData, const AffineTransform& transform, const Graphics::ResamplingQuality quality, const SrcPixelType*)
        {
            EdgeTableFillers::TransformedImageFill<SrcPixelType, SrcPixelType, false> renderer (srcData, srcData, transform, 255, quality);

            for (int y = 0; y < edgeTable.getMaximumBounds().getHeight(); ++y)
                renderer.clipEdgeTableLine (edgeTable, edgeTable.getMaximumBounds().getX(), y + edgeTable.getMaximumBounds().getY(),
                                            edgeTable.getMaximumBounds().getWidth());
        }

        template <class SrcPixelType>
        void straightClipImage (const Image::BitmapData& srcData, int imageX, int imageY, const SrcPixelType*)
        {
            Rectangle<int> r (imageX, imageY, srcData.width, srcData.height);
            edgeTable.clipToRectangle (r);

            EdgeTableFillers::ImageFill<SrcPixelType, SrcPixelType, false> renderer (srcData, srcData, 255, imageX, imageY);

            for (int y = 0; y < r.getHeight(); ++y)
                renderer.clipEdgeTableLine (edgeTable, r.getX(), y + r.getY(), r.getWidth());
        }

        EdgeTableRegion& operator= (const EdgeTableRegion&);
    };


    class RectangleListRegion : public Base
    {
    public:
        RectangleListRegion (const Rectangle<int>& r) : clip (r) {}
        RectangleListRegion (const RectangleList<int>& r) : clip (r) {}
        RectangleListRegion (const RectangleListRegion& other) : Base(), clip (other.clip) {}

        typedef typename Base::Ptr Ptr;

        Ptr clone() const { return new RectangleListRegion (*this); }
        Ptr applyClipTo (const Ptr& target) const { return target->clipToRectangleList (clip); }

        Ptr clipToRectangle (const Rectangle<int>& r)
        {
            clip.clipTo (r);
            return clip.isEmpty() ? nullptr : this;
        }

        Ptr clipToRectangleList (const RectangleList<int>& r)
        {
            clip.clipTo (r);
            return clip.isEmpty() ? nullptr : this;
        }

        Ptr excludeClipRectangle (const Rectangle<int>& r)
        {
            clip.subtract (r);
            return clip.isEmpty() ? nullptr : this;
        }

        Ptr clipToPath (const Path& p, const AffineTransform& transform) { return toEdgeTable()->clipToPath (p, transform); }
        Ptr clipToEdgeTable (const EdgeTable& et) { return toEdgeTable()->clipToEdgeTable (et); }

        Ptr clipToImageAlpha (const Image& image, const AffineTransform& transform, const Graphics::ResamplingQuality quality)
        {
            return toEdgeTable()->clipToImageAlpha (image, transform, quality);
        }

        void translate (Point<int> delta) { clip.offsetAll (delta); }
        bool clipRegionIntersects (const Rectangle<int>& r) const { return clip.intersects (r); }
        Rectangle<int> getClipBounds() const { return clip.getBounds(); }

        void fillRectWithColour (SavedStateType& state, const Rectangle<int>& area, const PixelARGB colour, bool replaceContents) const
        {
            SubRectangleIterator iter (clip, area);
            state.fillWithSolidColour (iter, colour, replaceContents);
        }

        void fillRectWithColour (SavedStateType& state, const Rectangle<float>& area, const PixelARGB colour) const
        {
            SubRectangleIteratorFloat iter (clip, area);
            state.fillWithSolidColour (iter, colour, false);
        }

        void fillAllWithColour (SavedStateType& state, const PixelARGB colour, bool replaceContents) const
        {
            state.fillWithSolidColour (*this, colour, replaceContents);
        }

        void fillAllWithGradient (SavedStateType& state, ColourGradient& gradient, const AffineTransform& transform, bool isIdentity) const
        {
            state.fillWithGradient (*this, gradient, transform, isIdentity);
        }

        void renderImageTransformed (SavedStateType& state, const Image& src, const int alpha, const AffineTransform& transform, Graphics::ResamplingQuality quality, bool tiledFill) const
        {
            state.renderImageTransformed (*this, src, alpha, transform, quality, tiledFill);
        }

        void renderImageUntransformed (SavedStateType& state, const Image& src, const int alpha, int x, int y, bool tiledFill) const
        {
            state.renderImageUntransformed (*this, src, alpha, x, y, tiledFill);
        }

        RectangleList<int> clip;


        template <class Renderer>
        void iterate (Renderer& r) const noexcept
        {
            for (const Rectangle<int>* i = clip.begin(), * const e = clip.end(); i != e; ++i)
            {
                const int x = i->getX();
                const int w = i->getWidth();
#pragma warning(push)
# 1853 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
#pragma warning(disable: 4127)
# 1853 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
 do { ; } while (false)
# 1853 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
#pragma warning(pop)
# 1853 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
;
                const int bottom = i->getBottom();

                for (int y = i->getY(); y < bottom; ++y)
                {
                    r.setEdgeTableYPos (y);
                    r.handleEdgeTableLineFull (x, w);
                }
            }
        }

    private:

        class SubRectangleIterator
        {
        public:
            SubRectangleIterator (const RectangleList<int>& clipList, const Rectangle<int>& clipBounds)
                : clip (clipList), area (clipBounds)
            {}

            template <class Renderer>
            void iterate (Renderer& r) const noexcept
            {
                for (const Rectangle<int>* i = clip.begin(), * const e = clip.end(); i != e; ++i)
                {
                    const Rectangle<int> rect (i->getIntersection (area));

                    if (! rect.isEmpty())
                    {
                        const int x = rect.getX();
                        const int w = rect.getWidth();
                        const int bottom = rect.getBottom();

                        for (int y = rect.getY(); y < bottom; ++y)
                        {
                            r.setEdgeTableYPos (y);
                            r.handleEdgeTableLineFull (x, w);
                        }
                    }
                }
            }

        private:
            const RectangleList<int>& clip;
            const Rectangle<int> area;

            SubRectangleIterator (const SubRectangleIterator&) = delete; SubRectangleIterator& operator= (const SubRectangleIterator&) = delete;
        };


        class SubRectangleIteratorFloat
        {
        public:
            SubRectangleIteratorFloat (const RectangleList<int>& clipList, const Rectangle<float>& clipBounds) noexcept
                : clip (clipList), area (clipBounds)
            {
            }

            template <class Renderer>
            void iterate (Renderer& r) const noexcept
            {
                const RenderingHelpers::FloatRectangleRasterisingInfo f (area);

                for (const Rectangle<int>* i = clip.begin(), * const e = clip.end(); i != e; ++i)
                {
                    const int clipLeft = i->getX();
                    const int clipRight = i->getRight();
                    const int clipTop = i->getY();
                    const int clipBottom = i->getBottom();

                    if (f.totalBottom > clipTop && f.totalTop < clipBottom
                         && f.totalRight > clipLeft && f.totalLeft < clipRight)
                    {
                        if (f.isOnePixelWide())
                        {
                            if (f.topAlpha != 0 && f.totalTop >= clipTop)
                            {
                                r.setEdgeTableYPos (f.totalTop);
                                r.handleEdgeTablePixel (f.left, f.topAlpha);
                            }

                            const int endY = jmin (f.bottom, clipBottom);
                            for (int y = jmax (clipTop, f.top); y < endY; ++y)
                            {
                                r.setEdgeTableYPos (y);
                                r.handleEdgeTablePixelFull (f.left);
                            }

                            if (f.bottomAlpha != 0 && f.bottom < clipBottom)
                            {
                                r.setEdgeTableYPos (f.bottom);
                                r.handleEdgeTablePixel (f.left, f.bottomAlpha);
                            }
                        }
                        else
                        {
                            const int clippedLeft = jmax (f.left, clipLeft);
                            const int clippedWidth = jmin (f.right, clipRight) - clippedLeft;
                            const bool doLeftAlpha = f.leftAlpha != 0 && f.totalLeft >= clipLeft;
                            const bool doRightAlpha = f.rightAlpha != 0 && f.right < clipRight;

                            if (f.topAlpha != 0 && f.totalTop >= clipTop)
                            {
                                r.setEdgeTableYPos (f.totalTop);

                                if (doLeftAlpha) r.handleEdgeTablePixel (f.totalLeft, f.getTopLeftCornerAlpha());
                                if (clippedWidth > 0) r.handleEdgeTableLine (clippedLeft, clippedWidth, f.topAlpha);
                                if (doRightAlpha) r.handleEdgeTablePixel (f.right, f.getTopRightCornerAlpha());
                            }

                            const int endY = jmin (f.bottom, clipBottom);
                            for (int y = jmax (clipTop, f.top); y < endY; ++y)
                            {
                                r.setEdgeTableYPos (y);

                                if (doLeftAlpha) r.handleEdgeTablePixel (f.totalLeft, f.leftAlpha);
                                if (clippedWidth > 0) r.handleEdgeTableLineFull (clippedLeft, clippedWidth);
                                if (doRightAlpha) r.handleEdgeTablePixel (f.right, f.rightAlpha);
                            }

                            if (f.bottomAlpha != 0 && f.bottom < clipBottom)
                            {
                                r.setEdgeTableYPos (f.bottom);

                                if (doLeftAlpha) r.handleEdgeTablePixel (f.totalLeft, f.getBottomLeftCornerAlpha());
                                if (clippedWidth > 0) r.handleEdgeTableLine (clippedLeft, clippedWidth, f.bottomAlpha);
                                if (doRightAlpha) r.handleEdgeTablePixel (f.right, f.getBottomRightCornerAlpha());
                            }
                        }
                    }
                }
            }

        private:
            const RectangleList<int>& clip;
            const Rectangle<float>& area;

            SubRectangleIteratorFloat (const SubRectangleIteratorFloat&) = delete; SubRectangleIteratorFloat& operator= (const SubRectangleIteratorFloat&) = delete;
        };

        Ptr toEdgeTable() const { return new EdgeTableRegion (clip); }

        RectangleListRegion& operator= (const RectangleListRegion&);
    };
};


template <class SavedStateType>
class SavedStateBase
{
public:
    typedef typename ClipRegions<SavedStateType>::Base BaseRegionType;
    typedef typename ClipRegions<SavedStateType>::EdgeTableRegion EdgeTableRegionType;
    typedef typename ClipRegions<SavedStateType>::RectangleListRegion RectangleListRegionType;

    SavedStateBase (const Rectangle<int>& initialClip)
        : clip (new RectangleListRegionType (initialClip)), transform (Point<int>()),
          interpolationQuality (Graphics::mediumResamplingQuality), transparencyLayerAlpha (1.0f)
    {
    }

    SavedStateBase (const RectangleList<int>& clipList, Point<int> origin)
        : clip (new RectangleListRegionType (clipList)), transform (origin),
          interpolationQuality (Graphics::mediumResamplingQuality), transparencyLayerAlpha (1.0f)
    {
    }

    SavedStateBase (const SavedStateBase& other)
        : clip (other.clip), transform (other.transform), fillType (other.fillType),
          interpolationQuality (other.interpolationQuality),
          transparencyLayerAlpha (other.transparencyLayerAlpha)
    {
    }

    SavedStateType& getThis() noexcept { return *static_cast<SavedStateType*> (this); }

    bool clipToRectangle (const Rectangle<int>& r)
    {
        if (clip != nullptr)
        {
            if (transform.isOnlyTranslated)
            {
                cloneClipIfMultiplyReferenced();
                clip = clip->clipToRectangle (transform.translated (r));
            }
            else if (! transform.isRotated)
            {
                cloneClipIfMultiplyReferenced();
                clip = clip->clipToRectangle (transform.transformed (r));
            }
            else
            {
                Path p;
                p.addRectangle (r);
                clipToPath (p, AffineTransform());
            }
        }

        return clip != nullptr;
    }

    bool clipToRectangleList (const RectangleList<int>& r)
    {
        if (clip != nullptr)
        {
            if (transform.isOnlyTranslated)
            {
                cloneClipIfMultiplyReferenced();
                RectangleList<int> offsetList (r);
                offsetList.offsetAll (transform.offset.x, transform.offset.y);
                clip = clip->clipToRectangleList (offsetList);
            }
            else if (! transform.isRotated)
            {
                cloneClipIfMultiplyReferenced();
                RectangleList<int> scaledList;

                for (const Rectangle<int>* i = r.begin(), * const e = r.end(); i != e; ++i)
                    scaledList.add (transform.transformed (*i));

                clip = clip->clipToRectangleList (scaledList);
            }
            else
            {
                clipToPath (r.toPath(), AffineTransform());
            }
        }

        return clip != nullptr;
    }

    static Rectangle<int> getLargestIntegerWithin (Rectangle<float> r)
    {
        const int x1 = (int) std::ceil (r.getX());
        const int y1 = (int) std::ceil (r.getY());
        const int x2 = (int) std::floor (r.getRight());
        const int y2 = (int) std::floor (r.getBottom());

        return Rectangle<int> (x1, y1, x2 - x1, y2 - y1);
    }

    bool excludeClipRectangle (const Rectangle<int>& r)
    {
        if (clip != nullptr)
        {
            cloneClipIfMultiplyReferenced();

            if (transform.isOnlyTranslated)
            {
                clip = clip->excludeClipRectangle (getLargestIntegerWithin (transform.translated (r.toFloat())));
            }
            else if (! transform.isRotated)
            {
                clip = clip->excludeClipRectangle (getLargestIntegerWithin (transform.transformed (r.toFloat())));
            }
            else
            {
                Path p;
                p.addRectangle (r.toFloat());
                p.applyTransform (transform.complexTransform);
                p.addRectangle (clip->getClipBounds().toFloat());
                p.setUsingNonZeroWinding (false);
                clip = clip->clipToPath (p, AffineTransform());
            }
        }

        return clip != nullptr;
    }

    void clipToPath (const Path& p, const AffineTransform& t)
    {
        if (clip != nullptr)
        {
            cloneClipIfMultiplyReferenced();
            clip = clip->clipToPath (p, transform.getTransformWith (t));
        }
    }

    void clipToImageAlpha (const Image& sourceImage, const AffineTransform& t)
    {
        if (clip != nullptr)
        {
            if (sourceImage.hasAlphaChannel())
            {
                cloneClipIfMultiplyReferenced();
                clip = clip->clipToImageAlpha (sourceImage, transform.getTransformWith (t), interpolationQuality);
            }
            else
            {
                Path p;
                p.addRectangle (sourceImage.getBounds());
                clipToPath (p, t);
            }
        }
    }

    bool clipRegionIntersects (const Rectangle<int>& r) const
    {
        if (clip != nullptr)
        {
            if (transform.isOnlyTranslated)
                return clip->clipRegionIntersects (transform.translated (r));

            return getClipBounds().intersects (r);
        }

        return false;
    }

    Rectangle<int> getClipBounds() const
    {
        return clip != nullptr ? transform.deviceSpaceToUserSpace (clip->getClipBounds())
                               : Rectangle<int>();
    }

    void setFillType (const FillType& newFill)
    {
        fillType = newFill;
    }

    void fillTargetRect (const Rectangle<int>& r, const bool replaceContents)
    {
        if (fillType.isColour())
        {
            clip->fillRectWithColour (getThis(), r, fillType.colour.getPixelARGB(), replaceContents);
        }
        else
        {
            const Rectangle<int> clipped (clip->getClipBounds().getIntersection (r));

            if (! clipped.isEmpty())
                fillShape (new RectangleListRegionType (clipped), false);
        }
    }

    void fillTargetRect (const Rectangle<float>& r)
    {
        if (fillType.isColour())
        {
            clip->fillRectWithColour (getThis(), r, fillType.colour.getPixelARGB());
        }
        else
        {
            const Rectangle<float> clipped (clip->getClipBounds().toFloat().getIntersection (r));

            if (! clipped.isEmpty())
                fillShape (new EdgeTableRegionType (clipped), false);
        }
    }

    template <typename CoordType>
    void fillRectAsPath (const Rectangle<CoordType>& r)
    {
        Path p;
        p.addRectangle (r);
        fillPath (p, AffineTransform());
    }

    void fillRect (const Rectangle<int>& r, const bool replaceContents)
    {
        if (clip != nullptr)
        {
            if (transform.isOnlyTranslated)
            {
                fillTargetRect (transform.translated (r), replaceContents);
            }
            else if (! transform.isRotated)
            {
                fillTargetRect (transform.transformed (r), replaceContents);
            }
            else
            {
#pragma warning(push)
# 2225 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
#pragma warning(disable: 4127)
# 2225 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
 do { ; } while (false)
# 2225 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
#pragma warning(pop)
# 2225 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
;
                fillRectAsPath (r);
            }
        }
    }

    void fillRect (const Rectangle<float>& r)
    {
        if (clip != nullptr)
        {
            if (transform.isOnlyTranslated)
                fillTargetRect (transform.translated (r));
            else if (! transform.isRotated)
                fillTargetRect (transform.transformed (r));
            else
                fillRectAsPath (r);
        }
    }

    void fillRectList (const RectangleList<float>& list)
    {
        if (clip != nullptr)
        {
            if (! transform.isRotated)
            {
                RectangleList<float> transformed (list);

                if (transform.isOnlyTranslated)
                    transformed.offsetAll (transform.offset.toFloat());
                else
                    transformed.transformAll (transform.getTransform());

                fillShape (new EdgeTableRegionType (transformed), false);
            }
            else
            {
                fillPath (list.toPath(), AffineTransform());
            }
        }
    }

    void fillPath (const Path& path, const AffineTransform& t)
    {
        if (clip != nullptr)
        {
            const AffineTransform trans (transform.getTransformWith (t));
            const Rectangle<int> clipRect (clip->getClipBounds());

            if (path.getBoundsTransformed (trans).getSmallestIntegerContainer().intersects (clipRect))
                fillShape (new EdgeTableRegionType (clipRect, path, trans), false);
        }
    }

    void fillEdgeTable (const EdgeTable& edgeTable, const float x, const int y)
    {
        if (clip != nullptr)
        {
            EdgeTableRegionType* edgeTableClip = new EdgeTableRegionType (edgeTable);
            edgeTableClip->edgeTable.translate (x, y);

            if (fillType.isColour())
            {
                float brightness = fillType.colour.getBrightness() - 0.5f;

                if (brightness > 0.0f)
                    edgeTableClip->edgeTable.multiplyLevels (1.0f + 1.6f * brightness);
            }

            fillShape (edgeTableClip, false);
        }
    }

    void drawLine (const Line<float>& line)
    {
        Path p;
        p.addLineSegment (line, 1.0f);
        fillPath (p, AffineTransform());
    }

    void drawImage (const Image& sourceImage, const AffineTransform& trans)
    {
        if (clip != nullptr && ! fillType.colour.isTransparent())
            renderImage (sourceImage, trans, nullptr);
    }

    static bool isOnlyTranslationAllowingError (const AffineTransform& t)
    {
        return (std::abs (t.mat01) < 0.002)
            && (std::abs (t.mat10) < 0.002)
            && (std::abs (t.mat00 - 1.0f) < 0.002)
            && (std::abs (t.mat11 - 1.0f) < 0.002);
    }

    void renderImage (const Image& sourceImage, const AffineTransform& trans,
                      const BaseRegionType* const tiledFillClipRegion)
    {
        const AffineTransform t (transform.getTransformWith (trans));

        const int alpha = fillType.colour.getAlpha();

        if (isOnlyTranslationAllowingError (t))
        {

            int tx = (int) (t.getTranslationX() * 256.0f);
            int ty = (int) (t.getTranslationY() * 256.0f);

            if (interpolationQuality == Graphics::lowResamplingQuality || ((tx | ty) & 224) == 0)
            {
                tx = ((tx + 128) >> 8);
                ty = ((ty + 128) >> 8);

                if (tiledFillClipRegion != nullptr)
                {
                    tiledFillClipRegion->renderImageUntransformed (getThis(), sourceImage, alpha, tx, ty, true);
                }
                else
                {
                    Rectangle<int> area (tx, ty, sourceImage.getWidth(), sourceImage.getHeight());
                    area = area.getIntersection (getThis().getMaximumBounds());

                    if (! area.isEmpty())
                        if (typename BaseRegionType::Ptr c = clip->applyClipTo (new EdgeTableRegionType (area)))
                            c->renderImageUntransformed (getThis(), sourceImage, alpha, tx, ty, false);
                }

                return;
            }
        }

        if (! t.isSingularity())
        {
            if (tiledFillClipRegion != nullptr)
            {
                tiledFillClipRegion->renderImageTransformed (getThis(), sourceImage, alpha, t, interpolationQuality, true);
            }
            else
            {
                Path p;
                p.addRectangle (sourceImage.getBounds());

                typename BaseRegionType::Ptr c (clip->clone());
                c = c->clipToPath (p, t);

                if (c != nullptr)
                    c->renderImageTransformed (getThis(), sourceImage, alpha, t, interpolationQuality, false);
            }
        }
    }

    void fillShape (typename BaseRegionType::Ptr shapeToFill, const bool replaceContents)
    {
#pragma warning(push)
# 2376 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
#pragma warning(disable: 4127)
# 2376 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
 do { ; } while (false)
# 2376 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
#pragma warning(pop)
# 2376 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
;

        shapeToFill = clip->applyClipTo (shapeToFill);

        if (shapeToFill != nullptr)
        {
            if (fillType.isGradient())
            {
#pragma warning(push)
# 2384 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
#pragma warning(disable: 4127)
# 2384 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
 do { ; } while (false)
# 2384 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
#pragma warning(pop)
# 2384 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
;

                ColourGradient g2 (*(fillType.gradient));
                g2.multiplyOpacity (fillType.getOpacity());
                AffineTransform t (transform.getTransformWith (fillType.transform).translated (-0.5f, -0.5f));

                const bool isIdentity = t.isOnlyTranslation();

                if (isIdentity)
                {

                    g2.point1.applyTransform (t);
                    g2.point2.applyTransform (t);
                    t = AffineTransform();
                }

                shapeToFill->fillAllWithGradient (getThis(), g2, t, isIdentity);
            }
            else if (fillType.isTiledImage())
            {
                renderImage (fillType.image, fillType.transform, shapeToFill);
            }
            else
            {
                shapeToFill->fillAllWithColour (getThis(), fillType.colour.getPixelARGB(), replaceContents);
            }
        }
    }

    void cloneClipIfMultiplyReferenced()
    {
        if (clip->getReferenceCount() > 1)
            clip = clip->clone();
    }

    typename BaseRegionType::Ptr clip;
    RenderingHelpers::TranslationOrTransform transform;
    FillType fillType;
    Graphics::ResamplingQuality interpolationQuality;
    float transparencyLayerAlpha;
};


class SoftwareRendererSavedState : public SavedStateBase<SoftwareRendererSavedState>
{
    typedef SavedStateBase<SoftwareRendererSavedState> BaseClass;

public:
    SoftwareRendererSavedState (const Image& im, const Rectangle<int>& clipBounds)
        : BaseClass (clipBounds), image (im)
    {
    }

    SoftwareRendererSavedState (const Image& im, const RectangleList<int>& clipList, Point<int> origin)
        : BaseClass (clipList, origin), image (im)
    {
    }

    SoftwareRendererSavedState (const SoftwareRendererSavedState& other)
        : BaseClass (other), image (other.image), font (other.font)
    {
    }

    SoftwareRendererSavedState* beginTransparencyLayer (float opacity)
    {
        SoftwareRendererSavedState* s = new SoftwareRendererSavedState (*this);

        if (clip != nullptr)
        {
            const Rectangle<int> layerBounds (clip->getClipBounds());

            s->image = Image (Image::ARGB, layerBounds.getWidth(), layerBounds.getHeight(), true);
            s->transparencyLayerAlpha = opacity;
            s->transform.moveOriginInDeviceSpace (-layerBounds.getPosition());
            s->cloneClipIfMultiplyReferenced();
            s->clip->translate (-layerBounds.getPosition());
        }

        return s;
    }

    void endTransparencyLayer (SoftwareRendererSavedState& finishedLayerState)
    {
        if (clip != nullptr)
        {
            const Rectangle<int> layerBounds (clip->getClipBounds());

            const ScopedPointer<LowLevelGraphicsContext> g (image.createLowLevelContext());
            g->setOpacity (finishedLayerState.transparencyLayerAlpha);
            g->drawImage (finishedLayerState.image, AffineTransform::translation (layerBounds.getPosition()));
        }
    }

    typedef GlyphCache<CachedGlyphEdgeTable<SoftwareRendererSavedState>, SoftwareRendererSavedState> GlyphCacheType;

    static void clearGlyphCache()
    {
        GlyphCacheType::getInstance().reset();
    }


    void drawGlyph (int glyphNumber, const AffineTransform& trans)
    {
        if (clip != nullptr)
        {
            if (trans.isOnlyTranslation() && ! transform.isRotated)
            {
                GlyphCacheType& cache = GlyphCacheType::getInstance();

                Point<float> pos (trans.getTranslationX(), trans.getTranslationY());

                if (transform.isOnlyTranslated)
                {
                    cache.drawGlyph (*this, font, glyphNumber, pos + transform.offset.toFloat());
                }
                else
                {
                    pos = transform.transformed (pos);

                    Font f (font);
                    f.setHeight (font.getHeight() * transform.complexTransform.mat11);

                    const float xScale = transform.complexTransform.mat00 / transform.complexTransform.mat11;
                    if (std::abs (xScale - 1.0f) > 0.01f)
                        f.setHorizontalScale (xScale);

                    cache.drawGlyph (*this, f, glyphNumber, pos);
                }
            }
            else
            {
                const float fontHeight = font.getHeight();

                AffineTransform t (transform.getTransformWith (AffineTransform::scale (fontHeight * font.getHorizontalScale(), fontHeight)
                                                                               .followedBy (trans)));

                const ScopedPointer<EdgeTable> et (font.getTypeface()->getEdgeTableForGlyph (glyphNumber, t, fontHeight));

                if (et != nullptr)
                    fillShape (new EdgeTableRegionType (*et), false);
            }
        }
    }

    Rectangle<int> getMaximumBounds() const { return image.getBounds(); }


    template <typename IteratorType>
    void renderImageTransformed (IteratorType& iter, const Image& src, const int alpha, const AffineTransform& trans, Graphics::ResamplingQuality quality, bool tiledFill) const
    {
        Image::BitmapData destData (image, Image::BitmapData::readWrite);
        const Image::BitmapData srcData (src, Image::BitmapData::readOnly);
        EdgeTableFillers::renderImageTransformed (iter, destData, srcData, alpha, trans, quality, tiledFill);
    }

    template <typename IteratorType>
    void renderImageUntransformed (IteratorType& iter, const Image& src, const int alpha, int x, int y, bool tiledFill) const
    {
        Image::BitmapData destData (image, Image::BitmapData::readWrite);
        const Image::BitmapData srcData (src, Image::BitmapData::readOnly);
        EdgeTableFillers::renderImageUntransformed (iter, destData, srcData, alpha, x, y, tiledFill);
    }

    template <typename IteratorType>
    void fillWithSolidColour (IteratorType& iter, const PixelARGB colour, bool replaceContents) const
    {
        Image::BitmapData destData (image, Image::BitmapData::readWrite);

        switch (destData.pixelFormat)
        {
            case Image::ARGB: EdgeTableFillers::renderSolidFill (iter, destData, colour, replaceContents, (PixelARGB*) 0); break;
            case Image::RGB: EdgeTableFillers::renderSolidFill (iter, destData, colour, replaceContents, (PixelRGB*) 0); break;
            default: EdgeTableFillers::renderSolidFill (iter, destData, colour, replaceContents, (PixelAlpha*) 0); break;
        }
    }

    template <typename IteratorType>
    void fillWithGradient (IteratorType& iter, ColourGradient& gradient, const AffineTransform& trans, bool isIdentity) const
    {
        HeapBlock<PixelARGB> lookupTable;
        const int numLookupEntries = gradient.createLookupTable (trans, lookupTable);
#pragma warning(push)
# 2565 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
#pragma warning(disable: 4127)
# 2565 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
 do { ; } while (false)
# 2565 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
#pragma warning(pop)
# 2565 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
;

        Image::BitmapData destData (image, Image::BitmapData::readWrite);

        switch (destData.pixelFormat)
        {
            case Image::ARGB: EdgeTableFillers::renderGradient (iter, destData, gradient, trans, lookupTable, numLookupEntries, isIdentity, (PixelARGB*) 0); break;
            case Image::RGB: EdgeTableFillers::renderGradient (iter, destData, gradient, trans, lookupTable, numLookupEntries, isIdentity, (PixelRGB*) 0); break;
            default: EdgeTableFillers::renderGradient (iter, destData, gradient, trans, lookupTable, numLookupEntries, isIdentity, (PixelAlpha*) 0); break;
        }
    }


    Image image;
    Font font;

private:
    SoftwareRendererSavedState& operator= (const SoftwareRendererSavedState&);
};


template <class StateObjectType>
class SavedStateStack
{
public:
    SavedStateStack (StateObjectType* const initialState) noexcept
        : currentState (initialState)
    {}

    SavedStateStack() noexcept {}

    void initialise (StateObjectType* state)
    {
        currentState = state;
    }

    inline StateObjectType* operator->() const noexcept { return currentState; }
    inline StateObjectType& operator*() const noexcept { return *currentState; }

    void save()
    {
        stack.add (new StateObjectType (*currentState));
    }

    void restore()
    {
        if (StateObjectType* const top = stack.getLast())
        {
            currentState = top;
            stack.removeLast (1, false);
        }
        else
        {
#pragma warning(push)
# 2618 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
#pragma warning(disable: 4127)
# 2618 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
 do { } while (false)
# 2618 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
#pragma warning(pop)
# 2618 "..\\..\\..\\JUCE\\modules\\juce_graphics/native/juce_RenderingHelpers.h"
;
        }
    }

    void beginTransparencyLayer (float opacity)
    {
        save();
        currentState = currentState->beginTransparencyLayer (opacity);
    }

    void endTransparencyLayer()
    {
        const ScopedPointer<StateObjectType> finishedTransparencyLayer (currentState);
        restore();
        currentState->endTransparencyLayer (*finishedTransparencyLayer);
    }

private:
    ScopedPointer<StateObjectType> currentState;
    OwnedArray<StateObjectType> stack;

    SavedStateStack (const SavedStateStack&) = delete; SavedStateStack& operator= (const SavedStateStack&) = delete;
};


template <class SavedStateType>
class StackBasedLowLevelGraphicsContext : public LowLevelGraphicsContext
{
public:
    bool isVectorDevice() const override { return false; }
    void setOrigin (Point<int> o) override { stack->transform.setOrigin (o); }
    void addTransform (const AffineTransform& t) override { stack->transform.addTransform (t); }
    float getPhysicalPixelScaleFactor() override { return stack->transform.getPhysicalPixelScaleFactor(); }
    Rectangle<int> getClipBounds() const override { return stack->getClipBounds(); }
    bool isClipEmpty() const override { return stack->clip == nullptr; }
    bool clipRegionIntersects (const Rectangle<int>& r) override { return stack->clipRegionIntersects (r); }
    bool clipToRectangle (const Rectangle<int>& r) override { return stack->clipToRectangle (r); }
    bool clipToRectangleList (const RectangleList<int>& r) override { return stack->clipToRectangleList (r); }
    void excludeClipRectangle (const Rectangle<int>& r) override { stack->excludeClipRectangle (r); }
    void clipToPath (const Path& path, const AffineTransform& t) override { stack->clipToPath (path, t); }
    void clipToImageAlpha (const Image& im, const AffineTransform& t) override { stack->clipToImageAlpha (im, t); }
    void saveState() override { stack.save(); }
    void restoreState() override { stack.restore(); }
    void beginTransparencyLayer (float opacity) override { stack.beginTransparencyLayer (opacity); }
    void endTransparencyLayer() override { stack.endTransparencyLayer(); }
    void setFill (const FillType& fillType) override { stack->setFillType (fillType); }
    void setOpacity (float newOpacity) override { stack->fillType.setOpacity (newOpacity); }
    void setInterpolationQuality (Graphics::ResamplingQuality quality) override { stack->interpolationQuality = quality; }
    void fillRect (const Rectangle<int>& r, bool replace) override { stack->fillRect (r, replace); }
    void fillRect (const Rectangle<float>& r) override { stack->fillRect (r); }
    void fillRectList (const RectangleList<float>& list) override { stack->fillRectList (list); }
    void fillPath (const Path& path, const AffineTransform& t) override { stack->fillPath (path, t); }
    void drawImage (const Image& im, const AffineTransform& t) override { stack->drawImage (im, t); }
    void drawGlyph (int glyphNumber, const AffineTransform& t) override { stack->drawGlyph (glyphNumber, t); }
    void drawLine (const Line<float>& line) override { stack->drawLine (line); }
    void setFont (const Font& newFont) override { stack->font = newFont; }
    const Font& getFont() override { return stack->font; }

protected:
    StackBasedLowLevelGraphicsContext (SavedStateType* initialState) : stack (initialState) {}
    StackBasedLowLevelGraphicsContext() {}

    RenderingHelpers::SavedStateStack<SavedStateType> stack;
};

}


#pragma warning(pop)
# 131 "..\\..\\..\\JUCE\\modules\\juce_graphics/juce_graphics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_graphics/contexts/juce_LowLevelGraphicsSoftwareRenderer.h" 1
# 37 "..\\..\\..\\JUCE\\modules\\juce_graphics/contexts/juce_LowLevelGraphicsSoftwareRenderer.h"
class LowLevelGraphicsSoftwareRenderer : public RenderingHelpers::StackBasedLowLevelGraphicsContext<RenderingHelpers::SoftwareRendererSavedState>
{
public:


    LowLevelGraphicsSoftwareRenderer (const Image& imageToRenderOnto);


    LowLevelGraphicsSoftwareRenderer (const Image& imageToRenderOnto, Point<int> origin,
                                      const RectangleList<int>& initialClip);


    ~LowLevelGraphicsSoftwareRenderer();

private:
    LowLevelGraphicsSoftwareRenderer (const LowLevelGraphicsSoftwareRenderer&) = delete; LowLevelGraphicsSoftwareRenderer& operator= (const LowLevelGraphicsSoftwareRenderer&) = delete;
};
# 132 "..\\..\\..\\JUCE\\modules\\juce_graphics/juce_graphics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_graphics/contexts/juce_LowLevelGraphicsPostScriptRenderer.h" 1
# 35 "..\\..\\..\\JUCE\\modules\\juce_graphics/contexts/juce_LowLevelGraphicsPostScriptRenderer.h"
class LowLevelGraphicsPostScriptRenderer : public LowLevelGraphicsContext
{
public:

    LowLevelGraphicsPostScriptRenderer (OutputStream& resultingPostScript,
                                        const String& documentTitle,
                                        int totalWidth,
                                        int totalHeight);

    ~LowLevelGraphicsPostScriptRenderer();


    bool isVectorDevice() const override;
    void setOrigin (Point<int>) override;
    void addTransform (const AffineTransform&) override;
    float getPhysicalPixelScaleFactor() override;

    bool clipToRectangle (const Rectangle<int>&) override;
    bool clipToRectangleList (const RectangleList<int>&) override;
    void excludeClipRectangle (const Rectangle<int>&) override;
    void clipToPath (const Path&, const AffineTransform&) override;
    void clipToImageAlpha (const Image&, const AffineTransform&) override;

    void saveState() override;
    void restoreState() override;

    void beginTransparencyLayer (float) override;
    void endTransparencyLayer() override;

    bool clipRegionIntersects (const Rectangle<int>&) override;
    Rectangle<int> getClipBounds() const override;
    bool isClipEmpty() const override;


    void setFill (const FillType&) override;
    void setOpacity (float) override;
    void setInterpolationQuality (Graphics::ResamplingQuality) override;


    void fillRect (const Rectangle<int>&, bool replaceExistingContents) override;
    void fillRect (const Rectangle<float>&) override;
    void fillRectList (const RectangleList<float>&) override;
    void fillPath (const Path&, const AffineTransform&) override;
    void drawImage (const Image&, const AffineTransform&) override;
    void drawLine (const Line <float>&) override;


    const Font& getFont() override;
    void setFont (const Font&) override;
    void drawGlyph (int glyphNumber, const AffineTransform&) override;

protected:

    OutputStream& out;
    int totalWidth, totalHeight;
    bool needToClip;
    Colour lastColour;

    struct SavedState
    {
        SavedState();
        ~SavedState();

        RectangleList<int> clip;
        int xOffset, yOffset;
        FillType fillType;
        Font font;

    private:
        SavedState& operator= (const SavedState&);
    };

    OwnedArray <SavedState> stateStack;

    void writeClip();
    void writeColour (Colour colour);
    void writePath (const Path&) const;
    void writeXY (float x, float y) const;
    void writeTransform (const AffineTransform&) const;
    void writeImage (const Image&, int sx, int sy, int maxW, int maxH) const;

    LowLevelGraphicsPostScriptRenderer (const LowLevelGraphicsPostScriptRenderer&) = delete; LowLevelGraphicsPostScriptRenderer& operator= (const LowLevelGraphicsPostScriptRenderer&) = delete;
};
# 133 "..\\..\\..\\JUCE\\modules\\juce_graphics/juce_graphics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_graphics/effects/juce_ImageEffectFilter.h" 1
# 40 "..\\..\\..\\JUCE\\modules\\juce_graphics/effects/juce_ImageEffectFilter.h"
class ImageEffectFilter
{
public:
# 59 "..\\..\\..\\JUCE\\modules\\juce_graphics/effects/juce_ImageEffectFilter.h"
    virtual void applyEffect (Image& sourceImage,
                              Graphics& destContext,
                              float scaleFactor,
                              float alpha) = 0;


    virtual ~ImageEffectFilter() {}

};
# 134 "..\\..\\..\\JUCE\\modules\\juce_graphics/juce_graphics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_graphics/effects/juce_DropShadowEffect.h" 1
# 33 "..\\..\\..\\JUCE\\modules\\juce_graphics/effects/juce_DropShadowEffect.h"
struct DropShadow
{

    DropShadow() noexcept;


    DropShadow (Colour shadowColour, int radius, Point<int> offset) noexcept;


    void drawForImage (Graphics& g, const Image& srcImage) const;


    void drawForPath (Graphics& g, const Path& path) const;




    void drawForRectangle (Graphics& g, const Rectangle<int>& area) const;





    Colour colour;


    int radius;


    Point<int> offset;
};
# 81 "..\\..\\..\\JUCE\\modules\\juce_graphics/effects/juce_DropShadowEffect.h"
class DropShadowEffect : public ImageEffectFilter
{
public:




    DropShadowEffect();


    ~DropShadowEffect();



    void setShadowProperties (const DropShadow& newShadow);



    void applyEffect (Image& sourceImage, Graphics& destContext, float scaleFactor, float alpha);


private:

    DropShadow shadow;


};
# 135 "..\\..\\..\\JUCE\\modules\\juce_graphics/juce_graphics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_graphics/effects/juce_GlowEffect.h" 1
# 37 "..\\..\\..\\JUCE\\modules\\juce_graphics/effects/juce_GlowEffect.h"
class GlowEffect : public ImageEffectFilter
{
public:





    GlowEffect();


    ~GlowEffect();
# 57 "..\\..\\..\\JUCE\\modules\\juce_graphics/effects/juce_GlowEffect.h"
    void setGlowProperties (float newRadius,
                            Colour newColour);




    void applyEffect (Image& sourceImage, Graphics& destContext, float scaleFactor, float alpha);

private:

    float radius;
    Colour colour;


};
# 136 "..\\..\\..\\JUCE\\modules\\juce_graphics/juce_graphics.h" 2







}
# 22 "C:\\Users\\Cathy\\OneDrive\\JUCE Terrain\\Source/../JuceLibraryCode/JuceHeader.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 1
# 111 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h"
namespace juce
{

class Component;
class LookAndFeel;
class MouseInputSource;
class MouseInputSourceInternal;
class ComponentPeer;
class MarkerList;
class RelativeRectangle;
class MouseEvent;
struct MouseWheelDetails;
class ToggleButton;
class TextButton;
class AlertWindow;
class TextLayout;
class ScrollBar;
class ComboBox;
class Button;
class FilenameComponent;
class DocumentWindow;
class ResizableWindow;
class GroupComponent;
class MenuBarComponent;
class DropShadower;
class GlyphArrangement;
class PropertyComponent;
class TableHeaderComponent;
class Toolbar;
class ToolbarItemComponent;
class PopupMenu;
class ProgressBar;
class FileBrowserComponent;
class DirectoryContentsDisplayComponent;
class FilePreviewComponent;
class ImageButton;
class CallOutBox;
class Drawable;
class DrawablePath;
class DrawableComposite;
class CaretComponent;
class BubbleComponent;
class KeyPressMappingSet;
class ApplicationCommandManagerListener;
class DrawableButton;
class FlexBox;


# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_MouseCursor.h" 1
# 36 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_MouseCursor.h"
class MouseCursor
{
public:


    enum StandardCursorType
    {
        ParentCursor = 0,

        NoCursor,
        NormalCursor,

        WaitCursor,
        IBeamCursor,
        CrosshairCursor,
        CopyingCursor,


        PointingHandCursor,
        DraggingHandCursor,

        LeftRightResizeCursor,
        UpDownResizeCursor,
        UpDownLeftRightResizeCursor,

        TopEdgeResizeCursor,
        BottomEdgeResizeCursor,
        LeftEdgeResizeCursor,
        RightEdgeResizeCursor,
        TopLeftCornerResizeCursor,
        TopRightCornerResizeCursor,
        BottomLeftCornerResizeCursor,
        BottomRightCornerResizeCursor,

        NumStandardCursorTypes
    };



    MouseCursor() noexcept;


    MouseCursor (StandardCursorType);
# 89 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_MouseCursor.h"
    MouseCursor (const Image& image, int hotSpotX, int hotSpotY);
# 102 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_MouseCursor.h"
    MouseCursor (const Image& image, int hotSpotX, int hotSpotY, float scaleFactor);



    MouseCursor (const MouseCursor&);


    MouseCursor& operator= (const MouseCursor&);


    ~MouseCursor();


    MouseCursor (MouseCursor&&) noexcept;
    MouseCursor& operator= (MouseCursor&&) noexcept;
# 125 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_MouseCursor.h"
    bool operator== (const MouseCursor&) const noexcept;







    bool operator!= (const MouseCursor&) const noexcept;


    bool operator== (StandardCursorType type) const noexcept;


    bool operator!= (StandardCursorType type) const noexcept;
# 150 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_MouseCursor.h"
    static void showWaitCursor();
# 160 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_MouseCursor.h"
    static void hideWaitCursor();


private:

    class SharedCursorHandle;
    friend class SharedCursorHandle;
    SharedCursorHandle* cursorHandle;

    friend class MouseInputSourceInternal;
    void showInWindow (ComponentPeer* window) const;
    void showInAllWindows() const;
    void* getHandle() const noexcept;

    static void* createStandardMouseCursor (MouseCursor::StandardCursorType type);
    static void deleteMouseCursor (void* cursorHandle, bool isStandard);


};
# 158 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_MouseListener.h" 1
# 36 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_MouseListener.h"
class MouseListener
{
public:

    virtual ~MouseListener() {}
# 53 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_MouseListener.h"
    virtual void mouseMove (const MouseEvent& event);
# 69 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_MouseListener.h"
    virtual void mouseEnter (const MouseEvent& event);
# 84 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_MouseListener.h"
    virtual void mouseExit (const MouseEvent& event);
# 99 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_MouseListener.h"
    virtual void mouseDown (const MouseEvent& event);
# 111 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_MouseListener.h"
    virtual void mouseDrag (const MouseEvent& event);
# 126 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_MouseListener.h"
    virtual void mouseUp (const MouseEvent& event);
# 138 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_MouseListener.h"
    virtual void mouseDoubleClick (const MouseEvent& event);
# 152 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_MouseListener.h"
    virtual void mouseWheelMove (const MouseEvent& event,
                                 const MouseWheelDetails& wheel);


private:





};
# 159 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/keyboard/juce_ModifierKeys.h" 1
# 38 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/keyboard/juce_ModifierKeys.h"
class ModifierKeys
{
public:


    ModifierKeys() noexcept;







    ModifierKeys (int flags) noexcept;


    ModifierKeys (const ModifierKeys& other) noexcept;


    ModifierKeys& operator= (const ModifierKeys other) noexcept;
# 66 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/keyboard/juce_ModifierKeys.h"
    inline bool isCommandDown() const noexcept { return testFlags (commandModifier); }
# 76 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/keyboard/juce_ModifierKeys.h"
    inline bool isPopupMenu() const noexcept { return testFlags (popupMenuClickModifier); }


    inline bool isLeftButtonDown() const noexcept { return testFlags (leftButtonModifier); }






    inline bool isRightButtonDown() const noexcept { return testFlags (rightButtonModifier); }

    inline bool isMiddleButtonDown() const noexcept { return testFlags (middleButtonModifier); }


    inline bool isAnyMouseButtonDown() const noexcept { return testFlags (allMouseButtonModifiers); }


    inline bool isAnyModifierKeyDown() const noexcept { return testFlags ((shiftModifier | ctrlModifier | altModifier | commandModifier)); }


    inline bool isShiftDown() const noexcept { return testFlags (shiftModifier); }
# 106 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/keyboard/juce_ModifierKeys.h"
    inline bool isCtrlDown() const noexcept { return testFlags (ctrlModifier); }


    inline bool isAltDown() const noexcept { return testFlags (altModifier); }



    enum Flags
    {

        noModifiers = 0,


        shiftModifier = 1,


        ctrlModifier = 2,


        altModifier = 4,


        leftButtonModifier = 16,


        rightButtonModifier = 32,


        middleButtonModifier = 64,
# 145 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/keyboard/juce_ModifierKeys.h"
        commandModifier = ctrlModifier,



        popupMenuClickModifier = rightButtonModifier,



        allKeyboardModifiers = shiftModifier | ctrlModifier | altModifier | commandModifier,


        allMouseButtonModifiers = leftButtonModifier | rightButtonModifier | middleButtonModifier,


        ctrlAltCommandModifiers = ctrlModifier | altModifier | commandModifier
    };



    ModifierKeys withOnlyMouseButtons() const noexcept { return ModifierKeys (flags & allMouseButtonModifiers); }


    ModifierKeys withoutMouseButtons() const noexcept { return ModifierKeys (flags & ~allMouseButtonModifiers); }

    bool operator== (const ModifierKeys other) const noexcept { return flags == other.flags; }
    bool operator!= (const ModifierKeys other) const noexcept { return flags != other.flags; }



    inline int getRawFlags() const noexcept { return flags; }

    ModifierKeys withoutFlags (int rawFlagsToClear) const noexcept { return ModifierKeys (flags & ~rawFlagsToClear); }
    ModifierKeys withFlags (int rawFlagsToSet) const noexcept { return ModifierKeys (flags | rawFlagsToSet); }


    bool testFlags (int flagsToTest) const noexcept { return (flags & flagsToTest) != 0; }


    int getNumMouseButtonsDown() const noexcept;







    static ModifierKeys getCurrentModifiers() noexcept;
# 207 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/keyboard/juce_ModifierKeys.h"
    static ModifierKeys getCurrentModifiersRealtime() noexcept;


private:

    int flags;

    friend class ComponentPeer;
    friend class MouseInputSource;
    friend class MouseInputSourceInternal;

    static ModifierKeys currentModifiers;
    static void updateCurrentModifiers() noexcept;
};
# 160 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_MouseInputSource.h" 1
# 49 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_MouseInputSource.h"
class MouseInputSource
{
public:

    MouseInputSource (const MouseInputSource&) noexcept;
    MouseInputSource& operator= (const MouseInputSource&) noexcept;
    ~MouseInputSource() noexcept;


    bool operator== (const MouseInputSource& other) const noexcept { return pimpl == other.pimpl; }
    bool operator!= (const MouseInputSource& other) const noexcept { return pimpl != other.pimpl; }



    bool isMouse() const noexcept;


    bool isTouch() const noexcept;




    bool canHover() const noexcept;


    bool hasMouseWheel() const noexcept;
# 85 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_MouseInputSource.h"
    int getIndex() const noexcept;


    bool isDragging() const noexcept;


    Point<float> getScreenPosition() const noexcept;




    ModifierKeys getCurrentModifiers() const noexcept;






    float getCurrentPressure() const noexcept;


    bool isPressureValid() const noexcept;


    Component* getComponentUnderMouse() const;




    void triggerFakeMove() const;






    int getNumberOfMultipleClicks() const noexcept;


    Time getLastMouseDownTime() const noexcept;


    Point<float> getLastMouseDownPosition() const noexcept;




    bool hasMouseMovedSignificantlySincePressed() const noexcept;


    bool hasMouseCursor() const noexcept;


    void showMouseCursor (const MouseCursor& cursor);


    void hideCursor();


    void revealCursor();


    void forceMouseCursorUpdate();


    bool canDoUnboundedMovement() const noexcept;
# 169 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_MouseInputSource.h"
    void enableUnboundedMouseMovement (bool isEnabled, bool keepCursorVisibleUntilOffscreen = false) const;


    bool isUnboundedMouseMovementEnabled() const;


    void setScreenPosition (Point<float> newPosition);




    static const float invalidPressure;

private:

    friend class ComponentPeer;
    friend class Desktop;
    friend class MouseInputSourceInternal;
    MouseInputSourceInternal* pimpl;

    struct SourceList;

    explicit MouseInputSource (MouseInputSourceInternal*) noexcept;
    void handleEvent (ComponentPeer&, Point<float>, int64 time, ModifierKeys, float);
    void handleWheel (ComponentPeer&, Point<float>, int64 time, const MouseWheelDetails&);
    void handleMagnifyGesture (ComponentPeer&, Point<float>, int64 time, float scaleFactor);

    static Point<float> getCurrentRawMousePosition();
    static void setRawMousePosition (Point<float>);


};
# 161 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_MouseEvent.h" 1
# 36 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_MouseEvent.h"
class MouseEvent
{
public:
# 62 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_MouseEvent.h"
    MouseEvent (MouseInputSource source,
                Point<float> position,
                ModifierKeys modifiers,
                float pressure,
                Component* eventComponent,
                Component* originator,
                Time eventTime,
                Point<float> mouseDownPos,
                Time mouseDownTime,
                int numberOfClicks,
                bool mouseWasDragged) noexcept;


    ~MouseEvent() noexcept;
# 86 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_MouseEvent.h"
    const Point<float> position;
# 95 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_MouseEvent.h"
    const int x;
# 104 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_MouseEvent.h"
    const int y;
# 114 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_MouseEvent.h"
    const ModifierKeys mods;






    float pressure;
# 136 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_MouseEvent.h"
    Component* const eventComponent;
# 145 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_MouseEvent.h"
    Component* const originalComponent;


    const Time eventTime;


    const Time mouseDownTime;


    MouseInputSource source;






    int getMouseDownX() const noexcept;





    int getMouseDownY() const noexcept;





    Point<int> getMouseDownPosition() const noexcept;
# 183 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_MouseEvent.h"
    int getDistanceFromDragStart() const noexcept;






    int getDistanceFromDragStartX() const noexcept;






    int getDistanceFromDragStartY() const noexcept;






    Point<int> getOffsetFromDragStart() const noexcept;
# 219 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_MouseEvent.h"
    bool mouseWasDraggedSinceMouseDown() const noexcept;




    bool mouseWasClicked() const noexcept;




    int getNumberOfClicks() const noexcept { return numberOfClicks; }
# 238 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_MouseEvent.h"
    int getLengthOfMousePress() const noexcept;


    bool isPressureValid() const noexcept;
# 251 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_MouseEvent.h"
    Point<int> getPosition() const noexcept;





    int getScreenX() const;





    int getScreenY() const;





    Point<int> getScreenPosition() const;





    int getMouseDownScreenX() const;





    int getMouseDownScreenY() const;





    Point<int> getMouseDownScreenPosition() const;
# 296 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_MouseEvent.h"
    MouseEvent getEventRelativeTo (Component* newComponent) const noexcept;





    MouseEvent withNewPosition (Point<float> newPosition) const noexcept;





    MouseEvent withNewPosition (Point<int> newPosition) const noexcept;
# 318 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_MouseEvent.h"
    static void setDoubleClickTimeout (int timeOutMilliseconds) noexcept;
# 327 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_MouseEvent.h"
    static int getDoubleClickTimeout() noexcept;


private:

    const Point<float> mouseDownPos;
    const uint8 numberOfClicks, wasMovedSinceMouseDown;

    MouseEvent& operator= (const MouseEvent&);
};
# 345 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_MouseEvent.h"
struct MouseWheelDetails
{
# 355 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_MouseEvent.h"
    float deltaX;
# 364 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_MouseEvent.h"
    float deltaY;




    bool isReversed;


    bool isSmooth;



    bool isInertial;
};
# 162 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/keyboard/juce_KeyPress.h" 1
# 37 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/keyboard/juce_KeyPress.h"
class KeyPress
{
public:





    KeyPress() noexcept;
# 66 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/keyboard/juce_KeyPress.h"
    KeyPress (int keyCode,
              ModifierKeys modifiers,
              juce_wchar textCharacter) noexcept;


    explicit KeyPress (int keyCode) noexcept;


    KeyPress (const KeyPress& other) noexcept;


    KeyPress& operator= (const KeyPress& other) noexcept;


    bool operator== (const KeyPress& other) const noexcept;


    bool operator!= (const KeyPress& other) const noexcept;


    bool operator== (int keyCode) const noexcept;


    bool operator!= (int keyCode) const noexcept;







    bool isValid() const noexcept { return keyCode != 0; }






    int getKeyCode() const noexcept { return keyCode; }





    ModifierKeys getModifiers() const noexcept { return mods; }






    juce_wchar getTextCharacter() const noexcept { return textCharacter; }
# 127 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/keyboard/juce_KeyPress.h"
    bool isKeyCode (int keyCodeToCompare) const noexcept { return keyCode == keyCodeToCompare; }
# 141 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/keyboard/juce_KeyPress.h"
    static KeyPress createFromDescription (const String& textVersion);
# 150 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/keyboard/juce_KeyPress.h"
    String getTextDescription() const;






    String getTextDescriptionWithIcons() const;
# 167 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/keyboard/juce_KeyPress.h"
    bool isCurrentlyDown() const;






    static bool isKeyCurrentlyDown (int keyCode);
# 184 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/keyboard/juce_KeyPress.h"
    static const int spaceKey;
    static const int escapeKey;
    static const int returnKey;
    static const int tabKey;

    static const int deleteKey;
    static const int backspaceKey;
    static const int insertKey;

    static const int upKey;
    static const int downKey;
    static const int leftKey;
    static const int rightKey;
    static const int pageUpKey;
    static const int pageDownKey;
    static const int homeKey;
    static const int endKey;

    static const int F1Key;
    static const int F2Key;
    static const int F3Key;
    static const int F4Key;
    static const int F5Key;
    static const int F6Key;
    static const int F7Key;
    static const int F8Key;
    static const int F9Key;
    static const int F10Key;
    static const int F11Key;
    static const int F12Key;
    static const int F13Key;
    static const int F14Key;
    static const int F15Key;
    static const int F16Key;

    static const int numberPad0;
    static const int numberPad1;
    static const int numberPad2;
    static const int numberPad3;
    static const int numberPad4;
    static const int numberPad5;
    static const int numberPad6;
    static const int numberPad7;
    static const int numberPad8;
    static const int numberPad9;

    static const int numberPadAdd;
    static const int numberPadSubtract;
    static const int numberPadMultiply;
    static const int numberPadDivide;
    static const int numberPadSeparator;
    static const int numberPadDecimalPoint;
    static const int numberPadEquals;
    static const int numberPadDelete;

    static const int playKey;
    static const int stopKey;
    static const int fastForwardKey;
    static const int rewindKey;

private:

    int keyCode;
    ModifierKeys mods;
    juce_wchar textCharacter;


};
# 163 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/keyboard/juce_KeyListener.h" 1
# 38 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/keyboard/juce_KeyListener.h"
class KeyListener
{
public:

    virtual ~KeyListener() {}
# 55 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/keyboard/juce_KeyListener.h"
    virtual bool keyPressed (const KeyPress& key,
                             Component* originatingComponent) = 0;
# 72 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/keyboard/juce_KeyListener.h"
    virtual bool keyStateChanged (bool isKeyDown, Component* originatingComponent);
};
# 164 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/keyboard/juce_KeyboardFocusTraverser.h" 1
# 49 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/keyboard/juce_KeyboardFocusTraverser.h"
class KeyboardFocusTraverser
{
public:
    KeyboardFocusTraverser();


    virtual ~KeyboardFocusTraverser();
# 65 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/keyboard/juce_KeyboardFocusTraverser.h"
    virtual Component* getNextComponent (Component* current);
# 75 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/keyboard/juce_KeyboardFocusTraverser.h"
    virtual Component* getPreviousComponent (Component* current);
# 85 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/keyboard/juce_KeyboardFocusTraverser.h"
    virtual Component* getDefaultComponent (Component* parentComponent);
};
# 165 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_ModalComponentManager.h" 1
# 40 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_ModalComponentManager.h"
class ModalComponentManager : private AsyncUpdater,
                                          private DeletedAtShutdown
{
public:
# 53 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_ModalComponentManager.h"
    class Callback
    {
    public:

        Callback() {}


        virtual ~Callback() {}
# 72 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_ModalComponentManager.h"
        virtual void modalStateFinished (int returnValue) = 0;
    };


    static ModalComponentManager* _singletonInstance; static ModalComponentManager* getInstance() { if (_singletonInstance == nullptr) _singletonInstance = new ModalComponentManager(); return _singletonInstance; } static inline ModalComponentManager* getInstanceWithoutCreating() noexcept { return _singletonInstance; } static void deleteInstance() { if (_singletonInstance != nullptr) { ModalComponentManager* const old = _singletonInstance; _singletonInstance = nullptr; delete old; } } void clearSingletonInstance() noexcept { if (_singletonInstance == this) _singletonInstance = nullptr; }





    int getNumModalComponents() const;




    Component* getModalComponent (int index) const;


    bool isModal (Component* component) const;


    bool isFrontModalComponent (Component* component) const;
# 108 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_ModalComponentManager.h"
    void attachCallback (Component* component, Callback* callback);


    void bringModalComponentsToFront (bool topOneShouldGrabFocus = true);




    bool cancelAllModalComponents();





    int runEventLoopForCurrentComponent();


protected:



    ModalComponentManager();


    ~ModalComponentManager();


    void handleAsyncUpdate() override;

private:

    class ModalItem;
    class ReturnValueRetriever;

    friend class Component;
    friend struct ContainerDeletePolicy<ModalItem>;
    OwnedArray<ModalItem> stack;

    void startModal (Component*, bool autoDelete);
    void endModal (Component*, int returnValue);
    void endModal (Component*);

    ModalComponentManager (const ModalComponentManager&) = delete; ModalComponentManager& operator= (const ModalComponentManager&) = delete;
};






class ModalCallbackFunction
{
public:
# 183 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_ModalComponentManager.h"
    template <typename ParamType>
    static ModalComponentManager::Callback* create (void (*functionToCall) (int, ParamType),
                                                    ParamType parameterValue)
    {
        return new FunctionCaller1<ParamType> (functionToCall, parameterValue);
    }
# 198 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_ModalComponentManager.h"
    static ModalComponentManager::Callback* create (std::function<void(int)>);
# 223 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_ModalComponentManager.h"
    template <typename ParamType1, typename ParamType2>
    static ModalComponentManager::Callback* withParam (void (*functionToCall) (int, ParamType1, ParamType2),
                                                       ParamType1 parameterValue1,
                                                       ParamType2 parameterValue2)
    {
        return new FunctionCaller2<ParamType1, ParamType2> (functionToCall, parameterValue1, parameterValue2);
    }
# 254 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_ModalComponentManager.h"
    template <class ComponentType>
    static ModalComponentManager::Callback* forComponent (void (*functionToCall) (int, ComponentType*),
                                                          ComponentType* component)
    {
        return new ComponentCaller1<ComponentType> (functionToCall, component);
    }
# 284 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_ModalComponentManager.h"
    template <class ComponentType, typename ParamType>
    static ModalComponentManager::Callback* forComponent (void (*functionToCall) (int, ComponentType*, ParamType),
                                                          ComponentType* component,
                                                          ParamType param)
    {
        return new ComponentCaller2<ComponentType, ParamType> (functionToCall, component, param);
    }

private:

    template <typename ParamType>
    struct FunctionCaller1 : public ModalComponentManager::Callback
    {
        typedef void (*FunctionType) (int, ParamType);

        FunctionCaller1 (FunctionType& f, ParamType& p1)
            : function (f), param (p1) {}

        void modalStateFinished (int returnValue) override { function (returnValue, param); }

    private:
        const FunctionType function;
        ParamType param;

        FunctionCaller1 (const FunctionCaller1&) = delete; FunctionCaller1& operator= (const FunctionCaller1&) = delete;
    };

    template <typename ParamType1, typename ParamType2>
    struct FunctionCaller2 : public ModalComponentManager::Callback
    {
        typedef void (*FunctionType) (int, ParamType1, ParamType2);

        FunctionCaller2 (FunctionType& f, ParamType1& p1, ParamType2& p2)
            : function (f), param1 (p1), param2 (p2) {}

        void modalStateFinished (int returnValue) override { function (returnValue, param1, param2); }

    private:
        const FunctionType function;
        ParamType1 param1;
        ParamType2 param2;

        FunctionCaller2 (const FunctionCaller2&) = delete; FunctionCaller2& operator= (const FunctionCaller2&) = delete;
    };

    template <typename ComponentType>
    struct ComponentCaller1 : public ModalComponentManager::Callback
    {
        typedef void (*FunctionType) (int, ComponentType*);

        ComponentCaller1 (FunctionType& f, ComponentType* c)
            : function (f), comp (c) {}

        void modalStateFinished (int returnValue) override
        {
            function (returnValue, static_cast<ComponentType*> (comp.get()));
        }

    private:
        const FunctionType function;
        WeakReference<Component> comp;

        ComponentCaller1 (const ComponentCaller1&) = delete; ComponentCaller1& operator= (const ComponentCaller1&) = delete;
    };

    template <typename ComponentType, typename ParamType1>
    struct ComponentCaller2 : public ModalComponentManager::Callback
    {
        typedef void (*FunctionType) (int, ComponentType*, ParamType1);

        ComponentCaller2 (FunctionType& f, ComponentType* c, ParamType1 p1)
            : function (f), comp (c), param1 (p1) {}

        void modalStateFinished (int returnValue) override
        {
            function (returnValue, static_cast<ComponentType*> (comp.get()), param1);
        }

    private:
        const FunctionType function;
        WeakReference<Component> comp;
        ParamType1 param1;

        ComponentCaller2 (const ComponentCaller2&) = delete; ComponentCaller2& operator= (const ComponentCaller2&) = delete;
    };

    ModalCallbackFunction();
    ~ModalCallbackFunction();
    ModalCallbackFunction (const ModalCallbackFunction&) = delete; ModalCallbackFunction& operator= (const ModalCallbackFunction&) = delete;
};
# 166 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_ComponentListener.h" 1
# 40 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_ComponentListener.h"
class ComponentListener
{
public:

    virtual ~ComponentListener() {}
# 53 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_ComponentListener.h"
    virtual void componentMovedOrResized (Component& component,
                                          bool wasMoved,
                                          bool wasResized);






    virtual void componentBroughtToFront (Component& component);






    virtual void componentVisibilityChanged (Component& component);
# 78 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_ComponentListener.h"
    virtual void componentChildrenChanged (Component& component);
# 89 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_ComponentListener.h"
    virtual void componentParentHierarchyChanged (Component& component);





    virtual void componentNameChanged (Component& component);
# 107 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_ComponentListener.h"
    virtual void componentBeingDeleted (Component& component);
};
# 167 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_CachedComponentImage.h" 1
# 39 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_CachedComponentImage.h"
class CachedComponentImage
{
public:
    CachedComponentImage() noexcept {}
    virtual ~CachedComponentImage() {}






    virtual void paint (Graphics&) = 0;





    virtual bool invalidateAll() = 0;





    virtual bool invalidate (const Rectangle<int>& area) = 0;




    virtual void releaseResources() = 0;
};
# 168 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h" 1
# 33 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
class Component : public MouseListener
{
public:
# 49 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    Component() noexcept;
# 63 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    virtual ~Component();





    explicit Component (const String& componentName) noexcept;




    const String& getName() const noexcept { return componentName; }
# 83 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    virtual void setName (const String& newName);




    const String& getComponentID() const noexcept { return componentID; }





    void setComponentID (const String& newID);
# 110 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    virtual void setVisible (bool shouldBeVisible);
# 120 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    bool isVisible() const noexcept { return flags.visibleFlag; }




    virtual void visibilityChanged();






    bool isShowing() const;
# 158 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    virtual void addToDesktop (int windowStyleFlags,
                               void* nativeWindowToAttachTo = nullptr);
# 168 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void removeFromDesktop();




    bool isOnDesktop() const noexcept;
# 185 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    ComponentPeer* getPeer() const;
# 194 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    virtual void userTriedToCloseWindow();





    virtual void minimisationStateChanged (bool isNowMinimised);
# 209 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    virtual float getDesktopScaleFactor() const;
# 222 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void toFront (bool shouldAlsoGainFocus);
# 231 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void toBack();




    void toBehind (Component* other);




    void setAlwaysOnTop (bool shouldStayOnTop);




    bool isAlwaysOnTop() const noexcept;
# 256 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    int getX() const noexcept { return boundsRelativeToParent.getX(); }
# 265 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    int getY() const noexcept { return boundsRelativeToParent.getY(); }


    int getWidth() const noexcept { return boundsRelativeToParent.getWidth(); }


    int getHeight() const noexcept { return boundsRelativeToParent.getHeight(); }
# 280 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    int getRight() const noexcept { return boundsRelativeToParent.getRight(); }


    Point<int> getPosition() const noexcept { return boundsRelativeToParent.getPosition(); }
# 292 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    int getBottom() const noexcept { return boundsRelativeToParent.getBottom(); }
# 301 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    const Rectangle<int>& getBounds() const noexcept { return boundsRelativeToParent; }





    Rectangle<int> getLocalBounds() const noexcept;
# 316 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    Rectangle<int> getBoundsInParent() const noexcept;





    int getScreenX() const;




    int getScreenY() const;




    Point<int> getScreenPosition() const;




    Rectangle<int> getScreenBounds() const;







    Point<int> getLocalPoint (const Component* sourceComponent,
                              Point<int> pointRelativeToSourceComponent) const;







    Point<float> getLocalPoint (const Component* sourceComponent,
                                Point<float> pointRelativeToSourceComponent) const;
# 367 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    Rectangle<int> getLocalArea (const Component* sourceComponent,
                                 const Rectangle<int>& areaRelativeToSourceComponent) const;




    Point<int> localPointToGlobal (Point<int> localPoint) const;




    Point<float> localPointToGlobal (Point<float> localPoint) const;
# 387 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    Rectangle<int> localAreaToGlobal (const Rectangle<int>& localArea) const;
# 403 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void setTopLeftPosition (int x, int y);
# 418 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void setTopLeftPosition (Point<int> newTopLeftPosition);
# 431 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void setTopRightPosition (int x, int y);
# 441 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void setSize (int newWidth, int newHeight);
# 457 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void setBounds (int x, int y, int width, int height);
# 473 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void setBounds (const Rectangle<int>& newBounds);
# 488 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void setBounds (const RelativeRectangle& newBounds);






    void setBounds (const String& newBoundsExpression);
# 506 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void setBoundsRelative (float proportionalX, float proportionalY,
                            float proportionalWidth, float proportionalHeight);
# 516 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void setBoundsInset (const BorderSize<int>& borders);
# 532 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void setBoundsToFit (int x, int y, int width, int height,
                         Justification justification,
                         bool onlyReduceInSize);
# 543 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void setCentrePosition (int x, int y);






    void setCentreRelative (float x, float y);







    void centreWithSize (int width, int height);
# 578 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void setTransform (const AffineTransform& transform);





    AffineTransform getTransform() const;





    bool isTransformed() const noexcept;





    int proportionOfWidth (float proportion) const noexcept;




    int proportionOfHeight (float proportion) const noexcept;






    int getParentWidth() const noexcept;






    int getParentHeight() const noexcept;







    Rectangle<int> getParentMonitorArea() const;






    int getNumChildComponents() const noexcept;
# 641 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    Component* getChildComponent (int index) const noexcept;
# 652 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    int getIndexOfChildComponent (const Component* child) const noexcept;




    Component* findChildWithID (StringRef componentID) const noexcept;
# 675 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void addChildComponent (Component* child, int zOrder = -1);
# 693 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void addChildComponent (Component& child, int zOrder = -1);






    void addAndMakeVisible (Component* child, int zOrder = -1);






    void addAndMakeVisible (Component& child, int zOrder = -1);




    void addChildAndSetID (Component* child, const String& componentID);
# 725 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void removeChildComponent (Component* childToRemove);
# 738 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    Component* removeChildComponent (int childIndexToRemove);




    void removeAllChildren();
# 754 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void deleteAllChildren();






    Component* getParentComponent() const noexcept { return parentComponent; }







    template <class TargetClass>
    TargetClass* findParentComponentOfClass() const
    {
        for (Component* p = parentComponent; p != nullptr; p = p->parentComponent)
            if (TargetClass* const target = dynamic_cast<TargetClass*> (p))
                return target;

        return nullptr;
    }







    Component* getTopLevelComponent() const noexcept;






    bool isParentOf (const Component* possibleChild) const noexcept;
# 805 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    virtual void parentHierarchyChanged();





    virtual void childrenChanged();
# 850 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    virtual bool hitTest (int x, int y);
# 869 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void setInterceptsMouseClicks (bool allowClicksOnThisComponent,
                                   bool allowClicksOnChildComponents) noexcept;
# 879 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void getInterceptsMouseClicks (bool& allowsClicksOnThisComponent,
                                   bool& allowsClicksOnChildComponents) const noexcept;
# 894 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    bool contains (Point<int> localPoint);
# 904 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    bool reallyContains (Point<int> localPoint, bool returnTrueIfWithinAChild);
# 916 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    Component* getComponentAt (int x, int y);
# 927 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    Component* getComponentAt (Point<int> position);
# 947 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void repaint();
# 962 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void repaint (int x, int y, int width, int height);
# 977 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void repaint (const Rectangle<int>& area);
# 992 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void setBufferedToImage (bool shouldBeBuffered);
# 1009 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    Image createComponentSnapshot (const Rectangle<int>& areaToGrab,
                                   bool clipImageToComponentBounds = true,
                                   float scaleFactor = 1.0f);
# 1030 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void paintEntireComponent (Graphics& context, bool ignoreAlphaLevel);
# 1044 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void setPaintingIsUnclipped (bool shouldPaintWithoutClipping) noexcept;
# 1060 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void setComponentEffect (ImageEffectFilter* newEffect);




    ImageEffectFilter* getComponentEffect() const noexcept { return effect; }
# 1076 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    LookAndFeel& getLookAndFeel() const noexcept;
# 1091 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void setLookAndFeel (LookAndFeel* newLookAndFeel);
# 1103 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    virtual void lookAndFeelChanged();
# 1112 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void sendLookAndFeelChange();
# 1129 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void setOpaque (bool shouldBeOpaque);






    bool isOpaque() const noexcept;
# 1151 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void setBroughtToFrontOnMouseClick (bool shouldBeBroughtToFront) noexcept;




    bool isBroughtToFrontOnMouseClick() const noexcept;
# 1171 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void setWantsKeyboardFocus (bool wantsFocus) noexcept;
# 1180 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    bool getWantsKeyboardFocus() const noexcept;
# 1189 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void setMouseClickGrabsKeyboardFocus (bool shouldGrabFocus);




    bool getMouseClickGrabsKeyboardFocus() const noexcept;
# 1216 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void grabKeyboardFocus();
# 1228 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    bool hasKeyboardFocus (bool trueIfChildIsFocused) const;




    static Component* __stdcall getCurrentlyFocusedComponent() noexcept;


    static void __stdcall unfocusAllComponents();
# 1250 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void moveKeyboardFocusToSibling (bool moveToNext);
# 1267 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    virtual KeyboardFocusTraverser* createFocusTraverser();
# 1283 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    int getExplicitFocusOrder() const;
# 1293 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void setExplicitFocusOrder (int newFocusOrderIndex);
# 1307 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void setFocusContainer (bool shouldBeFocusContainer) noexcept;







    bool isFocusContainer() const noexcept;
# 1329 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    bool isEnabled() const noexcept;
# 1341 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void setEnabled (bool shouldBeEnabled);
# 1353 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    virtual void enablementChanged();





    float getAlpha() const noexcept;
# 1368 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void setAlpha (float newAlpha);





    virtual void alphaChanged();
# 1384 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void setMouseCursor (const MouseCursor& cursorType);
# 1394 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    virtual MouseCursor getMouseCursor();
# 1406 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void updateMouseCursor() const;
# 1432 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    virtual void paint (Graphics& g);
# 1442 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    virtual void paintOverChildren (Graphics& g);
# 1457 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    virtual void mouseMove (const MouseEvent& event) override;
# 1473 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    virtual void mouseEnter (const MouseEvent& event) override;
# 1488 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    virtual void mouseExit (const MouseEvent& event) override;
# 1503 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    virtual void mouseDown (const MouseEvent& event) override;
# 1515 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    virtual void mouseDrag (const MouseEvent& event) override;
# 1530 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    virtual void mouseUp (const MouseEvent& event) override;
# 1542 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    virtual void mouseDoubleClick (const MouseEvent& event) override;
# 1559 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    virtual void mouseWheelMove (const MouseEvent& event,
                                 const MouseWheelDetails& wheel) override;
# 1573 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    virtual void mouseMagnify (const MouseEvent& event, float scaleFactor);
# 1591 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    static void __stdcall beginDragAutoRepeat (int millisecondsBetweenCallbacks);
# 1604 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void setRepaintsOnMouseActivity (bool shouldRepaint) noexcept;
# 1623 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void addMouseListener (MouseListener* newListener,
                           bool wantsEventsForAllNestedChildComponents);




    void removeMouseListener (MouseListener* listenerToRemove);
# 1642 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void addKeyListener (KeyListener* newListener);




    void removeKeyListener (KeyListener* listenerToRemove);
# 1665 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    virtual bool keyPressed (const KeyPress& key);
# 1689 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    virtual bool keyStateChanged (bool isKeyDown);
# 1704 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    virtual void modifierKeysChanged (const ModifierKeys& modifiers);



    enum FocusChangeType
    {
        focusChangedByMouseClick,
        focusChangedByTabKey,
        focusChangedDirectly
    };




    virtual void focusGained (FocusChangeType cause);




    virtual void focusLost (FocusChangeType cause);
# 1736 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    virtual void focusOfChildComponentChanged (FocusChangeType cause);
# 1754 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    bool isMouseOver (bool includeChildren = false) const;
# 1764 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    bool isMouseButtonDown() const;





    bool isMouseOverOrDragging (bool includeChildren = false) const;
# 1780 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    static bool __stdcall isMouseButtonDownAnywhere() noexcept;




    Point<int> getMouseXYRelative() const;
# 1803 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    virtual void resized();
# 1820 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    virtual void moved();
# 1829 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    virtual void childBoundsChanged (Component* child);
# 1838 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    virtual void parentSizeChanged();
# 1847 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    virtual void broughtToFront();
# 1858 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void addComponentListener (ComponentListener* newListener);




    void removeComponentListener (ComponentListener* listenerToRemove);
# 1877 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void postCommandMessage (int commandId);
# 1886 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    virtual void handleCommandMessage (int commandId);
# 1915 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    int runModalLoop();
# 1939 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void enterModalState (bool takeKeyboardFocus = true,
                          ModalComponentManager::Callback* callback = nullptr,
                          bool deleteWhenDismissed = false);
# 1950 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void exitModalState (int returnValue);
# 1962 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    bool isCurrentlyModal (bool onlyConsiderForemostModalComponent = true) const noexcept;




    static int __stdcall getNumCurrentlyModalComponents() noexcept;
# 1980 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    static Component* __stdcall getCurrentlyModalComponent (int index = 0) noexcept;
# 1990 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    bool isCurrentlyBlockedByAnotherModalComponent() const;
# 2003 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    virtual bool canModalEventBeSentToComponent (const Component* targetComponent);
# 2016 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    virtual void inputAttemptWhenModal();







    NamedValueSet& getProperties() noexcept { return properties; }





    const NamedValueSet& getProperties() const noexcept { return properties; }
# 2046 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    Colour findColour (int colourId, bool inheritFromParent = false) const;
# 2058 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    void setColour (int colourId, Colour newColour);




    void removeColour (int colourId);




    bool isColourSpecified (int colourId) const;




    void copyAllExplicitColoursTo (Component& target) const;




    virtual void colourChanged();







    virtual MarkerList* getMarkers (bool xAxis);






    void* getWindowHandle() const;
# 2108 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    template <class ComponentType>
    class SafePointer
    {
    public:

        SafePointer() noexcept {}


        SafePointer (ComponentType* component) : weakRef (component) {}


        SafePointer (const SafePointer& other) noexcept : weakRef (other.weakRef) {}


        SafePointer& operator= (const SafePointer& other) { weakRef = other.weakRef; return *this; }


        SafePointer& operator= (ComponentType* newComponent) { weakRef = newComponent; return *this; }


        ComponentType* getComponent() const noexcept { return dynamic_cast<ComponentType*> (weakRef.get()); }


        operator ComponentType*() const noexcept { return getComponent(); }


        ComponentType* operator->() noexcept { return getComponent(); }


        const ComponentType* operator->() const noexcept { return getComponent(); }


        void deleteAndZero() { delete getComponent(); }

        bool operator== (ComponentType* component) const noexcept { return weakRef == component; }
        bool operator!= (ComponentType* component) const noexcept { return weakRef != component; }

    private:
        WeakReference<Component> weakRef;
    };
# 2156 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    class BailOutChecker
    {
    public:

        BailOutChecker (Component* component);


        bool shouldBailOut() const noexcept;

    private:
        const WeakReference<Component> safePointer;

        BailOutChecker (const BailOutChecker&) = delete; BailOutChecker& operator= (const BailOutChecker&) = delete;
    };
# 2180 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
    class Positioner
    {
    public:

        explicit Positioner (Component& component) noexcept;

        virtual ~Positioner() {}


        Component& getComponent() const noexcept { return component; }






        virtual void applyNewBounds (const Rectangle<int>& newBounds) = 0;

    private:
        Component& component;

        Positioner (const Positioner&) = delete; Positioner& operator= (const Positioner&) = delete;
    };




    Positioner* getPositioner() const noexcept;







    void setPositioner (Positioner* newPositioner);






    void setCachedComponentImage (CachedComponentImage* newCachedImage);




    CachedComponentImage* getCachedComponentImage() const noexcept { return cachedImage; }



    __declspec(deprecated) Point<int> relativePositionToGlobal (Point<int>) const;
    __declspec(deprecated) Point<int> globalPositionToRelative (Point<int>) const;
    __declspec(deprecated) Point<int> relativePositionToOtherComponent (const Component*, Point<int>) const;

private:

    friend class ComponentPeer;
    friend class MouseInputSource;
    friend class MouseInputSourceInternal;


    static Component* currentlyFocusedComponent;


    String componentName, componentID;
    Component* parentComponent;
    Rectangle<int> boundsRelativeToParent;
    ScopedPointer<Positioner> positioner;
    ScopedPointer<AffineTransform> affineTransform;
    Array<Component*> childComponentList;
    LookAndFeel* lookAndFeel;
    MouseCursor cursor;
    ImageEffectFilter* effect;
    ScopedPointer<CachedComponentImage> cachedImage;

    class MouseListenerList;
    friend class MouseListenerList;
    friend struct ContainerDeletePolicy<MouseListenerList>;
    ScopedPointer<MouseListenerList> mouseListeners;
    ScopedPointer<Array<KeyListener*> > keyListeners;
    ListenerList<ComponentListener> componentListeners;
    NamedValueSet properties;

    friend class WeakReference<Component>;
    WeakReference<Component>::Master masterReference;

    struct ComponentFlags
    {
        bool hasHeavyweightPeerFlag : 1;
        bool visibleFlag : 1;
        bool opaqueFlag : 1;
        bool ignoresMouseClicksFlag : 1;
        bool allowChildMouseClicksFlag : 1;
        bool wantsFocusFlag : 1;
        bool isFocusContainerFlag : 1;
        bool dontFocusOnMouseClickFlag : 1;
        bool alwaysOnTopFlag : 1;
        bool bufferToImageFlag : 1;
        bool bringToFrontOnClickFlag : 1;
        bool repaintOnMouseActivityFlag : 1;
        bool isDisabledFlag : 1;
        bool childCompFocusedFlag : 1;
        bool dontClipGraphicsFlag : 1;
        bool mouseDownWasBlocked : 1;
        bool isMoveCallbackPending : 1;
        bool isResizeCallbackPending : 1;



    };

    union
    {
        uint32 componentFlags;
        ComponentFlags flags;
    };

    uint8 componentTransparency;


    void internalMouseEnter (MouseInputSource, Point<float>, Time);
    void internalMouseExit (MouseInputSource, Point<float>, Time);
    void internalMouseDown (MouseInputSource, Point<float>, Time, float);
    void internalMouseUp (MouseInputSource, Point<float>, Time, const ModifierKeys oldModifiers, float);
    void internalMouseDrag (MouseInputSource, Point<float>, Time, float);
    void internalMouseMove (MouseInputSource, Point<float>, Time);
    void internalMouseWheel (MouseInputSource, Point<float>, Time, const MouseWheelDetails&);
    void internalMagnifyGesture (MouseInputSource, Point<float>, Time, float);
    void internalBroughtToFront();
    void internalFocusGain (FocusChangeType, const WeakReference<Component>&);
    void internalFocusGain (FocusChangeType);
    void internalFocusLoss (FocusChangeType);
    void internalChildFocusChange (FocusChangeType, const WeakReference<Component>&);
    void internalModalInputAttempt();
    void internalModifierKeysChanged();
    void internalChildrenChanged();
    void internalHierarchyChanged();
    void internalRepaint (Rectangle<int>);
    void internalRepaintUnchecked (Rectangle<int>, bool);
    Component* removeChildComponent (int index, bool sendParentEvents, bool sendChildEvents);
    void reorderChildInternal (int sourceIndex, int destIndex);
    void paintComponentAndChildren (Graphics&);
    void paintWithinParentContext (Graphics&);
    void sendMovedResizedMessages (bool wasMoved, bool wasResized);
    void sendMovedResizedMessagesIfPending();
    void repaintParent();
    void sendFakeMouseMove() const;
    void takeKeyboardFocus (const FocusChangeType);
    void grabFocusInternal (const FocusChangeType, bool canTryParent);
    static void giveAwayFocus (bool sendFocusLossEvent);
    void sendEnablementChangeMessage();
    void sendVisibilityChangeMessage();

    struct ComponentHelpers;
    friend struct ComponentHelpers;




    Component (const Component&) = delete; Component& operator= (const Component&) = delete;
# 2355 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Component.h"
protected:


    virtual ComponentPeer* createNewPeer (int styleFlags, void* nativeWindowToAttachTo);

};
# 169 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ComponentAnimator.h" 1
# 50 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ComponentAnimator.h"
class ComponentAnimator : public ChangeBroadcaster,
                                     private Timer
{
public:


    ComponentAnimator();


    ~ComponentAnimator();
# 95 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ComponentAnimator.h"
    void animateComponent (Component* component,
                           const Rectangle<int>& finalBounds,
                           float finalAlpha,
                           int animationDurationMilliseconds,
                           bool useProxyComponent,
                           double startSpeed,
                           double endSpeed);






    void fadeOut (Component* component, int millisecondsToTake);




    void fadeIn (Component* component, int millisecondsToTake);







    void cancelAnimation (Component* component,
                          bool moveComponentToItsFinalPosition);







    void cancelAllAnimations (bool moveComponentsToTheirFinalPositions);
# 140 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ComponentAnimator.h"
    Rectangle<int> getComponentDestination (Component* component);


    bool isAnimating (Component* component) const noexcept;


    bool isAnimating() const noexcept;

private:

    class AnimationTask;
    OwnedArray<AnimationTask> tasks;
    uint32 lastTime;

    AnimationTask* findTaskFor (Component*) const noexcept;
    void timerCallback() override;

    ComponentAnimator (const ComponentAnimator&) = delete; ComponentAnimator& operator= (const ComponentAnimator&) = delete;
};
# 170 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Desktop.h" 1
# 36 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Desktop.h"
class FocusChangeListener
{
public:

    virtual ~FocusChangeListener() {}


    virtual void globalFocusChanged (Component* focusedComponent) = 0;
};







class Desktop : private DeletedAtShutdown,
                           private Timer,
                           private AsyncUpdater
{
public:


    static Desktop& __stdcall getInstance();
# 70 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Desktop.h"
    static Point<int> getMousePosition();




    static void setMousePosition (Point<int> newPosition);
# 84 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Desktop.h"
    static Point<int> getLastMouseDownPosition();





    int getMouseButtonClickCounter() const noexcept;





    int getMouseWheelMoveCounter() const noexcept;
# 113 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Desktop.h"
    static void setScreenSaverEnabled (bool isEnabled);
# 123 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Desktop.h"
    static bool isScreenSaverEnabled();







    void addGlobalMouseListener (MouseListener* listener);






    void removeGlobalMouseListener (MouseListener* listener);





    void addFocusChangeListener (FocusChangeListener* listener);


    void removeFocusChangeListener (FocusChangeListener* listener);
# 164 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Desktop.h"
    void setKioskModeComponent (Component* componentToUse,
                                bool allowMenusAndBars = true);






    Component* getKioskModeComponent() const noexcept { return kioskModeComponent; }







    int getNumComponents() const noexcept;
# 189 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Desktop.h"
    Component* getComponent (int index) const noexcept;
# 198 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Desktop.h"
    Component* findComponentAt (Point<int> screenPosition) const;
# 209 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Desktop.h"
    ComponentAnimator& getAnimator() noexcept { return animator; }






    LookAndFeel& getDefaultLookAndFeel() noexcept;
# 225 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Desktop.h"
    void setDefaultLookAndFeel (LookAndFeel* newDefaultLookAndFeel);
# 234 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Desktop.h"
    const Array<MouseInputSource>& getMouseSources() const noexcept;
# 243 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Desktop.h"
    int getNumMouseSources() const noexcept;







    MouseInputSource* getMouseSource (int index) const noexcept;




    MouseInputSource getMainMouseSource() const noexcept;






    int getNumDraggingMouseSources() const noexcept;





    MouseInputSource* getDraggingMouseSource (int index) const noexcept;
# 286 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Desktop.h"
    void beginDragAutoRepeat (int millisecondsBetweenCallbacks);



    enum DisplayOrientation
    {
        upright = 1,
        upsideDown = 2,
        rotatedClockwise = 4,
        rotatedAntiClockwise = 8,

        allOrientations = 1 + 2 + 4 + 8
    };


    DisplayOrientation getCurrentOrientation() const;
# 310 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/components/juce_Desktop.h"
    void setOrientationsEnabled (int allowedOrientations);




    bool isOrientationEnabled (DisplayOrientation orientation) const noexcept;


    class Displays
    {
    public:

        struct Display
        {


            Rectangle<int> userArea;


            Rectangle<int> totalArea;






            double scale;





            double dpi;


            bool isMain;
        };


        const Display& getMainDisplay() const noexcept;




        const Display& getDisplayContaining (Point<int> position) const noexcept;


        RectangleList<int> getRectangleList (bool userAreasOnly) const;


        Rectangle<int> getTotalBounds (bool userAreasOnly) const;


        Array<Display> displays;



        void refresh();


    private:
        friend class Desktop;
        friend struct ContainerDeletePolicy<Displays>;
        Displays (Desktop&);
        ~Displays();

        void init (Desktop&);
        void findDisplays (float masterScale);
    };

    const Displays& getDisplays() const noexcept { return *displays; }





    void setGlobalScaleFactor (float newScaleFactor) noexcept;




    float getGlobalScaleFactor() const noexcept { return masterScaleFactor; }



    static bool canUseSemiTransparentWindows() noexcept;






private:

    static Desktop* instance;

    friend class Component;
    friend class ComponentPeer;
    friend class MouseInputSourceInternal;
    friend class DeletedAtShutdown;
    friend class TopLevelWindowManager;

    ScopedPointer<MouseInputSource::SourceList> mouseSources;

    ListenerList<MouseListener> mouseListeners;
    ListenerList<FocusChangeListener> focusListeners;

    Array<Component*> desktopComponents;
    Array<ComponentPeer*> peers;

    ScopedPointer<Displays> displays;

    Point<float> lastFakeMouseMove;
    void sendMouseMove();

    int mouseClickCounter, mouseWheelCounter;
    void incrementMouseClickCounter() noexcept;
    void incrementMouseWheelCounter() noexcept;

    ScopedPointer<LookAndFeel> defaultLookAndFeel;
    WeakReference<LookAndFeel> currentLookAndFeel;

    Component* kioskModeComponent;
    Rectangle<int> kioskComponentOriginalBounds;
    bool kioskModeReentrant;

    int allowedOrientations;
    void allowedOrientationsChanged();

    float masterScaleFactor;

    ComponentAnimator animator;

    void timerCallback() override;
    void resetTimer();
    ListenerList<MouseListener>& getMouseListeners();

    void addDesktopComponent (Component*);
    void removeDesktopComponent (Component*);
    void componentBroughtToFront (Component*);

    void setKioskComponent (Component*, bool shouldBeEnabled, bool allowMenusAndBars);

    void triggerFocusCallback();
    void handleAsyncUpdate() override;

    static Point<float> getMousePositionFloat();

    static double getDefaultMasterScale();

    Desktop();
    ~Desktop();

    Desktop (const Desktop&) = delete; Desktop& operator= (const Desktop&) = delete;
};
# 171 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ComponentBoundsConstrainer.h" 1
# 41 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ComponentBoundsConstrainer.h"
class ComponentBoundsConstrainer
{
public:


    ComponentBoundsConstrainer() noexcept;


    virtual ~ComponentBoundsConstrainer();



    void setMinimumWidth (int minimumWidth) noexcept;


    int getMinimumWidth() const noexcept { return minW; }


    void setMaximumWidth (int maximumWidth) noexcept;


    int getMaximumWidth() const noexcept { return maxW; }


    void setMinimumHeight (int minimumHeight) noexcept;


    int getMinimumHeight() const noexcept { return minH; }


    void setMaximumHeight (int maximumHeight) noexcept;


    int getMaximumHeight() const noexcept { return maxH; }


    void setMinimumSize (int minimumWidth,
                         int minimumHeight) noexcept;


    void setMaximumSize (int maximumWidth,
                         int maximumHeight) noexcept;


    void setSizeLimits (int minimumWidth,
                        int minimumHeight,
                        int maximumWidth,
                        int maximumHeight) noexcept;
# 107 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ComponentBoundsConstrainer.h"
    void setMinimumOnscreenAmounts (int minimumWhenOffTheTop,
                                    int minimumWhenOffTheLeft,
                                    int minimumWhenOffTheBottom,
                                    int minimumWhenOffTheRight) noexcept;



    int getMinimumWhenOffTheTop() const noexcept { return minOffTop; }

    int getMinimumWhenOffTheLeft() const noexcept { return minOffLeft; }

    int getMinimumWhenOffTheBottom() const noexcept { return minOffBottom; }

    int getMinimumWhenOffTheRight() const noexcept { return minOffRight; }
# 130 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ComponentBoundsConstrainer.h"
    void setFixedAspectRatio (double widthOverHeight) noexcept;





    double getFixedAspectRatio() const noexcept;
# 151 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ComponentBoundsConstrainer.h"
    virtual void checkBounds (Rectangle<int>& bounds,
                              const Rectangle<int>& previousBounds,
                              const Rectangle<int>& limits,
                              bool isStretchingTop,
                              bool isStretchingLeft,
                              bool isStretchingBottom,
                              bool isStretchingRight);


    virtual void resizeStart();


    virtual void resizeEnd();


    void setBoundsForComponent (Component* component,
                                const Rectangle<int>& bounds,
                                bool isStretchingTop,
                                bool isStretchingLeft,
                                bool isStretchingBottom,
                                bool isStretchingRight);




    void checkComponentBounds (Component* component);







    virtual void applyBoundsToComponent (Component* component,
                                         const Rectangle<int>& bounds);

private:

    int minW, maxW, minH, maxH;
    int minOffTop, minOffLeft, minOffBottom, minOffRight;
    double aspectRatio;

    ComponentBoundsConstrainer (const ComponentBoundsConstrainer&) = delete; ComponentBoundsConstrainer& operator= (const ComponentBoundsConstrainer&) = delete;
};
# 172 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_ComponentDragger.h" 1
# 56 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_ComponentDragger.h"
class ComponentDragger
{
public:


    ComponentDragger();


    virtual ~ComponentDragger();
# 73 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_ComponentDragger.h"
    void startDraggingComponent (Component* componentToDrag,
                                 const MouseEvent& e);
# 88 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_ComponentDragger.h"
    void dragComponent (Component* componentToDrag,
                        const MouseEvent& e,
                        ComponentBoundsConstrainer* constrainer);

private:

    Point<int> mouseDownWithinTarget;

    ComponentDragger (const ComponentDragger&) = delete; ComponentDragger& operator= (const ComponentDragger&) = delete;
};
# 173 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_DragAndDropTarget.h" 1
# 43 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_DragAndDropTarget.h"
class DragAndDropTarget
{
public:

    virtual ~DragAndDropTarget() {}





    class SourceDetails
    {
    public:

        SourceDetails (const var& description,
                       Component* sourceComponent,
                       Point<int> localPosition) noexcept;


        var description;


        WeakReference<Component> sourceComponent;




        Point<int> localPosition;
    };
# 81 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_DragAndDropTarget.h"
    virtual bool isInterestedInDragSource (const SourceDetails& dragSourceDetails) = 0;
# 94 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_DragAndDropTarget.h"
    virtual void itemDragEnter (const SourceDetails& dragSourceDetails);
# 104 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_DragAndDropTarget.h"
    virtual void itemDragMove (const SourceDetails& dragSourceDetails);
# 117 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_DragAndDropTarget.h"
    virtual void itemDragExit (const SourceDetails& dragSourceDetails);
# 129 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_DragAndDropTarget.h"
    virtual void itemDropped (const SourceDetails& dragSourceDetails) = 0;







    virtual bool shouldDrawDragImageWhenOver();



private:
# 150 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_DragAndDropTarget.h"
};
# 174 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_DragAndDropContainer.h" 1
# 48 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_DragAndDropContainer.h"
class DragAndDropContainer
{
public:





    DragAndDropContainer();


    virtual ~DragAndDropContainer();
# 87 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_DragAndDropContainer.h"
    void startDragging (const var& sourceDescription,
                        Component* sourceComponent,
                        Image dragImage = Image(),
                        bool allowDraggingToOtherJuceWindows = false,
                        const Point<int>* imageOffsetFromMouse = nullptr);


    bool isDragAndDropActive() const;
# 103 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_DragAndDropContainer.h"
    var getCurrentDragDescription() const;


    void setCurrentDragImage (const Image& newImage);
# 118 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_DragAndDropContainer.h"
    static DragAndDropContainer* findParentDragContainerFor (Component* childComponent);
# 137 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_DragAndDropContainer.h"
    static bool performExternalDragDropOfFiles (const StringArray& files, bool canMoveFiles);
# 152 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_DragAndDropContainer.h"
    static bool performExternalDragDropOfText (const String& text);

protected:
# 168 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_DragAndDropContainer.h"
    virtual bool shouldDropFilesWhenDraggedExternally (const DragAndDropTarget::SourceDetails& sourceDetails,
                                                       StringArray& files, bool& canMoveFiles);
# 182 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_DragAndDropContainer.h"
    virtual bool shouldDropTextWhenDraggedExternally (const DragAndDropTarget::SourceDetails& sourceDetails,
                                                      String& text);


    virtual void dragOperationStarted (const DragAndDropTarget::SourceDetails&);


    virtual void dragOperationEnded (const DragAndDropTarget::SourceDetails&);

private:

    class DragImageComponent;
    friend class DragImageComponent;
    friend struct ContainerDeletePolicy<DragImageComponent>;
    ScopedPointer<DragImageComponent> dragImageComponent;
# 205 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_DragAndDropContainer.h"
    __declspec(deprecated) virtual bool shouldDropFilesWhenDraggedExternally (const String&, Component*, StringArray&, bool&) { return false; }

    DragAndDropContainer (const DragAndDropContainer&) = delete; DragAndDropContainer& operator= (const DragAndDropContainer&) = delete;
};
# 175 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_FileDragAndDropTarget.h" 1
# 33 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_FileDragAndDropTarget.h"
class FileDragAndDropTarget
{
public:

    virtual ~FileDragAndDropTarget() {}
# 49 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_FileDragAndDropTarget.h"
    virtual bool isInterestedInFileDrag (const StringArray& files) = 0;
# 62 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_FileDragAndDropTarget.h"
    virtual void fileDragEnter (const StringArray& files, int x, int y);
# 74 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_FileDragAndDropTarget.h"
    virtual void fileDragMove (const StringArray& files, int x, int y);
# 86 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_FileDragAndDropTarget.h"
    virtual void fileDragExit (const StringArray& files);
# 100 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_FileDragAndDropTarget.h"
    virtual void filesDropped (const StringArray& files, int x, int y) = 0;
};
# 176 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_SelectedItemSet.h" 1
# 42 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_SelectedItemSet.h"
template <class SelectableItemType>
class SelectedItemSet : public ChangeBroadcaster
{
public:

    typedef SelectableItemType ItemType;
    typedef Array<SelectableItemType> ItemArray;
    typedef typename TypeHelpers::ParameterType<SelectableItemType>::type ParameterType;



    SelectedItemSet()
    {
    }


    explicit SelectedItemSet (const ItemArray& items)
        : selectedItems (items)
    {
    }


    SelectedItemSet (const SelectedItemSet& other)
        : selectedItems (other.selectedItems)
    {
    }


    SelectedItemSet& operator= (const SelectedItemSet& other)
    {
        if (selectedItems != other.selectedItems)
        {
            changed();

            for (int i = selectedItems.size(); --i >= 0;)
                if (! other.isSelected (selectedItems.getReference (i)))
                    itemDeselected (selectedItems.removeAndReturn (i));

            for (SelectableItemType* i = other.selectedItems.begin(), *e = other.selectedItems.end(); i != e; ++i)
            {
                if (! isSelected (*i))
                {
                    selectedItems.add (*i);
                    itemSelected (*i);
                }
            }
        }

        return *this;
    }
# 101 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_SelectedItemSet.h"
    void selectOnly (ParameterType item)
    {
        if (isSelected (item))
        {
            for (int i = selectedItems.size(); --i >= 0;)
            {
                if (selectedItems.getUnchecked(i) != item)
                {
                    deselect (selectedItems.getUnchecked(i));
                    i = jmin (i, selectedItems.size());
                }
            }
        }
        else
        {
            changed();
            deselectAll();

            selectedItems.add (item);
            itemSelected (item);
        }
    }





    void addToSelection (ParameterType item)
    {
        if (! isSelected (item))
        {
            changed();

            selectedItems.add (item);
            itemSelected (item);
        }
    }
# 160 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_SelectedItemSet.h"
    void addToSelectionBasedOnModifiers (ParameterType item,
                                         ModifierKeys modifiers)
    {
        if (modifiers.isShiftDown())
        {
            addToSelection (item);
        }
        else if (modifiers.isCommandDown())
        {
            if (isSelected (item))
                deselect (item);
            else
                addToSelection (item);
        }
        else
        {
            selectOnly (item);
        }
    }
# 197 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_SelectedItemSet.h"
    bool addToSelectionOnMouseDown (ParameterType item,
                                    ModifierKeys modifiers)
    {
        if (isSelected (item))
            return ! modifiers.isPopupMenu();

        addToSelectionBasedOnModifiers (item, modifiers);
        return false;
    }
# 221 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_SelectedItemSet.h"
    void addToSelectionOnMouseUp (ParameterType item,
                                  ModifierKeys modifiers,
                                  const bool wasItemDragged,
                                  const bool resultOfMouseDownSelectMethod)
    {
        if (resultOfMouseDownSelectMethod && ! wasItemDragged)
            addToSelectionBasedOnModifiers (item, modifiers);
    }


    void deselect (ParameterType item)
    {
        const int i = selectedItems.indexOf (item);

        if (i >= 0)
        {
            changed();
            itemDeselected (selectedItems.removeAndReturn (i));
        }
    }


    void deselectAll()
    {
        if (selectedItems.size() > 0)
        {
            changed();

            for (int i = selectedItems.size(); --i >= 0;)
            {
                itemDeselected (selectedItems.removeAndReturn (i));
                i = jmin (i, selectedItems.size());
            }
        }
    }





    int getNumSelected() const noexcept { return selectedItems.size(); }





    SelectableItemType getSelectedItem (const int index) const { return selectedItems [index]; }


    bool isSelected (ParameterType item) const noexcept { return selectedItems.contains (item); }


    const ItemArray& getItemArray() const noexcept { return selectedItems; }


    SelectableItemType* begin() const noexcept { return selectedItems.begin(); }


    SelectableItemType* end() const noexcept { return selectedItems.end(); }







    virtual void itemSelected (SelectableItemType) {}






    virtual void itemDeselected (SelectableItemType) {}




    void changed()
    {
        sendChangeMessage();
    }




    void changed (const bool synchronous)
    {
        if (synchronous)
            sendSynchronousChangeMessage();
        else
            sendChangeMessage();
    }

private:

    ItemArray selectedItems;


};
# 177 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_LassoComponent.h" 1
# 38 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_LassoComponent.h"
template <class SelectableItemType>
class LassoSource
{
public:

    virtual ~LassoSource() {}
# 54 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_LassoComponent.h"
    virtual void findLassoItemsInArea (Array <SelectableItemType>& itemsFound,
                                       const Rectangle<int>& area) = 0;
# 64 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_LassoComponent.h"
    virtual SelectedItemSet<SelectableItemType>& getLassoSelection() = 0;
};
# 95 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_LassoComponent.h"
template <class SelectableItemType>
class LassoComponent : public Component
{
public:


    LassoComponent() : source (nullptr)
    {
    }
# 116 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_LassoComponent.h"
    void beginLasso (const MouseEvent& e, LassoSource<SelectableItemType>* lassoSource)
    {
#pragma warning(push)
# 118 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_LassoComponent.h"
#pragma warning(disable: 4127)
# 118 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_LassoComponent.h"
 do { ; } while (false)
# 118 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_LassoComponent.h"
#pragma warning(pop)
# 118 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_LassoComponent.h"
;
#pragma warning(push)
# 119 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_LassoComponent.h"
#pragma warning(disable: 4127)
# 119 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_LassoComponent.h"
 do { ; } while (false)
# 119 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_LassoComponent.h"
#pragma warning(pop)
# 119 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_LassoComponent.h"
;
#pragma warning(push)
# 120 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_LassoComponent.h"
#pragma warning(disable: 4127)
# 120 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_LassoComponent.h"
 do { ; } while (false)
# 120 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_LassoComponent.h"
#pragma warning(pop)
# 120 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_LassoComponent.h"
;

        source = lassoSource;

        if (lassoSource != nullptr)
            originalSelection = lassoSource->getLassoSelection().getItemArray();

        setSize (0, 0);
        dragStartPos = e.getMouseDownPosition();
    }
# 143 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_LassoComponent.h"
    void dragLasso (const MouseEvent& e)
    {
        if (source != nullptr)
        {
            setBounds (Rectangle<int> (dragStartPos, e.getPosition()));
            setVisible (true);

            Array<SelectableItemType> itemsInLasso;
            source->findLassoItemsInArea (itemsInLasso, getBounds());

            if (e.mods.isShiftDown())
            {
                itemsInLasso.removeValuesIn (originalSelection);
                itemsInLasso.addArray (originalSelection);
            }
            else if (e.mods.isCommandDown() || e.mods.isAltDown())
            {
                Array<SelectableItemType> originalMinusNew (originalSelection);
                originalMinusNew.removeValuesIn (itemsInLasso);

                itemsInLasso.removeValuesIn (originalSelection);
                itemsInLasso.addArray (originalMinusNew);
            }

            source->getLassoSelection() = SelectedItemSet<SelectableItemType> (itemsInLasso);
        }
    }




    void endLasso()
    {
        source = nullptr;
        originalSelection.clear();
        setVisible (false);
    }
# 192 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_LassoComponent.h"
    enum ColourIds
    {
        lassoFillColourId = 0x1000440,
        lassoOutlineColourId = 0x1000441,
    };



    void paint (Graphics& g) override
    {
        getLookAndFeel().drawLasso (g, *this);




#pragma warning(push)
# 207 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_LassoComponent.h"
#pragma warning(disable: 4127)
# 207 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_LassoComponent.h"
 do { ; } while (false)
# 207 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_LassoComponent.h"
#pragma warning(pop)
# 207 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_LassoComponent.h"
;
    }


    bool hitTest (int, int) override { return false; }

private:

    Array<SelectableItemType> originalSelection;
    LassoSource<SelectableItemType>* source;
    Point<int> dragStartPos;

    LassoComponent (const LassoComponent&) = delete; LassoComponent& operator= (const LassoComponent&) = delete;
};
# 178 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_MouseInactivityDetector.h" 1
# 41 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_MouseInactivityDetector.h"
class MouseInactivityDetector : private Timer,
                                           private MouseListener
{
public:




    MouseInactivityDetector (Component& target);


    ~MouseInactivityDetector();




    void setDelay (int newDelayMilliseconds) noexcept;




    void setMouseMoveTolerance (int pixelsNeededToTrigger) noexcept;





    class Listener
    {
    public:
        virtual ~Listener() {}



        virtual void mouseBecameActive() = 0;


        virtual void mouseBecameInactive() = 0;
    };


    void addListener (Listener* listener);


    void removeListener (Listener* listener);

private:

    Component& targetComp;
    ListenerList<Listener> listenerList;
    Point<int> lastMousePos;
    int delayMs, toleranceDistance;
    bool isActive;

    void timerCallback() override;
    void wakeUp (const MouseEvent&, bool alwaysWake);
    void setActive (bool);

    void mouseMove (const MouseEvent& e) override { wakeUp (e, false); }
    void mouseEnter (const MouseEvent& e) override { wakeUp (e, false); }
    void mouseExit (const MouseEvent& e) override { wakeUp (e, false); }
    void mouseDown (const MouseEvent& e) override { wakeUp (e, true); }
    void mouseDrag (const MouseEvent& e) override { wakeUp (e, true); }
    void mouseUp (const MouseEvent& e) override { wakeUp (e, true); }
    void mouseWheelMove (const MouseEvent& e, const MouseWheelDetails&) override { wakeUp (e, true); }

    MouseInactivityDetector (const MouseInactivityDetector&) = delete; MouseInactivityDetector& operator= (const MouseInactivityDetector&) = delete;
};
# 179 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_TextDragAndDropTarget.h" 1
# 35 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_TextDragAndDropTarget.h"
class TextDragAndDropTarget
{
public:

    virtual ~TextDragAndDropTarget() {}
# 50 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_TextDragAndDropTarget.h"
    virtual bool isInterestedInTextDrag (const String& text) = 0;
# 63 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_TextDragAndDropTarget.h"
    virtual void textDragEnter (const String& text, int x, int y);
# 75 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_TextDragAndDropTarget.h"
    virtual void textDragMove (const String& text, int x, int y);
# 87 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_TextDragAndDropTarget.h"
    virtual void textDragExit (const String& text);
# 101 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_TextDragAndDropTarget.h"
    virtual void textDropped (const String& text, int x, int y) = 0;
};
# 180 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_TooltipClient.h" 1
# 39 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_TooltipClient.h"
class TooltipClient
{
public:

    virtual ~TooltipClient() {}


    virtual String getTooltip() = 0;
};
# 63 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/mouse/juce_TooltipClient.h"
class SettableTooltipClient : public TooltipClient
{
public:


    ~SettableTooltipClient() {}



    virtual void setTooltip (const String& newTooltip) { tooltipString = newTooltip; }


    String getTooltip() override { return tooltipString; }

protected:
    SettableTooltipClient() {}

private:
    String tooltipString;
};
# 181 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/keyboard/juce_CaretComponent.h" 1
# 32 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/keyboard/juce_CaretComponent.h"
class CaretComponent : public Component,
                                   private Timer
{
public:





    CaretComponent (Component* keyFocusOwner);


    ~CaretComponent();
# 54 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/keyboard/juce_CaretComponent.h"
    virtual void setCaretPosition (const Rectangle<int>& characterArea);






    enum ColourIds
    {
        caretColourId = 0x1000204,
    };



    void paint (Graphics&) override;

private:
    Component* owner;

    bool shouldBeShown() const;
    void timerCallback() override;

    CaretComponent (const CaretComponent&) = delete; CaretComponent& operator= (const CaretComponent&) = delete;
};
# 182 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/keyboard/juce_SystemClipboard.h" 1
# 33 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/keyboard/juce_SystemClipboard.h"
class SystemClipboard
{
public:

    static void copyTextToClipboard (const String& text);






    static String getTextFromClipboard();
};
# 183 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/keyboard/juce_TextEditorKeyMapper.h" 1
# 35 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/keyboard/juce_TextEditorKeyMapper.h"
template <class CallbackClass>
struct TextEditorKeyMapper
{



    static bool invokeKeyFunction (CallbackClass& target, const KeyPress& key)
    {
        const ModifierKeys& mods = key.getModifiers();

        const bool isShiftDown = mods.isShiftDown();
        const bool ctrlOrAltDown = mods.isCtrlDown() || mods.isAltDown();

        int numCtrlAltCommandKeys = 0;
        if (mods.isCtrlDown()) ++numCtrlAltCommandKeys;
        if (mods.isAltDown()) ++numCtrlAltCommandKeys;

        if (key == KeyPress (KeyPress::downKey, ModifierKeys::ctrlModifier, 0) && target.scrollUp()) return true;
        if (key == KeyPress (KeyPress::upKey, ModifierKeys::ctrlModifier, 0) && target.scrollDown()) return true;
# 68 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/keyboard/juce_TextEditorKeyMapper.h"
        if (numCtrlAltCommandKeys < 2)
        {
            if (key.isKeyCode (KeyPress::leftKey)) return target.moveCaretLeft (ctrlOrAltDown, isShiftDown);
            if (key.isKeyCode (KeyPress::rightKey)) return target.moveCaretRight (ctrlOrAltDown, isShiftDown);

            if (key.isKeyCode (KeyPress::homeKey)) return ctrlOrAltDown ? target.moveCaretToTop (isShiftDown)
                                                                         : target.moveCaretToStartOfLine (isShiftDown);
            if (key.isKeyCode (KeyPress::endKey)) return ctrlOrAltDown ? target.moveCaretToEnd (isShiftDown)
                                                                         : target.moveCaretToEndOfLine (isShiftDown);
        }

        if (numCtrlAltCommandKeys == 0)
        {
            if (key.isKeyCode (KeyPress::upKey)) return target.moveCaretUp (isShiftDown);
            if (key.isKeyCode (KeyPress::downKey)) return target.moveCaretDown (isShiftDown);

            if (key.isKeyCode (KeyPress::pageUpKey)) return target.pageUp (isShiftDown);
            if (key.isKeyCode (KeyPress::pageDownKey)) return target.pageDown (isShiftDown);
        }

        if (key == KeyPress ('c', ModifierKeys::commandModifier, 0)
              || key == KeyPress (KeyPress::insertKey, ModifierKeys::ctrlModifier, 0))
            return target.copyToClipboard();

        if (key == KeyPress ('x', ModifierKeys::commandModifier, 0)
              || key == KeyPress (KeyPress::deleteKey, ModifierKeys::shiftModifier, 0))
            return target.cutToClipboard();

        if (key == KeyPress ('v', ModifierKeys::commandModifier, 0)
              || key == KeyPress (KeyPress::insertKey, ModifierKeys::shiftModifier, 0))
            return target.pasteFromClipboard();


        if (numCtrlAltCommandKeys < 2)
        {
            if (key.isKeyCode (KeyPress::backspaceKey)) return target.deleteBackwards (ctrlOrAltDown);
            if (key.isKeyCode (KeyPress::deleteKey)) return target.deleteForwards (ctrlOrAltDown);
        }

        if (key == KeyPress ('a', ModifierKeys::commandModifier, 0))
            return target.selectAll();

        if (key == KeyPress ('z', ModifierKeys::commandModifier, 0))
            return target.undo();

        if (key == KeyPress ('y', ModifierKeys::commandModifier, 0)
             || key == KeyPress ('z', ModifierKeys::commandModifier | ModifierKeys::shiftModifier, 0))
            return target.redo();

        return false;
    }
};
# 184 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/keyboard/juce_TextInputTarget.h" 1
# 38 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/keyboard/juce_TextInputTarget.h"
class TextInputTarget
{
public:


    TextInputTarget() {}


    virtual ~TextInputTarget() {}




    virtual bool isTextInputActive() const = 0;




    virtual Range<int> getHighlightedRegion() const = 0;


    virtual void setHighlightedRegion (const Range<int>& newRange) = 0;




    virtual void setTemporaryUnderlining (const Array <Range<int> >& underlinedRegions) = 0;


    virtual String getTextInRange (const Range<int>& range) const = 0;


    virtual void insertTextAtCaret (const String& textToInsert) = 0;


    virtual Rectangle<int> getCaretRectangle() = 0;




    enum VirtualKeyboardType
    {
        textKeyboard = 0,
        numericKeyboard,
        decimalKeyboard,
        urlKeyboard,
        emailAddressKeyboard,
        phoneNumberKeyboard
    };




    virtual VirtualKeyboardType getKeyboardType() { return textKeyboard; }
};
# 185 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/commands/juce_ApplicationCommandID.h" 1
# 37 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/commands/juce_ApplicationCommandID.h"
typedef int CommandID;
# 52 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/commands/juce_ApplicationCommandID.h"
namespace StandardApplicationCommandIDs
{
    enum
    {






        quit = 0x1001,


        del = 0x1002,


        cut = 0x1003,


        copy = 0x1004,


        paste = 0x1005,


        selectAll = 0x1006,


        deselectAll = 0x1007,


        undo = 0x1008,


        redo = 0x1009
    };
}
# 186 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/commands/juce_ApplicationCommandInfo.h" 1
# 42 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/commands/juce_ApplicationCommandInfo.h"
struct ApplicationCommandInfo
{

    explicit ApplicationCommandInfo (CommandID commandID) noexcept;







    void setInfo (const String& shortName,
                  const String& description,
                  const String& categoryName,
                  int flags) noexcept;






    void setActive (bool isActive) noexcept;



    void setTicked (bool isTicked) noexcept;
# 80 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/commands/juce_ApplicationCommandInfo.h"
    void addDefaultKeypress (int keyCode, ModifierKeys modifiers) noexcept;




    CommandID commandID;
# 94 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/commands/juce_ApplicationCommandInfo.h"
    String shortName;
# 104 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/commands/juce_ApplicationCommandInfo.h"
    String description;
# 115 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/commands/juce_ApplicationCommandInfo.h"
    String categoryName;
# 125 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/commands/juce_ApplicationCommandInfo.h"
    Array<KeyPress> defaultKeypresses;







    enum CommandFlags
    {
# 144 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/commands/juce_ApplicationCommandInfo.h"
        isDisabled = 1 << 0,
# 154 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/commands/juce_ApplicationCommandInfo.h"
        isTicked = 1 << 1,






        wantsKeyUpDownCallbacks = 1 << 2,




        hiddenFromKeyEditor = 1 << 3,




        readOnlyInKeyEditor = 1 << 4,





        dontTriggerVisualFeedback = 1 << 5
    };






    int flags;
};
# 187 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/commands/juce_ApplicationCommandTarget.h" 1
# 44 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/commands/juce_ApplicationCommandTarget.h"
class ApplicationCommandTarget
{
public:


    ApplicationCommandTarget();


    virtual ~ApplicationCommandTarget();





    struct InvocationInfo
    {

        InvocationInfo (const CommandID commandID);



        CommandID commandID;




        int commandFlags;



        enum InvocationMethod
        {
            direct = 0,
            fromKeyPress,
            fromMenu,
            fromButton
        };


        InvocationMethod invocationMethod;







        Component* originatingComponent;







        KeyPress keyPress;






        bool isKeyDown;






        int millisecsSinceKeyPressed;
    };
# 130 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/commands/juce_ApplicationCommandTarget.h"
    virtual ApplicationCommandTarget* getNextCommandTarget() = 0;






    virtual void getAllCommands (Array<CommandID>& commands) = 0;
# 163 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/commands/juce_ApplicationCommandTarget.h"
    virtual void getCommandInfo (CommandID commandID, ApplicationCommandInfo& result) = 0;
# 175 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/commands/juce_ApplicationCommandTarget.h"
    virtual bool perform (const InvocationInfo& info) = 0;
# 195 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/commands/juce_ApplicationCommandTarget.h"
    bool invoke (const InvocationInfo& invocationInfo,
                 const bool asynchronously);






    bool invokeDirectly (const CommandID commandID,
                         const bool asynchronously);
# 213 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/commands/juce_ApplicationCommandTarget.h"
    ApplicationCommandTarget* getTargetForCommand (const CommandID commandID);






    bool isCommandActive (const CommandID commandID);
# 229 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/commands/juce_ApplicationCommandTarget.h"
    ApplicationCommandTarget* findFirstTargetParentComponent();

private:

    WeakReference<ApplicationCommandTarget>::Master masterReference;
    friend class WeakReference<ApplicationCommandTarget>;

    class CommandMessage;
    friend class CommandMessage;

    bool tryToInvoke (const InvocationInfo&, bool async);

    ApplicationCommandTarget (const ApplicationCommandTarget&) = delete; ApplicationCommandTarget& operator= (const ApplicationCommandTarget&) = delete;
};
# 188 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/commands/juce_ApplicationCommandManager.h" 1
# 84 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/commands/juce_ApplicationCommandManager.h"
class ApplicationCommandManager : private AsyncUpdater,
                                              private FocusChangeListener
{
public:







    ApplicationCommandManager();






    virtual ~ApplicationCommandManager();





    void clearCommands();




    void registerCommand (const ApplicationCommandInfo& newCommand);
# 123 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/commands/juce_ApplicationCommandManager.h"
    void registerAllCommandsForTarget (ApplicationCommandTarget* target);




    void removeCommand (CommandID commandID);
# 140 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/commands/juce_ApplicationCommandManager.h"
    void commandStatusChanged();





    int getNumCommands() const noexcept { return commands.size(); }




    const ApplicationCommandInfo* getCommandForIndex (int index) const noexcept { return commands [index]; }







    const ApplicationCommandInfo* getCommandForID (CommandID commandID) const noexcept;






    String getNameOfCommand (CommandID commandID) const noexcept;
# 175 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/commands/juce_ApplicationCommandManager.h"
    String getDescriptionOfCommand (CommandID commandID) const noexcept;
# 184 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/commands/juce_ApplicationCommandManager.h"
    StringArray getCommandCategories() const;




    Array<CommandID> getCommandsInCategory (const String& categoryName) const;
# 200 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/commands/juce_ApplicationCommandManager.h"
    KeyPressMappingSet* getKeyMappings() const noexcept { return keyMappings; }







    bool invokeDirectly (CommandID commandID, bool asynchronously);
# 225 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/commands/juce_ApplicationCommandManager.h"
    bool invoke (const ApplicationCommandTarget::InvocationInfo& invocationInfo,
                 bool asynchronously);
# 246 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/commands/juce_ApplicationCommandManager.h"
    virtual ApplicationCommandTarget* getFirstCommandTarget (CommandID commandID);
# 256 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/commands/juce_ApplicationCommandManager.h"
    void setFirstCommandTarget (ApplicationCommandTarget* newTarget) noexcept;
# 271 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/commands/juce_ApplicationCommandManager.h"
    ApplicationCommandTarget* getTargetForCommand (CommandID commandID,
                                                   ApplicationCommandInfo& upToDateInfo);



    void addListener (ApplicationCommandManagerListener* listener);


    void removeListener (ApplicationCommandManagerListener* listener);
# 290 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/commands/juce_ApplicationCommandManager.h"
    static ApplicationCommandTarget* findDefaultComponentTarget();







    static ApplicationCommandTarget* findTargetForComponent (Component*);


private:

    OwnedArray<ApplicationCommandInfo> commands;
    ListenerList<ApplicationCommandManagerListener> listeners;
    ScopedPointer<KeyPressMappingSet> keyMappings;
    ApplicationCommandTarget* firstTarget;

    void sendListenerInvokeCallback (const ApplicationCommandTarget::InvocationInfo&);
    void handleAsyncUpdate() override;
    void globalFocusChanged (Component*) override;
    ApplicationCommandInfo* getMutableCommandForID (CommandID) const noexcept;







    ApplicationCommandManager (const ApplicationCommandManager&) = delete; ApplicationCommandManager& operator= (const ApplicationCommandManager&) = delete;
};
# 331 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/commands/juce_ApplicationCommandManager.h"
class ApplicationCommandManagerListener
{
public:


    virtual ~ApplicationCommandManagerListener() {}


    virtual void applicationCommandInvoked (const ApplicationCommandTarget::InvocationInfo&) = 0;
# 348 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/commands/juce_ApplicationCommandManager.h"
    virtual void applicationCommandListChanged() = 0;
};
# 189 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/commands/juce_KeyPressMappingSet.h" 1
# 84 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/commands/juce_KeyPressMappingSet.h"
class KeyPressMappingSet : public KeyListener,
                                      public ChangeBroadcaster,
                                      private FocusChangeListener
{
public:
# 102 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/commands/juce_KeyPressMappingSet.h"
    explicit KeyPressMappingSet (ApplicationCommandManager&);


    KeyPressMappingSet (const KeyPressMappingSet&);


    ~KeyPressMappingSet();


    ApplicationCommandManager& getCommandManager() const noexcept { return commandManager; }






    Array<KeyPress> getKeyPressesAssignedToCommand (CommandID commandID) const;
# 133 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/commands/juce_KeyPressMappingSet.h"
    void addKeyPress (CommandID commandID,
                      const KeyPress& newKeyPress,
                      int insertIndex = -1);




    void resetToDefaultMappings();




    void resetToDefaultMapping (CommandID commandID);


    void clearAllKeyPresses();


    void clearAllKeyPresses (CommandID commandID);





    void removeKeyPress (CommandID commandID, int keyPressIndex);


    void removeKeyPress (const KeyPress& keypress);


    bool containsMapping (CommandID commandID, const KeyPress& keyPress) const noexcept;





    CommandID findCommandForKeyPress (const KeyPress& keyPress) const noexcept;
# 187 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/commands/juce_KeyPressMappingSet.h"
    bool restoreFromXml (const XmlElement& xmlVersion);
# 206 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/commands/juce_KeyPressMappingSet.h"
    XmlElement* createXml (bool saveDifferencesFromDefaultSet) const;



    bool keyPressed (const KeyPress&, Component*) override;

    bool keyStateChanged (bool isKeyDown, Component*) override;

    void globalFocusChanged (Component*) override;

private:

    ApplicationCommandManager& commandManager;

    struct CommandMapping
    {
        CommandID commandID;
        Array<KeyPress> keypresses;
        bool wantsKeyUpDownCallbacks;
    };

    OwnedArray<CommandMapping> mappings;

    struct KeyPressTime
    {
        KeyPress key;
        uint32 timeWhenPressed;
    };

    OwnedArray<KeyPressTime> keysDown;

    void invokeCommand (const CommandID, const KeyPress&, const bool isKeyDown,
                        const int millisecsSinceKeyPressed, Component* originator) const;

    KeyPressMappingSet& operator= (const KeyPressMappingSet&);

};
# 190 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/buttons/juce_Button.h" 1
# 39 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/buttons/juce_Button.h"
class Button : public Component,
                          public SettableTooltipClient
{
protected:







    explicit Button (const String& buttonName);

public:

    virtual ~Button();





    void setButtonText (const String& newText);




    const String& getButtonText() const { return text; }





    bool isDown() const noexcept;





    bool isOver() const noexcept;
# 95 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/buttons/juce_Button.h"
    void setToggleState (bool shouldBeOn, NotificationType notification);
# 105 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/buttons/juce_Button.h"
    bool getToggleState() const noexcept { return isOn.getValue(); }







    Value& getToggleStateValue() noexcept { return isOn; }







    void setClickingTogglesState (bool shouldAutoToggleOnClick) noexcept;




    bool getClickingTogglesState() const noexcept;
# 149 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/buttons/juce_Button.h"
    void setRadioGroupId (int newGroupId, NotificationType notification = sendNotification);




    int getRadioGroupId() const noexcept { return radioGroupId; }







    class Listener
    {
    public:

        virtual ~Listener() {}


        virtual void buttonClicked (Button*) = 0;


        virtual void buttonStateChanged (Button*) {}
    };





    void addListener (Listener* newListener);




    void removeListener (Listener* listener);
# 194 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/buttons/juce_Button.h"
    virtual void triggerClick();
# 211 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/buttons/juce_Button.h"
    void setCommandToTrigger (ApplicationCommandManager* commandManagerToUse,
                              CommandID commandID,
                              bool generateTooltip);


    CommandID getCommandID() const noexcept { return commandID; }
# 228 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/buttons/juce_Button.h"
    void addShortcut (const KeyPress&);




    void clearShortcuts();




    bool isRegisteredForShortcut (const KeyPress&) const;
# 254 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/buttons/juce_Button.h"
    void setRepeatSpeed (int initialDelayInMillisecs,
                         int repeatDelayInMillisecs,
                         int minimumDelayInMillisecs = -1) noexcept;
# 267 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/buttons/juce_Button.h"
    void setTriggeredOnMouseDown (bool isTriggeredOnMouseDown) noexcept;




    uint32 getMillisecondsSinceButtonDown() const noexcept;





    void setTooltip (const String& newTooltip) override;



    enum ConnectedEdgeFlags
    {
        ConnectedOnLeft = 1,
        ConnectedOnRight = 2,
        ConnectedOnTop = 4,
        ConnectedOnBottom = 8
    };
# 301 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/buttons/juce_Button.h"
    void setConnectedEdges (int connectedEdgeFlags);


    int getConnectedEdgeFlags() const noexcept { return connectedEdgeFlags; }




    bool isConnectedOnLeft() const noexcept { return (connectedEdgeFlags & ConnectedOnLeft) != 0; }




    bool isConnectedOnRight() const noexcept { return (connectedEdgeFlags & ConnectedOnRight) != 0; }




    bool isConnectedOnTop() const noexcept { return (connectedEdgeFlags & ConnectedOnTop) != 0; }




    bool isConnectedOnBottom() const noexcept { return (connectedEdgeFlags & ConnectedOnBottom) != 0; }




    enum ButtonState
    {
        buttonNormal,
        buttonOver,
        buttonDown
    };
# 344 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/buttons/juce_Button.h"
    void setState (ButtonState newState);


    ButtonState getState() const noexcept { return buttonState; }


    __declspec(deprecated) void setToggleState (bool, bool);





    struct LookAndFeelMethods
    {
        virtual ~LookAndFeelMethods() {}

        virtual void drawButtonBackground (Graphics&, Button&, const Colour& backgroundColour,
                                           bool isMouseOverButton, bool isButtonDown) = 0;

        virtual Font getTextButtonFont (TextButton&, int buttonHeight) = 0;
        virtual int getTextButtonWidthToFitText (TextButton&, int buttonHeight) = 0;


        virtual void drawButtonText (Graphics&, TextButton&, bool isMouseOverButton, bool isButtonDown) = 0;


        virtual void drawToggleButton (Graphics&, ToggleButton&, bool isMouseOverButton, bool isButtonDown) = 0;

        virtual void changeToggleButtonWidthToFitText (ToggleButton&) = 0;

        virtual void drawTickBox (Graphics&, Component&, float x, float y, float w, float h,
                                  bool ticked, bool isEnabled, bool isMouseOverButton, bool isButtonDown) = 0;

        virtual void drawDrawableButton (Graphics&, DrawableButton&, bool isMouseOverButton, bool isButtonDown) = 0;

    private:





    };

protected:
# 399 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/buttons/juce_Button.h"
    virtual void clicked();
# 408 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/buttons/juce_Button.h"
    virtual void clicked (const ModifierKeys& modifiers);
# 420 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/buttons/juce_Button.h"
    virtual void paintButton (Graphics& g,
                              bool isMouseOverButton,
                              bool isButtonDown) = 0;
# 431 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/buttons/juce_Button.h"
    virtual void buttonStateChanged();



    virtual void internalClickCallback (const ModifierKeys&);

    void handleCommandMessage (int commandId) override;

    void mouseEnter (const MouseEvent&) override;

    void mouseExit (const MouseEvent&) override;

    void mouseDown (const MouseEvent&) override;

    void mouseDrag (const MouseEvent&) override;

    void mouseUp (const MouseEvent&) override;

    bool keyPressed (const KeyPress&) override;

    using Component::keyStateChanged;

    void paint (Graphics&) override;

    void parentHierarchyChanged() override;

    void visibilityChanged() override;

    void focusGained (FocusChangeType) override;

    void focusLost (FocusChangeType) override;

    void enablementChanged() override;

private:

    Array<KeyPress> shortcuts;
    WeakReference<Component> keySource;
    String text;
    ListenerList<Listener> buttonListeners;

    class CallbackHelper;
    friend class CallbackHelper;
    friend struct ContainerDeletePolicy<CallbackHelper>;
    ScopedPointer<CallbackHelper> callbackHelper;
    uint32 buttonPressTime, lastRepeatTime;
    ApplicationCommandManager* commandManagerToUse;
    int autoRepeatDelay, autoRepeatSpeed, autoRepeatMinimumDelay;
    int radioGroupId, connectedEdgeFlags;
    CommandID commandID;
    ButtonState buttonState, lastStatePainted;

    Value isOn;
    bool lastToggleState;
    bool clickTogglesState;
    bool needsToRelease;
    bool needsRepainting;
    bool isKeyDown;
    bool triggerOnMouseDown;
    bool generateTooltip;

    void repeatTimerCallback();
    bool keyStateChangedCallback();
    void applicationCommandListChangeCallback();
    void updateAutomaticTooltip (const ApplicationCommandInfo&);

    ButtonState updateState();
    ButtonState updateState (bool isOver, bool isDown);
    bool isShortcutPressed() const;
    void turnOffOtherButtonsInGroup (NotificationType);

    void flashButtonState();
    void sendClickMessage (const ModifierKeys&);
    void sendStateMessage();

    bool isMouseOrTouchOver (const MouseEvent& e);

    Button (const Button&) = delete; Button& operator= (const Button&) = delete;
};



 typedef Button::Listener ButtonListener;
# 191 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/buttons/juce_ArrowButton.h" 1
# 35 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/buttons/juce_ArrowButton.h"
class ArrowButton : public Button
{
public:
# 46 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/buttons/juce_ArrowButton.h"
    ArrowButton (const String& buttonName,
                 float arrowDirection,
                 Colour arrowColour);


    ~ArrowButton();


    void paintButton (Graphics&, bool isMouseOverButton, bool isButtonDown) override;

private:
    Colour colour;
    Path path;

    ArrowButton (const ArrowButton&) = delete; ArrowButton& operator= (const ArrowButton&) = delete;
};
# 192 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/buttons/juce_DrawableButton.h" 1
# 38 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/buttons/juce_DrawableButton.h"
class DrawableButton : public Button
{
public:

    enum ButtonStyle
    {
        ImageFitted,
        ImageRaw,

        ImageAboveTextLabel,
        ImageOnButtonBackground,


        ImageStretched
    };
# 64 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/buttons/juce_DrawableButton.h"
    DrawableButton (const String& buttonName,
                    ButtonStyle buttonStyle);


    ~DrawableButton();
# 99 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/buttons/juce_DrawableButton.h"
    void setImages (const Drawable* normalImage,
                    const Drawable* overImage = nullptr,
                    const Drawable* downImage = nullptr,
                    const Drawable* disabledImage = nullptr,
                    const Drawable* normalImageOn = nullptr,
                    const Drawable* overImageOn = nullptr,
                    const Drawable* downImageOn = nullptr,
                    const Drawable* disabledImageOn = nullptr);






    void setButtonStyle (ButtonStyle newStyle);


    ButtonStyle getStyle() const noexcept { return style; }





    void setEdgeIndent (int numPixelsIndent);



    Drawable* getCurrentImage() const noexcept;


    Drawable* getNormalImage() const noexcept;

    Drawable* getOverImage() const noexcept;

    Drawable* getDownImage() const noexcept;


    virtual Rectangle<float> getImageBounds() const;
# 149 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/buttons/juce_DrawableButton.h"
    enum ColourIds
    {
        textColourId = 0x1004010,
        textColourOnId = 0x1004013,

        backgroundColourId = 0x1004011,



        backgroundOnColourId = 0x1004012,



    };



    void paintButton (Graphics&, bool isMouseOverButton, bool isButtonDown) override;

    void buttonStateChanged() override;

    void resized() override;

    void enablementChanged() override;

    void colourChanged() override;

private:

    ButtonStyle style;
    ScopedPointer<Drawable> normalImage, overImage, downImage, disabledImage,
                            normalImageOn, overImageOn, downImageOn, disabledImageOn;
    Drawable* currentImage;
    int edgeIndent;

    DrawableButton (const DrawableButton&) = delete; DrawableButton& operator= (const DrawableButton&) = delete;
};
# 193 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/buttons/juce_HyperlinkButton.h" 1
# 36 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/buttons/juce_HyperlinkButton.h"
class HyperlinkButton : public Button
{
public:
# 47 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/buttons/juce_HyperlinkButton.h"
    HyperlinkButton (const String& linkText,
                     const URL& linkURL);


    HyperlinkButton();


    ~HyperlinkButton();







    void setFont (const Font& newFont,
                  bool resizeToMatchComponentHeight,
                  Justification justificationType = Justification::horizontallyCentred);
# 74 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/buttons/juce_HyperlinkButton.h"
    enum ColourIds
    {
        textColourId = 0x1001f00,
    };



    void setURL (const URL& newURL) noexcept;


    const URL& getURL() const noexcept { return url; }






    void changeWidthToFitText();

protected:


    void clicked() override;

    void colourChanged() override;

    void paintButton (Graphics&, bool isMouseOver, bool isButtonDown) override;

private:

    URL url;
    Font font;
    bool resizeFont;
    Justification justification;

    Font getFontToUse() const;

    HyperlinkButton (const HyperlinkButton&) = delete; HyperlinkButton& operator= (const HyperlinkButton&) = delete;
};
# 194 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/buttons/juce_ImageButton.h" 1
# 38 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/buttons/juce_ImageButton.h"
class ImageButton : public Button
{
public:
# 49 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/buttons/juce_ImageButton.h"
    explicit ImageButton (const String& name = String());


    ~ImageButton();
# 96 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/buttons/juce_ImageButton.h"
    void setImages (bool resizeButtonNowToFitThisImage,
                    bool rescaleImagesWhenButtonSizeChanges,
                    bool preserveImageProportions,
                    const Image& normalImage,
                    float imageOpacityWhenNormal,
                    Colour overlayColourWhenNormal,
                    const Image& overImage,
                    float imageOpacityWhenOver,
                    Colour overlayColourWhenOver,
                    const Image& downImage,
                    float imageOpacityWhenDown,
                    Colour overlayColourWhenDown,
                    float hitTestAlphaThreshold = 0.0f);


    Image getNormalImage() const;






    Image getOverImage() const;






    Image getDownImage() const;



    struct LookAndFeelMethods
    {
        virtual ~LookAndFeelMethods() {}

        virtual void drawImageButton (Graphics&, Image*,
                                      int imageX, int imageY, int imageW, int imageH,
                                      const Colour& overlayColour, float imageOpacity, ImageButton&) = 0;
    };

protected:


    bool hitTest (int x, int y) override;

    void paintButton (Graphics&, bool isMouseOver, bool isButtonDown) override;

private:

    bool scaleImageToFit, preserveProportions;
    uint8 alphaThreshold;
    Rectangle<int> imageBounds;
    Image normalImage, overImage, downImage;
    float normalOpacity, overOpacity, downOpacity;
    Colour normalOverlay, overOverlay, downOverlay;

    Image getCurrentImage() const;

    ImageButton (const ImageButton&) = delete; ImageButton& operator= (const ImageButton&) = delete;
};
# 195 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/buttons/juce_ShapeButton.h" 1
# 35 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/buttons/juce_ShapeButton.h"
class ShapeButton : public Button
{
public:
# 46 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/buttons/juce_ShapeButton.h"
    ShapeButton (const String& name,
                 Colour normalColour,
                 Colour overColour,
                 Colour downColour);


    ~ShapeButton();
# 63 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/buttons/juce_ShapeButton.h"
    void setShape (const Path& newShape,
                   bool resizeNowToFitThisShape,
                   bool maintainShapeProportions,
                   bool hasDropShadow);







    void setColours (Colour normalColour,
                     Colour overColour,
                     Colour downColour);






    void setOutline (Colour outlineColour, float outlineStrokeWidth);




    void setBorderSize (BorderSize<int> border);


    void paintButton (Graphics&, bool isMouseOverButton, bool isButtonDown) override;

private:

    Colour normalColour, overColour, downColour, outlineColour;
    DropShadowEffect shadow;
    Path shape;
    BorderSize<int> border;
    bool maintainShapeProportions;
    float outlineWidth;

    ShapeButton (const ShapeButton&) = delete; ShapeButton& operator= (const ShapeButton&) = delete;
};
# 196 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/buttons/juce_TextButton.h" 1
# 36 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/buttons/juce_TextButton.h"
class TextButton : public Button
{
public:


    TextButton();






    explicit TextButton (const String& buttonName);







    TextButton (const String& buttonName, const String& toolTip);


    ~TextButton();
# 69 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/buttons/juce_TextButton.h"
    enum ColourIds
    {
        buttonColourId = 0x1000100,


        buttonOnColourId = 0x1000101,


        textColourOffId = 0x1000102,
        textColourOnId = 0x1000103
    };





    void changeWidthToFitText();




    void changeWidthToFitText (int newHeight);




    int getBestWidthForHeight (int buttonHeight);



    void paintButton (Graphics&, bool isMouseOverButton, bool isButtonDown) override;

    void colourChanged() override;

private:





    TextButton (const TextButton&) = delete; TextButton& operator= (const TextButton&) = delete;
};
# 197 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/buttons/juce_ToggleButton.h" 1
# 38 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/buttons/juce_ToggleButton.h"
class ToggleButton : public Button
{
public:


    ToggleButton();







    explicit ToggleButton (const String& buttonText);


    ~ToggleButton();





    void changeWidthToFitText();
# 70 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/buttons/juce_ToggleButton.h"
    enum ColourIds
    {
        textColourId = 0x1006501,
        tickColourId = 0x1006502,
        tickDisabledColourId = 0x1006503
    };

protected:


    void paintButton (Graphics&, bool isMouseOverButton, bool isButtonDown) override;

    void colourChanged() override;

private:
    ToggleButton (const ToggleButton&) = delete; ToggleButton& operator= (const ToggleButton&) = delete;
};
# 198 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_AnimatedPosition.h" 1
# 50 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_AnimatedPosition.h"
template <typename Behaviour>
class AnimatedPosition : private Timer
{
public:
    AnimatedPosition()
        : position(), grabbedPos(), releaseVelocity(),
          range (-std::numeric_limits<double>::max(),
                  std::numeric_limits<double>::max())
    {
    }


    void setLimits (Range<double> newRange)
    {
        range = newRange;
    }
# 76 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_AnimatedPosition.h"
    void beginDrag()
    {
        grabbedPos = position;
        releaseVelocity = 0;
        stopTimer();
    }





    void drag (double deltaFromStartOfDrag)
    {
        moveTo (grabbedPos + deltaFromStartOfDrag);
    }




    void endDrag()
    {
        startTimerHz (60);
    }




    void nudge (double deltaFromCurrentPosition)
    {
        startTimerHz (10);
        moveTo (position + deltaFromCurrentPosition);
    }



    double getPosition() const noexcept
    {
        return position;
    }





    void setPosition (double newPosition)
    {
        stopTimer();
        setPositionAndSendChange (newPosition);
    }






    class Listener
    {
    public:
        virtual ~Listener() {}


        virtual void positionChanged (AnimatedPosition&, double newPosition) = 0;
    };


    void addListener (Listener* listener) { listeners.add (listener); }


    void removeListener (Listener* listener) { listeners.remove (listener); }





    Behaviour behaviour;

private:

    double position, grabbedPos, releaseVelocity;
    Range<double> range;
    Time lastUpdate, lastDrag;
    ListenerList<Listener> listeners;

    static double getSpeed (const Time last, double lastPos,
                            const Time now, double newPos)
    {
        const double elapsedSecs = jmax (0.005, (now - last).inSeconds());
        const double v = (newPos - lastPos) / elapsedSecs;
        return std::abs (v) > 0.2 ? v : 0.0;
    }

    void moveTo (double newPos)
    {
        const Time now (Time::getCurrentTime());
        releaseVelocity = getSpeed (lastDrag, position, now, newPos);
        behaviour.releasedWithVelocity (newPos, releaseVelocity);
        lastDrag = now;

        setPositionAndSendChange (newPos);
    }

    void setPositionAndSendChange (double newPosition)
    {
        newPosition = range.clipValue (newPosition);

        if (position != newPosition)
        {
            position = newPosition;
            listeners.call (&Listener::positionChanged, *this, newPosition);
        }
    }

    void timerCallback() override
    {
        const Time now = Time::getCurrentTime();

        const double elapsed = jlimit (0.001, 0.020, (now - lastUpdate).inSeconds());
        lastUpdate = now;

        const double newPos = behaviour.getNextPosition (position, elapsed);

        if (behaviour.isStopped (newPos))
            stopTimer();
        else
            startTimerHz (60);

        setPositionAndSendChange (newPos);
    }

    AnimatedPosition (const AnimatedPosition&) = delete; AnimatedPosition& operator= (const AnimatedPosition&) = delete;
};
# 199 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_AnimatedPositionBehaviours.h" 1
# 33 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_AnimatedPositionBehaviours.h"
namespace AnimatedPositionBehaviours
{
# 44 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_AnimatedPositionBehaviours.h"
    struct ContinuousWithMomentum
    {
        ContinuousWithMomentum() noexcept
            : velocity (0), damping (0.92)
        {
        }




        void setFriction (double newFriction) noexcept
        {
            damping = 1.0 - newFriction;
        }





        void releasedWithVelocity (double , double releaseVelocity) noexcept
        {
            velocity = releaseVelocity;
        }




        double getNextPosition (double oldPos, double elapsedSeconds) noexcept
        {
            velocity *= damping;

            if (std::abs (velocity) < 0.05)
                velocity = 0;

            return oldPos + velocity * elapsedSeconds;
        }




        bool isStopped (double ) const noexcept
        {
            return velocity == 0;
        }

    private:
        double velocity, damping;
    };
# 104 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_AnimatedPositionBehaviours.h"
    struct SnapToPageBoundaries
    {
        SnapToPageBoundaries() noexcept : targetSnapPosition()
        {
        }





        void releasedWithVelocity (double position, double releaseVelocity) noexcept
        {
            targetSnapPosition = std::floor (position + 0.5);

            if (releaseVelocity > 1.0 && targetSnapPosition < position) ++targetSnapPosition;
            if (releaseVelocity < -1.0 && targetSnapPosition > position) --targetSnapPosition;
        }




        double getNextPosition (double oldPos, double elapsedSeconds) const noexcept
        {
            if (isStopped (oldPos))
                return targetSnapPosition;

            const double snapSpeed = 10.0;
            const double velocity = (targetSnapPosition - oldPos) * snapSpeed;
            const double newPos = oldPos + velocity * elapsedSeconds;

            return isStopped (newPos) ? targetSnapPosition : newPos;
        }




        bool isStopped (double position) const noexcept
        {
            return std::abs (targetSnapPosition - position) < 0.001;
        }

    private:
        double targetSnapPosition;
    };
}
# 200 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ComponentBuilder.h" 1
# 45 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ComponentBuilder.h"
class ComponentBuilder : private ValueTree::Listener
{
public:





    explicit ComponentBuilder (const ValueTree& state);


    ComponentBuilder();


    ~ComponentBuilder();


    ValueTree state;
# 80 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ComponentBuilder.h"
    Component* getManagedComponent();





    Component* createComponent();
# 98 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ComponentBuilder.h"
    class TypeHandler
    {
    public:




        explicit TypeHandler (const Identifier& valueTreeType);


        virtual ~TypeHandler();


        const Identifier type;


        ComponentBuilder* getBuilder() const noexcept;
# 126 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ComponentBuilder.h"
        virtual Component* addNewComponentFromState (const ValueTree& state, Component* parent) = 0;
# 138 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ComponentBuilder.h"
        virtual void updateComponentFromState (Component* component, const ValueTree& state) = 0;

    private:

        friend class ComponentBuilder;
        ComponentBuilder* builder;

        TypeHandler (const TypeHandler&) = delete; TypeHandler& operator= (const TypeHandler&) = delete;
    };





    void registerTypeHandler (TypeHandler* type);


    TypeHandler* getHandlerForState (const ValueTree& state) const;




    int getNumHandlers() const noexcept;




    TypeHandler* getHandler (int index) const noexcept;


    void registerStandardComponentTypes();
# 183 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ComponentBuilder.h"
    class ImageProvider
    {
    public:
        ImageProvider() {}
        virtual ~ImageProvider() {}







        virtual Image getImageForIdentifier (const var& imageIdentifier) = 0;




        virtual var getIdentifierForImage (const Image& image) = 0;
    };
# 211 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ComponentBuilder.h"
    void setImageProvider (ImageProvider* newImageProvider) noexcept;


    ImageProvider* getImageProvider() const noexcept;





    void updateChildComponents (Component& parent, const ValueTree& children);




    static const Identifier idProperty;

private:

    OwnedArray<TypeHandler> types;
    ScopedPointer<Component> component;
    ImageProvider* imageProvider;




    void valueTreePropertyChanged (ValueTree&, const Identifier&) override;
    void valueTreeChildAdded (ValueTree&, ValueTree&) override;
    void valueTreeChildRemoved (ValueTree&, ValueTree&, int) override;
    void valueTreeChildOrderChanged (ValueTree&, int, int) override;
    void valueTreeParentChanged (ValueTree&) override;

    ComponentBuilder (const ComponentBuilder&) = delete; ComponentBuilder& operator= (const ComponentBuilder&) = delete;
};
# 201 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ComponentMovementWatcher.h" 1
# 44 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ComponentMovementWatcher.h"
class ComponentMovementWatcher : public ComponentListener
{
public:


    ComponentMovementWatcher (Component* component);


    ~ComponentMovementWatcher();




    virtual void componentMovedOrResized (bool wasMoved, bool wasResized) = 0;


    virtual void componentPeerChanged() = 0;




    virtual void componentVisibilityChanged() = 0;


    Component* getComponent() const noexcept { return component; }



    void componentParentHierarchyChanged (Component&) override;

    void componentMovedOrResized (Component&, bool wasMoved, bool wasResized) override;

    void componentBeingDeleted (Component&) override;

    void componentVisibilityChanged (Component&) override;

private:

    WeakReference<Component> component;
    uint32 lastPeerID;
    Array <Component*> registeredParentComps;
    bool reentrant, wasShowing;
    Rectangle<int> lastBounds;

    void unregister();
    void registerWithParentComps();

    ComponentMovementWatcher (const ComponentMovementWatcher&) = delete; ComponentMovementWatcher& operator= (const ComponentMovementWatcher&) = delete;
};
# 202 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ConcertinaPanel.h" 1
# 37 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ConcertinaPanel.h"
class ConcertinaPanel : public Component
{
public:



    ConcertinaPanel();


    ~ConcertinaPanel();
# 57 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ConcertinaPanel.h"
    void addPanel (int insertIndex, Component* component, bool takeOwnership);





    void removePanel (Component* panelComponent);




    int getNumPanels() const noexcept;




    Component* getPanel (int index) const noexcept;






    bool setPanelSize (Component* panelComponent, int newHeight, bool animate);







    bool expandPanelFully (Component* panelComponent, bool animate);


    void setMaximumPanelSize (Component* panelComponent, int maximumSize);


    void setPanelHeaderSize (Component* panelComponent, int headerSize);



    struct LookAndFeelMethods
    {
        virtual ~LookAndFeelMethods() {}

        virtual void drawConcertinaPanelHeader (Graphics&, const Rectangle<int>& area,
                                                bool isMouseOver, bool isMouseDown,
                                                ConcertinaPanel&, Component&) = 0;
    };

private:
    void resized() override;

    class PanelHolder;
    struct PanelSizes;
    friend class PanelHolder;
    friend struct PanelSizes;
    friend struct ContainerDeletePolicy<PanelSizes>;
    friend struct ContainerDeletePolicy<PanelHolder>;

    ScopedPointer<PanelSizes> currentSizes;
    OwnedArray<PanelHolder> holders;
    ComponentAnimator animator;
    int headerHeight;

    int indexOfComp (Component*) const noexcept;
    PanelSizes getFittedSizes() const;
    void applyLayout (const PanelSizes&, bool animate);
    void setLayout (const PanelSizes&, bool animate);
    void panelHeaderDoubleClicked (Component*);

    ConcertinaPanel (const ConcertinaPanel&) = delete; ConcertinaPanel& operator= (const ConcertinaPanel&) = delete;
};
# 203 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_GroupComponent.h" 1
# 35 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_GroupComponent.h"
class GroupComponent : public Component
{
public:






    GroupComponent (const String& componentName = String(),
                    const String& labelText = String());


    ~GroupComponent();



    void setText (const String& newText);


    String getText() const;







    void setTextLabelPosition (Justification justification);





    Justification getTextLabelPosition() const noexcept { return justification; }
# 79 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_GroupComponent.h"
    enum ColourIds
    {
        outlineColourId = 0x1005400,
        textColourId = 0x1005410
    };



    struct LookAndFeelMethods
    {
        virtual ~LookAndFeelMethods() {}

        virtual void drawGroupComponentOutline (Graphics&, int w, int h, const String& text,
                                                const Justification&, GroupComponent&) = 0;
    };



    void paint (Graphics&) override;

    void enablementChanged() override;

    void colourChanged() override;

private:
    String text;
    Justification justification;

    GroupComponent (const GroupComponent&) = delete; GroupComponent& operator= (const GroupComponent&) = delete;
};
# 204 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ResizableBorderComponent.h" 1
# 45 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ResizableBorderComponent.h"
class ResizableBorderComponent : public Component
{
public:
# 66 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ResizableBorderComponent.h"
    ResizableBorderComponent (Component* componentToResize,
                              ComponentBoundsConstrainer* constrainer);


    ~ResizableBorderComponent();







    void setBorderThickness (const BorderSize<int>& newBorderSize);





    BorderSize<int> getBorderThickness() const;






    class Zone
    {
    public:

        enum Zones
        {
            centre = 0,
            left = 1,
            top = 2,
            right = 4,
            bottom = 8
        };



        explicit Zone (int zoneFlags) noexcept;

        Zone() noexcept;
        Zone (const Zone&) noexcept;
        Zone& operator= (const Zone&) noexcept;

        bool operator== (const Zone&) const noexcept;
        bool operator!= (const Zone&) const noexcept;





        static Zone fromPositionOnBorder (const Rectangle<int>& totalSize,
                                          const BorderSize<int>& border,
                                          Point<int> position);


        MouseCursor getMouseCursor() const noexcept;


        bool isDraggingWholeObject() const noexcept { return zone == centre; }

        bool isDraggingLeftEdge() const noexcept { return (zone & left) != 0; }

        bool isDraggingRightEdge() const noexcept { return (zone & right) != 0; }

        bool isDraggingTopEdge() const noexcept { return (zone & top) != 0; }

        bool isDraggingBottomEdge() const noexcept { return (zone & bottom) != 0; }




        template <typename ValueType>
        Rectangle<ValueType> resizeRectangleBy (Rectangle<ValueType> original,
                                                const Point<ValueType>& distance) const noexcept
        {
            if (isDraggingWholeObject())
                return original + distance;

            if (isDraggingLeftEdge()) original.setLeft (jmin (original.getRight(), original.getX() + distance.x));
            if (isDraggingRightEdge()) original.setWidth (jmax (ValueType(), original.getWidth() + distance.x));
            if (isDraggingTopEdge()) original.setTop (jmin (original.getBottom(), original.getY() + distance.y));
            if (isDraggingBottomEdge()) original.setHeight (jmax (ValueType(), original.getHeight() + distance.y));

            return original;
        }


        int getZoneFlags() const noexcept { return zone; }

    private:

        int zone;
    };


    Zone getCurrentZone() const noexcept { return mouseZone; }

protected:

    void paint (Graphics&) override;

    void mouseEnter (const MouseEvent&) override;

    void mouseMove (const MouseEvent&) override;

    void mouseDown (const MouseEvent&) override;

    void mouseDrag (const MouseEvent&) override;

    void mouseUp (const MouseEvent&) override;

    bool hitTest (int x, int y) override;

private:
    WeakReference<Component> component;
    ComponentBoundsConstrainer* constrainer;
    BorderSize<int> borderSize;
    Rectangle<int> originalBounds;
    Zone mouseZone;

    void updateMouseZone (const MouseEvent&);

    ResizableBorderComponent (const ResizableBorderComponent&) = delete; ResizableBorderComponent& operator= (const ResizableBorderComponent&) = delete;
};
# 205 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ResizableCornerComponent.h" 1
# 39 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ResizableCornerComponent.h"
class ResizableCornerComponent : public Component
{
public:
# 61 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ResizableCornerComponent.h"
    ResizableCornerComponent (Component* componentToResize,
                              ComponentBoundsConstrainer* constrainer);


    ~ResizableCornerComponent();


protected:


    void paint (Graphics&) override;

    void mouseDown (const MouseEvent&) override;

    void mouseDrag (const MouseEvent&) override;

    void mouseUp (const MouseEvent&) override;

    bool hitTest (int x, int y) override;

private:

    WeakReference<Component> component;
    ComponentBoundsConstrainer* constrainer;
    Rectangle<int> originalBounds;

    ResizableCornerComponent (const ResizableCornerComponent&) = delete; ResizableCornerComponent& operator= (const ResizableCornerComponent&) = delete;
};
# 206 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ResizableEdgeComponent.h" 1
# 42 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ResizableEdgeComponent.h"
class ResizableEdgeComponent : public Component
{
public:

    enum Edge
    {
        leftEdge,
        rightEdge,
        topEdge,
        bottomEdge
    };
# 69 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ResizableEdgeComponent.h"
    ResizableEdgeComponent (Component* componentToResize,
                            ComponentBoundsConstrainer* constrainer,
                            Edge edgeToResize);


    ~ResizableEdgeComponent();

    bool isVertical() const noexcept;

protected:


    void paint (Graphics&) override;

    void mouseDown (const MouseEvent&) override;

    void mouseDrag (const MouseEvent&) override;

    void mouseUp (const MouseEvent&) override;

private:
    WeakReference<Component> component;
    ComponentBoundsConstrainer* constrainer;
    Rectangle<int> originalBounds;
    const Edge edge;

    ResizableEdgeComponent (const ResizableEdgeComponent&) = delete; ResizableEdgeComponent& operator= (const ResizableEdgeComponent&) = delete;
};
# 207 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ScrollBar.h" 1
# 49 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ScrollBar.h"
class ScrollBar : public Component,
                             public AsyncUpdater,
                             private Timer
{
public:




    ScrollBar (bool isVertical);


    ~ScrollBar();



    bool isVertical() const noexcept { return vertical; }
# 74 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ScrollBar.h"
    void setOrientation (bool shouldBeVertical);
# 83 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ScrollBar.h"
    void setAutoHide (bool shouldHideWhenFullRange);





    bool autoHides() const noexcept;
# 99 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ScrollBar.h"
    void setRangeLimits (Range<double> newRangeLimit,
                         NotificationType notification = sendNotificationAsync);
# 109 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ScrollBar.h"
    void setRangeLimits (double minimum, double maximum,
                         NotificationType notification = sendNotificationAsync);




    Range<double> getRangeLimit() const noexcept { return totalRange; }





    double getMinimumRangeLimit() const noexcept { return totalRange.getStart(); }





    double getMaximumRangeLimit() const noexcept { return totalRange.getEnd(); }
# 145 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ScrollBar.h"
    bool setCurrentRange (Range<double> newRange,
                          NotificationType notification = sendNotificationAsync);
# 163 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ScrollBar.h"
    void setCurrentRange (double newStart, double newSize,
                          NotificationType notification = sendNotificationAsync);
# 177 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ScrollBar.h"
    void setCurrentRangeStart (double newStart,
                               NotificationType notification = sendNotificationAsync);




    Range<double> getCurrentRange() const noexcept { return visibleRange; }




    double getCurrentRangeStart() const noexcept { return visibleRange.getStart(); }




    double getCurrentRangeSize() const noexcept { return visibleRange.getLength(); }







    void setSingleStepSize (double newSingleStepSize) noexcept;
# 212 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ScrollBar.h"
    bool moveScrollbarInSteps (int howManySteps,
                               NotificationType notification = sendNotificationAsync);
# 224 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ScrollBar.h"
    bool moveScrollbarInPages (int howManyPages,
                               NotificationType notification = sendNotificationAsync);





    bool scrollToTop (NotificationType notification = sendNotificationAsync);





    bool scrollToBottom (NotificationType notification = sendNotificationAsync);
# 246 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ScrollBar.h"
    void setButtonRepeatSpeed (int initialDelayInMillisecs,
                               int repeatDelayInMillisecs,
                               int minimumDelayInMillisecs = -1);
# 258 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ScrollBar.h"
    enum ColourIds
    {
        backgroundColourId = 0x1000300,
        thumbColourId = 0x1000400,
        trackColourId = 0x1000401
    };
# 274 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ScrollBar.h"
    class Listener
    {
    public:

        virtual ~Listener() {}






        virtual void scrollBarMoved (ScrollBar* scrollBarThatHasMoved,
                                     double newRangeStart) = 0;
    };


    void addListener (Listener* listener);


    void removeListener (Listener* listener);





    struct LookAndFeelMethods
    {
        virtual ~LookAndFeelMethods() {}

        virtual bool areScrollbarButtonsVisible() = 0;
# 316 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ScrollBar.h"
        virtual void drawScrollbarButton (Graphics& g,
                                          ScrollBar& scrollbar,
                                          int width, int height,
                                          int buttonDirection,
                                          bool isScrollbarVertical,
                                          bool isMouseOverButton,
                                          bool isButtonDown) = 0;
# 341 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_ScrollBar.h"
        virtual void drawScrollbar (Graphics& g, ScrollBar& scrollbar,
                                    int x, int y, int width, int height,
                                    bool isScrollbarVertical,
                                    int thumbStartPosition,
                                    int thumbSize,
                                    bool isMouseOver,
                                    bool isMouseDown) = 0;


        virtual ImageEffectFilter* getScrollbarEffect() = 0;


        virtual int getMinimumScrollbarThumbSize (ScrollBar&) = 0;


        virtual int getDefaultScrollbarWidth() = 0;


        virtual int getScrollbarButtonSize (ScrollBar&) = 0;
    };



    bool keyPressed (const KeyPress&) override;

    void mouseWheelMove (const MouseEvent&, const MouseWheelDetails&) override;

    void lookAndFeelChanged() override;

    void mouseDown (const MouseEvent&) override;

    void mouseDrag (const MouseEvent&) override;

    void mouseUp (const MouseEvent&) override;

    void paint (Graphics&) override;

    void resized() override;

    void parentHierarchyChanged() override;

private:

    Range<double> totalRange, visibleRange;
    double singleStepSize, dragStartRange;
    int thumbAreaStart, thumbAreaSize, thumbStart, thumbSize;
    int dragStartMousePos, lastMousePos;
    int initialDelayInMillisecs, repeatDelayInMillisecs, minimumDelayInMillisecs;
    bool vertical, isDraggingThumb, autohides;
    class ScrollbarButton;
    friend struct ContainerDeletePolicy<ScrollbarButton>;
    ScopedPointer<ScrollbarButton> upButton, downButton;
    ListenerList<Listener> listeners;

    void handleAsyncUpdate() override;
    void updateThumbPosition();
    void timerCallback() override;

    ScrollBar (const ScrollBar&) = delete; ScrollBar& operator= (const ScrollBar&) = delete;
};


typedef ScrollBar::Listener ScrollBarListener;
# 208 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_StretchableLayoutManager.h" 1
# 80 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_StretchableLayoutManager.h"
class StretchableLayoutManager
{
public:






    StretchableLayoutManager();


    ~StretchableLayoutManager();
# 109 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_StretchableLayoutManager.h"
    void setItemLayout (int itemIndex,
                        double minimumSize,
                        double maximumSize,
                        double preferredSize);
# 129 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_StretchableLayoutManager.h"
    bool getItemLayout (int itemIndex,
                        double& minimumSize,
                        double& maximumSize,
                        double& preferredSize) const;




    void clearAllItems();
# 170 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_StretchableLayoutManager.h"
    void layOutComponents (Component** components,
                           int numComponents,
                           int x, int y, int width, int height,
                           bool vertically,
                           bool resizeOtherDimension);
# 190 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_StretchableLayoutManager.h"
    int getItemCurrentPosition (int itemIndex) const;
# 201 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_StretchableLayoutManager.h"
    int getItemCurrentAbsoluteSize (int itemIndex) const;
# 213 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_StretchableLayoutManager.h"
    double getItemCurrentRelativeSize (int itemIndex) const;
# 231 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_StretchableLayoutManager.h"
    void setItemPosition (int itemIndex,
                          int newPosition);


private:

    struct ItemLayoutProperties
    {
        int itemIndex;
        int currentSize;
        double minSize, maxSize, preferredSize;
    };

    OwnedArray <ItemLayoutProperties> items;
    int totalSize;


    static int sizeToRealSize (double size, int totalSpace);
    ItemLayoutProperties* getInfoFor (int itemIndex) const;
    void setTotalSize (int newTotalSize);
    int fitComponentsIntoSpace (int startIndex, int endIndex, int availableSpace, int startPos);
    int getMinimumSizeOfItems (int startIndex, int endIndex) const;
    int getMaximumSizeOfItems (int startIndex, int endIndex) const;
    void updatePrefSizesToMatchCurrentPositions();

    StretchableLayoutManager (const StretchableLayoutManager&) = delete; StretchableLayoutManager& operator= (const StretchableLayoutManager&) = delete;
};
# 209 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_StretchableLayoutResizerBar.h" 1
# 38 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_StretchableLayoutResizerBar.h"
class StretchableLayoutResizerBar : public Component
{
public:
# 55 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_StretchableLayoutResizerBar.h"
    StretchableLayoutResizerBar (StretchableLayoutManager* layoutToUse,
                                 int itemIndexInLayout,
                                 bool isBarVertical);


    ~StretchableLayoutResizerBar();
# 73 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_StretchableLayoutResizerBar.h"
    virtual void hasBeenMoved();



    struct LookAndFeelMethods
    {
        virtual ~LookAndFeelMethods() {}

        virtual void drawStretchableLayoutResizerBar (Graphics&, int w, int h,
                                                      bool isVerticalBar, bool isMouseOver, bool isMouseDragging) = 0;
    };



    void paint (Graphics&) override;

    void mouseDown (const MouseEvent&) override;

    void mouseDrag (const MouseEvent&) override;


private:

    StretchableLayoutManager* layout;
    int itemIndex, mouseDownPos;
    bool isVertical;

    StretchableLayoutResizerBar (const StretchableLayoutResizerBar&) = delete; StretchableLayoutResizerBar& operator= (const StretchableLayoutResizerBar&) = delete;
};
# 210 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_StretchableObjectResizer.h" 1
# 44 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_StretchableObjectResizer.h"
class StretchableObjectResizer
{
public:


    StretchableObjectResizer();


    ~StretchableObjectResizer();
# 62 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_StretchableObjectResizer.h"
    void addItem (double currentSize,
                  double minSize,
                  double maxSize,
                  int order = 0);
# 76 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_StretchableObjectResizer.h"
    void resizeToFit (double targetSize);


    int getNumItems() const noexcept { return items.size(); }


    double getItemSize (int index) const noexcept;


private:

    struct Item
    {
        double size;
        double minSize;
        double maxSize;
        int order;
    };

    Array<Item> items;

    StretchableObjectResizer (const StretchableObjectResizer&) = delete; StretchableObjectResizer& operator= (const StretchableObjectResizer&) = delete;
};
# 211 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_TabbedButtonBar.h" 1
# 28 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_TabbedButtonBar.h"
class TabbedButtonBar;
# 40 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_TabbedButtonBar.h"
class TabBarButton : public Button
{
public:


    TabBarButton (const String& name, TabbedButtonBar& ownerBar);


    ~TabBarButton();


    TabbedButtonBar& getTabbedButtonBar() const { return owner; }




    enum ExtraComponentPlacement
    {
        beforeText,
        afterText
    };
# 69 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_TabbedButtonBar.h"
    void setExtraComponent (Component* extraTabComponent,
                            ExtraComponentPlacement extraComponentPlacement);


    Component* getExtraComponent() const noexcept { return extraComponent; }


    ExtraComponentPlacement getExtraComponentPlacement() const noexcept { return extraCompPlacement; }






    Rectangle<int> getActiveArea() const;


    Rectangle<int> getTextArea() const;


    int getIndex() const;


    Colour getTabBackgroundColour() const;


    bool isFrontTab() const;
# 104 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_TabbedButtonBar.h"
    virtual int getBestTabLength (int depth);



    void paintButton (Graphics&, bool isMouseOverButton, bool isButtonDown) override;

    void clicked (const ModifierKeys&) override;

    bool hitTest (int x, int y) override;

    void resized() override;

    void childBoundsChanged (Component*) override;

protected:
    friend class TabbedButtonBar;
    TabbedButtonBar& owner;
    int overlapPixels;

    ScopedPointer<Component> extraComponent;
    ExtraComponentPlacement extraCompPlacement;

private:
    void calcAreas (Rectangle<int>&, Rectangle<int>&) const;

    TabBarButton (const TabBarButton&) = delete; TabBarButton& operator= (const TabBarButton&) = delete;
};
# 147 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_TabbedButtonBar.h"
class TabbedButtonBar : public Component,
                                   public ChangeBroadcaster
{
public:




    enum Orientation
    {
        TabsAtTop,
        TabsAtBottom,
        TabsAtLeft,
        TabsAtRight
    };





    TabbedButtonBar (Orientation orientation);


    ~TabbedButtonBar();
# 179 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_TabbedButtonBar.h"
    void setOrientation (Orientation orientation);




    Orientation getOrientation() const noexcept { return orientation; }


    bool isVertical() const noexcept { return orientation == TabsAtLeft || orientation == TabsAtRight; }


    int getThickness() const noexcept { return isVertical() ? getWidth() : getHeight(); }




    void setMinimumTabScaleFactor (double newMinimumScale);





    void clearTabs();





    void addTab (const String& tabName,
                 Colour tabBackgroundColour,
                 int insertIndex);


    void setTabName (int tabIndex, const String& newName);


    void removeTab (int tabIndex, bool animate = false);




    void moveTab (int currentIndex, int newIndex, bool animate = false);


    int getNumTabs() const;


    StringArray getTabNames() const;
# 235 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_TabbedButtonBar.h"
    void setCurrentTabIndex (int newTabIndex, bool sendChangeMessage = true);




    String getCurrentTabName() const;




    int getCurrentTabIndex() const noexcept { return currentTabIndex; }






    TabBarButton* getTabButton (int index) const;


    int indexOfTabButton (const TabBarButton* button) const;


    Rectangle<int> getTargetBounds (TabBarButton* button) const;





    virtual void currentTabChanged (int newCurrentTabIndex,
                                    const String& newCurrentTabName);


    virtual void popupMenuClickOnTab (int tabIndex, const String& tabName);




    Colour getTabBackgroundColour (int tabIndex);




    void setTabBackgroundColour (int tabIndex, Colour newColour);
# 288 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_TabbedButtonBar.h"
    enum ColourIds
    {
        tabOutlineColourId = 0x1005812,
        tabTextColourId = 0x1005813,

        frontOutlineColourId = 0x1005814,
        frontTextColourId = 0x1005815,


    };





    struct LookAndFeelMethods
    {
        virtual ~LookAndFeelMethods() {}

        virtual int getTabButtonSpaceAroundImage() = 0;
        virtual int getTabButtonOverlap (int tabDepth) = 0;
        virtual int getTabButtonBestWidth (TabBarButton&, int tabDepth) = 0;
        virtual Rectangle<int> getTabButtonExtraComponentBounds (const TabBarButton&, Rectangle<int>& textArea, Component& extraComp) = 0;

        virtual void drawTabButton (TabBarButton&, Graphics&, bool isMouseOver, bool isMouseDown) = 0;
        virtual void drawTabButtonText (TabBarButton&, Graphics&, bool isMouseOver, bool isMouseDown) = 0;
        virtual void drawTabbedButtonBarBackground (TabbedButtonBar&, Graphics&) = 0;
        virtual void drawTabAreaBehindFrontButton (TabbedButtonBar&, Graphics&, int w, int h) = 0;

        virtual void createTabButtonShape (TabBarButton&, Path& path, bool isMouseOver, bool isMouseDown) = 0;
        virtual void fillTabButtonShape (TabBarButton&, Graphics&, const Path& path, bool isMouseOver, bool isMouseDown) = 0;

        virtual Button* createTabBarExtrasButton() = 0;
    };



    void paint (Graphics&) override;

    void resized() override;

    void lookAndFeelChanged() override;

protected:






    virtual TabBarButton* createTabButton (const String& tabName, int tabIndex);

private:
    Orientation orientation;

    struct TabInfo
    {
        ScopedPointer<TabBarButton> button;
        String name;
        Colour colour;
    };

    OwnedArray <TabInfo> tabs;

    double minimumScale;
    int currentTabIndex;

    class BehindFrontTabComp;
    friend class BehindFrontTabComp;
    friend struct ContainerDeletePolicy<BehindFrontTabComp>;
    ScopedPointer<BehindFrontTabComp> behindFrontTab;
    ScopedPointer<Button> extraTabsButton;

    void showExtraItemsMenu();
    static void extraItemsMenuCallback (int, TabbedButtonBar*);
    void updateTabPositions (bool animate);

    TabbedButtonBar (const TabbedButtonBar&) = delete; TabbedButtonBar& operator= (const TabbedButtonBar&) = delete;
};
# 212 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_TabbedComponent.h" 1
# 39 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_TabbedComponent.h"
class TabbedComponent : public Component
{
public:




    explicit TabbedComponent (TabbedButtonBar::Orientation orientation);


    ~TabbedComponent();
# 59 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_TabbedComponent.h"
    void setOrientation (TabbedButtonBar::Orientation orientation);




    TabbedButtonBar::Orientation getOrientation() const noexcept;







    void setTabBarDepth (int newDepth);




    int getTabBarDepth() const noexcept { return tabDepth; }
# 86 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_TabbedComponent.h"
    void setOutline (int newThickness);




    void setIndent (int indentThickness);





    void clearTabs();
# 107 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_TabbedComponent.h"
    void addTab (const String& tabName,
                 Colour tabBackgroundColour,
                 Component* contentComponent,
                 bool deleteComponentWhenNotNeeded,
                 int insertIndex = -1);


    void setTabName (int tabIndex, const String& newName);


    void removeTab (int tabIndex);




    void moveTab (int currentIndex, int newIndex, bool animate = false);


    int getNumTabs() const;


    StringArray getTabNames() const;





    Component* getTabContentComponent (int tabIndex) const noexcept;


    Colour getTabBackgroundColour (int tabIndex) const noexcept;


    void setTabBackgroundColour (int tabIndex, Colour newColour);






    void setCurrentTabIndex (int newTabIndex, bool sendChangeMessage = true);




    int getCurrentTabIndex() const;




    String getCurrentTabName() const;




    Component* getCurrentContentComponent() const noexcept { return panelComponent; }





    virtual void currentTabChanged (int newCurrentTabIndex, const String& newCurrentTabName);


    virtual void popupMenuClickOnTab (int tabIndex, const String& tabName);


    TabbedButtonBar& getTabbedButtonBar() const noexcept { return *tabs; }
# 184 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_TabbedComponent.h"
    enum ColourIds
    {
        backgroundColourId = 0x1005800,
        outlineColourId = 0x1005801,

    };



    void paint (Graphics&) override;

    void resized() override;

    void lookAndFeelChanged() override;

protected:






    virtual TabBarButton* createTabButton (const String& tabName, int tabIndex);


    ScopedPointer<TabbedButtonBar> tabs;

private:

    Array <WeakReference<Component> > contentComponents;
    WeakReference<Component> panelComponent;
    int tabDepth, outlineThickness, edgeIndent;

    class ButtonBar;
    friend class ButtonBar;
    void changeCallback (int newCurrentTabIndex, const String& newTabName);

    TabbedComponent (const TabbedComponent&) = delete; TabbedComponent& operator= (const TabbedComponent&) = delete;
};
# 213 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_Viewport.h" 1
# 42 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_Viewport.h"
class Viewport : public Component,
                            private ComponentListener,
                            private ScrollBar::Listener
{
public:






    explicit Viewport (const String& componentName = String());


    ~Viewport();
# 74 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_Viewport.h"
    void setViewedComponent (Component* newViewedComponent,
                             bool deleteComponentWhenNoLongerNeeded = true);





    Component* getViewedComponent() const noexcept { return contentComp; }
# 94 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_Viewport.h"
    void setViewPosition (int xPixelsOffset, int yPixelsOffset);
# 106 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_Viewport.h"
    void setViewPosition (Point<int> newPosition);
# 115 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_Viewport.h"
    void setViewPositionProportionately (double proportionX, double proportionY);
# 132 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_Viewport.h"
    bool autoScroll (int mouseX, int mouseY, int distanceFromEdge, int maximumSpeed);


    Point<int> getViewPosition() const noexcept { return lastVisibleArea.getPosition(); }


    Rectangle<int> getViewArea() const noexcept { return lastVisibleArea; }




    int getViewPositionX() const noexcept { return lastVisibleArea.getX(); }




    int getViewPositionY() const noexcept { return lastVisibleArea.getY(); }






    int getViewWidth() const noexcept { return lastVisibleArea.getWidth(); }






    int getViewHeight() const noexcept { return lastVisibleArea.getHeight(); }






    int getMaximumVisibleWidth() const;






    int getMaximumVisibleHeight() const;







    virtual void visibleAreaChanged (const Rectangle<int>& newVisibleArea);


    virtual void viewedComponentChanged (Component* newComponent);
# 199 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_Viewport.h"
    void setScrollBarsShown (bool showVerticalScrollbarIfNeeded,
                             bool showHorizontalScrollbarIfNeeded,
                             bool allowVerticalScrollingWithoutScrollbar = false,
                             bool allowHorizontalScrollingWithoutScrollbar = false);




    bool isVerticalScrollBarShown() const noexcept { return showVScrollbar; }




    bool isHorizontalScrollBarShown() const noexcept { return showHScrollbar; }







    void setScrollBarThickness (int thickness);





    int getScrollBarThickness() const;




    void setSingleStepSizes (int stepX, int stepY);




    ScrollBar* getVerticalScrollBar() noexcept { return &verticalScrollBar; }




    ScrollBar* getHorizontalScrollBar() noexcept { return &horizontalScrollBar; }



    void setScrollOnDragEnabled (bool shouldScrollOnDrag);


    bool isScrollOnDragEnabled() const noexcept;




    bool isCurrentlyScrollingOnDrag() const noexcept;



    void resized() override;

    void scrollBarMoved (ScrollBar*, double newRangeStart) override;

    void mouseWheelMove (const MouseEvent&, const MouseWheelDetails&) override;

    bool keyPressed (const KeyPress&) override;

    void componentMovedOrResized (Component&, bool wasMoved, bool wasResized) override;

    void lookAndFeelChanged() override;

    bool useMouseWheelMoveIfNeeded (const MouseEvent&, const MouseWheelDetails&);

    static bool respondsToKey (const KeyPress&);

private:

    WeakReference<Component> contentComp;
    Rectangle<int> lastVisibleArea;
    int scrollBarThickness;
    int singleStepX, singleStepY;
    bool showHScrollbar, showVScrollbar, deleteContent;
    bool customScrollBarThickness;
    bool allowScrollingWithoutScrollbarV, allowScrollingWithoutScrollbarH;
    Component contentHolder;
    ScrollBar verticalScrollBar, horizontalScrollBar;

    struct DragToScrollListener;
    friend struct DragToScrollListener;
    friend struct ContainerDeletePolicy<DragToScrollListener>;
    ScopedPointer<DragToScrollListener> dragToScrollListener;

    Point<int> viewportPosToCompPos (Point<int>) const;

    void updateVisibleArea();
    void deleteOrRemoveContentComp();






    Viewport (const Viewport&) = delete; Viewport& operator= (const Viewport&) = delete;
};
# 214 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/menus/juce_PopupMenu.h" 1
# 77 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/menus/juce_PopupMenu.h"
class PopupMenu
{
private:
    class Window;

public:
    class CustomComponent;
    class CustomCallback;



    PopupMenu();


    PopupMenu (const PopupMenu& other);


    ~PopupMenu();


    PopupMenu& operator= (const PopupMenu& other);


    PopupMenu (PopupMenu&& other) noexcept;
    PopupMenu& operator= (PopupMenu&& other) noexcept;




    void clear();


    struct Item
    {




        Item() noexcept;


        Item (const Item&);


        Item& operator= (const Item&);


        String text;


        int itemID;


        ScopedPointer<PopupMenu> subMenu;


        ScopedPointer<Drawable> image;


        ReferenceCountedObjectPtr<CustomComponent> customComponent;


        ReferenceCountedObjectPtr<CustomCallback> customCallback;


        ApplicationCommandManager* commandManager;







        String shortcutKeyDescription;




        Colour colour;


        bool isEnabled;


        bool isTicked;


        bool isSeparator;


        bool isSectionHeader;
    };





    void addItem (const Item& newItem);
# 188 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/menus/juce_PopupMenu.h"
    void addItem (int itemResultID,
                  const String& itemText,
                  bool isEnabled = true,
                  bool isTicked = false);
# 206 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/menus/juce_PopupMenu.h"
    void addItem (int itemResultID,
                  const String& itemText,
                  bool isEnabled,
                  bool isTicked,
                  const Image& iconToUse);
# 226 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/menus/juce_PopupMenu.h"
    void addItem (int itemResultID,
                  const String& itemText,
                  bool isEnabled,
                  bool isTicked,
                  Drawable* iconToUse);
# 243 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/menus/juce_PopupMenu.h"
    void addCommandItem (ApplicationCommandManager* commandManager,
                         CommandID commandID,
                         const String& displayName = String(),
                         Drawable* iconToUse = nullptr);
# 256 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/menus/juce_PopupMenu.h"
    void addColouredItem (int itemResultID,
                          const String& itemText,
                          Colour itemTextColour,
                          bool isEnabled = true,
                          bool isTicked = false,
                          const Image& iconToUse = Image());







    void addColouredItem (int itemResultID,
                          const String& itemText,
                          Colour itemTextColour,
                          bool isEnabled,
                          bool isTicked,
                          Drawable* iconToUse);
# 283 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/menus/juce_PopupMenu.h"
    void addCustomItem (int itemResultID,
                        CustomComponent* customComponent,
                        const PopupMenu* optionalSubMenu = nullptr);
# 298 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/menus/juce_PopupMenu.h"
    void addCustomItem (int itemResultID,
                        Component* customComponent,
                        int idealWidth,
                        int idealHeight,
                        bool triggerMenuItemAutomaticallyWhenClicked,
                        const PopupMenu* optionalSubMenu = nullptr);







    void addSubMenu (const String& subMenuName,
                     const PopupMenu& subMenu,
                     bool isEnabled = true);







    void addSubMenu (const String& subMenuName,
                     const PopupMenu& subMenu,
                     bool isEnabled,
                     const Image& iconToUse,
                     bool isTicked = false,
                     int itemResultID = 0);
# 338 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/menus/juce_PopupMenu.h"
    void addSubMenu (const String& subMenuName,
                     const PopupMenu& subMenu,
                     bool isEnabled,
                     Drawable* iconToUse,
                     bool isTicked = false,
                     int itemResultID = 0);







    void addSeparator();





    void addSectionHeader (const String& title);




    int getNumItems() const noexcept;


    bool containsCommandItem (int commandID) const;


    bool containsAnyActiveItems() const noexcept;
# 382 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/menus/juce_PopupMenu.h"
    class Options
    {
    public:
        Options();


        Options withTargetComponent (Component* targetComponent) const noexcept;
        Options withTargetScreenArea (const Rectangle<int>& targetArea) const noexcept;
        Options withMinimumWidth (int minWidth) const noexcept;
        Options withMaximumNumColumns (int maxNumColumns) const noexcept;
        Options withStandardItemHeight (int standardHeight) const noexcept;
        Options withItemThatMustBeVisible (int idOfItemToBeVisible) const noexcept;
        Options withParentComponent (Component* parentComponent) const noexcept;


        Component* getParentComponent() const noexcept { return parentComponent; }
        Component* getTargetComponent() const noexcept { return targetComponent; }
        Rectangle<int> getTargetScreenArea() const noexcept { return targetArea; }
        int getMinimumWidth() const noexcept { return minWidth; }
        int getMaximumNumColumns() const noexcept { return maxColumns; }
        int getStandardItemHeight() const noexcept { return standardHeight; }
        int getItemThatMustBeVisible() const noexcept { return visibleItemID; }

    private:

        friend class PopupMenu;
        friend class PopupMenu::Window;
        Rectangle<int> targetArea;
        Component* targetComponent;
        Component* parentComponent;
        int visibleItemID, minWidth, maxColumns, standardHeight;
    };
# 450 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/menus/juce_PopupMenu.h"
    int show (int itemIDThatMustBeVisible = 0,
              int minimumWidth = 0,
              int maximumNumColumns = 0,
              int standardItemHeight = 0,
              ModalComponentManager::Callback* callback = nullptr);
# 470 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/menus/juce_PopupMenu.h"
    int showAt (const Rectangle<int>& screenAreaToAttachTo,
                int itemIDThatMustBeVisible = 0,
                int minimumWidth = 0,
                int maximumNumColumns = 0,
                int standardItemHeight = 0,
                ModalComponentManager::Callback* callback = nullptr);







    int showAt (Component* componentToAttachTo,
                int itemIDThatMustBeVisible = 0,
                int minimumWidth = 0,
                int maximumNumColumns = 0,
                int standardItemHeight = 0,
                ModalComponentManager::Callback* callback = nullptr);



    int showMenu (const Options& options);



    void showMenuAsync (const Options& options,
                        ModalComponentManager::Callback* callback);
# 506 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/menus/juce_PopupMenu.h"
    static bool __stdcall dismissAllActiveMenus();
# 515 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/menus/juce_PopupMenu.h"
    void setLookAndFeel (LookAndFeel* newLookAndFeel);
# 525 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/menus/juce_PopupMenu.h"
    enum ColourIds
    {
        backgroundColourId = 0x1000700,
        textColourId = 0x1000600,

        headerTextColourId = 0x1000601,

        highlightedBackgroundColourId = 0x1000900,

        highlightedTextColourId = 0x1000800,

    };
# 548 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/menus/juce_PopupMenu.h"
    class MenuItemIterator
    {
    public:
# 563 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/menus/juce_PopupMenu.h"
        MenuItemIterator (const PopupMenu& menu, bool searchRecursively = false);


        ~MenuItemIterator();




        bool next();




        Item& getItem() const noexcept;

    private:

        bool searchRecursively;

        Array <int> index;
        Array <const PopupMenu*> menus;
        PopupMenu::Item *currentItem;

        MenuItemIterator& operator= (const MenuItemIterator&);

    };





    class CustomComponent : public Component,
                                       public SingleThreadedReferenceCountedObject
    {
    public:





        CustomComponent (bool isTriggeredAutomatically = true);


        ~CustomComponent();






        virtual void getIdealSize (int& idealWidth, int& idealHeight) = 0;






        void triggerMenuItem();





        bool isItemHighlighted() const noexcept { return isHighlighted; }


        bool isTriggeredAutomatically() const noexcept { return triggeredAutomatically; }

        void setHighlighted (bool shouldBeHighlighted);

    private:

        bool isHighlighted, triggeredAutomatically;

        CustomComponent (const CustomComponent&) = delete; CustomComponent& operator= (const CustomComponent&) = delete;
    };





    class CustomCallback : public SingleThreadedReferenceCountedObject
    {
    public:
        CustomCallback();
        ~CustomCallback();





        virtual bool menuItemTriggered() = 0;

    private:
        CustomCallback (const CustomCallback&) = delete; CustomCallback& operator= (const CustomCallback&) = delete;
    };





    struct LookAndFeelMethods
    {
        virtual ~LookAndFeelMethods() {}


        virtual void drawPopupMenuBackground (Graphics&, int width, int height) = 0;


        virtual void drawPopupMenuItem (Graphics&, const Rectangle<int>& area,
                                        bool isSeparator, bool isActive, bool isHighlighted,
                                        bool isTicked, bool hasSubMenu,
                                        const String& text,
                                        const String& shortcutKeyText,
                                        const Drawable* icon,
                                        const Colour* textColour) = 0;

        virtual void drawPopupMenuSectionHeader (Graphics&, const Rectangle<int>& area,
                                                 const String& sectionName) = 0;


        virtual Font getPopupMenuFont() = 0;

        virtual void drawPopupMenuUpDownArrow (Graphics&,
                                               int width, int height,
                                               bool isScrollUpArrow) = 0;


        virtual void getIdealPopupMenuItemSize (const String& text,
                                                bool isSeparator,
                                                int standardMenuItemHeight,
                                                int& idealWidth,
                                                int& idealHeight) = 0;

        virtual int getMenuWindowFlags() = 0;

        virtual void drawMenuBarBackground (Graphics&, int width, int height,
                                            bool isMouseOverBar,
                                            MenuBarComponent&) = 0;

        virtual int getDefaultMenuBarHeight() = 0;

        virtual int getMenuBarItemWidth (MenuBarComponent&, int itemIndex, const String& itemText) = 0;

        virtual Font getMenuBarFont (MenuBarComponent&, int itemIndex, const String& itemText) = 0;

        virtual void drawMenuBarItem (Graphics&, int width, int height,
                                      int itemIndex,
                                      const String& itemText,
                                      bool isMouseOverItem,
                                      bool isMenuOpen,
                                      bool isMouseOverBar,
                                      MenuBarComponent&) = 0;

        virtual Component* getParentComponentForMenuOptions (const PopupMenu::Options& options) = 0;

        virtual void preparePopupMenuWindow (Component& newWindow) = 0;
    };

private:

    struct HelperClasses;
    friend struct HelperClasses;
    friend class MenuBarComponent;

    OwnedArray<Item> items;
    WeakReference<LookAndFeel> lookAndFeel;

    Component* createWindow (const Options&, ApplicationCommandManager**) const;
    int showWithOptionalCallback (const Options&, ModalComponentManager::Callback*, bool);







};
# 215 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/menus/juce_MenuBarModel.h" 1
# 38 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/menus/juce_MenuBarModel.h"
class MenuBarModel : private AsyncUpdater,
                                    private ApplicationCommandManagerListener
{
public:

    MenuBarModel() noexcept;


    virtual ~MenuBarModel();
# 61 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/menus/juce_MenuBarModel.h"
    void menuItemsChanged();







    void setApplicationCommandManagerToWatch (ApplicationCommandManager* manager) noexcept;






    class Listener
    {
    public:

        virtual ~Listener() {}



        virtual void menuBarItemsChanged (MenuBarModel* menuBarModel) = 0;




        virtual void menuCommandInvoked (MenuBarModel* menuBarModel,
                                         const ApplicationCommandTarget::InvocationInfo& info) = 0;



        virtual void menuBarActivated (MenuBarModel* menuBarModel, bool isActive);
    };
# 104 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/menus/juce_MenuBarModel.h"
    void addListener (Listener* listenerToAdd) noexcept;




    void removeListener (Listener* listenerToRemove) noexcept;



    virtual StringArray getMenuBarNames() = 0;






    virtual PopupMenu getMenuForIndex (int topLevelMenuIndex,
                                       const String& menuName) = 0;
# 130 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/menus/juce_MenuBarModel.h"
    virtual void menuItemSelected (int menuItemID,
                                   int topLevelMenuIndex) = 0;





    virtual void menuBarActivated (bool isActive);
# 175 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/menus/juce_MenuBarModel.h"
    void applicationCommandInvoked (const ApplicationCommandTarget::InvocationInfo&) override;

    void applicationCommandListChanged() override;

    void handleAsyncUpdate() override;

    void handleMenuBarActivate (bool isActive);
private:
    ApplicationCommandManager* manager;
    ListenerList<Listener> listeners;

    MenuBarModel (const MenuBarModel&) = delete; MenuBarModel& operator= (const MenuBarModel&) = delete;
};


typedef MenuBarModel::Listener MenuBarModelListener;
# 216 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/menus/juce_MenuBarComponent.h" 1
# 35 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/menus/juce_MenuBarComponent.h"
class MenuBarComponent : public Component,
                                    private MenuBarModel::Listener,
                                    private Timer
{
public:







    MenuBarComponent (MenuBarModel* model = nullptr);


    ~MenuBarComponent();







    void setModel (MenuBarModel* newModel);


    MenuBarModel* getModel() const noexcept;







    void showMenu (int menuIndex);



    void paint (Graphics&) override;

    void resized() override;

    void mouseEnter (const MouseEvent&) override;

    void mouseExit (const MouseEvent&) override;

    void mouseDown (const MouseEvent&) override;

    void mouseDrag (const MouseEvent&) override;

    void mouseUp (const MouseEvent&) override;

    void mouseMove (const MouseEvent&) override;

    void handleCommandMessage (int commandId) override;

    bool keyPressed (const KeyPress&) override;

    void menuBarItemsChanged (MenuBarModel*) override;

    void menuCommandInvoked (MenuBarModel*, const ApplicationCommandTarget::InvocationInfo&) override;

private:

    MenuBarModel* model;

    StringArray menuNames;
    Array<int> xPositions;
    Point<int> lastMousePos;
    int itemUnderMouse, currentPopupIndex, topLevelIndexClicked;

    int getItemAt (Point<int>);
    void setItemUnderMouse (int index);
    void setOpenItem (int index);
    void updateItemUnderMouse (Point<int>);
    void timerCallback() override;
    void repaintMenuItem (int index);
    void menuDismissed (int topLevelIndex, int itemId);
    static void menuBarMenuDismissedCallback (int, MenuBarComponent*, int);

    MenuBarComponent (const MenuBarComponent&) = delete; MenuBarComponent& operator= (const MenuBarComponent&) = delete;
};
# 217 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/positioning/juce_RelativeCoordinate.h" 1
# 70 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/positioning/juce_RelativeCoordinate.h"
class RelativeCoordinate
{
public:


    RelativeCoordinate();
    RelativeCoordinate (const Expression& expression);
    RelativeCoordinate (const RelativeCoordinate&);
    RelativeCoordinate& operator= (const RelativeCoordinate&);


    RelativeCoordinate (RelativeCoordinate&&) noexcept;
    RelativeCoordinate& operator= (RelativeCoordinate&&) noexcept;






    RelativeCoordinate (double absoluteDistanceFromOrigin);






    RelativeCoordinate (const String& stringVersion);


    ~RelativeCoordinate();

    bool operator== (const RelativeCoordinate&) const noexcept;
    bool operator!= (const RelativeCoordinate&) const noexcept;







    double resolve (const Expression::Scope* evaluationScope) const;




    bool references (const String& coordName, const Expression::Scope* evaluationScope) const;


    bool isRecursive (const Expression::Scope* evaluationScope) const;


    bool isDynamic() const;
# 130 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/positioning/juce_RelativeCoordinate.h"
    void moveToAbsolute (double absoluteTargetPosition, const Expression::Scope* evaluationScope);


    const Expression& getExpression() const { return term; }






    String toString() const;
# 150 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/positioning/juce_RelativeCoordinate.h"
    struct Strings
    {
        static const String parent;
        static const String left;
        static const String right;
        static const String top;
        static const String bottom;
        static const String x;
        static const String y;
        static const String width;
        static const String height;
    };

    struct StandardStrings
    {
        enum Type
        {
            left, right, top, bottom,
            x, y, width, height,
            parent,
            unknown
        };

        static Type getTypeOf (const String& s) noexcept;
    };

private:

    Expression term;
};
# 218 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/positioning/juce_MarkerList.h" 1
# 36 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/positioning/juce_MarkerList.h"
class MarkerList
{
public:


    MarkerList();

    MarkerList (const MarkerList&);

    MarkerList& operator= (const MarkerList&);

    ~MarkerList();



    class Marker
    {
    public:

        Marker (const Marker&);

        Marker (const String& name, const RelativeCoordinate& position);


        String name;
# 73 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/positioning/juce_MarkerList.h"
        RelativeCoordinate position;


        bool operator== (const Marker&) const noexcept;

        bool operator!= (const Marker&) const noexcept;
    };



    int getNumMarkers() const noexcept;


    const Marker* getMarker (int index) const noexcept;




    const Marker* getMarker (const String& name) const noexcept;





    double getMarkerPosition (const Marker& marker, Component* parentComponent) const;






    void setMarker (const String& name, const RelativeCoordinate& position);


    void removeMarker (int index);


    void removeMarker (const String& name);


    bool operator== (const MarkerList&) const noexcept;

    bool operator!= (const MarkerList&) const noexcept;
# 126 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/positioning/juce_MarkerList.h"
    class Listener
    {
    public:

        virtual ~Listener() {}


        virtual void markersChanged (MarkerList* markerList) = 0;


        virtual void markerListBeingDeleted (MarkerList* markerList);
    };


    void addListener (Listener* listener);


    void removeListener (Listener* listener);


    void markersHaveChanged();



    class ValueTreeWrapper
    {
    public:
        ValueTreeWrapper (const ValueTree& state);

        ValueTree& getState() noexcept { return state; }
        int getNumMarkers() const;
        ValueTree getMarkerState (int index) const;
        ValueTree getMarkerState (const String& name) const;
        bool containsMarker (const ValueTree& state) const;
        MarkerList::Marker getMarker (const ValueTree& state) const;
        void setMarker (const MarkerList::Marker& marker, UndoManager* undoManager);
        void removeMarker (const ValueTree& state, UndoManager* undoManager);

        void applyTo (MarkerList& markerList);
        void readFrom (const MarkerList& markerList, UndoManager* undoManager);

        static const Identifier markerTag, nameProperty, posProperty;

    private:
        ValueTree state;
    };

private:

    OwnedArray<Marker> markers;
    ListenerList<Listener> listeners;

    Marker* getMarkerByName (const String& name) const noexcept;


};
# 219 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/positioning/juce_RelativePoint.h" 1
# 35 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/positioning/juce_RelativePoint.h"
class RelativePoint
{
public:

    RelativePoint();


    RelativePoint (Point<float> absolutePoint);


    RelativePoint (float absoluteX, float absoluteY);


    RelativePoint (const RelativeCoordinate& x, const RelativeCoordinate& y);






    RelativePoint (const String& stringVersion);

    bool operator== (const RelativePoint&) const noexcept;
    bool operator!= (const RelativePoint&) const noexcept;






    Point<float> resolve (const Expression::Scope* evaluationContext) const;







    void moveToAbsolute (Point<float> newPos, const Expression::Scope* evaluationContext);






    String toString() const;


    bool isDynamic() const;


    RelativeCoordinate x, y;
};
# 220 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/positioning/juce_RelativeRectangle.h" 1
# 37 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/positioning/juce_RelativeRectangle.h"
class RelativeRectangle
{
public:


    RelativeRectangle();


    explicit RelativeRectangle (const Rectangle<float>& rect);


    RelativeRectangle (const RelativeCoordinate& left, const RelativeCoordinate& right,
                       const RelativeCoordinate& top, const RelativeCoordinate& bottom);







    explicit RelativeRectangle (const String& stringVersion);

    bool operator== (const RelativeRectangle&) const noexcept;
    bool operator!= (const RelativeRectangle&) const noexcept;







    const Rectangle<float> resolve (const Expression::Scope* scope) const;







    void moveToAbsolute (const Rectangle<float>& newPos, const Expression::Scope* scope);




    bool isDynamic() const;







    String toString() const;




    void renameSymbol (const Expression::Symbol& oldSymbol, const String& newName, const Expression::Scope& scope);




    void applyToComponent (Component& component) const;



    RelativeCoordinate left, right, top, bottom;
};
# 221 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/positioning/juce_RelativeCoordinatePositioner.h" 1
# 33 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/positioning/juce_RelativeCoordinatePositioner.h"
class RelativeCoordinatePositionerBase : public Component::Positioner,
                                                    public ComponentListener,
                                                    public MarkerList::Listener
{
public:
    RelativeCoordinatePositionerBase (Component& component);
    ~RelativeCoordinatePositionerBase();

    void componentMovedOrResized (Component&, bool, bool);
    void componentParentHierarchyChanged (Component&);
    void componentChildrenChanged (Component&);
    void componentBeingDeleted (Component&);
    void markersChanged (MarkerList*);
    void markerListBeingDeleted (MarkerList* markerList);

    void apply();

    bool addCoordinate (const RelativeCoordinate& coord);
    bool addPoint (const RelativePoint& point);



    class ComponentScope : public Expression::Scope
    {
    public:
        ComponentScope (Component& component);

        Expression getSymbolValue (const String& symbol) const;
        void visitRelativeScope (const String& scopeName, Visitor& visitor) const;
        String getScopeUID() const;

    protected:
        Component& component;

        Component* findSiblingComponent (const String& componentID) const;

    private:
        ComponentScope (const ComponentScope&) = delete; ComponentScope& operator= (const ComponentScope&) = delete;
    };

protected:
    virtual bool registerCoordinates() = 0;
    virtual void applyToComponentBounds() = 0;

private:
    class DependencyFinderScope;
    friend class DependencyFinderScope;
    Array <Component*> sourceComponents;
    Array <MarkerList*> sourceMarkerLists;
    bool registeredOk;

    void registerComponentListener (Component& comp);
    void registerMarkerListListener (MarkerList* const list);
    void unregisterListeners();

    RelativeCoordinatePositionerBase (const RelativeCoordinatePositionerBase&) = delete; RelativeCoordinatePositionerBase& operator= (const RelativeCoordinatePositionerBase&) = delete;
};
# 222 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/positioning/juce_RelativeParallelogram.h" 1
# 35 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/positioning/juce_RelativeParallelogram.h"
class RelativeParallelogram
{
public:

    RelativeParallelogram();
    RelativeParallelogram (const Rectangle<float>& simpleRectangle);
    RelativeParallelogram (const RelativePoint& topLeft, const RelativePoint& topRight, const RelativePoint& bottomLeft);
    RelativeParallelogram (const String& topLeft, const String& topRight, const String& bottomLeft);
    ~RelativeParallelogram();


    void resolveThreePoints (Point<float>* points, Expression::Scope* scope) const;
    void resolveFourCorners (Point<float>* points, Expression::Scope* scope) const;
    const Rectangle<float> getBounds (Expression::Scope* scope) const;
    void getPath (Path& path, Expression::Scope* scope) const;
    AffineTransform resetToPerpendicular (Expression::Scope* scope);
    bool isDynamic() const;

    bool operator== (const RelativeParallelogram&) const noexcept;
    bool operator!= (const RelativeParallelogram&) const noexcept;

    static Point<float> getInternalCoordForPoint (const Point<float>* parallelogramCorners, Point<float> point) noexcept;
    static Point<float> getPointForInternalCoord (const Point<float>* parallelogramCorners, Point<float> internalPoint) noexcept;
    static Rectangle<float> getBoundingBox (const Point<float>* parallelogramCorners) noexcept;


    RelativePoint topLeft, topRight, bottomLeft;
};
# 223 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/positioning/juce_RelativePointPath.h" 1
# 38 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/positioning/juce_RelativePointPath.h"
class RelativePointPath
{
public:

    RelativePointPath();
    RelativePointPath (const RelativePointPath&);
    explicit RelativePointPath (const Path& path);
    ~RelativePointPath();

    bool operator== (const RelativePointPath&) const noexcept;
    bool operator!= (const RelativePointPath&) const noexcept;



    void createPath (Path& path, Expression::Scope* scope) const;


    bool containsAnyDynamicPoints() const;


    void swapWith (RelativePointPath&) noexcept;





    enum ElementType
    {
        nullElement,
        startSubPathElement,
        closeSubPathElement,
        lineToElement,
        quadraticToElement,
        cubicToElement
    };




    class ElementBase
    {
    public:
        ElementBase (ElementType type);
        virtual ~ElementBase() {}
        virtual ValueTree createTree() const = 0;
        virtual void addToPath (Path& path, Expression::Scope*) const = 0;
        virtual RelativePoint* getControlPoints (int& numPoints) = 0;
        virtual ElementBase* clone() const = 0;
        bool isDynamic();

        const ElementType type;

    private:
        ElementBase (const ElementBase&) = delete; ElementBase& operator= (const ElementBase&) = delete;
    };


    class StartSubPath : public ElementBase
    {
    public:
        StartSubPath (const RelativePoint& pos);
        ValueTree createTree() const;
        void addToPath (Path& path, Expression::Scope*) const;
        RelativePoint* getControlPoints (int& numPoints);
        ElementBase* clone() const;

        RelativePoint startPos;

    private:
        StartSubPath (const StartSubPath&) = delete; StartSubPath& operator= (const StartSubPath&) = delete;
    };


    class CloseSubPath : public ElementBase
    {
    public:
        CloseSubPath();
        ValueTree createTree() const;
        void addToPath (Path& path, Expression::Scope*) const;
        RelativePoint* getControlPoints (int& numPoints);
        ElementBase* clone() const;

    private:
        CloseSubPath (const CloseSubPath&) = delete; CloseSubPath& operator= (const CloseSubPath&) = delete;
    };


    class LineTo : public ElementBase
    {
    public:
        LineTo (const RelativePoint& endPoint);
        ValueTree createTree() const;
        void addToPath (Path& path, Expression::Scope*) const;
        RelativePoint* getControlPoints (int& numPoints);
        ElementBase* clone() const;

        RelativePoint endPoint;

    private:
        LineTo (const LineTo&) = delete; LineTo& operator= (const LineTo&) = delete;
    };


    class QuadraticTo : public ElementBase
    {
    public:
        QuadraticTo (const RelativePoint& controlPoint, const RelativePoint& endPoint);
        ValueTree createTree() const;
        void addToPath (Path& path, Expression::Scope*) const;
        RelativePoint* getControlPoints (int& numPoints);
        ElementBase* clone() const;

        RelativePoint controlPoints[2];

    private:
        QuadraticTo (const QuadraticTo&) = delete; QuadraticTo& operator= (const QuadraticTo&) = delete;
    };


    class CubicTo : public ElementBase
    {
    public:
        CubicTo (const RelativePoint& controlPoint1, const RelativePoint& controlPoint2, const RelativePoint& endPoint);
        ValueTree createTree() const;
        void addToPath (Path& path, Expression::Scope*) const;
        RelativePoint* getControlPoints (int& numPoints);
        ElementBase* clone() const;

        RelativePoint controlPoints[3];

    private:
        CubicTo (const CubicTo&) = delete; CubicTo& operator= (const CubicTo&) = delete;
    };


    void addElement (ElementBase* newElement);


    OwnedArray <ElementBase> elements;
    bool usesNonZeroWinding;

private:
    class Positioner;
    friend class Positioner;
    bool containsDynamicPoints;

    void applyTo (DrawablePath& path) const;

    RelativePointPath& operator= (const RelativePointPath&);

};
# 224 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/drawables/juce_Drawable.h" 1
# 35 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/drawables/juce_Drawable.h"
class Drawable : public Component
{
protected:





    Drawable();

public:

    virtual ~Drawable();






    virtual Drawable* createCopy() const = 0;
# 65 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/drawables/juce_Drawable.h"
    void draw (Graphics& g, float opacity,
               const AffineTransform& transform = AffineTransform()) const;
# 81 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/drawables/juce_Drawable.h"
    void drawAt (Graphics& g, float x, float y, float opacity) const;
# 99 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/drawables/juce_Drawable.h"
    void drawWithin (Graphics& g,
                     const Rectangle<float>& destArea,
                     RectanglePlacement placement,
                     float opacity) const;






    void setOriginWithOriginalSize (Point<float> originWithinParent);




    void setTransformToFit (const Rectangle<float>& areaInParent, RectanglePlacement placement);


    DrawableComposite* getParent() const;







    static Drawable* createFromImageData (const void* data, size_t numBytes);






    static Drawable* createFromImageDataStream (InputStream& dataSource);






    static Drawable* createFromImageFile (const File& file);
# 150 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/drawables/juce_Drawable.h"
    static Drawable* createFromSVG (const XmlElement& svgDocument);


    static Path parseSVGPath (const String& svgPath);
# 163 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/drawables/juce_Drawable.h"
    static Drawable* createFromValueTree (const ValueTree& tree, ComponentBuilder::ImageProvider* imageProvider);






    virtual ValueTree createValueTree (ComponentBuilder::ImageProvider* imageProvider) const = 0;





    virtual Rectangle<float> getDrawableBounds() const = 0;




    virtual bool replaceColour (Colour originalColour, Colour replacementColour);



    class ValueTreeWrapperBase
    {
    public:
        ValueTreeWrapperBase (const ValueTree& state);

        ValueTree& getState() noexcept { return state; }

        String getID() const;
        void setID (const String& newID);

        ValueTree state;
    };






    static void registerDrawableTypeHandlers (ComponentBuilder& componentBuilder);

protected:

    friend class DrawableComposite;
    friend class DrawableShape;


    void transformContextToCorrectOrigin (Graphics&);

    void parentHierarchyChanged() override;

    void setBoundsToEnclose (const Rectangle<float>&);

    Point<int> originRelativeToComponent;



    template <class DrawableType>
    class Positioner : public RelativeCoordinatePositionerBase
    {
    public:
        Positioner (DrawableType& c)
            : RelativeCoordinatePositionerBase (c),
              owner (c)
        {}

        bool registerCoordinates() override { return owner.registerCoordinates (*this); }

        void applyToComponentBounds() override
        {
            ComponentScope scope (getComponent());
            owner.recalculateCoordinates (&scope);
        }

        void applyNewBounds (const Rectangle<int>&) override
        {
#pragma warning(push)
# 240 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/drawables/juce_Drawable.h"
#pragma warning(disable: 4127)
# 240 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/drawables/juce_Drawable.h"
 do { } while (false)
# 240 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/drawables/juce_Drawable.h"
#pragma warning(pop)
# 240 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/drawables/juce_Drawable.h"
;
        }

    private:
        DrawableType& owner;

        Positioner (const Positioner&) = delete; Positioner& operator= (const Positioner&) = delete;
    };

    Drawable (const Drawable&);


private:
    void nonConstDraw (Graphics&, float opacity, const AffineTransform&);

    Drawable& operator= (const Drawable&);

};
# 225 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/drawables/juce_DrawableShape.h" 1
# 36 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/drawables/juce_DrawableShape.h"
class DrawableShape : public Drawable
{
protected:

    DrawableShape();
    DrawableShape (const DrawableShape&);

public:

    ~DrawableShape();




    class RelativeFillType
    {
    public:
        RelativeFillType();
        RelativeFillType (const FillType& fill);
        RelativeFillType (const RelativeFillType&);
        RelativeFillType& operator= (const RelativeFillType&);

        bool operator== (const RelativeFillType&) const;
        bool operator!= (const RelativeFillType&) const;

        bool isDynamic() const;
        bool recalculateCoords (Expression::Scope* scope);

        void writeTo (ValueTree& v, ComponentBuilder::ImageProvider*, UndoManager*) const;
        bool readFrom (const ValueTree& v, ComponentBuilder::ImageProvider*);


        FillType fill;
        RelativePoint gradientPoint1, gradientPoint2, gradientPoint3;
    };
# 80 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/drawables/juce_DrawableShape.h"
    void setFill (const FillType& newFill);
# 89 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/drawables/juce_DrawableShape.h"
    void setFill (const RelativeFillType& newFill);




    const RelativeFillType& getFill() const noexcept { return mainFill; }




    void setStrokeFill (const FillType& newStrokeFill);




    void setStrokeFill (const RelativeFillType& newStrokeFill);




    const RelativeFillType& getStrokeFill() const noexcept { return strokeFill; }





    void setStrokeType (const PathStrokeType& newStrokeType);




    void setStrokeThickness (float newThickness);


    const PathStrokeType& getStrokeType() const noexcept { return strokeType; }


    void setDashLengths (const Array<float>& newDashLengths);


    const Array<float>& getDashLengths() const noexcept { return dashLengths; };



    class FillAndStrokeState : public Drawable::ValueTreeWrapperBase
    {
    public:
        FillAndStrokeState (const ValueTree& state);

        ValueTree getFillState (const Identifier& fillOrStrokeType);
        RelativeFillType getFill (const Identifier& fillOrStrokeType, ComponentBuilder::ImageProvider*) const;
        void setFill (const Identifier& fillOrStrokeType, const RelativeFillType& newFill,
                      ComponentBuilder::ImageProvider*, UndoManager*);

        PathStrokeType getStrokeType() const;
        void setStrokeType (const PathStrokeType& newStrokeType, UndoManager*);

        static const Identifier type, colour, colours, fill, stroke, path, jointStyle, capStyle, strokeWidth,
                                gradientPoint1, gradientPoint2, gradientPoint3, radial, imageId, imageOpacity;
    };


    Rectangle<float> getDrawableBounds() const override;

    void paint (Graphics&) override;

    bool hitTest (int x, int y) override;

    bool replaceColour (Colour originalColour, Colour replacementColour) override;

protected:


    void pathChanged();

    void strokeChanged();

    bool isStrokeVisible() const noexcept;

    void refreshFillTypes (const FillAndStrokeState& newState, ComponentBuilder::ImageProvider*);

    void writeTo (FillAndStrokeState& state, ComponentBuilder::ImageProvider*, UndoManager*) const;


    PathStrokeType strokeType;
    Array<float> dashLengths;
    Path path, strokePath;

private:
    class RelativePositioner;
    RelativeFillType mainFill, strokeFill;
    ScopedPointer<RelativeCoordinatePositionerBase> mainFillPositioner, strokeFillPositioner;

    void setFillInternal (RelativeFillType& fill, const RelativeFillType& newFill,
                          ScopedPointer<RelativeCoordinatePositionerBase>& positioner);

    DrawableShape& operator= (const DrawableShape&);
};
# 226 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/drawables/juce_DrawableComposite.h" 1
# 40 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/drawables/juce_DrawableComposite.h"
class DrawableComposite : public Drawable
{
public:


    DrawableComposite();


    DrawableComposite (const DrawableComposite&);


    ~DrawableComposite();





    void setBoundingBox (const RelativeParallelogram& newBoundingBox);




    const RelativeParallelogram& getBoundingBox() const noexcept { return bounds; }




    void resetBoundingBoxToContentArea();






    RelativeRectangle getContentArea() const;






    void setContentArea (const RelativeRectangle& newArea);




    void resetContentAreaAndBoundingBoxToFitChildren();



    static const char* const contentLeftMarkerName;

    static const char* const contentRightMarkerName;

    static const char* const contentTopMarkerName;

    static const char* const contentBottomMarkerName;



    Drawable* createCopy() const override;

    void refreshFromValueTree (const ValueTree&, ComponentBuilder&);

    ValueTree createValueTree (ComponentBuilder::ImageProvider* imageProvider) const override;

    static const Identifier valueTreeType;

    Rectangle<float> getDrawableBounds() const override;

    void childBoundsChanged (Component*) override;

    void childrenChanged() override;

    void parentHierarchyChanged() override;

    MarkerList* getMarkers (bool xAxis) override;



    class ValueTreeWrapper : public Drawable::ValueTreeWrapperBase
    {
    public:
        ValueTreeWrapper (const ValueTree& state);

        ValueTree getChildList() const;
        ValueTree getChildListCreating (UndoManager* undoManager);

        RelativeParallelogram getBoundingBox() const;
        void setBoundingBox (const RelativeParallelogram& newBounds, UndoManager* undoManager);
        void resetBoundingBoxToContentArea (UndoManager* undoManager);

        RelativeRectangle getContentArea() const;
        void setContentArea (const RelativeRectangle& newArea, UndoManager* undoManager);

        MarkerList::ValueTreeWrapper getMarkerList (bool xAxis) const;
        MarkerList::ValueTreeWrapper getMarkerListCreating (bool xAxis, UndoManager* undoManager);

        static const Identifier topLeft, topRight, bottomLeft;

    private:
        static const Identifier childGroupTag, markerGroupTagX, markerGroupTagY;
    };

private:

    RelativeParallelogram bounds;
    MarkerList markersX, markersY;
    bool updateBoundsReentrant;

    friend class Drawable::Positioner<DrawableComposite>;
    bool registerCoordinates (RelativeCoordinatePositionerBase&);
    void recalculateCoordinates (Expression::Scope*);

    void updateBoundsToFitChildren();

    DrawableComposite& operator= (const DrawableComposite&);

};
# 227 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/drawables/juce_DrawableImage.h" 1
# 35 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/drawables/juce_DrawableImage.h"
class DrawableImage : public Drawable
{
public:

    DrawableImage();
    DrawableImage (const DrawableImage&);


    ~DrawableImage();



    void setImage (const Image& imageToUse);


    const Image& getImage() const noexcept { return image; }


    void setOpacity (float newOpacity);


    float getOpacity() const noexcept { return opacity; }
# 67 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/drawables/juce_DrawableImage.h"
    void setOverlayColour (Colour newOverlayColour);


    Colour getOverlayColour() const noexcept { return overlayColour; }


    void setBoundingBox (const RelativeParallelogram& newBounds);





    const RelativeParallelogram& getBoundingBox() const noexcept { return bounds; }



    void paint (Graphics&) override;

    bool hitTest (int x, int y) override;

    Drawable* createCopy() const override;

    Rectangle<float> getDrawableBounds() const override;

    void refreshFromValueTree (const ValueTree& tree, ComponentBuilder&);

    ValueTree createValueTree (ComponentBuilder::ImageProvider*) const override;

    static const Identifier valueTreeType;



    class ValueTreeWrapper : public Drawable::ValueTreeWrapperBase
    {
    public:
        ValueTreeWrapper (const ValueTree& state);

        var getImageIdentifier() const;
        void setImageIdentifier (const var&, UndoManager*);
        Value getImageIdentifierValue (UndoManager*);

        float getOpacity() const;
        void setOpacity (float newOpacity, UndoManager*);
        Value getOpacityValue (UndoManager*);

        Colour getOverlayColour() const;
        void setOverlayColour (Colour newColour, UndoManager*);
        Value getOverlayColourValue (UndoManager*);

        RelativeParallelogram getBoundingBox() const;
        void setBoundingBox (const RelativeParallelogram&, UndoManager*);

        static const Identifier opacity, overlay, image, topLeft, topRight, bottomLeft;
    };

private:

    Image image;
    float opacity;
    Colour overlayColour;
    RelativeParallelogram bounds;

    friend class Drawable::Positioner<DrawableImage>;
    bool registerCoordinates (RelativeCoordinatePositionerBase&);
    void recalculateCoordinates (Expression::Scope*);

    DrawableImage& operator= (const DrawableImage&);

};
# 228 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/drawables/juce_DrawablePath.h" 1
# 37 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/drawables/juce_DrawablePath.h"
class DrawablePath : public DrawableShape
{
public:


    DrawablePath();
    DrawablePath (const DrawablePath&);


    ~DrawablePath();





    void setPath (const Path& newPath);





    void setPath (const RelativePointPath& newPath);


    const Path& getPath() const;


    const Path& getStrokePath() const;



    Drawable* createCopy() const;

    void refreshFromValueTree (const ValueTree& tree, ComponentBuilder& builder);

    ValueTree createValueTree (ComponentBuilder::ImageProvider* imageProvider) const;

    static const Identifier valueTreeType;



    class ValueTreeWrapper : public DrawableShape::FillAndStrokeState
    {
    public:
        ValueTreeWrapper (const ValueTree& state);

        bool usesNonZeroWinding() const;
        void setUsesNonZeroWinding (bool b, UndoManager* undoManager);

        class Element
        {
        public:
            explicit Element (const ValueTree& state);
            ~Element();

            const Identifier getType() const noexcept { return state.getType(); }
            int getNumControlPoints() const noexcept;

            RelativePoint getControlPoint (int index) const;
            Value getControlPointValue (int index, UndoManager*);
            RelativePoint getStartPoint() const;
            RelativePoint getEndPoint() const;
            void setControlPoint (int index, const RelativePoint& point, UndoManager*);
            float getLength (Expression::Scope*) const;

            ValueTreeWrapper getParent() const;
            Element getPreviousElement() const;

            String getModeOfEndPoint() const;
            void setModeOfEndPoint (const String& newMode, UndoManager*);

            void convertToLine (UndoManager*);
            void convertToCubic (Expression::Scope*, UndoManager*);
            void convertToPathBreak (UndoManager* undoManager);
            ValueTree insertPoint (Point<float> targetPoint, Expression::Scope*, UndoManager*);
            void removePoint (UndoManager* undoManager);
            float findProportionAlongLine (Point<float> targetPoint, Expression::Scope*) const;

            static const Identifier mode, startSubPathElement, closeSubPathElement,
                                    lineToElement, quadraticToElement, cubicToElement;
            static const char* cornerMode;
            static const char* roundedMode;
            static const char* symmetricMode;

            ValueTree state;
        };

        ValueTree getPathState();

        void readFrom (const RelativePointPath& relativePath, UndoManager* undoManager);
        void writeTo (RelativePointPath& relativePath) const;

        static const Identifier nonZeroWinding, point1, point2, point3;
    };

private:

    ScopedPointer<RelativePointPath> relativePath;

    class RelativePositioner;
    friend class RelativePositioner;
    void applyRelativePath (const RelativePointPath&, Expression::Scope*);

    DrawablePath& operator= (const DrawablePath&);

};
# 229 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/drawables/juce_DrawableRectangle.h" 1
# 37 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/drawables/juce_DrawableRectangle.h"
class DrawableRectangle : public DrawableShape
{
public:

    DrawableRectangle();
    DrawableRectangle (const DrawableRectangle&);


    ~DrawableRectangle();



    void setRectangle (const RelativeParallelogram& newBounds);


    const RelativeParallelogram& getRectangle() const noexcept { return bounds; }


    const RelativePoint& getCornerSize() const noexcept { return cornerSize; }


    void setCornerSize (const RelativePoint& newSize);



    Drawable* createCopy() const;

    void refreshFromValueTree (const ValueTree& tree, ComponentBuilder& builder);

    ValueTree createValueTree (ComponentBuilder::ImageProvider* imageProvider) const;

    static const Identifier valueTreeType;



    class ValueTreeWrapper : public DrawableShape::FillAndStrokeState
    {
    public:
        ValueTreeWrapper (const ValueTree& state);

        RelativeParallelogram getRectangle() const;
        void setRectangle (const RelativeParallelogram& newBounds, UndoManager*);

        void setCornerSize (const RelativePoint& cornerSize, UndoManager*);
        RelativePoint getCornerSize() const;
        Value getCornerSizeValue (UndoManager*);

        static const Identifier topLeft, topRight, bottomLeft, cornerSize;
    };


private:
    friend class Drawable::Positioner<DrawableRectangle>;

    RelativeParallelogram bounds;
    RelativePoint cornerSize;

    void rebuildPath();
    bool registerCoordinates (RelativeCoordinatePositionerBase&);
    void recalculateCoordinates (Expression::Scope*);

    DrawableRectangle& operator= (const DrawableRectangle&);

};
# 230 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/drawables/juce_DrawableText.h" 1
# 35 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/drawables/juce_DrawableText.h"
class DrawableText : public Drawable
{
public:


    DrawableText();
    DrawableText (const DrawableText&);


    ~DrawableText();



    void setText (const String& newText);


    const String& getText() const noexcept { return text;}


    void setColour (Colour newColour);


    Colour getColour() const noexcept { return colour; }







    void setFont (const Font& newFont, bool applySizeAndScale);


    const Font& getFont() const noexcept { return font; }


    void setJustification (Justification newJustification);


    Justification getJustification() const noexcept { return justification; }


    const RelativeParallelogram& getBoundingBox() const noexcept { return bounds; }


    void setBoundingBox (const RelativeParallelogram& newBounds);

    const RelativeCoordinate& getFontHeight() const { return fontHeight; }
    void setFontHeight (const RelativeCoordinate& newHeight);

    const RelativeCoordinate& getFontHorizontalScale() const { return fontHScale; }
    void setFontHorizontalScale (const RelativeCoordinate& newScale);



    void paint (Graphics&) override;

    Drawable* createCopy() const override;

    void refreshFromValueTree (const ValueTree& tree, ComponentBuilder& builder);

    ValueTree createValueTree (ComponentBuilder::ImageProvider* imageProvider) const override;

    static const Identifier valueTreeType;

    Rectangle<float> getDrawableBounds() const override;



    class ValueTreeWrapper : public Drawable::ValueTreeWrapperBase
    {
    public:
        ValueTreeWrapper (const ValueTree& state);

        String getText() const;
        void setText (const String& newText, UndoManager* undoManager);
        Value getTextValue (UndoManager* undoManager);

        Colour getColour() const;
        void setColour (Colour newColour, UndoManager* undoManager);

        Justification getJustification() const;
        void setJustification (Justification newJustification, UndoManager* undoManager);

        Font getFont() const;
        void setFont (const Font& newFont, UndoManager* undoManager);
        Value getFontValue (UndoManager* undoManager);

        RelativeParallelogram getBoundingBox() const;
        void setBoundingBox (const RelativeParallelogram& newBounds, UndoManager* undoManager);

        RelativeCoordinate getFontHeight() const;
        void setFontHeight (const RelativeCoordinate& newHeight, UndoManager* undoManager);

        RelativeCoordinate getFontHorizontalScale() const;
        void setFontHorizontalScale (const RelativeCoordinate& newScale, UndoManager* undoManager);

        static const Identifier text, colour, font, justification, topLeft, topRight, bottomLeft, fontHeight, fontHScale;
    };

private:

    RelativeParallelogram bounds;
    RelativeCoordinate fontHeight, fontHScale;
    Point<float> resolvedPoints[3];
    Font font, scaledFont;
    String text;
    Colour colour;
    Justification justification;

    friend class Drawable::Positioner<DrawableText>;
    bool registerCoordinates (RelativeCoordinatePositionerBase&);
    void recalculateCoordinates (Expression::Scope*);
    void refreshBounds();

    DrawableText& operator= (const DrawableText&);

};
# 231 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TextEditor.h" 1
# 38 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TextEditor.h"
class TextEditor : public Component,
                              public TextInputTarget,
                              public SettableTooltipClient
{
public:
# 54 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TextEditor.h"
    explicit TextEditor (const String& componentName = String(),
                         juce_wchar passwordCharacter = 0);


    ~TextEditor();
# 71 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TextEditor.h"
    void setMultiLine (bool shouldBeMultiLine,
                       bool shouldWordWrap = true);


    bool isMultiLine() const;
# 85 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TextEditor.h"
    void setReturnKeyStartsNewLine (bool shouldStartNewLine);




    bool getReturnKeyStartsNewLine() const { return returnKeyStartsNewLine; }







    void setTabKeyUsedAsCharacter (bool shouldTabKeyBeUsed);




    bool isTabKeyUsedAsCharacter() const { return tabKeyUsed; }







    void setEscapeAndReturnKeysConsumed (bool shouldBeConsumed) noexcept;
# 123 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TextEditor.h"
    void setReadOnly (bool shouldBeReadOnly);


    bool isReadOnly() const noexcept;






    void setCaretVisible (bool shouldBeVisible);




    bool isCaretVisible() const noexcept { return caretVisible && ! isReadOnly(); }
# 149 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TextEditor.h"
    void setScrollbarsShown (bool shouldBeEnabled);




    bool areScrollbarsShown() const noexcept { return scrollbarVisible; }
# 166 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TextEditor.h"
    void setPasswordCharacter (juce_wchar passwordCharacter);




    juce_wchar getPasswordCharacter() const noexcept { return passwordCharacter; }
# 182 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TextEditor.h"
    void setPopupMenuEnabled (bool menuEnabled);




    bool isPopupMenuEnabled() const noexcept { return popupMenuEnabled; }


    bool isPopupMenuCurrentlyActive() const noexcept { return menuActive; }
# 202 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TextEditor.h"
    enum ColourIds
    {
        backgroundColourId = 0x1000200,


        textColourId = 0x1000201,




        highlightColourId = 0x1000202,



        highlightedTextColourId = 0x1000203,

        outlineColourId = 0x1000205,


        focusedOutlineColourId = 0x1000206,


        shadowColourId = 0x1000207,

    };
# 237 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TextEditor.h"
    void setFont (const Font& newFont);





    void applyFontToAllText (const Font& newFont);




    const Font& getFont() const noexcept { return currentFont; }
# 258 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TextEditor.h"
    void setSelectAllWhenFocused (bool shouldSelectAll);







    void setTextToShowWhenEmpty (const String& text, Colour colourToUse);





    void setScrollBarThickness (int newThicknessPixels);







    class Listener
    {
    public:

        virtual ~Listener() {}


        virtual void textEditorTextChanged (TextEditor&) {}


        virtual void textEditorReturnKeyPressed (TextEditor&) {}


        virtual void textEditorEscapeKeyPressed (TextEditor&) {}


        virtual void textEditorFocusLost (TextEditor&) {}
    };




    void addListener (Listener* newListener);




    void removeListener (Listener* listenerToRemove);



    String getText() const;


    String getTextInRange (const Range<int>& textRange) const override;




    bool isEmpty() const;
# 333 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TextEditor.h"
    void setText (const String& newText,
                  bool sendTextChangeMessage = true);







    Value& getTextValue();
# 354 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TextEditor.h"
    void insertTextAtCaret (const String& textToInsert) override;


    void clear();





    void cut();




    void copy();




    void paste();





    int getCaretPosition() const;




    void setCaretPosition (int newIndex);
# 397 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TextEditor.h"
    void scrollEditorToPositionCaret (int desiredCaretX, int desiredCaretY);






    Rectangle<int> getCaretRectangle() override;


    void setHighlightedRegion (const Range<int>& newSelection) override;





    Range<int> getHighlightedRegion() const override { return selection; }


    String getHighlightedText() const;




    int getTextIndexAt (int x, int y);






    int getTotalNumChars() const;






    int getTextWidth() const;






    int getTextHeight() const;




    void setIndents (int newLeftIndent, int newTopIndent);




    void setBorder (const BorderSize<int>& border);




    BorderSize<int> getBorder() const;






    void setScrollToShowCursor (bool shouldScrollToShowCaret);


    void moveCaretToEnd();
    bool moveCaretLeft (bool moveInWholeWordSteps, bool selecting);
    bool moveCaretRight (bool moveInWholeWordSteps, bool selecting);
    bool moveCaretUp (bool selecting);
    bool moveCaretDown (bool selecting);
    bool pageUp (bool selecting);
    bool pageDown (bool selecting);
    bool scrollDown();
    bool scrollUp();
    bool moveCaretToTop (bool selecting);
    bool moveCaretToStartOfLine (bool selecting);
    bool moveCaretToEnd (bool selecting);
    bool moveCaretToEndOfLine (bool selecting);
    bool deleteBackwards (bool moveInWholeWordSteps);
    bool deleteForwards (bool moveInWholeWordSteps);
    bool copyToClipboard();
    bool cutToClipboard();
    bool pasteFromClipboard();
    bool selectAll();
    bool undo();
    bool redo();
# 510 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TextEditor.h"
    virtual void addPopupMenuItems (PopupMenu& menuToAddTo,
                                    const MouseEvent* mouseClickEvent);
# 524 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TextEditor.h"
    virtual void performPopupMenuAction (int menuItemID);





    class InputFilter
    {
    public:
        InputFilter() {}
        virtual ~InputFilter() {}





        virtual String filterNewText (TextEditor&, const String& newInput) = 0;
    };




    class LengthAndCharacterRestriction : public InputFilter
    {
    public:






        LengthAndCharacterRestriction (int maxNumChars, const String& allowedCharacters);

        String filterNewText (TextEditor&, const String&) override;

    private:
        String allowedCharacters;
        int maxLength;

        LengthAndCharacterRestriction (const LengthAndCharacterRestriction&) = delete; LengthAndCharacterRestriction& operator= (const LengthAndCharacterRestriction&) = delete;
    };






    void setInputFilter (InputFilter* newFilter, bool takeOwnership);


    InputFilter* getInputFilter() const noexcept { return inputFilter; }
# 585 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TextEditor.h"
    void setInputRestrictions (int maxTextLength,
                               const String& allowedCharacters = String());

    void setKeyboardType (VirtualKeyboardType type) noexcept { keyboardType = type; }





    struct LookAndFeelMethods
    {
        virtual ~LookAndFeelMethods() {}

        virtual void fillTextEditorBackground (Graphics&, int width, int height, TextEditor&) = 0;
        virtual void drawTextEditorOutline (Graphics&, int width, int height, TextEditor&) = 0;

        virtual CaretComponent* createCaretComponent (Component* keyFocusOwner) = 0;
    };



    void paint (Graphics&) override;

    void paintOverChildren (Graphics&) override;

    void mouseDown (const MouseEvent&) override;

    void mouseUp (const MouseEvent&) override;

    void mouseDrag (const MouseEvent&) override;

    void mouseDoubleClick (const MouseEvent&) override;

    void mouseWheelMove (const MouseEvent&, const MouseWheelDetails&) override;

    bool keyPressed (const KeyPress&) override;

    bool keyStateChanged (bool) override;

    void focusGained (FocusChangeType) override;

    void focusLost (FocusChangeType) override;

    void resized() override;

    void enablementChanged() override;

    void colourChanged() override;

    void lookAndFeelChanged() override;

    void parentHierarchyChanged() override;

    bool isTextInputActive() const override;

    void setTemporaryUnderlining (const Array<Range<int> >&) override;

    VirtualKeyboardType getKeyboardType() override { return keyboardType; }

protected:


    void scrollToMakeSureCursorIsVisible();


    void textChanged();


    void newTransaction();


    virtual void returnPressed();


    virtual void escapePressed();

private:

    class Iterator;
    class UniformTextSection;
    class TextHolderComponent;
    class InsertAction;
    class RemoveAction;
    friend class InsertAction;
    friend class RemoveAction;

    ScopedPointer<Viewport> viewport;
    TextHolderComponent* textHolder;
    BorderSize<int> borderSize;

    bool readOnly;
    bool caretVisible;
    bool multiline;
    bool wordWrap;
    bool returnKeyStartsNewLine;
    bool popupMenuEnabled;
    bool selectAllTextWhenFocused;
    bool scrollbarVisible;
    bool wasFocused;
    bool keepCaretOnScreen;
    bool tabKeyUsed;
    bool menuActive;
    bool valueTextNeedsUpdating;
    bool consumeEscAndReturnKeys;
    bool styleChanged;

    UndoManager undoManager;
    ScopedPointer<CaretComponent> caret;
    Range<int> selection;
    int leftIndent, topIndent;
    unsigned int lastTransactionTime;
    Font currentFont;
    mutable int totalNumChars;
    int caretPosition;
    OwnedArray<UniformTextSection> sections;
    String textToShowWhenEmpty;
    Colour colourForTextWhenEmpty;
    juce_wchar passwordCharacter;
    OptionalScopedPointer<InputFilter> inputFilter;
    Value textValue;
    VirtualKeyboardType keyboardType;

    enum
    {
        notDragging,
        draggingSelectionStart,
        draggingSelectionEnd
    } dragType;

    ListenerList<Listener> listeners;
    Array<Range<int> > underlinedSections;

    void moveCaret (int newCaretPos);
    void moveCaretTo (int newPosition, bool isSelecting);
    void recreateCaret();
    void handleCommandMessage (int) override;
    void coalesceSimilarSections();
    void splitSection (int sectionIndex, int charToSplitAt);
    void clearInternal (UndoManager*);
    void insert (const String&, int insertIndex, const Font&, const Colour, UndoManager*, int newCaretPos);
    void reinsert (int insertIndex, const OwnedArray<UniformTextSection>&);
    void remove (Range<int> range, UndoManager*, int caretPositionToMoveTo);
    void getCharPosition (int index, float& x, float& y, float& lineHeight) const;
    void updateCaretPosition();
    void updateValueFromText();
    void textWasChangedByValue();
    int indexAtPosition (float x, float y);
    int findWordBreakAfter (int position) const;
    int findWordBreakBefore (int position) const;
    bool moveCaretWithTransaction (int newPos, bool selecting);
    friend class TextHolderComponent;
    friend class TextEditorViewport;
    void drawContent (Graphics&);
    void updateTextHolderSize();
    float getWordWrapWidth() const;
    void timerCallbackInt();
    void repaintText (Range<int>);
    void scrollByLines (int deltaLines);
    bool undoOrRedo (bool shouldUndo);
    UndoManager* getUndoManager() noexcept;

    TextEditor (const TextEditor&) = delete; TextEditor& operator= (const TextEditor&) = delete;
};


typedef TextEditor::Listener TextEditorListener;
# 232 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Label.h" 1
# 34 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Label.h"
class Label : public Component,
                         public SettableTooltipClient,
                         protected TextEditorListener,
                         private ComponentListener,
                         private ValueListener
{
public:






    Label (const String& componentName = String(),
           const String& labelText = String());


    ~Label();







    void setText (const String& newText,
                  NotificationType notification);
# 71 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Label.h"
    String getText (bool returnActiveEditorContents = false) const;





    Value& getTextValue() noexcept { return textValue; }





    void setFont (const Font& newFont);





    Font getFont() const noexcept;
# 102 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Label.h"
    enum ColourIds
    {
        backgroundColourId = 0x1000280,
        textColourId = 0x1000281,
        outlineColourId = 0x1000282,

        backgroundWhenEditingColourId = 0x1000283,
        textWhenEditingColourId = 0x1000284,
        outlineWhenEditingColourId = 0x1000285
    };





    void setJustificationType (Justification justification);


    Justification getJustificationType() const noexcept { return justification; }





    void setBorderSize (BorderSize<int> newBorderSize);


    BorderSize<int> getBorderSize() const noexcept { return border; }
# 140 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Label.h"
    void attachToComponent (Component* owner, bool onLeft);






    Component* getAttachedComponent() const;






    bool isAttachedOnLeft() const noexcept { return leftOfOwnerComp; }






    void setMinimumHorizontalScale (float newScale);


    float getMinimumHorizontalScale() const noexcept { return minimumHorizontalScale; }


    void setKeyboardType (TextInputTarget::VirtualKeyboardType type) noexcept { keyboardType = type; }
# 180 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Label.h"
    class Listener
    {
    public:

        virtual ~Listener() {}


        virtual void labelTextChanged (Label* labelThatHasChanged) = 0;


        virtual void editorShown (Label*, TextEditor&) {}


        virtual void editorHidden (Label*, TextEditor&) {}
    };


    void addListener (Listener* listener);


    void removeListener (Listener* listener);
# 223 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Label.h"
    void setEditable (bool editOnSingleClick,
                      bool editOnDoubleClick = false,
                      bool lossOfFocusDiscardsChanges = false);


    bool isEditableOnSingleClick() const noexcept { return editSingleClick; }


    bool isEditableOnDoubleClick() const noexcept { return editDoubleClick; }


    bool doesLossOfFocusDiscardChanges() const noexcept { return lossOfFocusDiscardsChanges; }


    bool isEditable() const noexcept { return editSingleClick || editDoubleClick; }




    void showEditor();
# 252 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Label.h"
    void hideEditor (bool discardCurrentEditorContents);


    bool isBeingEdited() const noexcept;


    TextEditor* getCurrentTextEditor() const noexcept;





    struct LookAndFeelMethods
    {
        virtual ~LookAndFeelMethods() {}

        virtual void drawLabel (Graphics&, Label&) = 0;
        virtual Font getLabelFont (Label&) = 0;
    };

protected:




    virtual TextEditor* createEditorComponent();


    virtual void textWasEdited();


    virtual void textWasChanged();


    virtual void editorShown (TextEditor*);


    virtual void editorAboutToBeHidden (TextEditor*);



    void paint (Graphics&) override;

    void resized() override;

    void mouseUp (const MouseEvent&) override;

    void mouseDoubleClick (const MouseEvent&) override;

    void componentMovedOrResized (Component&, bool wasMoved, bool wasResized) override;

    void componentParentHierarchyChanged (Component&) override;

    void componentVisibilityChanged (Component&) override;

    void inputAttemptWhenModal() override;

    void focusGained (FocusChangeType) override;

    void enablementChanged() override;

    KeyboardFocusTraverser* createFocusTraverser() override;

    void textEditorTextChanged (TextEditor&) override;

    void textEditorReturnKeyPressed (TextEditor&) override;

    void textEditorEscapeKeyPressed (TextEditor&) override;

    void textEditorFocusLost (TextEditor&) override;

    void colourChanged() override;

    void valueChanged (Value&) override;

    void callChangeListeners();

private:

    Value textValue;
    String lastTextValue;
    Font font;
    Justification justification;
    ScopedPointer<TextEditor> editor;
    ListenerList<Listener> listeners;
    WeakReference<Component> ownerComponent;
    BorderSize<int> border;
    float minimumHorizontalScale;
    TextInputTarget::VirtualKeyboardType keyboardType;
    bool editSingleClick;
    bool editDoubleClick;
    bool lossOfFocusDiscardsChanges;
    bool leftOfOwnerComp;

    bool updateFromTextEditorContents (TextEditor&);

    Label (const Label&) = delete; Label& operator= (const Label&) = delete;
};


typedef Label::Listener LabelListener;
# 233 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ComboBox.h" 1
# 44 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ComboBox.h"
class ComboBox : public Component,
                            public SettableTooltipClient,
                            public LabelListener,
                            public ValueListener,
                            private AsyncUpdater
{
public:
# 60 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ComboBox.h"
    explicit ComboBox (const String& componentName = String());


    virtual ~ComboBox();







    void setEditableText (bool isEditable);




    bool isTextEditable() const noexcept;






    void setJustificationType (Justification justification);




    Justification getJustificationType() const noexcept;
# 99 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ComboBox.h"
    void addItem (const String& newItemText, int newItemId);




    void addItemList (const StringArray& items, int firstItemIdOffset);





    void addSeparator();
# 121 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ComboBox.h"
    void addSectionHeading (const String& headingName);
# 131 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ComboBox.h"
    void setItemEnabled (int itemId, bool shouldBeEnabled);


    bool isItemEnabled (int itemId) const noexcept;



    void changeItemText (int itemId, const String& newText);
# 147 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ComboBox.h"
    void clear (NotificationType notification = sendNotificationAsync);





    int getNumItems() const noexcept;





    String getItemText (int index) const;





    int getItemId (int index) const noexcept;




    int indexOfItemId (int itemId) const noexcept;
# 181 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ComboBox.h"
    int getSelectedId() const noexcept;






    Value& getSelectedIdAsValue() { return currentId; }
# 200 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ComboBox.h"
    void setSelectedId (int newItemId,
                        NotificationType notification = sendNotificationAsync);
# 212 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ComboBox.h"
    int getSelectedItemIndex() const;
# 224 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ComboBox.h"
    void setSelectedItemIndex (int newItemIndex,
                               NotificationType notification = sendNotificationAsync);
# 236 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ComboBox.h"
    String getText() const;
# 250 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ComboBox.h"
    void setText (const String& newText,
                  NotificationType notification = sendNotificationAsync);






    void showEditor();





    virtual void showPopup();


    void hidePopup();


    bool isPopupActive() const noexcept { return menuActive; }




    PopupMenu* getRootMenu() { return &currentMenu; }
# 286 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ComboBox.h"
    class Listener
    {
    public:

        virtual ~Listener() {}


        virtual void comboBoxChanged (ComboBox* comboBoxThatHasChanged) = 0;
    };


    void addListener (Listener* listener);


    void removeListener (Listener* listener);





    void setTextWhenNothingSelected (const String& newMessage);




    String getTextWhenNothingSelected() const;







    void setTextWhenNoChoicesAvailable (const String& newMessage);




    String getTextWhenNoChoicesAvailable() const;



    void setTooltip (const String& newTooltip) override;





    void setScrollWheelEnabled (bool enabled) noexcept;
# 347 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ComboBox.h"
    enum ColourIds
    {
        backgroundColourId = 0x1000b00,
        textColourId = 0x1000a00,
        outlineColourId = 0x1000c00,
        buttonColourId = 0x1000d00,
        arrowColourId = 0x1000e00,
    };





    struct LookAndFeelMethods
    {
        virtual ~LookAndFeelMethods() {}

        virtual void drawComboBox (Graphics&, int width, int height, bool isButtonDown,
                                   int buttonX, int buttonY, int buttonW, int buttonH,
                                   ComboBox&) = 0;

        virtual Font getComboBoxFont (ComboBox&) = 0;

        virtual Label* createComboBoxTextBox (ComboBox&) = 0;

        virtual void positionComboBoxText (ComboBox&, Label& labelToPosition) = 0;
    };



    void labelTextChanged (Label*) override;

    void enablementChanged() override;

    void colourChanged() override;

    void focusGained (Component::FocusChangeType) override;

    void focusLost (Component::FocusChangeType) override;

    void handleAsyncUpdate() override;

    String getTooltip() override { return label->getTooltip(); }

    void mouseDown (const MouseEvent&) override;

    void mouseDrag (const MouseEvent&) override;

    void mouseUp (const MouseEvent&) override;

    void mouseWheelMove (const MouseEvent&, const MouseWheelDetails&) override;

    void lookAndFeelChanged() override;

    void paint (Graphics&) override;

    void resized() override;

    bool keyStateChanged (bool) override;

    bool keyPressed (const KeyPress&) override;

    void valueChanged (Value&) override;

    void parentHierarchyChanged() override;


    __declspec(deprecated) void clear (bool);
    __declspec(deprecated) void setSelectedId (int, bool);
    __declspec(deprecated) void setSelectedItemIndex (int, bool);
    __declspec(deprecated) void setText (const String&, bool);

private:

    enum EditableState
    {
        editableUnknown,
        labelIsNotEditable,
        labelIsEditable
    };

    PopupMenu currentMenu;
    Value currentId;
    int lastCurrentId;
    bool isButtonDown, menuActive, scrollWheelEnabled;
    float mouseWheelAccumulator;
    ListenerList<Listener> listeners;
    ScopedPointer<Label> label;
    String textWhenNothingSelected, noChoicesMessage;
    EditableState labelEditableState;

    PopupMenu::Item* getItemForId (int) const noexcept;
    PopupMenu::Item* getItemForIndex (int) const noexcept;
    bool selectIfEnabled (int index);
    bool nudgeSelectedItem (int delta);
    void sendChange (NotificationType);
    void showPopupIfNotActive();

    ComboBox (const ComboBox&) = delete; ComboBox& operator= (const ComboBox&) = delete;
};


typedef ComboBox::Listener ComboBoxListener;
# 234 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ImageComponent.h" 1
# 35 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ImageComponent.h"
class ImageComponent : public Component,
                                  public SettableTooltipClient
{
public:


    ImageComponent (const String& componentName = String());


    ~ImageComponent();



    void setImage (const Image& newImage);


    void setImage (const Image& newImage,
                   RectanglePlacement placementToUse);


    const Image& getImage() const;





    void setImagePlacement (RectanglePlacement newPlacement);


    RectanglePlacement getImagePlacement() const;



    void paint (Graphics&) override;

private:
    Image image;
    RectanglePlacement placement;

    ImageComponent (const ImageComponent&) = delete; ImageComponent& operator= (const ImageComponent&) = delete;
};
# 235 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ListBox.h" 1
# 35 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ListBox.h"
class ListBoxModel
{
public:


    virtual ~ListBoxModel() {}





    virtual int getNumRows() = 0;





    virtual void paintListBoxItem (int rowNumber,
                                   Graphics& g,
                                   int width, int height,
                                   bool rowIsSelected) = 0;
# 84 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ListBox.h"
    virtual Component* refreshComponentForRow (int rowNumber, bool isRowSelected,
                                               Component* existingComponentToUpdate);




    virtual void listBoxItemClicked (int row, const MouseEvent&);




    virtual void listBoxItemDoubleClicked (int row, const MouseEvent&);





    virtual void backgroundClicked (const MouseEvent&);
# 111 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ListBox.h"
    virtual void selectedRowsChanged (int lastRowSelected);
# 121 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ListBox.h"
    virtual void deleteKeyPressed (int lastRowSelected);
# 131 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ListBox.h"
    virtual void returnKeyPressed (int lastRowSelected);






    virtual void listWasScrolled();
# 149 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ListBox.h"
    virtual var getDragSourceDescription (const SparseSet<int>& rowsToDescribe);




    virtual String getTooltipForRow (int row);


    virtual MouseCursor getMouseCursorForRow (int row);

private:




};
# 177 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ListBox.h"
class ListBox : public Component,
                           public SettableTooltipClient
{
public:






    ListBox (const String& componentName = String(),
             ListBoxModel* model = nullptr);


    ~ListBox();




    void setModel (ListBoxModel* newModel);


    ListBoxModel* getModel() const noexcept { return model; }
# 210 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ListBox.h"
    void updateContent();
# 222 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ListBox.h"
    void setMultipleSelectionEnabled (bool shouldBeEnabled) noexcept;
# 231 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ListBox.h"
    void setClickingTogglesRowSelection (bool flipRowSelection) noexcept;




    void setRowSelectedOnMouseDown (bool isSelectedOnMouseDown) noexcept;






    void setMouseMoveSelectsRows (bool shouldSelect);
# 259 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ListBox.h"
    void selectRow (int rowNumber,
                    bool dontScrollToShowThisRow = false,
                    bool deselectOthersFirst = true);
# 274 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ListBox.h"
    void selectRangeOfRows (int firstRow,
                            int lastRow,
                            bool dontScrollToShowThisRange = false);





    void deselectRow (int rowNumber);




    void deselectAllRows();




    void flipRowSelection (int rowNumber);




    SparseSet<int> getSelectedRows() const;
# 306 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ListBox.h"
    void setSelectedRows (const SparseSet<int>& setOfRowsToBeSelected,
                          NotificationType sendNotificationEventToModel = sendNotification);



    bool isRowSelected (int rowNumber) const;




    int getNumSelectedRows() const;
# 328 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ListBox.h"
    int getSelectedRow (int index = 0) const;
# 337 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ListBox.h"
    int getLastRowSelected() const;
# 352 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ListBox.h"
    void selectRowsBasedOnModifierKeys (int rowThatWasClickedOn,
                                        ModifierKeys modifiers,
                                        bool isMouseUpEvent);
# 367 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ListBox.h"
    void setVerticalPosition (double newProportion);
# 376 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ListBox.h"
    double getVerticalPosition() const;


    void scrollToEnsureRowIsOnscreen (int row);


    ScrollBar* getVerticalScrollBar() const noexcept;


    ScrollBar* getHorizontalScrollBar() const noexcept;






    int getRowContainingPosition (int x, int y) const noexcept;
# 407 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ListBox.h"
    int getInsertionIndexForPosition (int x, int y) const noexcept;







    Rectangle<int> getRowPosition (int rowNumber,
                                   bool relativeToComponentTopLeft) const noexcept;
# 427 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ListBox.h"
    Component* getComponentForRowNumber (int rowNumber) const noexcept;




    int getRowNumberOfComponent (Component* rowComponent) const noexcept;




    int getVisibleRowWidth() const noexcept;






    void setRowHeight (int newHeight);




    int getRowHeight() const noexcept { return rowHeight; }






    int getNumRowsOnScreen() const noexcept;
# 466 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ListBox.h"
    enum ColourIds
    {
        backgroundColourId = 0x1002800,

        outlineColourId = 0x1002810,

        textColourId = 0x1002820
    };






    void setOutlineThickness (int outlineThickness);




    int getOutlineThickness() const noexcept { return outlineThickness; }
# 496 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ListBox.h"
    void setHeaderComponent (Component* newHeaderComponent);


    Component* getHeaderComponent() const noexcept { return headerComponent; }
# 511 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ListBox.h"
    void setMinimumContentWidth (int newMinimumWidth);




    int getVisibleContentWidth() const noexcept;






    void repaintRow (int rowNumber) noexcept;
# 537 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ListBox.h"
    virtual Image createSnapshotOfRows (const SparseSet<int>& rows, int& x, int& y);






    Viewport* getViewport() const noexcept;



    bool keyPressed (const KeyPress&) override;

    bool keyStateChanged (bool isKeyDown) override;

    void paint (Graphics&) override;

    void paintOverChildren (Graphics&) override;

    void resized() override;

    void visibilityChanged() override;

    void mouseWheelMove (const MouseEvent&, const MouseWheelDetails&) override;

    void mouseUp (const MouseEvent&) override;

    void colourChanged() override;

    void parentHierarchyChanged() override;

    void startDragAndDrop (const MouseEvent&, const SparseSet<int>& rowsToDrag,
                           const var& dragDescription, bool allowDraggingToOtherWindows);

private:

    class ListViewport;
    class RowComponent;
    friend class ListViewport;
    friend class TableListBox;
    ListBoxModel* model;
    ScopedPointer<ListViewport> viewport;
    ScopedPointer<Component> headerComponent;
    ScopedPointer<MouseListener> mouseMoveSelector;
    int totalItems, rowHeight, minimumRowWidth;
    int outlineThickness;
    int lastRowSelected;
    bool multipleSelection, alwaysFlipSelection, hasDoneInitialUpdate, selectOnMouseDown;
    SparseSet<int> selected;

    void selectRowInternal (int rowNumber, bool dontScrollToShowThisRow,
                            bool deselectOthersFirst, bool isMouseClick);
# 598 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ListBox.h"
    ListBox (const ListBox&) = delete; ListBox& operator= (const ListBox&) = delete;
};
# 236 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ProgressBar.h" 1
# 42 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ProgressBar.h"
class ProgressBar : public Component,
                               public SettableTooltipClient,
                               private Timer
{
public:
# 57 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ProgressBar.h"
    explicit ProgressBar (double& progress);


    ~ProgressBar();







    void setPercentageDisplay (bool shouldDisplayPercentage);






    void setTextToDisplay (const String& text);
# 86 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ProgressBar.h"
    enum ColourIds
    {
        backgroundColourId = 0x1001900,
        foregroundColourId = 0x1001a00,

    };



    struct LookAndFeelMethods
    {
        virtual ~LookAndFeelMethods() {}
# 107 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ProgressBar.h"
        virtual void drawProgressBar (Graphics&, ProgressBar&, int width, int height,
                                      double progress, const String& textToShow) = 0;
    };

protected:


    void paint (Graphics&) override;

    void lookAndFeelChanged() override;

    void visibilityChanged() override;

    void colourChanged() override;

private:
    double& progress;
    double currentValue;
    bool displayPercentage;
    String displayedMessage, currentMessage;
    uint32 lastCallbackTime;

    void timerCallback() override;

    ProgressBar (const ProgressBar&) = delete; ProgressBar& operator= (const ProgressBar&) = delete;
};
# 237 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Slider.h" 1
# 50 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Slider.h"
class Slider : public Component,
                          public SettableTooltipClient
{
public:





    enum SliderStyle
    {
        LinearHorizontal,
        LinearVertical,
        LinearBar,
        LinearBarVertical,
        Rotary,

        RotaryHorizontalDrag,

        RotaryVerticalDrag,

        RotaryHorizontalVerticalDrag,

        IncDecButtons,

        TwoValueHorizontal,

        TwoValueVertical,


        ThreeValueHorizontal,


        ThreeValueVertical,


    };




    enum TextEntryBoxPosition
    {
        NoTextBox,
        TextBoxLeft,
        TextBoxRight,
        TextBoxAbove,
        TextBoxBelow
    };




    enum DragMode
    {
        notDragging,
        absoluteDrag,
        velocityDrag
    };





    Slider();




    explicit Slider (const String& componentName);


    Slider (SliderStyle style, TextEntryBoxPosition textBoxPosition);


    ~Slider();







    void setSliderStyle (SliderStyle newStyle);




    SliderStyle getSliderStyle() const noexcept;


    struct RotaryParameters
    {


        float startAngleRadians;




        float endAngleRadians;






        bool stopAtEnd;
    };


    void setRotaryParameters (RotaryParameters newParameters) noexcept;


    void setRotaryParameters (float startAngleRadians,
                              float endAngleRadians,
                              bool stopAtEnd) noexcept;


    RotaryParameters getRotaryParameters() const noexcept;







    void setMouseDragSensitivity (int distanceForFullScaleDrag);


    int getMouseDragSensitivity() const noexcept;
# 191 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Slider.h"
    void setVelocityBasedMode (bool isVelocityBased);




    bool getVelocityBasedMode() const noexcept;
# 211 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Slider.h"
    void setVelocityModeParameters (double sensitivity = 1.0,
                                    int threshold = 1,
                                    double offset = 0.0,
                                    bool userCanPressKeyToSwapMode = true);




    double getVelocitySensitivity() const noexcept;




    int getVelocityThreshold() const noexcept;




    double getVelocityOffset() const noexcept;




    bool getVelocityModeIsSwappable() const noexcept;
# 255 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Slider.h"
    void setSkewFactor (double factor, bool symmetricSkew = false);
# 264 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Slider.h"
    void setSkewFactorFromMidPoint (double sliderValueToShowAtMidPoint);





    double getSkewFactor() const noexcept;





    bool isSymmetricSkew() const noexcept;




    enum IncDecButtonMode
    {
        incDecButtonsNotDraggable,
        incDecButtonsDraggable_AutoDirection,
        incDecButtonsDraggable_Horizontal,
        incDecButtonsDraggable_Vertical
    };
# 299 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Slider.h"
    void setIncDecButtonsMode (IncDecButtonMode mode);
# 313 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Slider.h"
    void setTextBoxStyle (TextEntryBoxPosition newPosition,
                          bool isReadOnly,
                          int textEntryBoxWidth,
                          int textEntryBoxHeight);




    TextEntryBoxPosition getTextBoxPosition() const noexcept;




    int getTextBoxWidth() const noexcept;




    int getTextBoxHeight() const noexcept;
# 340 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Slider.h"
    void setTextBoxIsEditable (bool shouldBeEditable);




    bool isTextBoxEditable() const noexcept;





    void showTextBox();
# 361 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Slider.h"
    void hideTextBox (bool discardCurrentEditorContents);
# 378 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Slider.h"
    void setValue (double newValue, NotificationType notification = sendNotificationAsync);


    double getValue() const;







    Value& getValueObject() noexcept;
# 399 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Slider.h"
    void setRange (double newMinimum,
                   double newMaximum,
                   double newInterval = 0);




    double getMaximum() const noexcept;




    double getMinimum() const noexcept;




    double getInterval() const noexcept;
# 427 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Slider.h"
    double getMinValue() const;







    Value& getMinValueObject() noexcept;
# 455 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Slider.h"
    void setMinValue (double newValue,
                      NotificationType notification = sendNotificationAsync,
                      bool allowNudgingOfOtherValues = false);
# 467 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Slider.h"
    double getMaxValue() const;







    Value& getMaxValueObject() noexcept;
# 495 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Slider.h"
    void setMaxValue (double newValue,
                      NotificationType notification = sendNotificationAsync,
                      bool allowNudgingOfOtherValues = false);
# 514 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Slider.h"
    void setMinAndMaxValues (double newMinValue, double newMaxValue,
                             NotificationType notification = sendNotificationAsync);
# 525 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Slider.h"
    class Listener
    {
    public:


        virtual ~Listener() {}
# 542 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Slider.h"
        virtual void sliderValueChanged (Slider* slider) = 0;
# 553 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Slider.h"
        virtual void sliderDragStarted (Slider*) {}




        virtual void sliderDragEnded (Slider*) {}
    };


    void addListener (Listener* listener);


    void removeListener (Listener* listener);
# 576 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Slider.h"
    void setDoubleClickReturnValue (bool shouldDoubleClickBeEnabled,
                                    double valueToSetOnDoubleClick);




    double getDoubleClickReturnValue() const noexcept;




    bool isDoubleClickReturnEnabled() const noexcept;
# 598 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Slider.h"
    void setChangeNotificationOnlyOnRelease (bool onlyNotifyOnRelease);
# 609 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Slider.h"
    void setSliderSnapsToMousePosition (bool shouldSnapToMouse);


    bool getSliderSnapsToMousePosition() const noexcept;
# 626 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Slider.h"
    void setPopupDisplayEnabled (bool isEnabled, Component* parentComponentToUse);





    Component* getCurrentPopupDisplay() const noexcept;
# 641 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Slider.h"
    void setPopupMenuEnabled (bool menuEnabled);




    void setScrollWheelEnabled (bool enabled);






    int getThumbBeingDragged() const noexcept;





    virtual void startedDragging();




    virtual void stoppedDragging();




    virtual void valueChanged();
# 680 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Slider.h"
    virtual double getValueFromText (const String& text);
# 692 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Slider.h"
    virtual String getTextFromValue (double value);
# 701 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Slider.h"
    void setTextValueSuffix (const String& suffix);


    String getTextValueSuffix() const;






    int getNumDecimalPlacesToDisplay() const noexcept;
# 725 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Slider.h"
    virtual double proportionOfLengthToValue (double proportion);
# 740 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Slider.h"
    virtual double valueToProportionOfLength (double value);
# 751 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Slider.h"
    float getPositionOfValue (double value) const;
# 766 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Slider.h"
    virtual double snapValue (double attemptedValue, DragMode dragMode);






    void updateText();


    bool isHorizontal() const noexcept;

    bool isVertical() const noexcept;

    bool isRotary() const noexcept;

    bool isBar() const noexcept;
# 792 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Slider.h"
    enum ColourIds
    {
        backgroundColourId = 0x1001200,
        thumbColourId = 0x1001300,

        trackColourId = 0x1001310,
        rotarySliderFillColourId = 0x1001311,
        rotarySliderOutlineColourId = 0x1001312,

        textBoxTextColourId = 0x1001400,
        textBoxBackgroundColourId = 0x1001500,
        textBoxHighlightColourId = 0x1001600,
        textBoxOutlineColourId = 0x1001700
    };





    struct SliderLayout
    {
        Rectangle<int> sliderBounds;
        Rectangle<int> textBoxBounds;
    };





    struct LookAndFeelMethods
    {
        virtual ~LookAndFeelMethods() {}


        virtual void drawLinearSlider (Graphics&,
                                       int x, int y, int width, int height,
                                       float sliderPos,
                                       float minSliderPos,
                                       float maxSliderPos,
                                       const Slider::SliderStyle,
                                       Slider&) = 0;

        virtual void drawLinearSliderBackground (Graphics&,
                                                 int x, int y, int width, int height,
                                                 float sliderPos,
                                                 float minSliderPos,
                                                 float maxSliderPos,
                                                 const Slider::SliderStyle style,
                                                 Slider&) = 0;

        virtual void drawLinearSliderThumb (Graphics&,
                                            int x, int y, int width, int height,
                                            float sliderPos,
                                            float minSliderPos,
                                            float maxSliderPos,
                                            const Slider::SliderStyle,
                                            Slider&) = 0;

        virtual int getSliderThumbRadius (Slider&) = 0;

        virtual void drawRotarySlider (Graphics&,
                                       int x, int y, int width, int height,
                                       float sliderPosProportional,
                                       float rotaryStartAngle,
                                       float rotaryEndAngle,
                                       Slider&) = 0;

        virtual Button* createSliderButton (Slider&, bool isIncrement) = 0;
        virtual Label* createSliderTextBox (Slider&) = 0;

        virtual ImageEffectFilter* getSliderEffect (Slider&) = 0;

        virtual Font getSliderPopupFont (Slider&) = 0;
        virtual int getSliderPopupPlacement (Slider&) = 0;

        virtual SliderLayout getSliderLayout (Slider&) = 0;
# 876 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Slider.h"
    };



    void paint (Graphics&) override;

    void resized() override;

    void mouseDown (const MouseEvent&) override;

    void mouseUp (const MouseEvent&) override;

    void mouseDrag (const MouseEvent&) override;

    void mouseDoubleClick (const MouseEvent&) override;

    void mouseWheelMove (const MouseEvent&, const MouseWheelDetails&) override;

    void modifierKeysChanged (const ModifierKeys&) override;

    void lookAndFeelChanged() override;

    void enablementChanged() override;

    void focusOfChildComponentChanged (FocusChangeType) override;

    void colourChanged() override;

private:

    class Pimpl;
    friend class Pimpl;
    friend struct ContainerDeletePolicy<Pimpl>;
    ScopedPointer<Pimpl> pimpl;

    void init (SliderStyle, TextEntryBoxPosition);
# 928 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Slider.h"
    Slider (const Slider&) = delete; Slider& operator= (const Slider&) = delete;
};


typedef Slider::Listener SliderListener;
# 238 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TableHeaderComponent.h" 1
# 43 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TableHeaderComponent.h"
class TableHeaderComponent : public Component,
                                         private AsyncUpdater
{
public:



    TableHeaderComponent();


    ~TableHeaderComponent();





    enum ColumnPropertyFlags
    {
        visible = 1,
        resizable = 2,
        draggable = 4,
        appearsOnColumnMenu = 8,
        sortable = 16,
        sortedForwards = 32,
        sortedBackwards = 64,


        defaultFlags = (visible | resizable | draggable | appearsOnColumnMenu | sortable),


        notResizable = (visible | draggable | appearsOnColumnMenu | sortable),


        notResizableOrSortable = (visible | draggable | appearsOnColumnMenu),


        notSortable = (visible | resizable | draggable | appearsOnColumnMenu)
    };
# 102 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TableHeaderComponent.h"
    void addColumn (const String& columnName,
                    int columnId,
                    int width,
                    int minimumWidth = 30,
                    int maximumWidth = -1,
                    int propertyFlags = defaultFlags,
                    int insertIndex = -1);






    void removeColumn (int columnIdToRemove);






    void removeAllColumns();
# 131 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TableHeaderComponent.h"
    int getNumColumns (bool onlyCountVisibleColumns) const;




    String getColumnName (int columnId) const;


    void setColumnName (int columnId, const String& newName);






    void moveColumn (int columnId, int newVisibleIndex);



    int getColumnWidth (int columnId) const;





    void setColumnWidth (int columnId, int newWidth);






    void setColumnVisible (int columnId, bool shouldBeVisible);




    bool isColumnVisible (int columnId) const;
# 179 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TableHeaderComponent.h"
    void setSortColumnId (int columnId, bool sortForwards);





    int getSortColumnId() const;




    bool isSortedForwards() const;
# 200 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TableHeaderComponent.h"
    void reSortTable();




    int getTotalWidth() const;
# 214 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TableHeaderComponent.h"
    int getIndexOfColumnId (int columnId, bool onlyCountVisibleColumns) const;
# 223 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TableHeaderComponent.h"
    int getColumnIdOfIndex (int index, bool onlyCountVisibleColumns) const;







    Rectangle<int> getColumnPosition (int index) const;




    int getColumnIdAtX (int xToFind) const;







    void setStretchToFitActive (bool shouldStretchToFit);




    bool isStretchToFitActive() const;







    void resizeAllColumnsToFit (int targetTotalWidth);
# 269 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TableHeaderComponent.h"
    void setPopupMenuActive (bool hasMenu);




    bool isPopupMenuActive() const;
# 284 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TableHeaderComponent.h"
    String toString() const;






    void restoreFromString (const String& storedVersion);
# 302 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TableHeaderComponent.h"
    class Listener
    {
    public:

        Listener() {}


        virtual ~Listener() {}





        virtual void tableColumnsChanged (TableHeaderComponent* tableHeader) = 0;


        virtual void tableColumnsResized (TableHeaderComponent* tableHeader) = 0;


        virtual void tableSortOrderChanged (TableHeaderComponent* tableHeader) = 0;






        virtual void tableColumnDraggingChanged (TableHeaderComponent* tableHeader,
                                                 int columnIdNowBeingDragged);
    };


    void addListener (Listener* newListener);


    void removeListener (Listener* listenerToRemove);







    virtual void columnClicked (int columnId, const ModifierKeys& mods);
# 355 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TableHeaderComponent.h"
    virtual void addMenuItems (PopupMenu& menu, int columnIdClicked);
# 366 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TableHeaderComponent.h"
    virtual void reactToMenuItem (int menuReturnId, int columnIdClicked);



    struct LookAndFeelMethods
    {
        virtual ~LookAndFeelMethods() {}

        virtual void drawTableHeaderBackground (Graphics&, TableHeaderComponent&) = 0;

        virtual void drawTableHeaderColumn (Graphics&, const String& columnName, int columnId,
                                            int width, int height,
                                            bool isMouseOver, bool isMouseDown, int columnFlags) = 0;
    };



    void paint (Graphics&) override;

    void resized() override;

    void mouseMove (const MouseEvent&) override;

    void mouseEnter (const MouseEvent&) override;

    void mouseExit (const MouseEvent&) override;

    void mouseDown (const MouseEvent&) override;

    void mouseDrag (const MouseEvent&) override;

    void mouseUp (const MouseEvent&) override;

    MouseCursor getMouseCursor() override;


    virtual void showColumnChooserMenu (int columnIdClicked);

private:
    struct ColumnInfo
    {
        String name;
        int id, propertyFlags, width, minimumWidth, maximumWidth;
        double lastDeliberateWidth;

        bool isVisible() const;
    };

    OwnedArray<ColumnInfo> columns;
    Array<Listener*> listeners;
    ScopedPointer<Component> dragOverlayComp;
    class DragOverlayComp;

    bool columnsChanged, columnsResized, sortChanged, menuActive, stretchToFit;
    int columnIdBeingResized, columnIdBeingDragged, initialColumnWidth;
    int columnIdUnderMouse, draggingColumnOffset, draggingColumnOriginalIndex, lastDeliberateWidth;

    ColumnInfo* getInfoForId (int columnId) const;
    int visibleIndexToTotalIndex (int visibleIndex) const;
    void sendColumnsChanged();
    void handleAsyncUpdate() override;
    void beginDrag (const MouseEvent&);
    void endDrag (int finalIndex);
    int getResizeDraggerAt (int mouseX) const;
    void updateColumnUnderMouse (const MouseEvent&);
    void setColumnUnderMouse (int columnId);
    void resizeColumnsToFit (int firstColumnIndex, int targetTotalWidth);

    TableHeaderComponent (const TableHeaderComponent&) = delete; TableHeaderComponent& operator= (const TableHeaderComponent&) = delete;
};


typedef TableHeaderComponent::Listener TableHeaderListener;
# 239 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TableListBox.h" 1
# 38 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TableListBox.h"
class TableListBoxModel
{
public:

    TableListBoxModel() {}


    virtual ~TableListBoxModel() {}







    virtual int getNumRows() = 0;
# 63 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TableListBox.h"
    virtual void paintRowBackground (Graphics&,
                                     int rowNumber,
                                     int width, int height,
                                     bool rowIsSelected) = 0;
# 76 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TableListBox.h"
    virtual void paintCell (Graphics&,
                            int rowNumber,
                            int columnId,
                            int width, int height,
                            bool rowIsSelected) = 0;
# 103 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TableListBox.h"
    virtual Component* refreshComponentForCell (int rowNumber, int columnId, bool isRowSelected,
                                                Component* existingComponentToUpdate);







    virtual void cellClicked (int rowNumber, int columnId, const MouseEvent&);






    virtual void cellDoubleClicked (int rowNumber, int columnId, const MouseEvent&);






    virtual void backgroundClicked (const MouseEvent&);
# 137 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TableListBox.h"
    virtual void sortOrderChanged (int newSortColumnId, bool isForwards);
# 149 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TableListBox.h"
    virtual int getColumnAutoSizeWidth (int columnId);


    virtual String getCellTooltip (int rowNumber, int columnId);





    virtual void selectedRowsChanged (int lastRowSelected);




    virtual void deleteKeyPressed (int lastRowSelected);




    virtual void returnKeyPressed (int lastRowSelected);






    virtual void listWasScrolled();
# 186 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TableListBox.h"
    virtual var getDragSourceDescription (const SparseSet<int>& currentlySelectedRows);

private:




};
# 206 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TableListBox.h"
class TableListBox : public ListBox,
                                 private ListBoxModel,
                                 private TableHeaderComponent::Listener
{
public:
# 219 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TableListBox.h"
    TableListBox (const String& componentName = String(),
                  TableListBoxModel* model = nullptr);


    ~TableListBox();






    void setModel (TableListBoxModel* newModel);


    TableListBoxModel* getModel() const noexcept { return model; }



    TableHeaderComponent& getHeader() const noexcept { return *header; }






    void setHeader (TableHeaderComponent* newHeader);




    void setHeaderHeight (int newHeight);




    int getHeaderHeight() const noexcept;
# 264 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TableListBox.h"
    void autoSizeColumn (int columnId);


    void autoSizeAllColumns();




    void setAutoSizeMenuOptionShown (bool shouldBeShown) noexcept;




    bool isAutoSizeMenuOptionShown() const noexcept { return autoSizeOptionsShown; }
# 288 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TableListBox.h"
    Rectangle<int> getCellPosition (int columnId, int rowNumber,
                                    bool relativeToComponentTopLeft) const;






    Component* getCellComponent (int columnId, int rowNumber) const;





    void scrollToEnsureColumnIsOnscreen (int columnId);



    int getNumRows() override;

    void paintListBoxItem (int, Graphics&, int, int, bool) override;

    Component* refreshComponentForRow (int rowNumber, bool isRowSelected, Component* existingComponentToUpdate) override;

    void selectedRowsChanged (int row) override;

    void deleteKeyPressed (int currentSelectedRow) override;

    void returnKeyPressed (int currentSelectedRow) override;

    void backgroundClicked (const MouseEvent&) override;

    void listWasScrolled() override;

    void tableColumnsChanged (TableHeaderComponent*) override;

    void tableColumnsResized (TableHeaderComponent*) override;

    void tableSortOrderChanged (TableHeaderComponent*) override;

    void tableColumnDraggingChanged (TableHeaderComponent*, int) override;

    void resized() override;


private:

    class Header;
    class RowComp;

    TableHeaderComponent* header;
    TableListBoxModel* model;
    int columnIdNowBeingDragged;
    bool autoSizeOptionsShown;

    void updateColumnComponents() const;

    TableListBox (const TableListBox&) = delete; TableListBox& operator= (const TableListBox&) = delete;
};
# 240 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Toolbar.h" 1
# 28 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Toolbar.h"
class ToolbarItemComponent;
class ToolbarItemFactory;
# 49 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Toolbar.h"
class Toolbar : public Component,
                            public DragAndDropContainer,
                            public DragAndDropTarget,
                            private ButtonListener
{
public:
# 64 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Toolbar.h"
    Toolbar();





    ~Toolbar();





    void setVertical (bool shouldBeVertical);





    bool isVertical() const noexcept { return vertical; }
# 91 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Toolbar.h"
    int getThickness() const noexcept;
# 100 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Toolbar.h"
    int getLength() const noexcept;




    void clear();
# 120 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Toolbar.h"
    void addItem (ToolbarItemFactory& factory,
                  int itemId,
                  int insertIndex = -1);


    void removeToolbarItem (int itemIndex);


    ToolbarItemComponent* removeAndReturnItem (int itemIndex);





    int getNumItems() const noexcept;
# 143 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Toolbar.h"
    int getItemId (int itemIndex) const noexcept;
# 152 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Toolbar.h"
    ToolbarItemComponent* getItemComponent (int itemIndex) const noexcept;






    void addDefaultItems (ToolbarItemFactory& factoryToUse);





    enum ToolbarItemStyle
    {
        iconsOnly,
        iconsWithText,
        textOnly
    };




    ToolbarItemStyle getStyle() const noexcept { return toolbarStyle; }




    void setStyle (const ToolbarItemStyle& newStyle);



    enum CustomisationFlags
    {
        allowIconsOnlyChoice = 1,

        allowIconsWithTextChoice = 2,

        allowTextOnlyChoice = 4,

        showResetToDefaultsButton = 8,


        allCustomisationOptionsEnabled = (allowIconsOnlyChoice | allowIconsWithTextChoice | allowTextOnlyChoice | showResetToDefaultsButton)
    };
# 212 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Toolbar.h"
    void showCustomisationDialog (ToolbarItemFactory& factory,
                                  int optionFlags = allCustomisationOptionsEnabled);
# 223 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Toolbar.h"
    void setEditingActive (bool editingEnabled);
# 233 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Toolbar.h"
    enum ColourIds
    {
        backgroundColourId = 0x1003200,

        separatorColourId = 0x1003210,

        buttonMouseOverBackgroundColourId = 0x1003220,

        buttonMouseDownBackgroundColourId = 0x1003230,


        labelTextColourId = 0x1003240,


        editingModeOutlineColourId = 0x1003250

    };
# 258 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Toolbar.h"
    String toString() const;
# 267 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_Toolbar.h"
    bool restoreFromString (ToolbarItemFactory& factoryToUse,
                            const String& savedVersion);



    struct LookAndFeelMethods
    {
        virtual ~LookAndFeelMethods() {}

        virtual void paintToolbarBackground (Graphics&, int width, int height, Toolbar&) = 0;

        virtual Button* createToolbarMissingItemsButton (Toolbar&) = 0;

        virtual void paintToolbarButtonBackground (Graphics&, int width, int height,
                                                   bool isMouseOver, bool isMouseDown,
                                                   ToolbarItemComponent&) = 0;

        virtual void paintToolbarButtonLabel (Graphics&, int x, int y, int width, int height,
                                              const String& text, ToolbarItemComponent&) = 0;
    };



    void paint (Graphics&) override;

    void resized() override;

    void mouseDown (const MouseEvent&) override;

    bool isInterestedInDragSource (const SourceDetails&) override;

    void itemDragMove (const SourceDetails&) override;

    void itemDragExit (const SourceDetails&) override;

    void itemDropped (const SourceDetails&) override;

    void updateAllItemPositions (bool animate);

    static ToolbarItemComponent* createItem (ToolbarItemFactory&, int itemId);

    static const char* const toolbarDragDescriptor;

private:

    ScopedPointer<Button> missingItemsButton;
    bool vertical, isEditingActive;
    ToolbarItemStyle toolbarStyle;
    class MissingItemsComponent;
    friend class MissingItemsComponent;
    OwnedArray<ToolbarItemComponent> items;
    class Spacer;
    class CustomisationDialog;

    void buttonClicked (Button*) override;
    void addItemInternal (ToolbarItemFactory& factory, int itemId, int insertIndex);

    ToolbarItemComponent* getNextActiveComponent (int index, int delta) const;

    Toolbar (const Toolbar&) = delete; Toolbar& operator= (const Toolbar&) = delete;
};
# 241 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ToolbarItemComponent.h" 1
# 47 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ToolbarItemComponent.h"
class ToolbarItemComponent : public Button
{
public:
# 60 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ToolbarItemComponent.h"
    ToolbarItemComponent (int itemId,
                          const String& labelText,
                          bool isBeingUsedAsAButton);


    ~ToolbarItemComponent();





    int getItemId() const noexcept { return itemId; }




    Toolbar* getToolbar() const;




    bool isToolbarVertical() const;






    Toolbar::ToolbarItemStyle getStyle() const noexcept { return toolbarStyle; }
# 97 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ToolbarItemComponent.h"
    virtual void setStyle (const Toolbar::ToolbarItemStyle& newStyle);
# 107 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ToolbarItemComponent.h"
    Rectangle<int> getContentArea() const noexcept { return contentArea; }
# 127 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ToolbarItemComponent.h"
    virtual bool getToolbarItemSizes (int toolbarThickness,
                                      bool isToolbarVertical,
                                      int& preferredSize,
                                      int& minSize,
                                      int& maxSize) = 0;
# 141 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ToolbarItemComponent.h"
    virtual void paintButtonArea (Graphics& g,
                                  int width, int height,
                                  bool isMouseOver, bool isMouseDown) = 0;
# 152 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ToolbarItemComponent.h"
    virtual void contentAreaChanged (const Rectangle<int>& newBounds) = 0;






    enum ToolbarEditingMode
    {
        normalMode = 0,
        editableOnToolbar,

        editableOnPalette

    };






    void setEditingMode (const ToolbarEditingMode newMode);






    ToolbarEditingMode getEditingMode() const noexcept { return mode; }




    void paintButton (Graphics&, bool isMouseOver, bool isMouseDown) override;

    void resized() override;

private:
    friend class Toolbar;
    class ItemDragAndDropOverlayComponent;
    friend class ItemDragAndDropOverlayComponent;
    const int itemId;
    ToolbarEditingMode mode;
    Toolbar::ToolbarItemStyle toolbarStyle;
    ScopedPointer<Component> overlayComp;
    int dragOffsetX, dragOffsetY;
    bool isActive, isBeingDragged, isBeingUsedAsAButton;
    Rectangle<int> contentArea;

    ToolbarItemComponent (const ToolbarItemComponent&) = delete; ToolbarItemComponent& operator= (const ToolbarItemComponent&) = delete;
};
# 242 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ToolbarItemFactory.h" 1
# 42 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ToolbarItemFactory.h"
class ToolbarItemFactory
{
public:

    ToolbarItemFactory();


    virtual ~ToolbarItemFactory();




    enum SpecialItemIds
    {
        separatorBarId = -1,

        spacerId = -2,

        flexibleSpacerId = -3

    };
# 81 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ToolbarItemFactory.h"
    virtual void getAllToolbarItemIds (Array <int>& ids) = 0;
# 91 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ToolbarItemFactory.h"
    virtual void getDefaultItemSet (Array <int>& ids) = 0;
# 104 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ToolbarItemFactory.h"
    virtual ToolbarItemComponent* createItem (int itemId) = 0;
};
# 243 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ToolbarItemPalette.h" 1
# 39 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ToolbarItemPalette.h"
class ToolbarItemPalette : public Component,
                                        public DragAndDropContainer
{
public:
# 52 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_ToolbarItemPalette.h"
    ToolbarItemPalette (ToolbarItemFactory& factory,
                        Toolbar& toolbar);


    ~ToolbarItemPalette();



    void resized() override;

private:
    ToolbarItemFactory& factory;
    Toolbar& toolbar;
    Viewport viewport;
    OwnedArray <ToolbarItemComponent> items;

    friend class Toolbar;
    void replaceComponent (ToolbarItemComponent&);
    void addComponent (int itemId, int index);

    ToolbarItemPalette (const ToolbarItemPalette&) = delete; ToolbarItemPalette& operator= (const ToolbarItemPalette&) = delete;
};
# 244 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/buttons/juce_ToolbarButton.h" 1
# 39 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/buttons/juce_ToolbarButton.h"
class ToolbarButton : public ToolbarItemComponent
{
public:
# 60 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/buttons/juce_ToolbarButton.h"
    ToolbarButton (int itemId,
                   const String& labelText,
                   Drawable* normalImage,
                   Drawable* toggledOnImage);


    ~ToolbarButton();




    bool getToolbarItemSizes (int toolbarDepth, bool isToolbarVertical, int& preferredSize,
                              int& minSize, int& maxSize) override;

    void paintButtonArea (Graphics&, int width, int height, bool isMouseOver, bool isMouseDown) override;

    void contentAreaChanged (const Rectangle<int>&) override;

    void buttonStateChanged() override;

    void resized() override;

    void enablementChanged() override;

private:

    ScopedPointer<Drawable> normalImage, toggledOnImage;
    Drawable* currentImage;

    void updateDrawable();
    Drawable* getImageToUse() const;
    void setCurrentImage (Drawable*);

    ToolbarButton (const ToolbarButton&) = delete; ToolbarButton& operator= (const ToolbarButton&) = delete;
};
# 245 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/misc/juce_DropShadower.h" 1
# 43 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/misc/juce_DropShadower.h"
class DropShadower : private ComponentListener
{
public:


    DropShadower (const DropShadow& shadowType);


    ~DropShadower();


    void setOwner (Component* componentToFollow);


private:

    class ShadowWindow;

    Component* owner;
    OwnedArray<Component> shadowWindows;
    DropShadow shadow;
    bool reentrant;
    WeakReference<Component> lastParentComp;

    void componentMovedOrResized (Component&, bool, bool) override;
    void componentBroughtToFront (Component&) override;
    void componentChildrenChanged (Component&) override;
    void componentParentHierarchyChanged (Component&) override;
    void componentVisibilityChanged (Component&) override;

    void updateParent();
    void updateShadows();

    DropShadower (const DropShadower&) = delete; DropShadower& operator= (const DropShadower&) = delete;
};
# 246 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TreeView.h" 1
# 28 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TreeView.h"
class TreeView;
# 45 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TreeView.h"
class TreeViewItem
{
public:


    TreeViewItem();


    virtual ~TreeViewItem();
# 62 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TreeView.h"
    int getNumSubItems() const noexcept;
# 71 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TreeView.h"
    TreeViewItem* getSubItem (int index) const noexcept;


    void clearSubItems();
# 84 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TreeView.h"
    void addSubItem (TreeViewItem* newItem, int insertPosition = -1);
# 94 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TreeView.h"
    template <class ElementComparator>
    void addSubItemSorted (ElementComparator& comparator, TreeViewItem* newItem)
    {
        addSubItem (newItem, findInsertIndexInSortedArray (comparator, subItems.begin(), newItem, 0, subItems.size()));
    }






    void removeSubItem (int index, bool deleteItem = true);
# 122 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TreeView.h"
    template <class ElementComparator>
    void sortSubItems (ElementComparator& comparator)
    {
        subItems.sort (comparator);
    }



    TreeView* getOwnerView() const noexcept { return ownerView; }


    TreeViewItem* getParentItem() const noexcept { return parentItem; }





    bool isOpen() const noexcept;
# 154 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TreeView.h"
    void setOpen (bool shouldBeOpen);


    enum Openness
    {
        opennessDefault = 0,
        opennessClosed = 1,
        opennessOpen = 2
    };




    Openness getOpenness() const noexcept;
# 177 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TreeView.h"
    void setOpenness (Openness newOpenness);




    bool isSelected() const noexcept;





    void setSelected (bool shouldBeSelected,
                      bool deselectOtherItemsFirst,
                      NotificationType shouldNotify = sendNotification);
# 199 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TreeView.h"
    Rectangle<int> getItemPosition (bool relativeToTreeViewTopLeft) const noexcept;




    void treeHasChanged() const noexcept;






    void repaintItem() const;





    int getRowNumberInTree() const noexcept;




    bool areAllParentsOpen() const noexcept;




    void setLinesDrawnForSubItems (bool shouldDrawLines) noexcept;
# 236 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TreeView.h"
    virtual bool mightContainSubItems() = 0;
# 248 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TreeView.h"
    virtual String getUniqueName() const;
# 270 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TreeView.h"
    virtual void itemOpennessChanged (bool isNowOpen);
# 285 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TreeView.h"
    virtual int getItemWidth() const { return -1; }







    virtual int getItemHeight() const { return 20; }




    virtual bool canBeSelected() const { return true; }
# 324 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TreeView.h"
    virtual Component* createItemComponent() { return nullptr; }
# 342 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TreeView.h"
    virtual void paintItem (Graphics& g, int width, int height);
# 352 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TreeView.h"
    virtual void paintOpenCloseButton (Graphics&, const Rectangle<float>& area,
                                       Colour backgroundColour, bool isMouseOver);


    virtual void paintHorizontalConnectingLine (Graphics&, const Line<float>& line);


    virtual void paintVerticalConnectingLine (Graphics&, const Line<float>& line);
# 372 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TreeView.h"
    virtual void itemClicked (const MouseEvent& e);
# 388 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TreeView.h"
    virtual void itemDoubleClicked (const MouseEvent& e);






    virtual void itemSelectionChanged (bool isNowSelected);


    virtual void ownerViewChanged (TreeView* newOwner);




    virtual String getTooltip();
# 421 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TreeView.h"
    virtual var getDragSourceDescription();
# 435 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TreeView.h"
    virtual bool isInterestedInFileDrag (const StringArray& files);
# 445 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TreeView.h"
    virtual void filesDropped (const StringArray& files, int insertIndex);
# 454 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TreeView.h"
    virtual bool isInterestedInDragSource (const DragAndDropTarget::SourceDetails& dragSourceDetails);
# 464 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TreeView.h"
    virtual void itemDropped (const DragAndDropTarget::SourceDetails& dragSourceDetails, int insertIndex);
# 480 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TreeView.h"
    void setDrawsInLeftMargin (bool canDrawInLeftMargin) noexcept;
# 493 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TreeView.h"
    void setDrawsInRightMargin (bool canDrawInRightMargin) noexcept;
# 516 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TreeView.h"
    XmlElement* getOpennessState() const;
# 528 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TreeView.h"
    void restoreOpennessState (const XmlElement& xml);



    int getIndexInParent() const noexcept;


    bool isLastOfSiblings() const noexcept;
# 544 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TreeView.h"
    String getItemIdentifierString() const;
# 568 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TreeView.h"
    class OpennessRestorer
    {
    public:
        OpennessRestorer (TreeViewItem& treeViewItem);
        ~OpennessRestorer();

    private:
        TreeViewItem& treeViewItem;
        ScopedPointer<XmlElement> oldOpenness;

        OpennessRestorer (const OpennessRestorer&) = delete; OpennessRestorer& operator= (const OpennessRestorer&) = delete;
    };

private:

    TreeView* ownerView;
    TreeViewItem* parentItem;
    OwnedArray<TreeViewItem> subItems;
    int y, itemHeight, totalHeight, itemWidth, totalWidth;
    int uid;
    bool selected : 1;
    bool redrawNeeded : 1;
    bool drawLinesInside : 1;
    bool drawLinesSet : 1;
    bool drawsInLeftMargin : 1;
    bool drawsInRightMargin : 1;
    unsigned int openness : 2;

    friend class TreeView;

    void updatePositions (int newY);
    int getIndentX() const noexcept;
    void setOwnerView (TreeView*) noexcept;
    void paintRecursively (Graphics&, int width);
    TreeViewItem* getTopLevelItem() noexcept;
    TreeViewItem* findItemRecursively (int y) noexcept;
    TreeViewItem* getDeepestOpenParentItem() noexcept;
    int getNumRows() const noexcept;
    TreeViewItem* getItemOnRow (int index) noexcept;
    void deselectAllRecursively (TreeViewItem* itemToIgnore);
    int countSelectedItemsRecursively (int depth) const noexcept;
    TreeViewItem* getSelectedItemWithIndex (int index) noexcept;
    TreeViewItem* getNextVisibleItem (bool recurse) const noexcept;
    TreeViewItem* findItemFromIdentifierString (const String&);
    void restoreToDefaultOpenness();
    bool isFullyOpen() const noexcept;
    XmlElement* getOpennessState (bool canReturnNull) const;
    bool removeSubItemFromList (int index, bool deleteItem);
    void removeAllSubItemsFromList();
    bool areLinesDrawn() const;







    TreeViewItem (const TreeViewItem&) = delete; TreeViewItem& operator= (const TreeViewItem&) = delete;
};
# 636 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TreeView.h"
class TreeView : public Component,
                            public SettableTooltipClient,
                            public FileDragAndDropTarget,
                            public DragAndDropTarget
{
public:






    TreeView (const String& componentName = String());


    ~TreeView();
# 668 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TreeView.h"
    void setRootItem (TreeViewItem* newRootItem);





    TreeViewItem* getRootItem() const noexcept { return rootItem; }




    void deleteRootItem();







    void setRootItemVisible (bool shouldBeVisible);





    bool isRootItemVisible() const noexcept { return rootItemVisible; }
# 702 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TreeView.h"
    void setDefaultOpenness (bool isOpenByDefault);





    bool areItemsOpenByDefault() const noexcept { return defaultOpenness; }
# 720 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TreeView.h"
    void setMultiSelectEnabled (bool canMultiSelect);





    bool isMultiSelectEnabled() const noexcept { return multiSelectEnabled; }





    void setOpenCloseButtonsVisible (bool shouldBeVisible);





    bool areOpenCloseButtonsVisible() const noexcept { return openCloseButtonsVisible; }



    void clearSelectedItems();






    int getNumSelectedItems (int maximumDepthToSearchTo = -1) const noexcept;




    TreeViewItem* getSelectedItem (int index) const noexcept;


    void moveSelectedRow (int deltaRows);






    int getNumRowsInTree() const;





    TreeViewItem* getItemOnRow (int index) const;




    TreeViewItem* getItemAt (int yPosition) const noexcept;


    void scrollToKeepItemVisible (TreeViewItem* item);


    Viewport* getViewport() const noexcept;




    int getIndentSize() noexcept;




    void setIndentSize (int newIndentSize);






    TreeViewItem* findItemFromIdentifierString (const String& identifierString) const;
# 818 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TreeView.h"
    XmlElement* getOpennessState (bool alsoIncludeScrollPosition) const;
# 831 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TreeView.h"
    void restoreOpennessState (const XmlElement& newState,
                               bool restoreStoredSelection);
# 842 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/widgets/juce_TreeView.h"
    enum ColourIds
    {
        backgroundColourId = 0x1000500,
        linesColourId = 0x1000501,
        dragAndDropIndicatorColourId = 0x1000502,
        selectedItemBackgroundColourId = 0x1000503,
        oddItemsColourId = 0x1000504,
        evenItemsColourId = 0x1000505
    };





    struct LookAndFeelMethods
    {
        virtual ~LookAndFeelMethods() {}

        virtual void drawTreeviewPlusMinusBox (Graphics&, const Rectangle<float>& area,
                                               Colour backgroundColour, bool isItemOpen, bool isMouseOver) = 0;

        virtual bool areLinesDrawnForTreeView (TreeView&) = 0;
        virtual int getTreeViewIndentSize (TreeView&) = 0;
    };



    void paint (Graphics&) override;

    void resized() override;

    bool keyPressed (const KeyPress&) override;

    void colourChanged() override;

    void enablementChanged() override;

    bool isInterestedInFileDrag (const StringArray& files) override;

    void fileDragEnter (const StringArray& files, int x, int y) override;

    void fileDragMove (const StringArray& files, int x, int y) override;

    void fileDragExit (const StringArray& files) override;

    void filesDropped (const StringArray& files, int x, int y) override;

    bool isInterestedInDragSource (const SourceDetails&) override;

    void itemDragEnter (const SourceDetails&) override;

    void itemDragMove (const SourceDetails&) override;

    void itemDragExit (const SourceDetails&) override;

    void itemDropped (const SourceDetails&) override;

private:
    class ContentComponent;
    class TreeViewport;
    class InsertPointHighlight;
    class TargetGroupHighlight;
    friend class TreeViewItem;
    friend class ContentComponent;
    friend struct ContainerDeletePolicy<TreeViewport>;
    friend struct ContainerDeletePolicy<InsertPointHighlight>;
    friend struct ContainerDeletePolicy<TargetGroupHighlight>;

    ScopedPointer<TreeViewport> viewport;
    CriticalSection nodeAlterationLock;
    TreeViewItem* rootItem;
    ScopedPointer<InsertPointHighlight> dragInsertPointHighlight;
    ScopedPointer<TargetGroupHighlight> dragTargetGroupHighlight;
    int indentSize;
    bool defaultOpenness, needsRecalculating, rootItemVisible;
    bool multiSelectEnabled, openCloseButtonsVisible;

    void itemsChanged() noexcept;
    void recalculateIfNeeded();
    void updateButtonUnderMouse (const MouseEvent&);
    struct InsertPoint;
    void showDragHighlight (const InsertPoint&) noexcept;
    void hideDragHighlight() noexcept;
    void handleDrag (const StringArray&, const SourceDetails&);
    void handleDrop (const StringArray&, const SourceDetails&);
    bool toggleOpenSelectedItem();
    void moveOutOfSelectedItem();
    void moveIntoSelectedItem();
    void moveByPages (int numPages);






    TreeView (const TreeView&) = delete; TreeView& operator= (const TreeView&) = delete;
};
# 247 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_TopLevelWindow.h" 1
# 51 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_TopLevelWindow.h"
class TopLevelWindow : public Component
{
public:







    TopLevelWindow (const String& name, bool addToDesktop);


    ~TopLevelWindow();
# 75 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_TopLevelWindow.h"
    bool isActiveWindow() const noexcept { return isCurrentlyActive; }
# 89 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_TopLevelWindow.h"
    void centreAroundComponent (Component* componentToCentreAround,
                                int width, int height);



    void setDropShadowEnabled (bool useShadow);


    bool isDropShadowEnabled() const noexcept { return useDropShadow; }




    void setUsingNativeTitleBar (bool useNativeTitleBar);




    bool isUsingNativeTitleBar() const noexcept;





    static int getNumTopLevelWindows() noexcept;




    static TopLevelWindow* getTopLevelWindow (int index) noexcept;




    static TopLevelWindow* getActiveTopLevelWindow() noexcept;


    void addToDesktop();



    void addToDesktop (int windowStyleFlags, void* nativeWindowToAttachTo = nullptr) override;

protected:




    virtual void activeWindowStatusChanged();




    void focusOfChildComponentChanged (FocusChangeType) override;

    void parentHierarchyChanged() override;

    virtual int getDesktopWindowStyleFlags() const;

    void recreateDesktopWindow();

    void visibilityChanged() override;

private:
    friend class TopLevelWindowManager;
    friend class ResizableWindow;
    bool useDropShadow, useNativeTitleBar, isCurrentlyActive;
    ScopedPointer<DropShadower> shadower;

    void setWindowActive (bool);

    TopLevelWindow (const TopLevelWindow&) = delete; TopLevelWindow& operator= (const TopLevelWindow&) = delete;
};
# 248 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_AlertWindow.h" 1
# 42 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_AlertWindow.h"
class AlertWindow : public TopLevelWindow,
                               private ButtonListener
{
public:


    enum AlertIconType
    {
        NoIcon,
        QuestionIcon,

        WarningIcon,

        InfoIcon


    };
# 71 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_AlertWindow.h"
    AlertWindow (const String& title,
                 const String& message,
                 AlertIconType iconType,
                 Component* associatedComponent = nullptr);


    ~AlertWindow();




    AlertIconType getAlertType() const noexcept { return alertIconType; }






    void setMessage (const String& message);
# 100 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_AlertWindow.h"
    void addButton (const String& name,
                    int returnValue,
                    const KeyPress& shortcutKey1 = KeyPress(),
                    const KeyPress& shortcutKey2 = KeyPress());


    int getNumButtons() const;


    void triggerButtonClick (const String& buttonName);







    void setEscapeKeyCancels (bool shouldEscapeKeyCancel);
# 132 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_AlertWindow.h"
    void addTextEditor (const String& name,
                        const String& initialContents,
                        const String& onScreenLabel = String(),
                        bool isPasswordBox = false);
# 145 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_AlertWindow.h"
    String getTextEditorContents (const String& nameOfTextEditor) const;


    TextEditor* getTextEditor (const String& nameOfTextEditor) const;
# 162 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_AlertWindow.h"
    void addComboBox (const String& name,
                      const StringArray& items,
                      const String& onScreenLabel = String());







    ComboBox* getComboBoxComponent (const String& nameOfList) const;







    void addTextBlock (const String& text);
# 189 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_AlertWindow.h"
    void addProgressBarComponent (double& progressValue);
# 198 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_AlertWindow.h"
    void addCustomComponent (Component* component);




    int getNumCustomComponents() const;







    Component* getCustomComponent (int index) const;
# 221 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_AlertWindow.h"
    Component* removeCustomComponent (int index);



    bool containsAnyExtraComponents() const;
# 246 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_AlertWindow.h"
    static void __stdcall showMessageBox (AlertIconType iconType,
                                              const String& title,
                                              const String& message,
                                              const String& buttonText = String(),
                                              Component* associatedComponent = nullptr);
# 274 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_AlertWindow.h"
    static void __stdcall showMessageBoxAsync (AlertIconType iconType,
                                                   const String& title,
                                                   const String& message,
                                                   const String& buttonText = String(),
                                                   Component* associatedComponent = nullptr,
                                                   ModalComponentManager::Callback* callback = nullptr);
# 316 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_AlertWindow.h"
    static bool __stdcall showOkCancelBox (AlertIconType iconType,
                                               const String& title,
                                               const String& message,

                                               const String& button1Text = String(),
                                               const String& button2Text = String(),
                                               Component* associatedComponent = nullptr,
                                               ModalComponentManager::Callback* callback = nullptr);
# 370 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_AlertWindow.h"
    static int __stdcall showYesNoCancelBox (AlertIconType iconType,
                                                 const String& title,
                                                 const String& message,

                                                 const String& button1Text = String(),
                                                 const String& button2Text = String(),
                                                 const String& button3Text = String(),
                                                 Component* associatedComponent = nullptr,
                                                 ModalComponentManager::Callback* callback = nullptr);
# 397 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_AlertWindow.h"
    static bool __stdcall showNativeDialogBox (const String& title,
                                                   const String& bodyText,
                                                   bool isOkCancel);
# 411 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_AlertWindow.h"
    enum ColourIds
    {
        backgroundColourId = 0x1001800,
        textColourId = 0x1001810,
        outlineColourId = 0x1001820
    };





    struct LookAndFeelMethods
    {
        virtual ~LookAndFeelMethods() {}

        virtual AlertWindow* createAlertWindow (const String& title, const String& message,
                                                const String& button1,
                                                const String& button2,
                                                const String& button3,
                                                AlertWindow::AlertIconType iconType,
                                                int numButtons,
                                                Component* associatedComponent) = 0;

        virtual void drawAlertBox (Graphics&, AlertWindow&, const Rectangle<int>& textArea, TextLayout&) = 0;

        virtual int getAlertBoxWindowFlags() = 0;

        virtual Array<int> getWidthsForTextButtons (AlertWindow&, const Array<TextButton*>&) = 0;
        virtual int getAlertWindowButtonHeight() = 0;

        virtual Font getAlertWindowTitleFont() = 0;
        virtual Font getAlertWindowMessageFont() = 0;
        virtual Font getAlertWindowFont() = 0;
    };

protected:


    void paint (Graphics&) override;

    void mouseDown (const MouseEvent&) override;

    void mouseDrag (const MouseEvent&) override;

    bool keyPressed (const KeyPress&) override;

    void buttonClicked (Button*) override;

    void lookAndFeelChanged() override;

    void userTriedToCloseWindow() override;

    int getDesktopWindowStyleFlags() const override;

private:

    String text;
    TextLayout textLayout;
    AlertIconType alertIconType;
    ComponentBoundsConstrainer constrainer;
    ComponentDragger dragger;
    Rectangle<int> textArea;
    OwnedArray<TextButton> buttons;
    OwnedArray<TextEditor> textBoxes;
    OwnedArray<ComboBox> comboBoxes;
    OwnedArray<ProgressBar> progressBars;
    Array<Component*> customComps;
    OwnedArray<Component> textBlocks;
    Array<Component*> allComps;
    StringArray textboxNames, comboBoxNames;
    Component* associatedComponent;
    bool escapeKeyCancels;

    void updateLayout (bool onlyIncreaseSize);

    AlertWindow (const AlertWindow&) = delete; AlertWindow& operator= (const AlertWindow&) = delete;
};
# 249 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_CallOutBox.h" 1
# 56 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_CallOutBox.h"
class CallOutBox : public Component,
                                private Timer
{
public:
# 74 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_CallOutBox.h"
    CallOutBox (Component& contentComponent,
                const Rectangle<int>& areaToPointTo,
                Component* parentComponent);


    ~CallOutBox();



    void setArrowSize (float newSize);
# 93 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_CallOutBox.h"
    void updatePosition (const Rectangle<int>& newAreaToPointTo,
                         const Rectangle<int>& newAreaToFitIn);
# 118 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_CallOutBox.h"
    static CallOutBox& launchAsynchronously (Component* contentComponent,
                                             const Rectangle<int>& areaToPointTo,
                                             Component* parentComponent);




    void dismiss();
# 135 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_CallOutBox.h"
    void setDismissalMouseClicksAreAlwaysConsumed (bool shouldAlwaysBeConsumed) noexcept;



    struct LookAndFeelMethods
    {
        virtual ~LookAndFeelMethods() {}

        virtual void drawCallOutBoxBackground (CallOutBox&, Graphics&, const Path&, Image&) = 0;
        virtual int getCallOutBoxBorderSize (const CallOutBox&) = 0;
    };



    void paint (Graphics&) override;

    void resized() override;

    void moved() override;

    void childBoundsChanged (Component*) override;

    bool hitTest (int x, int y) override;

    void inputAttemptWhenModal() override;

    bool keyPressed (const KeyPress&) override;

    void handleCommandMessage (int) override;

    int getBorderSize() const noexcept;

private:

    float arrowSize;
    Component& content;
    Path outline;
    Point<float> targetPoint;
    Rectangle<int> availableArea, targetArea;
    Image background;
    bool dismissalMouseClicksAreAlwaysConsumed;

    Time creationTime;

    void refreshPath();
    void timerCallback() override;

    CallOutBox (const CallOutBox&) = delete; CallOutBox& operator= (const CallOutBox&) = delete;
};
# 250 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_ComponentPeer.h" 1
# 41 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_ComponentPeer.h"
class ComponentPeer
{
public:


    enum StyleFlags
    {
        windowAppearsOnTaskbar = (1 << 0),

        windowIsTemporary = (1 << 1),

        windowIgnoresMouseClicks = (1 << 2),

        windowHasTitleBar = (1 << 3),


        windowIsResizable = (1 << 4),
        windowHasMinimiseButton = (1 << 5),

        windowHasMaximiseButton = (1 << 6),

        windowHasCloseButton = (1 << 7),

        windowHasDropShadow = (1 << 8),

        windowRepaintedExplictly = (1 << 9),


        windowIgnoresKeyPresses = (1 << 10),


        windowIsSemiTransparent = (1 << 31)

    };







    ComponentPeer (Component& component, int styleFlags);


    virtual ~ComponentPeer();



    Component& getComponent() noexcept { return component; }




    int getStyleFlags() const noexcept { return styleFlags; }




    uint32 getUniqueID() const noexcept { return uniqueID; }







    virtual void* getNativeHandle() const = 0;


    virtual void setVisible (bool shouldBeVisible) = 0;


    virtual void setTitle (const String& title) = 0;







    virtual bool setDocumentEditedStatus (bool edited);






    virtual void setRepresentedFile (const File&);
# 138 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_ComponentPeer.h"
    virtual void setBounds (const Rectangle<int>& newBounds, bool isNowFullScreen) = 0;


    void updateBounds();






    virtual Rectangle<int> getBounds() const = 0;


    virtual Point<float> localToGlobal (Point<float> relativePosition) = 0;


    virtual Point<float> globalToLocal (Point<float> screenPosition) = 0;


    Point<int> localToGlobal (Point<int> relativePosition);


    Point<int> globalToLocal (Point<int> screenPosition);


    virtual Rectangle<int> localToGlobal (const Rectangle<int>& relativePosition);


    virtual Rectangle<int> globalToLocal (const Rectangle<int>& screenPosition);




    Rectangle<int> getAreaCoveredBy (Component& subComponent) const;


    virtual void setMinimised (bool shouldBeMinimised) = 0;


    virtual bool isMinimised() const = 0;


    virtual void setFullScreen (bool shouldBeFullScreen) = 0;


    virtual bool isFullScreen() const = 0;


    virtual bool isKioskMode() const;


    void setNonFullScreenBounds (const Rectangle<int>& newBounds) noexcept;


    const Rectangle<int>& getNonFullScreenBounds() const noexcept;


    virtual void setIcon (const Image& newIcon) = 0;




    void setConstrainer (ComponentBoundsConstrainer* newConstrainer) noexcept;


    ComponentBoundsConstrainer* getConstrainer() const noexcept { return constrainer; }







    virtual bool contains (Point<int> localPos, bool trueIfInAChildWindow) const = 0;





    virtual BorderSize<int> getFrameSize() const = 0;





    void handleMovedOrResized();





    virtual void handleScreenSizeChange();



    void handlePaint (LowLevelGraphicsContext& contextToPaintTo);





    virtual bool setAlwaysOnTop (bool alwaysOnTop) = 0;


    virtual void toFront (bool makeActive) = 0;


    virtual void toBehind (ComponentPeer* other) = 0;




    void handleBroughtToFront();



    virtual bool isFocused() const = 0;


    virtual void grabFocus() = 0;


    void handleFocusGain();

    void handleFocusLoss();

    Component* getLastFocusedSubcomponent() const noexcept;





    bool handleKeyPress (int keyCode, juce_wchar textCharacter);




    bool handleKeyPress (const KeyPress& key);




    bool handleKeyUpOrDown (bool isKeyDown);


    void handleModifierKeysChange();






    virtual void textInputRequired (Point<int> position, TextInputTarget&) = 0;


    virtual void dismissPendingTextInput();


    TextInputTarget* findCurrentTextInputTarget();



    virtual void repaint (const Rectangle<int>& area) = 0;







    virtual void performAnyPendingRepaintsNow() = 0;


    virtual void setAlpha (float newAlpha) = 0;


    void handleMouseEvent (int touchIndex, Point<float> positionWithinPeer, ModifierKeys newMods, float pressure, int64 time);
    void handleMouseWheel (int touchIndex, Point<float> positionWithinPeer, int64 time, const MouseWheelDetails&);
    void handleMagnifyGesture (int touchIndex, Point<float> positionWithinPeer, int64 time, float scaleFactor);

    void handleUserClosingWindow();

    struct DragInfo
    {
        StringArray files;
        String text;
        Point<int> position;

        bool isEmpty() const noexcept { return files.size() == 0 && text.isEmpty(); }
        void clear() noexcept { files.clear(); text.clear(); }
    };

    bool handleDragMove (const DragInfo&);
    bool handleDragExit (const DragInfo&);
    bool handleDragDrop (const DragInfo&);





    static int getNumPeers() noexcept;




    static ComponentPeer* getPeer (int index) noexcept;


    static ComponentPeer* getPeerFor (const Component*) noexcept;




    static bool isValidPeer (const ComponentPeer* peer) noexcept;


    virtual StringArray getAvailableRenderingEngines() = 0;
    virtual int getCurrentRenderingEngine() const;
    virtual void setCurrentRenderingEngine (int index);

protected:

    Component& component;
    const int styleFlags;
    Rectangle<int> lastNonFullscreenBounds;
    ComponentBoundsConstrainer* constrainer;

private:

    WeakReference<Component> lastFocusedComponent, dragAndDropTargetComponent;
    Component* lastDragAndDropCompUnderMouse;
    const uint32 uniqueID;
    bool isWindowMinimised;
    Component* getTargetForKeyPress();

    ComponentPeer (const ComponentPeer&) = delete; ComponentPeer& operator= (const ComponentPeer&) = delete;
};
# 251 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_ResizableWindow.h" 1
# 49 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_ResizableWindow.h"
class ResizableWindow : public TopLevelWindow
{
public:
# 62 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_ResizableWindow.h"
    ResizableWindow (const String& name,
                     bool addToDesktop);
# 72 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_ResizableWindow.h"
    ResizableWindow (const String& name,
                     Colour backgroundColour,
                     bool addToDesktop);




    ~ResizableWindow();
# 91 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_ResizableWindow.h"
    Colour getBackgroundColour() const noexcept;
# 108 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_ResizableWindow.h"
    void setBackgroundColour (Colour newColour);
# 119 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_ResizableWindow.h"
    void setResizable (bool shouldBeResizable,
                       bool useBottomRightCornerResizer);




    bool isResizable() const noexcept;
# 138 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_ResizableWindow.h"
    void setResizeLimits (int newMinimumWidth,
                          int newMinimumHeight,
                          int newMaximumWidth,
                          int newMaximumHeight) noexcept;


    void setDraggable (bool shouldBeDraggable) noexcept;


    bool isDraggable() const noexcept { return canDrag; }




    ComponentBoundsConstrainer* getConstrainer() noexcept { return constrainer; }
# 161 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_ResizableWindow.h"
    void setConstrainer (ComponentBoundsConstrainer* newConstrainer);





    void setBoundsConstrained (const Rectangle<int>& newBounds);






    bool isFullScreen() const;
# 183 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_ResizableWindow.h"
    void setFullScreen (bool shouldBeFullScreen);




    bool isMinimised() const;
# 197 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_ResizableWindow.h"
    void setMinimised (bool shouldMinimise);




    bool isKioskMode() const;
# 215 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_ResizableWindow.h"
    String getWindowStateAsString();
# 226 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_ResizableWindow.h"
    bool restoreWindowStateFromString (const String& previousState);
# 237 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_ResizableWindow.h"
    Component* getContentComponent() const noexcept { return contentComponent; }
# 255 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_ResizableWindow.h"
    void setContentOwned (Component* newContentComponent,
                          bool resizeToFitWhenContentChangesSize);
# 274 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_ResizableWindow.h"
    void setContentNonOwned (Component* newContentComponent,
                             bool resizeToFitWhenContentChangesSize);





    void clearContentComponent();






    void setContentComponentSize (int width, int height);




    virtual BorderSize<int> getBorderThickness();




    virtual BorderSize<int> getContentComponentBorder();
# 308 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_ResizableWindow.h"
    enum ColourIds
    {
        backgroundColourId = 0x1005700,
    };



    __declspec(deprecated) void setContentComponent (Component* newContentComponent, bool deleteOldOne = true, bool resizeToFit = false);


    using TopLevelWindow::addToDesktop;





    struct LookAndFeelMethods
    {
        virtual ~LookAndFeelMethods() {}


        virtual void drawCornerResizer (Graphics&, int w, int h, bool isMouseOver, bool isMouseDragging) = 0;
        virtual void drawResizableFrame (Graphics&, int w, int h, const BorderSize<int>&) = 0;

        virtual void fillResizableWindowBackground (Graphics&, int w, int h, const BorderSize<int>&, ResizableWindow&) = 0;
        virtual void drawResizableWindowBorder (Graphics&, int w, int h, const BorderSize<int>& border, ResizableWindow&) = 0;
    };

protected:

    void paint (Graphics&) override;

    void moved() override;

    void resized() override;

    void mouseDown (const MouseEvent&) override;

    void mouseDrag (const MouseEvent&) override;

    void mouseUp (const MouseEvent&) override;

    void lookAndFeelChanged() override;

    void childBoundsChanged (Component*) override;

    void parentSizeChanged() override;

    void visibilityChanged() override;

    void activeWindowStatusChanged() override;

    int getDesktopWindowStyleFlags() const override;
# 379 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_ResizableWindow.h"
    ScopedPointer<ResizableCornerComponent> resizableCorner;
    ScopedPointer<ResizableBorderComponent> resizableBorder;

private:

    Component::SafePointer<Component> contentComponent;
    bool ownsContentComponent, resizeToFitContent, fullscreen, canDrag, dragStarted;
    ComponentDragger dragger;
    Rectangle<int> lastNonFullScreenPos;
    ComponentBoundsConstrainer defaultConstrainer;
    ComponentBoundsConstrainer* constrainer;




    void initialise (bool addToDesktop);
    void updateLastPosIfNotFullScreen();
    void updateLastPosIfShowing();
    void setContent (Component*, bool takeOwnership, bool resizeToFit);
    void updatePeerConstrainer();







    ResizableWindow (const ResizableWindow&) = delete; ResizableWindow& operator= (const ResizableWindow&) = delete;
};
# 252 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_DocumentWindow.h" 1
# 52 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_DocumentWindow.h"
class DocumentWindow : public ResizableWindow
{
public:





    enum TitleBarButtons
    {
        minimiseButton = 1,
        maximiseButton = 2,
        closeButton = 4,


        allButtons = 7
    };
# 87 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_DocumentWindow.h"
    DocumentWindow (const String& name,
                    Colour backgroundColour,
                    int requiredButtons,
                    bool addToDesktop = true);




    ~DocumentWindow();







    void setName (const String& newName) override;







    void setIcon (const Image& imageToUse);


    void setTitleBarHeight (int newHeight);


    int getTitleBarHeight() const;
# 128 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_DocumentWindow.h"
    void setTitleBarButtonsRequired (int requiredButtons,
                                     bool positionTitleBarButtonsOnLeft);






    void setTitleBarTextCentred (bool textShouldBeCentred);
# 150 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_DocumentWindow.h"
    void setMenuBar (MenuBarModel* menuBarModel,
                     int menuBarHeight = 0);





    Component* getMenuBarComponent() const noexcept;




    void setMenuBarComponent (Component* newMenuBarComponent);
# 185 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_DocumentWindow.h"
    virtual void closeButtonPressed();






    virtual void minimiseButtonPressed();







    virtual void maximiseButtonPressed();



    Button* getCloseButton() const noexcept;


    Button* getMinimiseButton() const noexcept;


    Button* getMaximiseButton() const noexcept;
# 220 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_DocumentWindow.h"
    enum ColourIds
    {
        textColourId = 0x1005701,

    };





    struct LookAndFeelMethods
    {
        virtual ~LookAndFeelMethods() {}

        virtual void drawDocumentWindowTitleBar (DocumentWindow&,
                                                 Graphics&, int w, int h,
                                                 int titleSpaceX, int titleSpaceW,
                                                 const Image* icon,
                                                 bool drawTitleTextOnLeft) = 0;

        virtual Button* createDocumentWindowButton (int buttonType) = 0;

        virtual void positionDocumentWindowButtons (DocumentWindow&,
                                                    int titleBarX, int titleBarY, int titleBarW, int titleBarH,
                                                    Button* minimiseButton,
                                                    Button* maximiseButton,
                                                    Button* closeButton,
                                                    bool positionTitleBarButtonsOnLeft) = 0;
    };




    void paint (Graphics&) override;

    void resized() override;

    void lookAndFeelChanged() override;

    BorderSize<int> getBorderThickness() override;

    BorderSize<int> getContentComponentBorder() override;

    void mouseDoubleClick (const MouseEvent&) override;

    void userTriedToCloseWindow() override;

    void activeWindowStatusChanged() override;

    int getDesktopWindowStyleFlags() const override;

    void parentHierarchyChanged() override;

    Rectangle<int> getTitleBarArea();


private:

    int titleBarHeight, menuBarHeight, requiredButtons;
    bool positionTitleBarButtonsOnLeft, drawTitleTextCentred;
    ScopedPointer<Button> titleBarButtons [3];
    Image titleBarIcon;
    ScopedPointer<Component> menuBar;
    MenuBarModel* menuBarModel;

    class ButtonListenerProxy;
    friend struct ContainerDeletePolicy<ButtonListenerProxy>;
    ScopedPointer<ButtonListenerProxy> buttonListener;

    void repaintTitleBar();

    DocumentWindow (const DocumentWindow&) = delete; DocumentWindow& operator= (const DocumentWindow&) = delete;
};
# 253 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_DialogWindow.h" 1
# 49 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_DialogWindow.h"
class DialogWindow : public DocumentWindow
{
public:
# 64 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_DialogWindow.h"
    DialogWindow (const String& name,
                  Colour backgroundColour,
                  bool escapeKeyTriggersCloseButton,
                  bool addToDesktop = true);




    ~DialogWindow();
# 81 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_DialogWindow.h"
    struct LaunchOptions
    {
        LaunchOptions() noexcept;


        String dialogTitle;


        Colour dialogBackgroundColour;






        OptionalScopedPointer<Component> content;





        Component* componentToCentreAround;


        bool escapeKeyTriggersCloseButton;

        bool useNativeTitleBar;

        bool resizable;

        bool useBottomRightCornerResizer;
# 129 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_DialogWindow.h"
        DialogWindow* launchAsync();





        DialogWindow* create();
# 144 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_DialogWindow.h"
        int runModal();

    };
# 186 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_DialogWindow.h"
    static void showDialog (const String& dialogTitle,
                            Component* contentComponent,
                            Component* componentToCentreAround,
                            Colour backgroundColour,
                            bool escapeKeyTriggersCloseButton,
                            bool shouldBeResizable = false,
                            bool useBottomRightCornerResizer = false);
# 232 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_DialogWindow.h"
    static int showModalDialog (const String& dialogTitle,
                                Component* contentComponent,
                                Component* componentToCentreAround,
                                Colour backgroundColour,
                                bool escapeKeyTriggersCloseButton,
                                bool shouldBeResizable = false,
                                bool useBottomRightCornerResizer = false);







    virtual bool escapeKeyPressed();

protected:


    void resized() override;

    bool keyPressed (const KeyPress&) override;

private:
    bool escapeKeyTriggersCloseButton;

    DialogWindow (const DialogWindow&) = delete; DialogWindow& operator= (const DialogWindow&) = delete;
};
# 254 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_NativeMessageBox.h" 1
# 32 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_NativeMessageBox.h"
class NativeMessageBox
{
public:
# 48 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_NativeMessageBox.h"
    static void __stdcall showMessageBox (AlertWindow::AlertIconType iconType,
                                              const String& title,
                                              const String& message,
                                              Component* associatedComponent = nullptr);
# 71 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_NativeMessageBox.h"
    static void __stdcall showMessageBoxAsync (AlertWindow::AlertIconType iconType,
                                                    const String& title,
                                                    const String& message,
                                                    Component* associatedComponent = nullptr,
                                                    ModalComponentManager::Callback* callback = nullptr);
# 105 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_NativeMessageBox.h"
    static bool __stdcall showOkCancelBox (AlertWindow::AlertIconType iconType,
                                               const String& title,
                                               const String& message,

                                               Component* associatedComponent = nullptr,
                                               ModalComponentManager::Callback* callback = nullptr);
# 148 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_NativeMessageBox.h"
    static int __stdcall showYesNoCancelBox (AlertWindow::AlertIconType iconType,
                                                 const String& title,
                                                 const String& message,

                                                 Component* associatedComponent = nullptr,
                                                 ModalComponentManager::Callback* callback = nullptr);





private:
    NativeMessageBox() = delete;
    NativeMessageBox (const NativeMessageBox&) = delete; NativeMessageBox& operator= (const NativeMessageBox&) = delete;
};
# 255 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_ThreadWithProgressWindow.h" 1
# 81 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_ThreadWithProgressWindow.h"
class ThreadWithProgressWindow : public Thread,
                                            private Timer
{
public:
# 103 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_ThreadWithProgressWindow.h"
    ThreadWithProgressWindow (const String& windowTitle,
                              bool hasProgressBar,
                              bool hasCancelButton,
                              int timeOutMsWhenCancelling = 10000,
                              const String& cancelButtonText = String(),
                              Component* componentToCentreAround = nullptr);


    ~ThreadWithProgressWindow();
# 126 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_ThreadWithProgressWindow.h"
    bool runThread (int priority = 5);
# 138 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_ThreadWithProgressWindow.h"
    void launchThread (int priority = 5);






    void setProgress (double newProgress);


    void setStatusMessage (const String& newStatusMessage);


    AlertWindow* getAlertWindow() const noexcept { return alertWindow; }





    virtual void threadComplete (bool userPressedCancel);

private:

    void timerCallback() override;

    double progress;
    ScopedPointer<AlertWindow> alertWindow;
    String message;
    CriticalSection messageLock;
    const int timeOutMsWhenCancelling;
    bool wasCancelledByUser;

    ThreadWithProgressWindow (const ThreadWithProgressWindow&) = delete; ThreadWithProgressWindow& operator= (const ThreadWithProgressWindow&) = delete;
};
# 256 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_TooltipWindow.h" 1
# 47 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_TooltipWindow.h"
class TooltipWindow : public Component,
                                 private Timer
{
public:
# 69 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_TooltipWindow.h"
    explicit TooltipWindow (Component* parentComponent = nullptr,
                            int millisecondsBeforeTipAppears = 700);


    ~TooltipWindow();





    void setMillisecondsBeforeTipAppears (int newTimeMs = 700) noexcept;


    void displayTip (Point<int> screenPosition, const String& text);


    void hideTip();
# 95 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/windows/juce_TooltipWindow.h"
    enum ColourIds
    {
        backgroundColourId = 0x1001b00,
        textColourId = 0x1001c00,
        outlineColourId = 0x1001c10
    };





    struct LookAndFeelMethods
    {
        virtual ~LookAndFeelMethods() {}


        virtual Rectangle<int> getTooltipBounds (const String& tipText, Point<int> screenPos, Rectangle<int> parentArea) = 0;
        virtual void drawTooltip (Graphics&, const String& text, int width, int height) = 0;





    };

private:

    Point<float> lastMousePos;
    Component* lastComponentUnderMouse;
    String tipShowing, lastTipUnderMouse;
    int millisecondsBeforeTipAppears;
    int mouseClicks, mouseWheelMoves;
    unsigned int lastCompChangeTime, lastHideTime;
    bool reentrant;

    void paint (Graphics&) override;
    void mouseEnter (const MouseEvent&) override;
    void timerCallback() override;
    void updatePosition (const String&, Point<int>, Rectangle<int>);

    static String getTipFor (Component*);

    TooltipWindow (const TooltipWindow&) = delete; TooltipWindow& operator= (const TooltipWindow&) = delete;
};
# 257 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_MultiDocumentPanel.h" 1
# 28 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_MultiDocumentPanel.h"
class MultiDocumentPanel;
# 41 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_MultiDocumentPanel.h"
class MultiDocumentPanelWindow : public DocumentWindow
{
public:



    MultiDocumentPanelWindow (Colour backgroundColour);


    ~MultiDocumentPanelWindow();



    void maximiseButtonPressed() override;

    void closeButtonPressed() override;

    void activeWindowStatusChanged() override;

    void broughtToFront() override;

private:

    void updateOrder();
    MultiDocumentPanel* getOwner() const noexcept;

    MultiDocumentPanelWindow (const MultiDocumentPanelWindow&) = delete; MultiDocumentPanelWindow& operator= (const MultiDocumentPanelWindow&) = delete;
};
# 83 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_MultiDocumentPanel.h"
class MultiDocumentPanel : public Component,
                                      private ComponentListener
{
public:







    MultiDocumentPanel();
# 103 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_MultiDocumentPanel.h"
    ~MultiDocumentPanel();
# 117 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_MultiDocumentPanel.h"
    bool closeAllDocuments (bool checkItsOkToCloseFirst);
# 136 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_MultiDocumentPanel.h"
    bool addDocument (Component* component,
                      Colour backgroundColour,
                      bool deleteWhenRemoved);
# 154 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_MultiDocumentPanel.h"
    bool closeDocument (Component* component,
                        bool checkItsOkToCloseFirst);





    int getNumDocuments() const noexcept;
# 170 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_MultiDocumentPanel.h"
    Component* getDocument (int index) const noexcept;
# 181 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_MultiDocumentPanel.h"
    Component* getActiveDocument() const noexcept;





    void setActiveDocument (Component* component);


    virtual void activeDocumentChanged();






    void setMaximumNumDocuments (int maximumNumDocuments);
# 206 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_MultiDocumentPanel.h"
    void useFullscreenWhenOneDocument (bool shouldUseTabs);



    bool isFullscreenWhenOneDocument() const noexcept;



    enum LayoutMode
    {
        FloatingWindows,
        MaximisedWindowsWithTabs
    };





    void setLayoutMode (LayoutMode newLayoutMode);


    LayoutMode getLayoutMode() const noexcept { return mode; }






    void setBackgroundColour (Colour newBackgroundColour);





    Colour getBackgroundColour() const noexcept { return backgroundColour; }


    TabbedComponent* getCurrentTabbedComponent() const noexcept { return tabComponent; }
# 267 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_MultiDocumentPanel.h"
    virtual bool tryToCloseDocument (Component* component) = 0;






    virtual MultiDocumentPanelWindow* createNewDocumentWindow();



    void paint (Graphics&) override;

    void resized() override;

    void componentNameChanged (Component&) override;

private:

    LayoutMode mode;
    Array <Component*> components;
    ScopedPointer<TabbedComponent> tabComponent;
    Colour backgroundColour;
    int maximumNumDocuments, numDocsBeforeTabsUsed;

    class TabbedComponentInternal;
    friend class MultiDocumentPanelWindow;
    friend class TabbedComponentInternal;

    Component* getContainerComp (Component*) const;
    void updateOrder();
    void addWindow (Component*);

    MultiDocumentPanel (const MultiDocumentPanel&) = delete; MultiDocumentPanel& operator= (const MultiDocumentPanel&) = delete;
};
# 258 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_FileBrowserListener.h" 1
# 35 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_FileBrowserListener.h"
class FileBrowserListener
{
public:


    virtual ~FileBrowserListener();



    virtual void selectionChanged() = 0;


    virtual void fileClicked (const File& file, const MouseEvent& e) = 0;


    virtual void fileDoubleClicked (const File& file) = 0;


    virtual void browserRootChanged (const File& newRoot) = 0;
};
# 259 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_DirectoryContentsList.h" 1
# 39 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_DirectoryContentsList.h"
class DirectoryContentsList : public ChangeBroadcaster,
                                          private TimeSliceClient
{
public:
# 62 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_DirectoryContentsList.h"
    DirectoryContentsList (const FileFilter* fileFilter,
                           TimeSliceThread& threadToUse);


    ~DirectoryContentsList();




    const File& getDirectory() const noexcept { return root; }






    void setDirectory (const File& directory,
                       bool includeDirectories,
                       bool includeFiles);




    bool isFindingDirectories() const noexcept { return (fileTypeFlags & File::findDirectories) != 0; }




    bool isFindingFiles() const noexcept { return (fileTypeFlags & File::findFiles) != 0; }


    void clear();


    void refresh();


    bool isStillLoading() const;




    void setIgnoresHiddenFiles (bool shouldIgnoreHiddenFiles);




    bool ignoresHiddenFiles() const;
# 118 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_DirectoryContentsList.h"
    void setFileFilter (const FileFilter* newFileFilter);




    struct FileInfo
    {
# 133 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_DirectoryContentsList.h"
        String filename;


        int64 fileSize;




        Time modificationTime;




        Time creationTime;


        bool isDirectory;


        bool isReadOnly;
    };
# 165 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_DirectoryContentsList.h"
    int getNumFiles() const noexcept { return files.size(); }
# 177 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_DirectoryContentsList.h"
    bool getFileInfo (int index, FileInfo& resultInfo) const;







    File getFile (int index) const;




    const FileFilter* getFilter() const noexcept { return fileFilter; }


    bool contains (const File&) const;



    TimeSliceThread& getTimeSliceThread() const noexcept { return thread; }

private:
    File root;
    const FileFilter* fileFilter;
    TimeSliceThread& thread;
    int fileTypeFlags;

    CriticalSection fileListLock;
    OwnedArray<FileInfo> files;

    ScopedPointer<DirectoryIterator> fileFindHandle;
    bool volatile shouldStop;

    int useTimeSlice() override;
    void stopSearching();
    void changed();
    bool checkNextFile (bool& hasChanged);
    bool addFile (const File&, bool isDir, int64 fileSize, Time modTime,
                  Time creationTime, bool isReadOnly);
    void setTypeFlags (int);

    DirectoryContentsList (const DirectoryContentsList&) = delete; DirectoryContentsList& operator= (const DirectoryContentsList&) = delete;
};
# 260 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_DirectoryContentsDisplayComponent.h" 1
# 35 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_DirectoryContentsDisplayComponent.h"
class DirectoryContentsDisplayComponent
{
public:


    DirectoryContentsDisplayComponent (DirectoryContentsList& listToShow);


    virtual ~DirectoryContentsDisplayComponent();





    virtual int getNumSelectedFiles() const = 0;





    virtual File getSelectedFile (int index) const = 0;


    virtual void deselectAllFiles() = 0;


    virtual void scrollToTop() = 0;



    virtual void setSelectedFile (const File&) = 0;





    void addListener (FileBrowserListener* listener);




    void removeListener (FileBrowserListener* listener);
# 87 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_DirectoryContentsDisplayComponent.h"
    enum ColourIds
    {
        highlightColourId = 0x1000540,
        textColourId = 0x1000541,
    };



    void sendSelectionChangeMessage();

    void sendDoubleClickMessage (const File& file);

    void sendMouseClickMessage (const File& file, const MouseEvent& e);

protected:

    DirectoryContentsList& fileList;
    ListenerList <FileBrowserListener> listeners;

private:
    DirectoryContentsDisplayComponent (const DirectoryContentsDisplayComponent&) = delete; DirectoryContentsDisplayComponent& operator= (const DirectoryContentsDisplayComponent&) = delete;
};
# 261 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_FileBrowserComponent.h" 1
# 39 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_FileBrowserComponent.h"
class FileBrowserComponent : public Component,
                                        private FileBrowserListener,
                                        private TextEditorListener,
                                        private ButtonListener,
                                        private ComboBoxListener,
                                        private FileFilter,
                                        private Timer
{
public:





    enum FileChooserFlags
    {
        openMode = 1,

        saveMode = 2,

        canSelectFiles = 4,

        canSelectDirectories = 8,

        canSelectMultipleItems = 16,
        useTreeView = 32,
        filenameBoxIsReadOnly = 64,
        warnAboutOverwriting = 128,
        doNotClearFileNameOnRootChange = 256
    };
# 85 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_FileBrowserComponent.h"
    FileBrowserComponent (int flags,
                          const File& initialFileOrDirectory,
                          const FileFilter* fileFilter,
                          FilePreviewComponent* previewComp);


    ~FileBrowserComponent();






    int getNumSelectedFiles() const noexcept;






    File getSelectedFile (int index) const noexcept;


    void deselectAllFiles();
# 117 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_FileBrowserComponent.h"
    bool currentFileIsValid() const;







    File getHighlightedFile() const noexcept;



    const File& getRoot() const;


    void setRoot (const File& newRootDirectory);


    void setFileName (const String& newName);


    void goUp();


    void refresh();


    void setFileFilter (const FileFilter* newFileFilter);






    virtual String getActionVerb() const;


    bool isSaveMode() const noexcept;





    void setFilenameBoxLabel (const String& name);





    void addListener (FileBrowserListener* listener);




    void removeListener (FileBrowserListener* listener);






    static void getDefaultRoots (StringArray& rootNames, StringArray& rootPaths);





    struct LookAndFeelMethods
    {
        virtual ~LookAndFeelMethods() {}



        virtual const Drawable* getDefaultFolderImage() = 0;
        virtual const Drawable* getDefaultDocumentFileImage() = 0;

        virtual AttributedString createFileChooserHeaderText (const String& title,
                                                              const String& instructions) = 0;

        virtual void drawFileBrowserRow (Graphics&, int width, int height,
                                         const String& filename,
                                         Image* optionalIcon,
                                         const String& fileSizeDescription,
                                         const String& fileTimeDescription,
                                         bool isDirectory,
                                         bool isItemSelected,
                                         int itemIndex,
                                         DirectoryContentsDisplayComponent&) = 0;

        virtual Button* createFileBrowserGoUpButton() = 0;

        virtual void layoutFileBrowserComponent (FileBrowserComponent& browserComp,
                                                 DirectoryContentsDisplayComponent* fileListComponent,
                                                 FilePreviewComponent* previewComp,
                                                 ComboBox* currentPathBox,
                                                 TextEditor* filenameBox,
                                                 Button* goUpButton) = 0;
    };



    void resized() override;

    void buttonClicked (Button*) override;

    void comboBoxChanged (ComboBox*) override;

    void textEditorTextChanged (TextEditor&) override;

    void textEditorReturnKeyPressed (TextEditor&) override;

    void textEditorEscapeKeyPressed (TextEditor&) override;

    void textEditorFocusLost (TextEditor&) override;

    bool keyPressed (const KeyPress&) override;

    void selectionChanged() override;

    void fileClicked (const File&, const MouseEvent&) override;

    void fileDoubleClicked (const File&) override;

    void browserRootChanged (const File&) override;

    bool isFileSuitable (const File&) const override;

    bool isDirectorySuitable (const File&) const override;

    FilePreviewComponent* getPreviewComponent() const noexcept;

    DirectoryContentsDisplayComponent* getDisplayComponent() const noexcept;

protected:





    virtual void getRoots (StringArray& rootNames, StringArray& rootPaths);


    void resetRecentPaths();

private:

    ScopedPointer<DirectoryContentsList> fileList;
    const FileFilter* fileFilter;

    int flags;
    File currentRoot;
    Array<File> chosenFiles;
    ListenerList<FileBrowserListener> listeners;

    ScopedPointer<DirectoryContentsDisplayComponent> fileListComponent;
    FilePreviewComponent* previewComp;
    ComboBox currentPathBox;
    TextEditor filenameBox;
    Label fileLabel;
    ScopedPointer<Button> goUpButton;
    TimeSliceThread thread;
    bool wasProcessActive;

    void timerCallback() override;
    void sendListenerChangeMessage();
    bool isFileOrDirSuitable (const File&) const;

    FileBrowserComponent (const FileBrowserComponent&) = delete; FileBrowserComponent& operator= (const FileBrowserComponent&) = delete;
};
# 262 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_FileChooser.h" 1
# 55 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_FileChooser.h"
class FileChooser
{
public:
# 84 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_FileChooser.h"
    FileChooser (const String& dialogBoxTitle,
                 const File& initialFileOrDirectory = File(),
                 const String& filePatternsAllowed = String(),
                 bool useOSNativeDialogBox = true,
                 bool treatFilePackagesAsDirectories = false);


    ~FileChooser();
# 107 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_FileChooser.h"
    bool browseForFileToOpen (FilePreviewComponent* previewComponent = nullptr);






    bool browseForMultipleFilesToOpen (FilePreviewComponent* previewComponent = nullptr);
# 129 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_FileChooser.h"
    bool browseForFileToSave (bool warnAboutOverwritingExistingFiles);
# 141 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_FileChooser.h"
    bool browseForDirectory();






    bool browseForMultipleFilesOrDirectories (FilePreviewComponent* previewComponent = nullptr);
# 159 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_FileChooser.h"
    bool showDialog (int flags, FilePreviewComponent* previewComponent);
# 175 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_FileChooser.h"
    File getResult() const;
# 185 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_FileChooser.h"
    const Array<File>& getResults() const noexcept { return results; }

private:

    String title, filters;
    const File startingFile;
    Array<File> results;
    const bool useNativeDialogBox;
    const bool treatFilePackagesAsDirs;

    static void showPlatformDialog (Array<File>& results, const String& title, const File& file,
                                    const String& filters, bool selectsDirectories, bool selectsFiles,
                                    bool isSave, bool warnAboutOverwritingExistingFiles, bool selectMultipleFiles,
                                    bool treatFilePackagesAsDirs, FilePreviewComponent* previewComponent);
    static bool isPlatformDialogAvailable();

    FileChooser (const FileChooser&) = delete; FileChooser& operator= (const FileChooser&) = delete;
};
# 263 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_FileChooserDialogBox.h" 1
# 64 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_FileChooserDialogBox.h"
class FileChooserDialogBox : public ResizableWindow,
                                       private ButtonListener,
                                       private FileBrowserListener
{
public:
# 85 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_FileChooserDialogBox.h"
    FileChooserDialogBox (const String& title,
                          const String& instructions,
                          FileBrowserComponent& browserComponent,
                          bool warnAboutOverwritingExistingFiles,
                          Colour backgroundColour);


    ~FileChooserDialogBox();
# 103 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_FileChooserDialogBox.h"
    bool show (int width = 0, int height = 0);
# 112 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_FileChooserDialogBox.h"
    bool showAt (int x, int y, int width, int height);





    void centreWithDefaultSize (Component* componentToCentreAround = nullptr);
# 128 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_FileChooserDialogBox.h"
    enum ColourIds
    {
        titleTextColourId = 0x1000850,
    };

private:
    class ContentComponent;
    ContentComponent* content;
    const bool warnAboutOverwritingExistingFiles;

    void buttonClicked (Button*) override;
    void closeButtonPressed();
    void selectionChanged() override;
    void fileClicked (const File&, const MouseEvent&) override;
    void fileDoubleClicked (const File&) override;
    void browserRootChanged (const File&) override;
    int getDefaultWidth() const;

    void okButtonPressed();
    void createNewFolder();
    void createNewFolderConfirmed (const String& name);

    static void okToOverwriteFileCallback (int result, FileChooserDialogBox*);
    static void createNewFolderCallback (int result, FileChooserDialogBox*, Component::SafePointer<AlertWindow>);

    FileChooserDialogBox (const FileChooserDialogBox&) = delete; FileChooserDialogBox& operator= (const FileChooserDialogBox&) = delete;
};
# 264 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_FileListComponent.h" 1
# 41 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_FileListComponent.h"
class FileListComponent : public ListBox,
                                     public DirectoryContentsDisplayComponent,
                                     private ListBoxModel,
                                     private ChangeListener
{
public:



    FileListComponent (DirectoryContentsList& listToShow);


    ~FileListComponent();





    int getNumSelectedFiles() const override;





    File getSelectedFile (int index = 0) const override;


    void deselectAllFiles() override;


    void scrollToTop() override;



    void setSelectedFile (const File&) override;

private:

    File lastDirectory;

    class ItemComponent;

    void changeListenerCallback (ChangeBroadcaster*) override;

    int getNumRows() override;
    void paintListBoxItem (int, Graphics&, int, int, bool) override;
    Component* refreshComponentForRow (int rowNumber, bool isRowSelected, Component*) override;
    void selectedRowsChanged (int row) override;
    void deleteKeyPressed (int currentSelectedRow) override;
    void returnKeyPressed (int currentSelectedRow) override;

    FileListComponent (const FileListComponent&) = delete; FileListComponent& operator= (const FileListComponent&) = delete;
};
# 265 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_FilenameComponent.h" 1
# 38 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_FilenameComponent.h"
class FilenameComponentListener
{
public:

    virtual ~FilenameComponentListener() {}


    virtual void filenameComponentChanged (FilenameComponent* fileComponentThatHasChanged) = 0;
};
# 63 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_FilenameComponent.h"
class FilenameComponent : public Component,
                                     public SettableTooltipClient,
                                     public FileDragAndDropTarget,
                                     private AsyncUpdater,
                                     private ButtonListener,
                                     private ComboBoxListener
{
public:
# 90 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_FilenameComponent.h"
    FilenameComponent (const String& name,
                       const File& currentFile,
                       bool canEditFilename,
                       bool isDirectory,
                       bool isForSaving,
                       const String& fileBrowserWildcard,
                       const String& enforcedSuffix,
                       const String& textWhenNothingSelected);


    ~FilenameComponent();



    File getCurrentFile() const;


    String getCurrentFileText() const;
# 116 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_FilenameComponent.h"
    void setCurrentFile (File newFile,
                         bool addToRecentlyUsedList,
                         NotificationType notification = sendNotificationAsync);



    void setFilenameIsEditable (bool shouldBeEditable);





    void setDefaultBrowseTarget (const File& newDefaultDirectory);






    virtual File getLocationToBrowse();
# 144 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_FilenameComponent.h"
    StringArray getRecentlyUsedFilenames() const;
# 153 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_FilenameComponent.h"
    void setRecentlyUsedFilenames (const StringArray& filenames);
# 162 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_FilenameComponent.h"
    void addRecentlyUsedFile (const File& file);



    void setMaxNumberOfRecentFiles (int newMaximum);







    void setBrowseButtonText (const String& browseButtonText);



    void addListener (FilenameComponentListener* listener);


    void removeListener (FilenameComponentListener* listener);


    void setTooltip (const String& newTooltip) override;



    struct LookAndFeelMethods
    {
        virtual ~LookAndFeelMethods() {}

        virtual Button* createFilenameComponentBrowseButton (const String& text) = 0;
        virtual void layoutFilenameComponent (FilenameComponent&, ComboBox* filenameBox, Button* browseButton) = 0;
    };



    void paintOverChildren (Graphics&) override;

    void resized() override;

    void lookAndFeelChanged() override;

    bool isInterestedInFileDrag (const StringArray&) override;

    void filesDropped (const StringArray&, int, int) override;

    void fileDragEnter (const StringArray&, int, int) override;

    void fileDragExit (const StringArray&) override;

    KeyboardFocusTraverser* createFocusTraverser() override;

private:

    ComboBox filenameBox;
    String lastFilename;
    ScopedPointer<Button> browseButton;
    int maxRecentFiles;
    bool isDir, isSaving, isFileDragOver;
    String wildcard, enforcedSuffix, browseButtonText;
    ListenerList <FilenameComponentListener> listeners;
    File defaultBrowseFile;

    void comboBoxChanged (ComboBox*) override;
    void buttonClicked (Button*) override;
    void handleAsyncUpdate() override;

    FilenameComponent (const FilenameComponent&) = delete; FilenameComponent& operator= (const FilenameComponent&) = delete;
};
# 266 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_FilePreviewComponent.h" 1
# 41 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_FilePreviewComponent.h"
class FilePreviewComponent : public Component
{
public:


    FilePreviewComponent();


    ~FilePreviewComponent();






    virtual void selectedFileChanged (const File& newSelectedFile) = 0;


private:

    FilePreviewComponent (const FilePreviewComponent&) = delete; FilePreviewComponent& operator= (const FilePreviewComponent&) = delete;
};
# 267 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_FileSearchPathListComponent.h" 1
# 36 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_FileSearchPathListComponent.h"
class FileSearchPathListComponent : public Component,
                                               public SettableTooltipClient,
                                               public FileDragAndDropTarget,
                                               private ButtonListener,
                                               private ListBoxModel
{
public:


    FileSearchPathListComponent();


    ~FileSearchPathListComponent();



    const FileSearchPath& getPath() const noexcept { return path; }


    void setPath (const FileSearchPath& newPath);





    void setDefaultBrowseTarget (const File& newDefaultDirectory);
# 70 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_FileSearchPathListComponent.h"
    enum ColourIds
    {
        backgroundColourId = 0x1004100,

    };



    int getNumRows() override;

    void paintListBoxItem (int rowNumber, Graphics& g, int width, int height, bool rowIsSelected) override;

    void deleteKeyPressed (int lastRowSelected) override;

    void returnKeyPressed (int lastRowSelected) override;

    void listBoxItemDoubleClicked (int row, const MouseEvent&) override;

    void selectedRowsChanged (int lastRowSelected) override;

    void resized() override;

    void paint (Graphics&) override;

    bool isInterestedInFileDrag (const StringArray&) override;

    void filesDropped (const StringArray& files, int, int) override;

    void buttonClicked (Button*) override;

private:

    FileSearchPath path;
    File defaultBrowseTarget;

    ListBox listBox;
    TextButton addButton, removeButton, changeButton;
    DrawableButton upButton, downButton;

    void changed();
    void updateButtons();

    FileSearchPathListComponent (const FileSearchPathListComponent&) = delete; FileSearchPathListComponent& operator= (const FileSearchPathListComponent&) = delete;
};
# 268 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_FileTreeComponent.h" 1
# 41 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_FileTreeComponent.h"
class FileTreeComponent : public TreeView,
                                     public DirectoryContentsDisplayComponent
{
public:



    FileTreeComponent (DirectoryContentsList& listToShow);


    ~FileTreeComponent();





    int getNumSelectedFiles() const override { return TreeView::getNumSelectedItems(); }





    File getSelectedFile (int index = 0) const override;


    void deselectAllFiles() override;


    void scrollToTop() override;



    void setSelectedFile (const File&) override;


    void refresh();






    void setDragAndDropDescription (const String& description);



    const String& getDragAndDropDescription() const noexcept { return dragAndDropDescription; }


    void setItemHeight (int newHeight);


    int getItemHeight() const noexcept { return itemHeight; }

private:

    String dragAndDropDescription;
    int itemHeight;

    FileTreeComponent (const FileTreeComponent&) = delete; FileTreeComponent& operator= (const FileTreeComponent&) = delete;
};
# 269 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_ImagePreviewComponent.h" 1
# 35 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/filebrowser/juce_ImagePreviewComponent.h"
class ImagePreviewComponent : public FilePreviewComponent,
                                         private Timer
{
public:


    ImagePreviewComponent();


    ~ImagePreviewComponent();




    void selectedFileChanged (const File& newSelectedFile) override;

    void paint (Graphics&) override;

    void timerCallback() override;

private:
    File fileToLoad;
    Image currentThumbnail;
    String currentDetails;

    void getThumbSize (int& w, int& h) const;

    ImagePreviewComponent (const ImagePreviewComponent&) = delete; ImagePreviewComponent& operator= (const ImagePreviewComponent&) = delete;
};
# 270 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/properties/juce_PropertyComponent.h" 1
# 45 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/properties/juce_PropertyComponent.h"
class PropertyComponent : public Component,
                                     public SettableTooltipClient
{
public:
# 60 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/properties/juce_PropertyComponent.h"
    PropertyComponent (const String& propertyName,
                       int preferredHeight = 25);


    ~PropertyComponent();







    int getPreferredHeight() const noexcept { return preferredHeight; }

    void setPreferredHeight (int newHeight) noexcept { preferredHeight = newHeight; }
# 87 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/properties/juce_PropertyComponent.h"
    virtual void refresh() = 0;







    void paint (Graphics&) override;




    void resized() override;


    void enablementChanged() override;
# 113 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/properties/juce_PropertyComponent.h"
    enum ColourIds
    {
        backgroundColourId = 0x1008300,
        labelTextColourId = 0x1008301,
    };



    struct LookAndFeelMethods
    {
        virtual ~LookAndFeelMethods() {}

        virtual void drawPropertyPanelSectionHeader (Graphics&, const String& name, bool isOpen, int width, int height) = 0;
        virtual void drawPropertyComponentBackground (Graphics&, int width, int height, PropertyComponent&) = 0;
        virtual void drawPropertyComponentLabel (Graphics&, int width, int height, PropertyComponent&) = 0;
        virtual Rectangle<int> getPropertyComponentContentPosition (PropertyComponent&) = 0;
    };

protected:




    int preferredHeight;

private:
    PropertyComponent (const PropertyComponent&) = delete; PropertyComponent& operator= (const PropertyComponent&) = delete;
};
# 271 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/properties/juce_BooleanPropertyComponent.h" 1
# 38 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/properties/juce_BooleanPropertyComponent.h"
class BooleanPropertyComponent : public PropertyComponent,
                                            private ButtonListener
{
protected:
# 52 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/properties/juce_BooleanPropertyComponent.h"
    BooleanPropertyComponent (const String& propertyName,
                              const String& buttonTextWhenTrue,
                              const String& buttonTextWhenFalse);

public:
# 67 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/properties/juce_BooleanPropertyComponent.h"
    BooleanPropertyComponent (const Value& valueToControl,
                              const String& propertyName,
                              const String& buttonText);


    ~BooleanPropertyComponent();



    virtual void setState (bool newState);


    virtual bool getState() const;
# 89 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/properties/juce_BooleanPropertyComponent.h"
    enum ColourIds
    {
        backgroundColourId = 0x100e801,
        outlineColourId = 0x100e803,
    };



    void paint (Graphics&) override;

    void refresh() override;

    void buttonClicked (Button*) override;

private:
    ToggleButton button;
    String onText, offText;

    BooleanPropertyComponent (const BooleanPropertyComponent&) = delete; BooleanPropertyComponent& operator= (const BooleanPropertyComponent&) = delete;
};
# 272 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/properties/juce_ButtonPropertyComponent.h" 1
# 38 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/properties/juce_ButtonPropertyComponent.h"
class ButtonPropertyComponent : public PropertyComponent,
                                           private ButtonListener
{
public:






    ButtonPropertyComponent (const String& propertyName,
                             bool triggerOnMouseDown);


    ~ButtonPropertyComponent();




    virtual void buttonClicked() = 0;





    virtual String getButtonText() const = 0;



    void refresh();

    void buttonClicked (Button*);

private:
    TextButton button;

    ButtonPropertyComponent (const ButtonPropertyComponent&) = delete; ButtonPropertyComponent& operator= (const ButtonPropertyComponent&) = delete;
};
# 273 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/properties/juce_ChoicePropertyComponent.h" 1
# 48 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/properties/juce_ChoicePropertyComponent.h"
class ChoicePropertyComponent : public PropertyComponent,
                                             private ComboBoxListener
{
protected:



    ChoicePropertyComponent (const String& propertyName);

public:
# 72 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/properties/juce_ChoicePropertyComponent.h"
    ChoicePropertyComponent (const Value& valueToControl,
                             const String& propertyName,
                             const StringArray& choices,
                             const Array<var>& correspondingValues);


    ~ChoicePropertyComponent();
# 87 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/properties/juce_ChoicePropertyComponent.h"
    virtual void setIndex (int newIndex);




    virtual int getIndex() const;


    const StringArray& getChoices() const;




    void refresh();

protected:






    StringArray choices;

private:
    ComboBox comboBox;
    bool isCustomClass;

    class RemapperValueSource;
    void createComboBox();
    void comboBoxChanged (ComboBox*);

    ChoicePropertyComponent (const ChoicePropertyComponent&) = delete; ChoicePropertyComponent& operator= (const ChoicePropertyComponent&) = delete;
};
# 274 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/properties/juce_PropertyPanel.h" 1
# 41 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/properties/juce_PropertyPanel.h"
class PropertyPanel : public Component
{
public:


    PropertyPanel();


    PropertyPanel (const String& name);


    ~PropertyPanel();



    void clear();
# 66 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/properties/juce_PropertyPanel.h"
    void addProperties (const Array<PropertyComponent*>& newPropertyComponents);
# 79 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/properties/juce_PropertyPanel.h"
    void addSection (const String& sectionTitle,
                     const Array<PropertyComponent*>& newPropertyComponents,
                     bool shouldSectionInitiallyBeOpen = true,
                     int indexToInsertAt = -1);


    void refreshAll() const;


    bool isEmpty() const;




    int getTotalContentHeight() const;





    StringArray getSectionNames() const;




    bool isSectionOpen (int sectionIndex) const;




    void setSectionOpen (int sectionIndex, bool shouldBeOpen);




    void setSectionEnabled (int sectionIndex, bool shouldBeEnabled);




    void removeSection (int sectionIndex);
# 129 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/properties/juce_PropertyPanel.h"
    XmlElement* getOpennessState() const;
# 139 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/properties/juce_PropertyPanel.h"
    void restoreOpennessState (const XmlElement& newState);





    void setMessageWhenEmpty (const String& newMessage);




    const String& getMessageWhenEmpty() const noexcept;



    Viewport& getViewport() noexcept { return viewport; }



    void paint (Graphics&) override;

    void resized() override;

private:
    Viewport viewport;
    struct SectionComponent;
    struct PropertyHolderComponent;
    PropertyHolderComponent* propertyHolderComponent;
    String messageWhenEmpty;

    void init();
    void updatePropHolderLayout() const;
    void updatePropHolderLayout (int width) const;

    PropertyPanel (const PropertyPanel&) = delete; PropertyPanel& operator= (const PropertyPanel&) = delete;
};
# 275 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/properties/juce_SliderPropertyComponent.h" 1
# 35 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/properties/juce_SliderPropertyComponent.h"
class SliderPropertyComponent : public PropertyComponent,
                                            private SliderListener
{
protected:
# 47 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/properties/juce_SliderPropertyComponent.h"
    SliderPropertyComponent (const String& propertyName,
                             double rangeMin,
                             double rangeMax,
                             double interval,
                             double skewFactor = 1.0,
                             bool symmetricSkew = false);

public:
# 67 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/properties/juce_SliderPropertyComponent.h"
    SliderPropertyComponent (const Value& valueToControl,
                             const String& propertyName,
                             double rangeMin,
                             double rangeMax,
                             double interval,
                             double skewFactor = 1.0,
                             bool symmetricSkew = false);


    ~SliderPropertyComponent();
# 85 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/properties/juce_SliderPropertyComponent.h"
    virtual void setValue (double newValue);


    virtual double getValue() const;




    void refresh();

    void sliderValueChanged (Slider*);

protected:



    Slider slider;

private:

    SliderPropertyComponent (const SliderPropertyComponent&) = delete; SliderPropertyComponent& operator= (const SliderPropertyComponent&) = delete;
};
# 276 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/properties/juce_TextPropertyComponent.h" 1
# 35 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/properties/juce_TextPropertyComponent.h"
class TextPropertyComponent : public PropertyComponent
{
protected:
# 48 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/properties/juce_TextPropertyComponent.h"
    TextPropertyComponent (const String& propertyName,
                           int maxNumChars,
                           bool isMultiLine);

public:
# 63 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/properties/juce_TextPropertyComponent.h"
    TextPropertyComponent (const Value& valueToControl,
                           const String& propertyName,
                           int maxNumChars,
                           bool isMultiLine);


    ~TextPropertyComponent();







    virtual void setText (const String& newText);


    virtual String getText() const;


    Value& getValue() const;
# 93 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/properties/juce_TextPropertyComponent.h"
    enum ColourIds
    {
        backgroundColourId = 0x100e401,
        textColourId = 0x100e402,
        outlineColourId = 0x100e403,
    };

    void colourChanged() override;


    class Listener
    {
    public:

        virtual ~Listener() {}


        virtual void textPropertyComponentChanged (TextPropertyComponent*) = 0;
    };





    void addListener (Listener* newListener);




    void removeListener (Listener* listener);



    void refresh() override;

    virtual void textWasEdited();

private:
    class LabelComp;
    friend class LabelComp;

    ScopedPointer<LabelComp> textEditor;
    ListenerList<Listener> listenerList;

    void callListeners();
    void createEditor (int maxNumChars, bool isMultiLine);

    TextPropertyComponent (const TextPropertyComponent&) = delete; TextPropertyComponent& operator= (const TextPropertyComponent&) = delete;
};



 typedef TextPropertyComponent::Listener TextPropertyComponentListener;
# 277 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/application/juce_Application.h" 1
# 88 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/application/juce_Application.h"
class JUCEApplication : public JUCEApplicationBase,
                                   public ApplicationCommandTarget
{
public:







    JUCEApplication();







    ~JUCEApplication();



    static JUCEApplication* __stdcall getInstance() noexcept;
# 132 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/application/juce_Application.h"
    bool moreThanOneInstanceAllowed() override;




    void anotherInstanceStarted (const String& commandLine) override;
# 151 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/application/juce_Application.h"
    void systemRequestedQuit() override;




    void suspended() override;




    void resumed() override;
# 171 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/application/juce_Application.h"
    void unhandledException (const std::exception* e,
                             const String& sourceFilename,
                             int lineNumber) override;



    ApplicationCommandTarget* getNextCommandTarget() override;

    void getCommandInfo (CommandID, ApplicationCommandInfo&) override;

    void getAllCommands (Array<CommandID>&) override;

    bool perform (const InvocationInfo&) override;

private:
    bool initialiseApp() override;

    JUCEApplication (const JUCEApplication&) = delete; JUCEApplication& operator= (const JUCEApplication&) = delete;
};
# 278 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/misc/juce_BubbleComponent.h" 1
# 44 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/misc/juce_BubbleComponent.h"
class BubbleComponent : public Component
{
protected:






    BubbleComponent();

public:

    ~BubbleComponent();







    enum BubblePlacement
    {
        above = 1,
        below = 2,
        left = 4,
        right = 8
    };
# 85 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/misc/juce_BubbleComponent.h"
    void setAllowedPlacement (int newPlacement);
# 97 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/misc/juce_BubbleComponent.h"
    void setPosition (Component* componentToPointTo,
                      int distanceFromTarget = 15, int arrowLength = 10);
# 111 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/misc/juce_BubbleComponent.h"
    void setPosition (Point<int> arrowTipPosition, int arrowLength = 10);
# 127 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/misc/juce_BubbleComponent.h"
    void setPosition (Rectangle<int> rectangleToPointTo,
                      int distanceFromTarget = 15, int arrowLength = 10);
# 138 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/misc/juce_BubbleComponent.h"
    enum ColourIds
    {
        backgroundColourId = 0x1000af0,
        outlineColourId = 0x1000af1
    };





    struct LookAndFeelMethods
    {
        virtual ~LookAndFeelMethods() {}

        virtual void drawBubble (Graphics&, BubbleComponent&,
                                 const Point<float>& positionOfTip,
                                 const Rectangle<float>& body) = 0;
    };

protected:




    virtual void getContentSize (int& width, int& height) = 0;






    virtual void paintContent (Graphics& g, int width, int height) = 0;

public:

    void paint (Graphics&) override;

private:
    Rectangle<int> content;
    Point<int> arrowTip;
    int allowablePlacements;
    DropShadowEffect shadow;

    BubbleComponent (const BubbleComponent&) = delete; BubbleComponent& operator= (const BubbleComponent&) = delete;
};
# 279 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/lookandfeel/juce_LookAndFeel.h" 1
# 33 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/lookandfeel/juce_LookAndFeel.h"
struct ExtraLookAndFeelBaseClasses
{


    struct LassoComponentMethods
    {
        virtual ~LassoComponentMethods() {}

        virtual void drawLasso (Graphics&, Component& lassoComp) = 0;
    };



    struct KeyMappingEditorComponentMethods
    {
        virtual ~KeyMappingEditorComponentMethods() {}

        virtual void drawKeymapChangeButton (Graphics&, int width, int height, Button&, const String& keyDescription) = 0;
    };



    struct AudioDeviceSelectorComponentMethods
    {
        virtual ~AudioDeviceSelectorComponentMethods() {}

        virtual void drawLevelMeter (Graphics&, int width, int height, float level) = 0;
    };
};
# 74 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/lookandfeel/juce_LookAndFeel.h"
class LookAndFeel : public ScrollBar::LookAndFeelMethods,
                                public Button::LookAndFeelMethods,
                                public ImageButton::LookAndFeelMethods,
                                public TextEditor::LookAndFeelMethods,
                                public FileBrowserComponent::LookAndFeelMethods,
                                public TreeView::LookAndFeelMethods,
                                public BubbleComponent::LookAndFeelMethods,
                                public AlertWindow::LookAndFeelMethods,
                                public PopupMenu::LookAndFeelMethods,
                                public ComboBox::LookAndFeelMethods,
                                public Label::LookAndFeelMethods,
                                public Slider::LookAndFeelMethods,
                                public ResizableWindow::LookAndFeelMethods,
                                public DocumentWindow::LookAndFeelMethods,
                                public TooltipWindow::LookAndFeelMethods,
                                public TabbedButtonBar::LookAndFeelMethods,
                                public PropertyComponent::LookAndFeelMethods,
                                public FilenameComponent::LookAndFeelMethods,
                                public GroupComponent::LookAndFeelMethods,
                                public TableHeaderComponent::LookAndFeelMethods,
                                public CallOutBox::LookAndFeelMethods,
                                public Toolbar::LookAndFeelMethods,
                                public ConcertinaPanel::LookAndFeelMethods,
                                public ProgressBar::LookAndFeelMethods,
                                public StretchableLayoutResizerBar::LookAndFeelMethods,
                                public ExtraLookAndFeelBaseClasses::KeyMappingEditorComponentMethods,
                                public ExtraLookAndFeelBaseClasses::AudioDeviceSelectorComponentMethods,
                                public ExtraLookAndFeelBaseClasses::LassoComponentMethods
{
public:


    LookAndFeel();


    virtual ~LookAndFeel();







    static LookAndFeel& getDefaultLookAndFeel() noexcept;
# 127 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/lookandfeel/juce_LookAndFeel.h"
    static void setDefaultLookAndFeel (LookAndFeel* newDefaultLookAndFeel) noexcept;
# 147 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/lookandfeel/juce_LookAndFeel.h"
    Colour findColour (int colourId) const noexcept;





    void setColour (int colourId, Colour colour) noexcept;




    bool isColourSpecified (int colourId) const noexcept;






    virtual Typeface::Ptr getTypefaceForFont (const Font&);







    void setDefaultSansSerifTypefaceName (const String& newName);





    virtual MouseCursor getMouseCursorFor (Component&);



    virtual LowLevelGraphicsContext* createGraphicsContext (const Image& imageToRenderOn,
                                                            const Point<int>& origin,
                                                            const RectangleList<int>& initialClip);

    void setUsingNativeAlertWindows (bool shouldUseNativeAlerts);
    bool isUsingNativeAlertWindows();






    virtual void drawSpinningWaitAnimation (Graphics&, const Colour& colour,
                                            int x, int y, int w, int h) = 0;



    virtual Path getTickShape (float height) = 0;

    virtual Path getCrossShape (float height) = 0;


    virtual DropShadower* createDropShadowerForComponent (Component*) = 0;



    virtual void playAlertSound();

private:

    friend class WeakReference<LookAndFeel>;
    WeakReference<LookAndFeel>::Master masterReference;

    struct ColourSetting
    {
        int colourID;
        Colour colour;

        bool operator< (const ColourSetting& other) const noexcept { return colourID < other.colourID; }
        bool operator== (const ColourSetting& other) const noexcept { return colourID == other.colourID; }
    };

    SortedSet<ColourSetting> colours;
    String defaultSans, defaultSerif, defaultFixed;
    bool useNativeAlertWindows;

    LookAndFeel (const LookAndFeel&) = delete; LookAndFeel& operator= (const LookAndFeel&) = delete;
};
# 280 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/lookandfeel/juce_LookAndFeel_V2.h" 1
# 35 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/lookandfeel/juce_LookAndFeel_V2.h"
class LookAndFeel_V2 : public LookAndFeel
{
public:
    LookAndFeel_V2();
    ~LookAndFeel_V2();


    void drawButtonBackground (Graphics&, Button&, const Colour& backgroundColour,
                               bool isMouseOverButton, bool isButtonDown) override;
    Font getTextButtonFont (TextButton&, int buttonHeight) override;

    void drawButtonText (Graphics&, TextButton&, bool isMouseOverButton, bool isButtonDown) override;
    int getTextButtonWidthToFitText (TextButton&, int buttonHeight) override;

    void drawToggleButton (Graphics&, ToggleButton&, bool isMouseOverButton, bool isButtonDown) override;

    void changeToggleButtonWidthToFitText (ToggleButton&) override;

    void drawTickBox (Graphics&, Component&,
                      float x, float y, float w, float h,
                      bool ticked, bool isEnabled, bool isMouseOverButton, bool isButtonDown) override;

    void drawDrawableButton (Graphics&, DrawableButton&, bool isMouseOverButton, bool isButtonDown) override;


    AlertWindow* createAlertWindow (const String& title, const String& message,
                                    const String& button1,
                                    const String& button2,
                                    const String& button3,
                                    AlertWindow::AlertIconType iconType,
                                    int numButtons, Component* associatedComponent) override;

    void drawAlertBox (Graphics&, AlertWindow&, const Rectangle<int>& textArea, TextLayout&) override;
    int getAlertBoxWindowFlags() override;

    Array<int> getWidthsForTextButtons (AlertWindow&, const Array<TextButton*>&) override;
    int getAlertWindowButtonHeight() override;







    Font getAlertWindowTitleFont() override;






    Font getAlertWindowMessageFont() override;

    Font getAlertWindowFont() override;


    void drawProgressBar (Graphics&, ProgressBar&, int width, int height, double progress, const String& textToShow) override;
    void drawSpinningWaitAnimation (Graphics&, const Colour& colour, int x, int y, int w, int h) override;


    bool areScrollbarButtonsVisible() override;
    void drawScrollbarButton (Graphics&, ScrollBar&, int width, int height, int buttonDirection,
                              bool isScrollbarVertical, bool isMouseOverButton, bool isButtonDown) override;

    void drawScrollbar (Graphics&, ScrollBar&, int x, int y, int width, int height,
                        bool isScrollbarVertical, int thumbStartPosition, int thumbSize,
                        bool isMouseOver, bool isMouseDown) override;

    ImageEffectFilter* getScrollbarEffect() override;
    int getMinimumScrollbarThumbSize (ScrollBar&) override;
    int getDefaultScrollbarWidth() override;
    int getScrollbarButtonSize (ScrollBar&) override;


    Path getTickShape (float height) override;
    Path getCrossShape (float height) override;


    void drawTreeviewPlusMinusBox (Graphics&, const Rectangle<float>& area,
                                   Colour backgroundColour, bool isOpen, bool isMouseOver) override;
    bool areLinesDrawnForTreeView (TreeView&) override;
    int getTreeViewIndentSize (TreeView&) override;


    void fillTextEditorBackground (Graphics&, int width, int height, TextEditor&) override;
    void drawTextEditorOutline (Graphics&, int width, int height, TextEditor&) override;
    CaretComponent* createCaretComponent (Component* keyFocusOwner) override;


    const Drawable* getDefaultFolderImage() override;
    const Drawable* getDefaultDocumentFileImage() override;

    AttributedString createFileChooserHeaderText (const String& title, const String& instructions) override;

    void drawFileBrowserRow (Graphics&, int width, int height,
                             const String& filename, Image* icon,
                             const String& fileSizeDescription, const String& fileTimeDescription,
                             bool isDirectory, bool isItemSelected, int itemIndex,
                             DirectoryContentsDisplayComponent&) override;

    Button* createFileBrowserGoUpButton() override;

    void layoutFileBrowserComponent (FileBrowserComponent&,
                                     DirectoryContentsDisplayComponent*,
                                     FilePreviewComponent*,
                                     ComboBox* currentPathBox,
                                     TextEditor* filenameBox,
                                     Button* goUpButton) override;


    void drawBubble (Graphics&, BubbleComponent&, const Point<float>& tip, const Rectangle<float>& body) override;

    void drawLasso (Graphics&, Component&) override;


    void drawPopupMenuBackground (Graphics&, int width, int height) override;

    void drawPopupMenuItem (Graphics&, const Rectangle<int>& area,
                            bool isSeparator, bool isActive, bool isHighlighted, bool isTicked, bool hasSubMenu,
                            const String& text, const String& shortcutKeyText,
                            const Drawable* icon, const Colour* textColour) override;

    void drawPopupMenuSectionHeader (Graphics&, const Rectangle<int>& area,
                                     const String& sectionName) override;

    Font getPopupMenuFont() override;

    void drawPopupMenuUpDownArrow (Graphics&, int width, int height, bool isScrollUpArrow) override;

    void getIdealPopupMenuItemSize (const String& text, bool isSeparator, int standardMenuItemHeight,
                                    int& idealWidth, int& idealHeight) override;
    int getMenuWindowFlags() override;
    void preparePopupMenuWindow (Component&) override;

    void drawMenuBarBackground (Graphics&, int width, int height, bool isMouseOverBar, MenuBarComponent&) override;
    int getMenuBarItemWidth (MenuBarComponent&, int itemIndex, const String& itemText) override;
    Font getMenuBarFont (MenuBarComponent&, int itemIndex, const String& itemText) override;
    int getDefaultMenuBarHeight() override;

    void drawMenuBarItem (Graphics&, int width, int height,
                          int itemIndex, const String& itemText,
                          bool isMouseOverItem, bool isMenuOpen, bool isMouseOverBar,
                          MenuBarComponent&) override;

    Component* getParentComponentForMenuOptions (const PopupMenu::Options& options) override;


    void drawComboBox (Graphics&, int width, int height, bool isButtonDown,
                       int buttonX, int buttonY, int buttonW, int buttonH,
                       ComboBox&) override;
    Font getComboBoxFont (ComboBox&) override;
    Label* createComboBoxTextBox (ComboBox&) override;
    void positionComboBoxText (ComboBox&, Label&) override;


    void drawLabel (Graphics&, Label&) override;
    Font getLabelFont (Label&) override;


    void drawLinearSlider (Graphics&, int x, int y, int width, int height,
                           float sliderPos, float minSliderPos, float maxSliderPos,
                           const Slider::SliderStyle, Slider&) override;

    void drawLinearSliderBackground (Graphics&, int x, int y, int width, int height,
                                     float sliderPos, float minSliderPos, float maxSliderPos,
                                     const Slider::SliderStyle, Slider&) override;

    void drawLinearSliderThumb (Graphics&, int x, int y, int width, int height,
                                float sliderPos, float minSliderPos, float maxSliderPos,
                                const Slider::SliderStyle, Slider&) override;

    void drawRotarySlider (Graphics&, int x, int y, int width, int height,
                           float sliderPosProportional, float rotaryStartAngle, float rotaryEndAngle,
                           Slider&) override;

    int getSliderThumbRadius (Slider&) override;
    Button* createSliderButton (Slider&, bool isIncrement) override;
    Label* createSliderTextBox (Slider&) override;
    ImageEffectFilter* getSliderEffect (Slider&) override;
    Font getSliderPopupFont (Slider&) override;
    int getSliderPopupPlacement (Slider&) override;
    Slider::SliderLayout getSliderLayout (Slider&) override;


    Rectangle<int> getTooltipBounds (const String& tipText, Point<int> screenPos, Rectangle<int> parentArea) override;
    void drawTooltip (Graphics&, const String& text, int width, int height) override;


    Button* createFilenameComponentBrowseButton (const String& text) override;
    void layoutFilenameComponent (FilenameComponent&, ComboBox* filenameBox, Button* browseButton) override;


    void drawConcertinaPanelHeader (Graphics&, const Rectangle<int>& area,
                                    bool isMouseOver, bool isMouseDown,
                                    ConcertinaPanel&, Component& panel) override;


    void drawCornerResizer (Graphics&, int w, int h, bool isMouseOver, bool isMouseDragging) override;
    void drawResizableFrame (Graphics&, int w, int h, const BorderSize<int>&) override;


    void fillResizableWindowBackground (Graphics&, int w, int h, const BorderSize<int>&, ResizableWindow&) override;
    void drawResizableWindowBorder (Graphics&, int w, int h, const BorderSize<int>& border, ResizableWindow&) override;


    void drawDocumentWindowTitleBar (DocumentWindow&, Graphics&, int w, int h,
                                     int titleSpaceX, int titleSpaceW,
                                     const Image* icon, bool drawTitleTextOnLeft) override;

    Button* createDocumentWindowButton (int buttonType) override;

    void positionDocumentWindowButtons (DocumentWindow&,
                                        int titleBarX, int titleBarY, int titleBarW, int titleBarH,
                                        Button* minimiseButton,
                                        Button* maximiseButton,
                                        Button* closeButton,
                                        bool positionTitleBarButtonsOnLeft) override;


    DropShadower* createDropShadowerForComponent (Component*) override;


    void drawStretchableLayoutResizerBar (Graphics&, int w, int h, bool isVerticalBar,
                                          bool isMouseOver, bool isMouseDragging) override;


    void drawGroupComponentOutline (Graphics&, int w, int h, const String& text,
                                    const Justification&, GroupComponent&) override;


    int getTabButtonSpaceAroundImage() override;
    int getTabButtonOverlap (int tabDepth) override;
    int getTabButtonBestWidth (TabBarButton&, int tabDepth) override;
    Rectangle<int> getTabButtonExtraComponentBounds (const TabBarButton&, Rectangle<int>& textArea, Component& extraComp) override;

    void drawTabButton (TabBarButton&, Graphics&, bool isMouseOver, bool isMouseDown) override;
    void drawTabButtonText (TabBarButton&, Graphics&, bool isMouseOver, bool isMouseDown) override;
    void drawTabbedButtonBarBackground (TabbedButtonBar&, Graphics&) override;
    void drawTabAreaBehindFrontButton (TabbedButtonBar&, Graphics&, int w, int h) override;

    void createTabButtonShape (TabBarButton&, Path&, bool isMouseOver, bool isMouseDown) override;
    void fillTabButtonShape (TabBarButton&, Graphics&, const Path&, bool isMouseOver, bool isMouseDown) override;

    Button* createTabBarExtrasButton() override;


    void drawImageButton (Graphics&, Image*,
                          int imageX, int imageY, int imageW, int imageH,
                          const Colour& overlayColour, float imageOpacity, ImageButton&) override;


    void drawTableHeaderBackground (Graphics&, TableHeaderComponent&) override;

    void drawTableHeaderColumn (Graphics&, const String& columnName, int columnId,
                                int width, int height, bool isMouseOver, bool isMouseDown,
                                int columnFlags) override;


    void paintToolbarBackground (Graphics&, int width, int height, Toolbar&) override;

    Button* createToolbarMissingItemsButton (Toolbar&) override;

    void paintToolbarButtonBackground (Graphics&, int width, int height,
                                       bool isMouseOver, bool isMouseDown,
                                       ToolbarItemComponent&) override;

    void paintToolbarButtonLabel (Graphics&, int x, int y, int width, int height,
                                  const String& text, ToolbarItemComponent&) override;


    void drawPropertyPanelSectionHeader (Graphics&, const String& name, bool isOpen, int width, int height) override;
    void drawPropertyComponentBackground (Graphics&, int width, int height, PropertyComponent&) override;
    void drawPropertyComponentLabel (Graphics&, int width, int height, PropertyComponent&) override;
    Rectangle<int> getPropertyComponentContentPosition (PropertyComponent&) override;


    void drawCallOutBoxBackground (CallOutBox&, Graphics&, const Path& path, Image& cachedImage) override;
    int getCallOutBoxBorderSize (const CallOutBox&) override;


    void drawLevelMeter (Graphics&, int width, int height, float level) override;

    void drawKeymapChangeButton (Graphics&, int width, int height, Button&, const String& keyDescription) override;
# 334 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/lookandfeel/juce_LookAndFeel_V2.h"
    static void drawBevel (Graphics&,
                           int x, int y, int width, int height,
                           int bevelThickness,
                           const Colour& topLeftColour = Colours::white,
                           const Colour& bottomRightColour = Colours::black,
                           bool useGradient = true,
                           bool sharpEdgeOnOutside = true);


    static void drawGlassSphere (Graphics&, float x, float y, float diameter,
                                 const Colour&, float outlineThickness) noexcept;

    static void drawGlassPointer (Graphics&, float x, float y, float diameter,
                                  const Colour&, float outlineThickness, int direction) noexcept;


    static void drawGlassLozenge (Graphics&,
                                  float x, float y, float width, float height,
                                  const Colour&, float outlineThickness, float cornerSize,
                                  bool flatOnLeft, bool flatOnRight, bool flatOnTop, bool flatOnBottom) noexcept;

private:

    ScopedPointer<Drawable> folderImage, documentImage;

    void drawShinyButtonShape (Graphics&,
                               float x, float y, float w, float h, float maxCornerSize,
                               const Colour&, float strokeWidth,
                               bool flatOnLeft, bool flatOnRight, bool flatOnTop, bool flatOnBottom) noexcept;

    class GlassWindowButton;
    class SliderLabelComp;

    LookAndFeel_V2 (const LookAndFeel_V2&) = delete; LookAndFeel_V2& operator= (const LookAndFeel_V2&) = delete;
};
# 281 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/lookandfeel/juce_LookAndFeel_V1.h" 1
# 33 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/lookandfeel/juce_LookAndFeel_V1.h"
class LookAndFeel_V1 : public LookAndFeel_V2
{
public:
    LookAndFeel_V1();
    ~LookAndFeel_V1();


    void drawButtonBackground (Graphics&, Button&, const Colour& backgroundColour,
                               bool isMouseOverButton, bool isButtonDown) override;

    void drawToggleButton (Graphics&, ToggleButton&, bool isMouseOverButton, bool isButtonDown) override;

    void drawTickBox (Graphics&, Component&, float x, float y, float w, float h,
                      bool ticked, bool isEnabled, bool isMouseOverButton, bool isButtonDown) override;

    void drawProgressBar (Graphics&, ProgressBar&, int width, int height,
                          double progress, const String& textToShow) override;


    void drawScrollbarButton (Graphics&, ScrollBar&, int width, int height,
                              int buttonDirection, bool isScrollbarVertical,
                              bool isMouseOverButton, bool isButtonDown) override;

    void drawScrollbar (Graphics&, ScrollBar&, int x, int y, int width, int height,
                        bool isScrollbarVertical, int thumbStartPosition, int thumbSize,
                        bool isMouseOver, bool isMouseDown) override;

    ImageEffectFilter* getScrollbarEffect() override;


    void drawTextEditorOutline (Graphics&, int width, int height, TextEditor&) override;


    void drawPopupMenuBackground (Graphics&, int width, int height) override;
    void drawMenuBarBackground (Graphics&, int width, int height, bool isMouseOverBar, MenuBarComponent&) override;


    void drawComboBox (Graphics&, int width, int height, bool isButtonDown,
                       int buttonX, int buttonY, int buttonW, int buttonH, ComboBox&) override;

    Font getComboBoxFont (ComboBox&) override;


    void drawLinearSlider (Graphics&, int x, int y, int width, int height,
                           float sliderPos, float minSliderPos, float maxSliderPos,
                           const Slider::SliderStyle, Slider&) override;

    int getSliderThumbRadius (Slider&) override;
    Button* createSliderButton (Slider&, bool isIncrement) override;
    ImageEffectFilter* getSliderEffect (Slider&) override;


    void drawCornerResizer (Graphics&, int w, int h, bool isMouseOver, bool isMouseDragging) override;

    Button* createDocumentWindowButton (int buttonType) override;

    void positionDocumentWindowButtons (DocumentWindow&,
                                        int titleBarX, int titleBarY, int titleBarW, int titleBarH,
                                        Button* minimiseButton, Button* maximiseButton, Button* closeButton,
                                        bool positionTitleBarButtonsOnLeft) override;

private:
    DropShadowEffect scrollbarShadow;

    LookAndFeel_V1 (const LookAndFeel_V1&) = delete; LookAndFeel_V1& operator= (const LookAndFeel_V1&) = delete;
};
# 282 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/lookandfeel/juce_LookAndFeel_V3.h" 1
# 33 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/lookandfeel/juce_LookAndFeel_V3.h"
class LookAndFeel_V3 : public LookAndFeel_V2
{
public:
    LookAndFeel_V3();
    ~LookAndFeel_V3();


    void drawButtonBackground (Graphics&, Button&, const Colour& backgroundColour,
                               bool isMouseOverButton, bool isButtonDown) override;

    void drawTableHeaderBackground (Graphics&, TableHeaderComponent&) override;

    void drawTreeviewPlusMinusBox (Graphics&, const Rectangle<float>& area,
                                   Colour backgroundColour, bool isOpen, bool isMouseOver) override;
    bool areLinesDrawnForTreeView (TreeView&) override;
    int getTreeViewIndentSize (TreeView&) override;

    Button* createDocumentWindowButton (int buttonType) override;

    void drawComboBox (Graphics&, int width, int height, bool isButtonDown,
                       int buttonX, int buttonY, int buttonW, int buttonH, ComboBox& box) override;

    void drawKeymapChangeButton (Graphics&, int width, int height, Button& button, const String& keyDescription) override;

    void drawPopupMenuBackground (Graphics&, int width, int height) override;
    void drawMenuBarBackground (Graphics&, int width, int height, bool, MenuBarComponent&) override;

    int getTabButtonOverlap (int tabDepth) override;
    int getTabButtonSpaceAroundImage() override;
    void drawTabButton (TabBarButton&, Graphics&, bool isMouseOver, bool isMouseDown) override;
    void drawTabAreaBehindFrontButton (TabbedButtonBar& bar, Graphics& g, int w, int h) override;

    void drawTextEditorOutline (Graphics&, int width, int height, TextEditor&) override;

    void drawStretchableLayoutResizerBar (Graphics&, int w, int h, bool isVerticalBar, bool isMouseOver, bool isMouseDragging) override;

    bool areScrollbarButtonsVisible() override;

    void drawScrollbar (Graphics&, ScrollBar&, int x, int y, int width, int height, bool isScrollbarVertical,
                        int thumbStartPosition, int thumbSize, bool isMouseOver, bool isMouseDown) override;

    void drawLinearSlider (Graphics&, int x, int y, int width, int height,
                           float sliderPos, float minSliderPos, float maxSliderPos,
                           const Slider::SliderStyle, Slider&) override;

    void drawLinearSliderBackground (Graphics&, int x, int y, int width, int height,
                                     float sliderPos, float minSliderPos, float maxSliderPos,
                                     const Slider::SliderStyle, Slider&) override;

    void drawConcertinaPanelHeader (Graphics&, const Rectangle<int>& area, bool isMouseOver, bool isMouseDown,
                                    ConcertinaPanel&, Component&) override;

    Path getTickShape (float height) override;
    Path getCrossShape (float height) override;

    static void createTabTextLayout (const TabBarButton& button, float length, float depth, Colour colour, TextLayout&);

private:
    Image backgroundTexture;
    Colour backgroundTextureBaseColour;
};
# 283 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2




# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_FlexItem.h" 1
# 31 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_FlexItem.h"
class FlexItem
{
public:


    FlexItem() noexcept;


    FlexItem (float width, float height) noexcept;


    FlexItem (float width, float height, Component& targetComponent) noexcept;


    FlexItem (float width, float height, FlexBox& flexBoxToControl) noexcept;


    FlexItem (Component& componentToControl) noexcept;


    FlexItem (FlexBox& flexBoxToControl) noexcept;



    Rectangle<float> currentBounds;


    Component* associatedComponent = nullptr;


    FlexBox* associatedFlexBox = nullptr;





    int order = 0;




    float flexGrow = 0.0f;





    float flexShrink = 1.0f;





    float flexBasis = 0.0f;


    enum class AlignSelf { autoAlign, flexStart, flexEnd, center, stretch };





    AlignSelf alignSelf = AlignSelf::stretch;



    static const int autoValue = -2;

    static const int notAssigned = -1;

    float width = (float) notAssigned;
    float minWidth = 0.0f;
    float maxWidth = (float) notAssigned;

    float height = (float) notAssigned;
    float minHeight = 0.0f;
    float maxHeight = (float) notAssigned;


    struct Margin
    {
        Margin() noexcept;
        Margin (float size) noexcept;
        Margin (float top, float right, float bottom, float left) noexcept;

        float left;
        float right;
        float top;
        float bottom;
    };


    Margin margin;



    FlexItem withFlex (float newFlexGrow) const noexcept;


    FlexItem withFlex (float newFlexGrow, float newFlexShrink) const noexcept;


    FlexItem withFlex (float newFlexGrow, float newFlexShrink, float newFlexBasis) const noexcept;


    FlexItem withWidth (float newWidth) const noexcept;


    FlexItem withMinWidth (float newMinWidth) const noexcept;


    FlexItem withMaxWidth (float newMaxWidth) const noexcept;


    FlexItem withHeight (float newHeight) const noexcept;


    FlexItem withMinHeight (float newMinHeight) const noexcept;


    FlexItem withMaxHeight (float newMaxHeight) const noexcept;


    FlexItem withMargin (Margin) const noexcept;


    FlexItem withOrder (int newOrder) const noexcept;


    FlexItem withAlignSelf (AlignSelf newAlignSelf) const noexcept;
};
# 287 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_FlexBox.h" 1
# 36 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/layout/juce_FlexBox.h"
class FlexBox
{
public:

    enum class Direction { row, rowReverse, column, columnReverse };

    enum class Wrap { noWrap, wrap, wrapReverse };

    enum class AlignContent { stretch, flexStart, flexEnd, center, spaceBetween, spaceAround };

    enum class AlignItems { stretch, flexStart, flexEnd, center };

    enum class JustifyContent { flexStart, flexEnd, center, spaceBetween, spaceAround };



    FlexBox() noexcept;


    FlexBox (Direction, Wrap, AlignContent, AlignItems, JustifyContent) noexcept;


    FlexBox (JustifyContent) noexcept;


    ~FlexBox() noexcept;



    void performLayout (Rectangle<float> targetArea);


    void performLayout (Rectangle<int> targetArea);





    Direction flexDirection = Direction::row;




    Wrap flexWrap = Wrap::noWrap;





    AlignContent alignContent = AlignContent::stretch;


    AlignItems alignItems = AlignItems::stretch;






    JustifyContent justifyContent = JustifyContent::flexStart;


    Array<FlexItem> items;

private:

};
# 288 "..\\..\\..\\JUCE\\modules\\juce_gui_basics/juce_gui_basics.h" 2



}
# 23 "C:\\Users\\Cathy\\OneDrive\\JUCE Terrain\\Source/../JuceLibraryCode/JuceHeader.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/juce_gui_extra.h" 1
# 75 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/juce_gui_extra.h"
namespace juce
{


# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/documents/juce_FileBasedDocument.h" 1
# 49 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/documents/juce_FileBasedDocument.h"
class FileBasedDocument : public ChangeBroadcaster
{
public:







    FileBasedDocument (const String& fileExtension,
                       const String& fileWildCard,
                       const String& openFileDialogTitle,
                       const String& saveFileDialogTitle);


    virtual ~FileBasedDocument();







    bool hasChangedSinceSaved() const { return changedSinceSave; }
# 85 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/documents/juce_FileBasedDocument.h"
    virtual void changed();
# 94 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/documents/juce_FileBasedDocument.h"
    void setChangedFlag (bool hasChanged);
# 107 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/documents/juce_FileBasedDocument.h"
    Result loadFrom (const File& fileToLoadFrom,
                     bool showMessageOnFailure);
# 121 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/documents/juce_FileBasedDocument.h"
    Result loadFromUserSpecifiedFile (bool showMessageOnFailure);




    enum SaveResult
    {
        savedOk = 0,
        userCancelledSave,
        failedToWriteToFile
    };
# 145 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/documents/juce_FileBasedDocument.h"
    SaveResult save (bool askUserForFileIfNotSpecified,
                     bool showMessageOnFailure);
# 168 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/documents/juce_FileBasedDocument.h"
    SaveResult saveIfNeededAndUserAgrees();
# 185 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/documents/juce_FileBasedDocument.h"
    SaveResult saveAs (const File& newFile,
                       bool warnAboutOverwritingExistingFiles,
                       bool askUserForFileIfNotSpecified,
                       bool showMessageOnFailure);
# 201 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/documents/juce_FileBasedDocument.h"
    SaveResult saveAsInteractive (bool warnAboutOverwritingExistingFiles);
# 211 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/documents/juce_FileBasedDocument.h"
    const File& getFile() const { return documentFile; }







    void setFile (const File& newFile);


protected:






    virtual String getDocumentTitle() = 0;




    virtual Result loadDocument (const File& file) = 0;




    virtual Result saveDocument (const File& file) = 0;
# 257 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/documents/juce_FileBasedDocument.h"
    virtual File getLastDocumentOpened() = 0;
# 272 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/documents/juce_FileBasedDocument.h"
    virtual void setLastDocumentOpened (const File& file) = 0;
# 281 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/documents/juce_FileBasedDocument.h"
    virtual File getSuggestedSaveAsFile (const File& defaultFile);


private:

    File documentFile;
    bool changedSinceSave;
    String fileExtension, fileWildcard, openFileDialogTitle, saveFileDialogTitle;

    FileBasedDocument (const FileBasedDocument&) = delete; FileBasedDocument& operator= (const FileBasedDocument&) = delete;
};
# 78 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/juce_gui_extra.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/code_editor/juce_CodeDocument.h" 1
# 28 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/code_editor/juce_CodeDocument.h"
class CodeDocumentLine;
# 42 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/code_editor/juce_CodeDocument.h"
class CodeDocument
{
public:

    CodeDocument();


    ~CodeDocument();
# 59 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/code_editor/juce_CodeDocument.h"
    class Position
    {
    public:




        Position() noexcept;
# 78 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/code_editor/juce_CodeDocument.h"
        Position (const CodeDocument& ownerDocument,
                  int line, int indexInLine) noexcept;
# 88 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/code_editor/juce_CodeDocument.h"
        Position (const CodeDocument& ownerDocument,
                  int charactersFromStartOfDocument) noexcept;






        Position (const Position&) noexcept;


        ~Position();

        Position& operator= (const Position&);

        bool operator== (const Position&) const noexcept;
        bool operator!= (const Position&) const noexcept;







        void setPosition (int charactersFromStartOfDocument);




        int getPosition() const noexcept { return characterPos; }
# 128 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/code_editor/juce_CodeDocument.h"
        void setLineAndIndex (int newLineNumber, int newIndexInLine);




        int getLineNumber() const noexcept { return line; }







        int getIndexInLine() const noexcept { return indexInLine; }







        void setPositionMaintained (bool isMaintained);





        void moveBy (int characterDelta);





        Position movedBy (int characterDelta) const;





        Position movedByLines (int deltaLines) const;




        juce_wchar getCharacter() const;




        String getLineText() const;

    private:
        CodeDocument* owner;
        int characterPos, line, indexInLine;
        bool positionMaintained;
    };



    String getAllContent() const;


    String getTextBetween (const Position& start, const Position& end) const;


    String getLine (int lineIndex) const noexcept;


    int getNumCharacters() const noexcept;


    int getNumLines() const noexcept { return lines.size(); }


    int getMaximumLineLength() noexcept;




    void deleteSection (const Position& startPosition, const Position& endPosition);




    void deleteSection (int startIndex, int endIndex);




    void insertText (const Position& position, const String& text);




    void insertText (int insertIndex, const String& text);




    void replaceSection (int startIndex, int endIndex, const String& newText);






    void replaceAllContent (const String& newContent);




    void applyChanges (const String& newContent);




    bool loadFromStream (InputStream& stream);


    bool writeToStream (OutputStream& stream);






    String getNewLineCharacters() const noexcept { return newLineChars; }





    void setNewLineCharacters (const String& newLineCharacters) noexcept;
# 269 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/code_editor/juce_CodeDocument.h"
    void newTransaction();




    void undo();




    void redo();




    void clearUndoHistory();


    UndoManager& getUndoManager() noexcept { return undoManager; }
# 299 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/code_editor/juce_CodeDocument.h"
    void setSavePoint() noexcept;






    bool hasChangedSinceSavePoint() const noexcept;



    Position findWordBreakAfter (const Position& position) const noexcept;

    Position findWordBreakBefore (const Position& position) const noexcept;

    void findTokenContaining (const Position& pos, Position& start, Position& end) const noexcept;

    void findLineContaining (const Position& pos, Position& start, Position& end) const noexcept;





    class Listener
    {
    public:
        Listener() {}
        virtual ~Listener() {}


        virtual void codeDocumentTextInserted (const String& newText, int insertIndex) = 0;


        virtual void codeDocumentTextDeleted (int startIndex, int endIndex) = 0;
    };





    void addListener (Listener* listener) noexcept;




    void removeListener (Listener* listener) noexcept;
# 354 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/code_editor/juce_CodeDocument.h"
    class Iterator
    {
    public:
        Iterator (const CodeDocument& document) noexcept;
        Iterator (const Iterator&) noexcept;
        Iterator& operator= (const Iterator&) noexcept;
        ~Iterator() noexcept;




        juce_wchar nextChar() noexcept;


        juce_wchar peekNextChar() const noexcept;


        void skip() noexcept;


        int getPosition() const noexcept { return position; }


        void skipWhitespace() noexcept;


        void skipToEndOfLine() noexcept;


        int getLine() const noexcept { return line; }


        bool isEOF() const noexcept;

    private:
        const CodeDocument* document;
        mutable String::CharPointerType charPointer;
        int line, position;
    };

private:

    friend class CodeDocumentInsertAction;
    friend class CodeDocumentDeleteAction;
    friend class Iterator;
    friend class Position;

    OwnedArray <CodeDocumentLine> lines;
    Array <Position*> positionsToMaintain;
    UndoManager undoManager;
    int currentActionIndex, indexOfSavedState;
    int maximumLineLength;
    ListenerList <Listener> listeners;
    String newLineChars;

    void insert (const String& text, int insertPos, bool undoable);
    void remove (int startPos, int endPos, bool undoable);
    void checkLastLineStatus();

    CodeDocument (const CodeDocument&) = delete; CodeDocument& operator= (const CodeDocument&) = delete;
};
# 79 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/juce_gui_extra.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/code_editor/juce_CodeEditorComponent.h" 1
# 28 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/code_editor/juce_CodeEditorComponent.h"
class CodeTokeniser;
# 38 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/code_editor/juce_CodeEditorComponent.h"
class CodeEditorComponent : public Component,
                                        public ApplicationCommandTarget,
                                        public TextInputTarget
{
public:
# 52 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/code_editor/juce_CodeEditorComponent.h"
    CodeEditorComponent (CodeDocument& document,
                         CodeTokeniser* codeTokeniser);


    ~CodeEditorComponent();



    CodeDocument& getDocument() const noexcept { return document; }





    void loadContent (const String& newContent);



    float getCharWidth() const noexcept { return charWidth; }


    int getLineHeight() const noexcept { return lineHeight; }





    int getNumLinesOnScreen() const noexcept { return linesOnScreen; }


    int getFirstLineOnScreen() const noexcept { return firstLineOnScreen; }




    int getNumColumnsOnScreen() const noexcept { return columnsOnScreen; }


    CodeDocument::Position getCaretPos() const { return caretPos; }


    Rectangle<int> getCaretRectangle() override;






    void moveCaretTo (const CodeDocument::Position& newPos, bool selecting);




    Rectangle<int> getCharacterBounds (const CodeDocument::Position& pos) const;




    CodeDocument::Position getPositionAt (int x, int y);


    CodeDocument::Position getSelectionStart() const { return selectionStart; }


    CodeDocument::Position getSelectionEnd() const { return selectionEnd; }


    void setLineNumbersShown (bool shouldBeShown);


    bool moveCaretLeft (bool moveInWholeWordSteps, bool selecting);
    bool moveCaretRight (bool moveInWholeWordSteps, bool selecting);
    bool moveCaretUp (bool selecting);
    bool moveCaretDown (bool selecting);
    bool scrollDown();
    bool scrollUp();
    bool pageUp (bool selecting);
    bool pageDown (bool selecting);
    bool moveCaretToTop (bool selecting);
    bool moveCaretToStartOfLine (bool selecting);
    bool moveCaretToEnd (bool selecting);
    bool moveCaretToEndOfLine (bool selecting);
    bool deleteBackwards (bool moveInWholeWordSteps);
    bool deleteForwards (bool moveInWholeWordSteps);
    bool deleteWhitespaceBackwardsToTabStop();
    virtual bool copyToClipboard();
    virtual bool cutToClipboard();
    virtual bool pasteFromClipboard();
    bool undo();
    bool redo();

    void selectRegion (const CodeDocument::Position& start, const CodeDocument::Position& end);
    bool selectAll();
    void deselectAll();

    void scrollToLine (int newFirstLineOnScreen);
    void scrollBy (int deltaLines);
    void scrollToColumn (int newFirstColumnOnScreen);
    void scrollToKeepCaretOnScreen();
    void scrollToKeepLinesOnScreen (Range<int> linesToShow);

    void insertTextAtCaret (const String& textToInsert) override;
    void insertTabAtCaret();

    void indentSelection();
    void unindentSelection();


    Range<int> getHighlightedRegion() const override;
    bool isHighlightActive() const noexcept;
    void setHighlightedRegion (const Range<int>& newRange) override;
    String getTextInRange (const Range<int>& range) const override;



    struct State
    {

        State (const CodeEditorComponent&);

        State (const String& stringifiedVersion);
        State (const State&) noexcept;


        void restoreState (CodeEditorComponent&) const;


        String toString() const;

    private:
        int lastTopLine, lastCaretPos, lastSelectionEnd;
    };






    void setTabSize (int numSpacesPerTab, bool insertSpacesInsteadOfTabCharacters);




    int getTabSize() const noexcept { return spacesPerTab; }




    bool areSpacesInsertedForTabs() const { return useSpacesForTabs; }


    String getTabString (int numSpaces) const;




    void setFont (const Font& newFont);


    const Font& getFont() const noexcept { return font; }


    void setReadOnly (bool shouldBeReadOnly) noexcept;


    bool isReadOnly() const noexcept { return readOnly; }


    struct ColourScheme
    {
        struct TokenType
        {
            String name;
            Colour colour;
        };

        Array<TokenType> types;

        void set (const String& name, const Colour colour);
    };






    void setColourScheme (const ColourScheme& scheme);


    const ColourScheme& getColourScheme() const noexcept { return colourScheme; }





    Colour getColourForTokenType (int tokenType) const;
# 257 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/code_editor/juce_CodeEditorComponent.h"
    enum ColourIds
    {
        backgroundColourId = 0x1004500,
        highlightColourId = 0x1004502,
        defaultTextColourId = 0x1004503,
        lineNumberBackgroundId = 0x1004504,
        lineNumberTextId = 0x1004505,
    };



    void setScrollbarThickness (int thickness);


    int getScrollbarThickness() const noexcept { return scrollbarThickness; }



    virtual void handleReturnKey();

    virtual void handleTabKey();

    virtual void handleEscapeKey();


    virtual void editorViewportPositionChanged();
# 302 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/code_editor/juce_CodeEditorComponent.h"
    virtual void addPopupMenuItems (PopupMenu& menuToAddTo,
                                    const MouseEvent* mouseClickEvent);
# 316 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/code_editor/juce_CodeEditorComponent.h"
    virtual void performPopupMenuAction (int menuItemID);
# 325 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/code_editor/juce_CodeEditorComponent.h"
    void setCommandManager (ApplicationCommandManager* newManager) noexcept;



    void paint (Graphics&) override;

    void resized() override;

    bool keyPressed (const KeyPress&) override;

    void mouseDown (const MouseEvent&) override;

    void mouseDrag (const MouseEvent&) override;

    void mouseUp (const MouseEvent&) override;

    void mouseDoubleClick (const MouseEvent&) override;

    void mouseWheelMove (const MouseEvent&, const MouseWheelDetails&) override;

    void focusGained (FocusChangeType) override;

    void focusLost (FocusChangeType) override;

    bool isTextInputActive() const override;

    void setTemporaryUnderlining (const Array<Range<int> >&) override;

    ApplicationCommandTarget* getNextCommandTarget() override;

    void getAllCommands (Array<CommandID>&) override;

    void getCommandInfo (CommandID, ApplicationCommandInfo&) override;

    bool perform (const InvocationInfo&) override;

private:

    CodeDocument& document;

    Font font;
    int firstLineOnScreen, spacesPerTab;
    float charWidth;
    int lineHeight, linesOnScreen, columnsOnScreen;
    int scrollbarThickness, columnToTryToMaintain;
    bool readOnly, useSpacesForTabs, showLineNumbers, shouldFollowDocumentChanges;
    double xOffset;

    CodeDocument::Position caretPos, selectionStart, selectionEnd;

    ScopedPointer<CaretComponent> caret;
    ScrollBar verticalScrollBar, horizontalScrollBar;
    ApplicationCommandManager* appCommandManager;

    class Pimpl;
    friend class Pimpl;
    friend struct ContainerDeletePolicy<Pimpl>;
    ScopedPointer<Pimpl> pimpl;

    class GutterComponent;
    friend class GutterComponent;
    friend struct ContainerDeletePolicy<GutterComponent>;
    ScopedPointer<GutterComponent> gutter;

    enum DragType
    {
        notDragging,
        draggingSelectionStart,
        draggingSelectionEnd
    };

    DragType dragType;


    CodeTokeniser* codeTokeniser;
    ColourScheme colourScheme;

    class CodeEditorLine;
    OwnedArray<CodeEditorLine> lines;
    void rebuildLineTokens();
    void rebuildLineTokensAsync();
    void codeDocumentChanged (int start, int end);

    OwnedArray<CodeDocument::Iterator> cachedIterators;
    void clearCachedIterators (int firstLineToBeInvalid);
    void updateCachedIterators (int maxLineNum);
    void getIteratorForPosition (int position, CodeDocument::Iterator&);

    void moveLineDelta (int delta, bool selecting);
    int getGutterSize() const noexcept;


    void insertText (const String&);
    virtual void updateCaretPosition();
    void updateScrollBars();
    void scrollToLineInternal (int line);
    void scrollToColumnInternal (double column);
    void newTransaction();
    void cut();
    void indentSelectedLines (int spacesToAdd);
    bool skipBackwardsToPreviousTab();
    bool performCommand (CommandID);

    int indexToColumn (int line, int index) const noexcept;
    int columnToIndex (int line, int column) const noexcept;

    CodeEditorComponent (const CodeEditorComponent&) = delete; CodeEditorComponent& operator= (const CodeEditorComponent&) = delete;
};
# 80 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/juce_gui_extra.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/code_editor/juce_CodeTokeniser.h" 1
# 36 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/code_editor/juce_CodeTokeniser.h"
class CodeTokeniser
{
public:
    CodeTokeniser() {}
    virtual ~CodeTokeniser() {}







    virtual int readNextToken (CodeDocument::Iterator& source) = 0;


    virtual CodeEditorComponent::ColourScheme getDefaultColourScheme() = 0;

private:

};
# 81 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/juce_gui_extra.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/code_editor/juce_CPlusPlusCodeTokeniser.h" 1
# 35 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/code_editor/juce_CPlusPlusCodeTokeniser.h"
class CPlusPlusCodeTokeniser : public CodeTokeniser
{
public:

    CPlusPlusCodeTokeniser();
    ~CPlusPlusCodeTokeniser();


    int readNextToken (CodeDocument::Iterator&) override;
    CodeEditorComponent::ColourScheme getDefaultColourScheme() override;


    static bool isReservedKeyword (const String& token) noexcept;


    enum TokenType
    {
        tokenType_error = 0,
        tokenType_comment,
        tokenType_keyword,
        tokenType_operator,
        tokenType_identifier,
        tokenType_integer,
        tokenType_float,
        tokenType_string,
        tokenType_bracket,
        tokenType_punctuation,
        tokenType_preprocessor
    };

private:


};
# 82 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/juce_gui_extra.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/code_editor/juce_CPlusPlusCodeTokeniserFunctions.h" 1
# 32 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/code_editor/juce_CPlusPlusCodeTokeniserFunctions.h"
struct CppTokeniserFunctions
{
    static bool isIdentifierStart (const juce_wchar c) noexcept
    {
        return CharacterFunctions::isLetter (c)
                || c == '_' || c == '@';
    }

    static bool isIdentifierBody (const juce_wchar c) noexcept
    {
        return CharacterFunctions::isLetterOrDigit (c)
                || c == '_' || c == '@';
    }

    static bool isReservedKeyword (String::CharPointerType token, const int tokenLength) noexcept
    {
        static const char* const keywords2Char[] =
            { "if", "do", "or", nullptr };

        static const char* const keywords3Char[] =
            { "for", "int", "new", "try", "xor", "and", "asm", "not", nullptr };

        static const char* const keywords4Char[] =
            { "bool", "void", "this", "true", "long", "else", "char",
              "enum", "case", "goto", "auto", nullptr };

        static const char* const keywords5Char[] =
            { "float", "const", "while", "break", "false", "catch", "class", "bitor",
              "compl", "or_eq", "short", "throw", "union", "using", "final", nullptr };

        static const char* const keywords6Char[] =
            { "return", "and_eq", "bitand", "delete", "double", "export", "extern",
              "friend", "inline", "not_eq", "public", "signed", "sizeof", "static",
              "struct", "switch", "typeid", "xor_eq", nullptr };

        static const char* const keywords7Char[] =
            { "nullptr", "alignas", "alignof", "default", "mutable", "private",
              "typedef", "virtual", "wchar_t", "__cdecl", "_Pragma", "uint8_t", nullptr };

        static const char* const keywordsOther[] =
            { "char16_t", "char32_t", "const_cast", "constexpr", "continue", "decltype", "dynamic_cast",
              "explicit", "namespace", "noexcept", "operator", "protected", "register", "reinterpret_cast",
              "static_assert", "static_cast", "template", "thread_local", "typename", "unsigned", "volatile",
              "@class", "@dynamic", "@end", "@implementation", "@interface", "@public", "@private",
              "@protected", "@property", "@synthesize", "__fastcall", "__stdcall", nullptr };

        const char* const* k;

        switch (tokenLength)
        {
            case 2: k = keywords2Char; break;
            case 3: k = keywords3Char; break;
            case 4: k = keywords4Char; break;
            case 5: k = keywords5Char; break;
            case 6: k = keywords6Char; break;
            case 7: k = keywords7Char; break;

            default:
                if (tokenLength < 2 || tokenLength > 16)
                    return false;

                k = keywordsOther;
                break;
        }

        for (int i = 0; k[i] != 0; ++i)
            if (token.compare (CharPointer_ASCII (k[i])) == 0)
                return true;

        return false;
    }

    template <typename Iterator>
    static int parseIdentifier (Iterator& source) noexcept
    {
        int tokenLength = 0;
        String::CharPointerType::CharType possibleIdentifier [100];
        String::CharPointerType possible (possibleIdentifier);

        while (isIdentifierBody (source.peekNextChar()))
        {
            const juce_wchar c = source.nextChar();

            if (tokenLength < 20)
                possible.write (c);

            ++tokenLength;
        }

        if (tokenLength > 1 && tokenLength <= 16)
        {
            possible.writeNull();

            if (isReservedKeyword (String::CharPointerType (possibleIdentifier), tokenLength))
                return CPlusPlusCodeTokeniser::tokenType_keyword;
        }

        return CPlusPlusCodeTokeniser::tokenType_identifier;
    }

    template <typename Iterator>
    static bool skipNumberSuffix (Iterator& source)
    {
        const juce_wchar c = source.peekNextChar();
        if (c == 'l' || c == 'L' || c == 'u' || c == 'U')
            source.skip();

        if (CharacterFunctions::isLetterOrDigit (source.peekNextChar()))
            return false;

        return true;
    }

    static bool isHexDigit (const juce_wchar c) noexcept
    {
        return (c >= '0' && c <= '9')
                || (c >= 'a' && c <= 'f')
                || (c >= 'A' && c <= 'F');
    }

    template <typename Iterator>
    static bool parseHexLiteral (Iterator& source) noexcept
    {
        if (source.peekNextChar() == '-')
            source.skip();

        if (source.nextChar() != '0')
            return false;

        juce_wchar c = source.nextChar();
        if (c != 'x' && c != 'X')
            return false;

        int numDigits = 0;
        while (isHexDigit (source.peekNextChar()))
        {
            ++numDigits;
            source.skip();
        }

        if (numDigits == 0)
            return false;

        return skipNumberSuffix (source);
    }

    static bool isOctalDigit (const juce_wchar c) noexcept
    {
        return c >= '0' && c <= '7';
    }

    template <typename Iterator>
    static bool parseOctalLiteral (Iterator& source) noexcept
    {
        if (source.peekNextChar() == '-')
            source.skip();

        if (source.nextChar() != '0')
            return false;

        if (! isOctalDigit (source.nextChar()))
            return false;

        while (isOctalDigit (source.peekNextChar()))
            source.skip();

        return skipNumberSuffix (source);
    }

    static bool isDecimalDigit (const juce_wchar c) noexcept
    {
        return c >= '0' && c <= '9';
    }

    template <typename Iterator>
    static bool parseDecimalLiteral (Iterator& source) noexcept
    {
        if (source.peekNextChar() == '-')
            source.skip();

        int numChars = 0;
        while (isDecimalDigit (source.peekNextChar()))
        {
            ++numChars;
            source.skip();
        }

        if (numChars == 0)
            return false;

        return skipNumberSuffix (source);
    }

    template <typename Iterator>
    static bool parseFloatLiteral (Iterator& source) noexcept
    {
        if (source.peekNextChar() == '-')
            source.skip();

        int numDigits = 0;

        while (isDecimalDigit (source.peekNextChar()))
        {
            source.skip();
            ++numDigits;
        }

        const bool hasPoint = (source.peekNextChar() == '.');

        if (hasPoint)
        {
            source.skip();

            while (isDecimalDigit (source.peekNextChar()))
            {
                source.skip();
                ++numDigits;
            }
        }

        if (numDigits == 0)
            return false;

        juce_wchar c = source.peekNextChar();
        const bool hasExponent = (c == 'e' || c == 'E');

        if (hasExponent)
        {
            source.skip();

            c = source.peekNextChar();
            if (c == '+' || c == '-')
                source.skip();

            int numExpDigits = 0;
            while (isDecimalDigit (source.peekNextChar()))
            {
                source.skip();
                ++numExpDigits;
            }

            if (numExpDigits == 0)
                return false;
        }

        c = source.peekNextChar();
        if (c == 'f' || c == 'F')
            source.skip();
        else if (! (hasExponent || hasPoint))
            return false;

        return true;
    }

    template <typename Iterator>
    static int parseNumber (Iterator& source)
    {
        const Iterator original (source);

        if (parseFloatLiteral (source)) return CPlusPlusCodeTokeniser::tokenType_float;
        source = original;

        if (parseHexLiteral (source)) return CPlusPlusCodeTokeniser::tokenType_integer;
        source = original;

        if (parseOctalLiteral (source)) return CPlusPlusCodeTokeniser::tokenType_integer;
        source = original;

        if (parseDecimalLiteral (source)) return CPlusPlusCodeTokeniser::tokenType_integer;
        source = original;

        return CPlusPlusCodeTokeniser::tokenType_error;
    }

    template <typename Iterator>
    static void skipQuotedString (Iterator& source) noexcept
    {
        const juce_wchar quote = source.nextChar();

        for (;;)
        {
            const juce_wchar c = source.nextChar();

            if (c == quote || c == 0)
                break;

            if (c == '\\')
                source.skip();
        }
    }

    template <typename Iterator>
    static void skipComment (Iterator& source) noexcept
    {
        bool lastWasStar = false;

        for (;;)
        {
            const juce_wchar c = source.nextChar();

            if (c == 0 || (c == '/' && lastWasStar))
                break;

            lastWasStar = (c == '*');
        }
    }

    template <typename Iterator>
    static void skipPreprocessorLine (Iterator& source) noexcept
    {
        bool lastWasBackslash = false;

        for (;;)
        {
            const juce_wchar c = source.peekNextChar();

            if (c == '"')
            {
                skipQuotedString (source);
                continue;
            }

            if (c == '/')
            {
                Iterator next (source);
                next.skip();
                const juce_wchar c2 = next.peekNextChar();

                if (c2 == '/' || c2 == '*')
                    return;
            }

            if (c == 0)
                break;

            if (c == '\n' || c == '\r')
            {
                source.skipToEndOfLine();

                if (lastWasBackslash)
                    skipPreprocessorLine (source);

                break;
            }

            lastWasBackslash = (c == '\\');
            source.skip();
        }
    }

    template <typename Iterator>
    static void skipIfNextCharMatches (Iterator& source, const juce_wchar c) noexcept
    {
        if (source.peekNextChar() == c)
            source.skip();
    }

    template <typename Iterator>
    static void skipIfNextCharMatches (Iterator& source, const juce_wchar c1, const juce_wchar c2) noexcept
    {
        const juce_wchar c = source.peekNextChar();

        if (c == c1 || c == c2)
            source.skip();
    }

    template <typename Iterator>
    static int readNextToken (Iterator& source)
    {
        source.skipWhitespace();

        const juce_wchar firstChar = source.peekNextChar();

        switch (firstChar)
        {
        case 0:
            break;

        case '0': case '1': case '2': case '3': case '4':
        case '5': case '6': case '7': case '8': case '9':
        case '.':
        {
            int result = parseNumber (source);

            if (result == CPlusPlusCodeTokeniser::tokenType_error)
            {
                source.skip();

                if (firstChar == '.')
                    return CPlusPlusCodeTokeniser::tokenType_punctuation;
            }

            return result;
        }

        case ',':
        case ';':
        case ':':
            source.skip();
            return CPlusPlusCodeTokeniser::tokenType_punctuation;

        case '(': case ')':
        case '{': case '}':
        case '[': case ']':
            source.skip();
            return CPlusPlusCodeTokeniser::tokenType_bracket;

        case '"':
        case '\'':
            skipQuotedString (source);
            return CPlusPlusCodeTokeniser::tokenType_string;

        case '+':
            source.skip();
            skipIfNextCharMatches (source, '+', '=');
            return CPlusPlusCodeTokeniser::tokenType_operator;

        case '-':
        {
            source.skip();
            int result = parseNumber (source);

            if (result == CPlusPlusCodeTokeniser::tokenType_error)
            {
                skipIfNextCharMatches (source, '-', '=');
                return CPlusPlusCodeTokeniser::tokenType_operator;
            }

            return result;
        }

        case '*': case '%':
        case '=': case '!':
            source.skip();
            skipIfNextCharMatches (source, '=');
            return CPlusPlusCodeTokeniser::tokenType_operator;

        case '/':
        {
            source.skip();
            juce_wchar nextChar = source.peekNextChar();

            if (nextChar == '/')
            {
                source.skipToEndOfLine();
                return CPlusPlusCodeTokeniser::tokenType_comment;
            }

            if (nextChar == '*')
            {
                source.skip();
                skipComment (source);
                return CPlusPlusCodeTokeniser::tokenType_comment;
            }

            if (nextChar == '=')
                source.skip();

            return CPlusPlusCodeTokeniser::tokenType_operator;
        }

        case '?':
        case '~':
            source.skip();
            return CPlusPlusCodeTokeniser::tokenType_operator;

        case '<': case '>':
        case '|': case '&': case '^':
            source.skip();
            skipIfNextCharMatches (source, firstChar);
            skipIfNextCharMatches (source, '=');
            return CPlusPlusCodeTokeniser::tokenType_operator;

        case '#':
            skipPreprocessorLine (source);
            return CPlusPlusCodeTokeniser::tokenType_preprocessor;

        default:
            if (isIdentifierStart (firstChar))
                return parseIdentifier (source);

            source.skip();
            break;
        }

        return CPlusPlusCodeTokeniser::tokenType_error;
    }




    struct StringIterator
    {
        StringIterator (const String& s) noexcept : t (s.getCharPointer()), numChars (0) {}
        StringIterator (String::CharPointerType s) noexcept : t (s), numChars (0) {}

        juce_wchar nextChar() noexcept { if (isEOF()) return 0; ++numChars; return t.getAndAdvance(); }
        juce_wchar peekNextChar()noexcept { return *t; }
        void skip() noexcept { if (! isEOF()) { ++t; ++numChars; } }
        void skipWhitespace() noexcept { while (t.isWhitespace()) skip(); }
        void skipToEndOfLine() noexcept { while (*t != '\r' && *t != '\n' && *t != 0) skip(); }
        bool isEOF() const noexcept { return t.isEmpty(); }

        String::CharPointerType t;
        int numChars;
    };
# 550 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/code_editor/juce_CPlusPlusCodeTokeniserFunctions.h"
    static void writeEscapeChars (OutputStream& out, const char* utf8, const int numBytesToRead,
                                  const int maxCharsOnLine, const bool breakAtNewLines,
                                  const bool replaceSingleQuotes, const bool allowStringBreaks)
    {
        int charsOnLine = 0;
        bool lastWasHexEscapeCode = false;
        bool trigraphDetected = false;

        for (int i = 0; i < numBytesToRead || numBytesToRead < 0; ++i)
        {
            const unsigned char c = (unsigned char) utf8[i];
            bool startNewLine = false;

            switch (c)
            {

                case '\t': out << "\\t"; trigraphDetected = false; lastWasHexEscapeCode = false; charsOnLine += 2; break;
                case '\r': out << "\\r"; trigraphDetected = false; lastWasHexEscapeCode = false; charsOnLine += 2; break;
                case '\n': out << "\\n"; trigraphDetected = false; lastWasHexEscapeCode = false; charsOnLine += 2; startNewLine = breakAtNewLines; break;
                case '\\': out << "\\\\"; trigraphDetected = false; lastWasHexEscapeCode = false; charsOnLine += 2; break;
                case '\"': out << "\\\""; trigraphDetected = false; lastWasHexEscapeCode = false; charsOnLine += 2; break;

                case '?':
                    if (trigraphDetected)
                    {
                        out << "\\?";
                        charsOnLine++;
                        trigraphDetected = false;
                    }
                    else
                    {
                        out << "?";
                        trigraphDetected = true;
                    }

                    lastWasHexEscapeCode = false;
                    charsOnLine++;
                    break;

                case 0:
                    if (numBytesToRead < 0)
                        return;

                    out << "\\0";
                    lastWasHexEscapeCode = true;
                    trigraphDetected = false;
                    charsOnLine += 2;
                    break;

                case '\'':
                    if (replaceSingleQuotes)
                    {
                        out << "\\\'";
                        lastWasHexEscapeCode = false;
                        trigraphDetected = false;
                        charsOnLine += 2;
                        break;
                    }



                default:
                    if (c >= 32 && c < 127 && ! (lastWasHexEscapeCode
                                                   && CharacterFunctions::getHexDigitValue (c) >= 0))
                    {
                        out << (char) c;
                        lastWasHexEscapeCode = false;
                        trigraphDetected = false;
                        ++charsOnLine;
                    }
                    else if (allowStringBreaks && lastWasHexEscapeCode && c >= 32 && c < 127)
                    {
                        out << "\"\"" << (char) c;
                        lastWasHexEscapeCode = false;
                        trigraphDetected = false;
                        charsOnLine += 3;
                    }
                    else
                    {
                        out << (c < 16 ? "\\x0" : "\\x") << String::toHexString ((int) c);
                        lastWasHexEscapeCode = true;
                        trigraphDetected = false;
                        charsOnLine += 4;
                    }

                    break;
            }

            if ((startNewLine || (maxCharsOnLine > 0 && charsOnLine >= maxCharsOnLine))
                 && (numBytesToRead < 0 || i < numBytesToRead - 1))
            {
                charsOnLine = 0;
                out << "\"" << newLine << "\"";
                lastWasHexEscapeCode = false;
            }
        }
    }
# 656 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/code_editor/juce_CPlusPlusCodeTokeniserFunctions.h"
    static String addEscapeChars (const String& s)
    {
        MemoryOutputStream mo;
        writeEscapeChars (mo, s.toRawUTF8(), -1, -1, false, true, true);
        return mo.toString();
    }
};
# 83 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/juce_gui_extra.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/code_editor/juce_XMLCodeTokeniser.h" 1
# 32 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/code_editor/juce_XMLCodeTokeniser.h"
class XmlTokeniser : public CodeTokeniser
{
public:

    XmlTokeniser();
    ~XmlTokeniser();


    int readNextToken (CodeDocument::Iterator&) override;
    CodeEditorComponent::ColourScheme getDefaultColourScheme() override;


    enum TokenType
    {
        tokenType_error = 0,
        tokenType_comment,
        tokenType_keyword,
        tokenType_operator,
        tokenType_identifier,
        tokenType_string,
        tokenType_bracket,
        tokenType_punctuation,
        tokenType_preprocessor
    };

private:
    XmlTokeniser (const XmlTokeniser&) = delete; XmlTokeniser& operator= (const XmlTokeniser&) = delete;
};
# 84 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/juce_gui_extra.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/code_editor/juce_LuaCodeTokeniser.h" 1
# 32 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/code_editor/juce_LuaCodeTokeniser.h"
class LuaTokeniser : public CodeTokeniser
{
public:

    LuaTokeniser();
    ~LuaTokeniser();


    int readNextToken (CodeDocument::Iterator&) override;
    CodeEditorComponent::ColourScheme getDefaultColourScheme() override;


    enum TokenType
    {
        tokenType_error = 0,
        tokenType_comment,
        tokenType_keyword,
        tokenType_operator,
        tokenType_identifier,
        tokenType_integer,
        tokenType_float,
        tokenType_string,
        tokenType_bracket,
        tokenType_punctuation
    };

private:

    LuaTokeniser (const LuaTokeniser&) = delete; LuaTokeniser& operator= (const LuaTokeniser&) = delete;
};
# 85 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/juce_gui_extra.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/embedding/juce_ActiveXControlComponent.h" 1
# 42 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/embedding/juce_ActiveXControlComponent.h"
class ActiveXControlComponent : public Component
{
public:


    ActiveXControlComponent();


    ~ActiveXControlComponent();
# 63 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/embedding/juce_ActiveXControlComponent.h"
    bool createControl (const void* controlIID);



    void deleteControl();


    bool isControlOpen() const noexcept { return control != nullptr; }
# 97 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/embedding/juce_ActiveXControlComponent.h"
    void* queryInterface (const void* iid) const;



    void setMouseEventsAllowed (bool eventsCanReachControl);



    bool areMouseEventsAllowed() const noexcept { return mouseEventsAllowed; }



    void paint (Graphics&) override;

private:
    class Pimpl;
    friend struct ContainerDeletePolicy<Pimpl>;
    ScopedPointer<Pimpl> control;
    bool mouseEventsAllowed;

    ActiveXControlComponent (const ActiveXControlComponent&) = delete; ActiveXControlComponent& operator= (const ActiveXControlComponent&) = delete;
};
# 86 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/juce_gui_extra.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/embedding/juce_NSViewComponent.h" 1
# 87 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/juce_gui_extra.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/embedding/juce_UIViewComponent.h" 1
# 88 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/juce_gui_extra.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_AppleRemote.h" 1
# 89 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/juce_gui_extra.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_BubbleMessageComponent.h" 1
# 38 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_BubbleMessageComponent.h"
class BubbleMessageComponent : public BubbleComponent,
                                          private Timer
{
public:
# 53 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_BubbleMessageComponent.h"
    BubbleMessageComponent (int fadeOutLengthMs = 150);


    ~BubbleMessageComponent();
# 77 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_BubbleMessageComponent.h"
    void showAt (const Rectangle<int>& position,
                 const AttributedString& message,
                 int numMillisecondsBeforeRemoving,
                 bool removeWhenMouseClicked = true,
                 bool deleteSelfAfterUse = false);
# 100 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_BubbleMessageComponent.h"
    void showAt (Component* component,
                 const AttributedString& message,
                 int numMillisecondsBeforeRemoving,
                 bool removeWhenMouseClicked = true,
                 bool deleteSelfAfterUse = false);




    void getContentSize (int& w, int& h) override;

    void paintContent (Graphics& g, int w, int h) override;

    void timerCallback() override;

private:

    int fadeOutLength, mouseClickCounter;
    TextLayout textLayout;
    int64 expiryTime;
    bool deleteAfterUse;

    void createLayout (const AttributedString&);
    void init (int, bool, bool);
    void hide (bool fadeOut);

    BubbleMessageComponent (const BubbleMessageComponent&) = delete; BubbleMessageComponent& operator= (const BubbleMessageComponent&) = delete;
};
# 90 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/juce_gui_extra.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_ColourSelector.h" 1
# 38 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_ColourSelector.h"
class ColourSelector : public Component,
                                  public ChangeBroadcaster,
                                  protected SliderListener
{
public:


    enum ColourSelectorOptions
    {
        showAlphaChannel = 1 << 0,

        showColourAtTop = 1 << 1,
        showSliders = 1 << 2,
        showColourspace = 1 << 3
    };
# 65 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_ColourSelector.h"
    ColourSelector (int flags = (showAlphaChannel | showColourAtTop | showSliders | showColourspace),
                    int edgeGap = 4,
                    int gapAroundColourSpaceComponent = 7);


    ~ColourSelector();
# 80 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_ColourSelector.h"
    Colour getCurrentColour() const;


    void setCurrentColour (Colour newColour, NotificationType notificationType = sendNotification);
# 92 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_ColourSelector.h"
    virtual int getNumSwatches() const;
# 102 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_ColourSelector.h"
    virtual Colour getSwatchColour (int index) const;
# 112 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_ColourSelector.h"
    virtual void setSwatchColour (int index, const Colour& newColour) const;
# 123 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_ColourSelector.h"
    enum ColourIds
    {
        backgroundColourId = 0x1007000,
        labelTextColourId = 0x1007001
    };


private:

    class ColourSpaceView;
    class HueSelectorComp;
    class SwatchComponent;
    class ColourComponentSlider;
    class ColourSpaceMarker;
    class HueSelectorMarker;
    friend class ColourSpaceView;
    friend struct ContainerDeletePolicy<ColourSpaceView>;
    friend class HueSelectorComp;
    friend struct ContainerDeletePolicy<HueSelectorComp>;

    Colour colour;
    float h, s, v;
    ScopedPointer<Slider> sliders[4];
    ScopedPointer<ColourSpaceView> colourSpace;
    ScopedPointer<HueSelectorComp> hueSelector;
    OwnedArray<SwatchComponent> swatchComponents;
    const int flags;
    int edgeGap;
    Rectangle<int> previewArea;

    void setHue (float newH);
    void setSV (float newS, float newV);
    void updateHSV();
    void update (NotificationType);
    void sliderValueChanged (Slider*) override;
    void paint (Graphics&) override;
    void resized() override;

    ColourSelector (const ColourSelector&) = delete; ColourSelector& operator= (const ColourSelector&) = delete;






};
# 91 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/juce_gui_extra.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_KeyMappingEditorComponent.h" 1
# 36 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_KeyMappingEditorComponent.h"
class KeyMappingEditorComponent : public Component
{
public:
# 47 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_KeyMappingEditorComponent.h"
    KeyMappingEditorComponent (KeyPressMappingSet& mappingSet,
                               bool showResetToDefaultButton);


    ~KeyMappingEditorComponent();







    void setColours (Colour mainBackground,
                     Colour textColour);


    KeyPressMappingSet& getMappings() const noexcept { return mappings; }


    ApplicationCommandManager& getCommandManager() const noexcept { return mappings.getCommandManager(); }
# 75 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_KeyMappingEditorComponent.h"
    virtual bool shouldCommandBeIncluded (CommandID commandID);






    virtual bool isCommandReadOnly (CommandID commandID);
# 92 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_KeyMappingEditorComponent.h"
    virtual String getDescriptionForKeyPress (const KeyPress& key);
# 102 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_KeyMappingEditorComponent.h"
    enum ColourIds
    {
        backgroundColourId = 0x100ad00,
        textColourId = 0x100ad01,
    };



    void parentHierarchyChanged() override;

    void resized() override;

private:

    KeyPressMappingSet& mappings;
    TreeView tree;
    TextButton resetButton;

    class TopLevelItem;
    class ChangeKeyButton;
    class MappingItem;
    class CategoryItem;
    class ItemComponent;
    friend class TopLevelItem;
    friend struct ContainerDeletePolicy<ChangeKeyButton>;
    friend struct ContainerDeletePolicy<TopLevelItem>;
    ScopedPointer<TopLevelItem> treeItem;

    KeyMappingEditorComponent (const KeyMappingEditorComponent&) = delete; KeyMappingEditorComponent& operator= (const KeyMappingEditorComponent&) = delete;
};
# 92 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/juce_gui_extra.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_PreferencesPanel.h" 1
# 46 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_PreferencesPanel.h"
class PreferencesPanel : public Component,
                                    private ButtonListener
{
public:





    PreferencesPanel();


    ~PreferencesPanel();
# 74 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_PreferencesPanel.h"
    void addSettingsPage (const String& pageTitle,
                          const Drawable* normalIcon,
                          const Drawable* overIcon,
                          const Drawable* downIcon);
# 92 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_PreferencesPanel.h"
    void addSettingsPage (const String& pageTitle,
                          const void* imageData,
                          int imageDataSize);







    void showInDialogBox (const String& dialogTitle,
                          int dialogWidth,
                          int dialogHeight,
                          Colour backgroundColour = Colours::white);
# 116 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_PreferencesPanel.h"
    virtual Component* createComponentForPage (const String& pageName) = 0;



    void setCurrentPage (const String& pageName);


    int getButtonSize() const noexcept;


    void setButtonSize (int newSize);



    void resized() override;

    void paint (Graphics&) override;

    void buttonClicked (Button*) override;

private:

    String currentPageName;
    ScopedPointer<Component> currentPage;
    OwnedArray<DrawableButton> buttons;
    int buttonSize;

    PreferencesPanel (const PreferencesPanel&) = delete; PreferencesPanel& operator= (const PreferencesPanel&) = delete;
};
# 93 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/juce_gui_extra.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_RecentlyOpenedFilesList.h" 1
# 39 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_RecentlyOpenedFilesList.h"
class RecentlyOpenedFilesList
{
public:



    RecentlyOpenedFilesList();


    ~RecentlyOpenedFilesList();
# 58 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_RecentlyOpenedFilesList.h"
    void setMaxNumberOfItems (int newMaxNumber);




    int getMaxNumberOfItems() const noexcept { return maxNumberOfItems; }





    int getNumFiles() const;





    File getFile (int index) const;



    const StringArray& getAllFilenames() const noexcept { return files; }


    void clear();
# 92 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_RecentlyOpenedFilesList.h"
    void addFile (const File& file);


    void removeFile (const File& file);






    void removeNonExistentFiles();





    static void registerRecentFileNatively (const File& file);
# 128 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_RecentlyOpenedFilesList.h"
    int createPopupMenuItems (PopupMenu& menuToAddItemsTo,
                              int baseItemId,
                              bool showFullPaths,
                              bool dontAddNonExistentFiles,
                              const File** filesToAvoid = nullptr);
# 143 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_RecentlyOpenedFilesList.h"
    String toString() const;
# 152 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_RecentlyOpenedFilesList.h"
    void restoreFromString (const String& stringifiedVersion);


private:

    StringArray files;
    int maxNumberOfItems;


};
# 94 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/juce_gui_extra.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_SplashScreen.h" 1
# 70 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_SplashScreen.h"
class SplashScreen : public Component,
                                private Timer,
                                private DeletedAtShutdown
{
public:
# 101 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_SplashScreen.h"
    SplashScreen (const String& title,
                  const Image& backgroundImage,
                  bool useDropShadow);


    ~SplashScreen();
# 130 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_SplashScreen.h"
    void deleteAfterDelay (RelativeTime minimumTotalTimeToDisplayFor,
                           bool removeOnMouseClick);

protected:


    SplashScreen (const String& title, int width, int height, bool useDropShadow);


    void paint (Graphics&) override;

private:

    Image backgroundImage;
    Time creationTime;
    RelativeTime minimumVisibleTime;
    int clickCountToDelete;

    void timerCallback() override;
    void makeVisible (int w, int h, bool shadow, bool fullscreen);

    SplashScreen (const SplashScreen&) = delete; SplashScreen& operator= (const SplashScreen&) = delete;
};
# 95 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/juce_gui_extra.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_SystemTrayIconComponent.h" 1
# 51 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_SystemTrayIconComponent.h"
class SystemTrayIconComponent : public Component
{
public:

    SystemTrayIconComponent();


    ~SystemTrayIconComponent();



    void setIconImage (const Image& newImage);


    void setIconTooltip (const String& tooltip);


    void setHighlighted (bool);


    void showInfoBubble (const String& title, const String& content);


    void hideInfoBubble();





    void* getNativeHandle() const;
# 92 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_SystemTrayIconComponent.h"
private:

    class Pimpl;
    ScopedPointer<Pimpl> pimpl;

    SystemTrayIconComponent (const SystemTrayIconComponent&) = delete; SystemTrayIconComponent& operator= (const SystemTrayIconComponent&) = delete;
};
# 96 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/juce_gui_extra.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_WebBrowserComponent.h" 1
# 38 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_WebBrowserComponent.h"
class WebBrowserComponent : public Component
{
public:
# 52 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_WebBrowserComponent.h"
    explicit WebBrowserComponent (bool unloadPageWhenBrowserIsHidden = true);


    ~WebBrowserComponent();
# 67 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_WebBrowserComponent.h"
    void goToURL (const String& url,
                  const StringArray* headers = nullptr,
                  const MemoryBlock* postData = nullptr);


    void stop();


    void goBack();


    void goForward();


    void refresh();
# 91 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_WebBrowserComponent.h"
    virtual bool pageAboutToLoad (const String& newURL);


    virtual void pageFinishedLoading (const String& url);




    virtual void windowCloseRequest();





    virtual void newWindowAttemptingToLoad (const String& newURL);



    void paint (Graphics&) override;

    void resized() override;

    void parentHierarchyChanged() override;

    void visibilityChanged() override;

    void focusGained (FocusChangeType) override;

private:

    class Pimpl;
    Pimpl* browser;
    bool blankPageShown, unloadPageWhenBrowserIsHidden;
    String lastURL;
    StringArray lastHeaders;
    MemoryBlock lastPostData;

    void reloadLastURL();
    void checkWindowAssociation();

    WebBrowserComponent (const WebBrowserComponent&) = delete; WebBrowserComponent& operator= (const WebBrowserComponent&) = delete;
};
# 97 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/juce_gui_extra.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_LiveConstantEditor.h" 1
# 98 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/juce_gui_extra.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_AnimatedAppComponent.h" 1
# 37 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/misc/juce_AnimatedAppComponent.h"
class AnimatedAppComponent : public Component,
                               private Timer
{
public:
    AnimatedAppComponent();




    void setFramesPerSecond (int framesPerSecond);





    virtual void update() = 0;




    int getFrameCounter() const noexcept { return totalUpdates; }





    int getMillisecondsSinceLastUpdate() const noexcept;

private:

    Time lastUpdateTime;
    int totalUpdates;

    void timerCallback() override;

    AnimatedAppComponent (const AnimatedAppComponent&) = delete; AnimatedAppComponent& operator= (const AnimatedAppComponent&) = delete;
};
# 99 "..\\..\\..\\JUCE\\modules\\juce_gui_extra/juce_gui_extra.h" 2


}
# 24 "C:\\Users\\Cathy\\OneDrive\\JUCE Terrain\\Source/../JuceLibraryCode/JuceHeader.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_opengl/juce_opengl.h" 1
# 78 "..\\..\\..\\JUCE\\modules\\juce_opengl/juce_opengl.h"
# 1 "C:\\Program Files (x86)\\Windows Kits\\8.1\\Include\\um\\gl/GL.h" 1
# 22 "C:\\Program Files (x86)\\Windows Kits\\8.1\\Include\\um\\gl/GL.h"
# 1 "C:\\Program Files (x86)\\Windows Kits\\8.1\\Include\\shared\\winapifamily.h" 1
# 22 "C:\\Program Files (x86)\\Windows Kits\\8.1\\Include\\um\\gl/GL.h" 2



extern "C" {
# 48 "C:\\Program Files (x86)\\Windows Kits\\8.1\\Include\\um\\gl/GL.h"
typedef unsigned int GLenum;
typedef unsigned char GLboolean;
typedef unsigned int GLbitfield;
typedef signed char GLbyte;
typedef short GLshort;
typedef int GLint;
typedef int GLsizei;
typedef unsigned char GLubyte;
typedef unsigned short GLushort;
typedef unsigned int GLuint;
typedef float GLfloat;
typedef float GLclampf;
typedef double GLdouble;
typedef double GLclampd;
typedef void GLvoid;
# 1157 "C:\\Program Files (x86)\\Windows Kits\\8.1\\Include\\um\\gl/GL.h"
__declspec(dllimport) void __stdcall glAccum (GLenum op, GLfloat value);
__declspec(dllimport) void __stdcall glAlphaFunc (GLenum func, GLclampf ref);
__declspec(dllimport) GLboolean __stdcall glAreTexturesResident (GLsizei n, const GLuint *textures, GLboolean *residences);
__declspec(dllimport) void __stdcall glArrayElement (GLint i);
__declspec(dllimport) void __stdcall glBegin (GLenum mode);
__declspec(dllimport) void __stdcall glBindTexture (GLenum target, GLuint texture);
__declspec(dllimport) void __stdcall glBitmap (GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap);
__declspec(dllimport) void __stdcall glBlendFunc (GLenum sfactor, GLenum dfactor);
__declspec(dllimport) void __stdcall glCallList (GLuint list);
__declspec(dllimport) void __stdcall glCallLists (GLsizei n, GLenum type, const GLvoid *lists);
__declspec(dllimport) void __stdcall glClear (GLbitfield mask);
__declspec(dllimport) void __stdcall glClearAccum (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
__declspec(dllimport) void __stdcall glClearColor (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
__declspec(dllimport) void __stdcall glClearDepth (GLclampd depth);
__declspec(dllimport) void __stdcall glClearIndex (GLfloat c);
__declspec(dllimport) void __stdcall glClearStencil (GLint s);
__declspec(dllimport) void __stdcall glClipPlane (GLenum plane, const GLdouble *equation);
__declspec(dllimport) void __stdcall glColor3b (GLbyte red, GLbyte green, GLbyte blue);
__declspec(dllimport) void __stdcall glColor3bv (const GLbyte *v);
__declspec(dllimport) void __stdcall glColor3d (GLdouble red, GLdouble green, GLdouble blue);
__declspec(dllimport) void __stdcall glColor3dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glColor3f (GLfloat red, GLfloat green, GLfloat blue);
__declspec(dllimport) void __stdcall glColor3fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glColor3i (GLint red, GLint green, GLint blue);
__declspec(dllimport) void __stdcall glColor3iv (const GLint *v);
__declspec(dllimport) void __stdcall glColor3s (GLshort red, GLshort green, GLshort blue);
__declspec(dllimport) void __stdcall glColor3sv (const GLshort *v);
__declspec(dllimport) void __stdcall glColor3ub (GLubyte red, GLubyte green, GLubyte blue);
__declspec(dllimport) void __stdcall glColor3ubv (const GLubyte *v);
__declspec(dllimport) void __stdcall glColor3ui (GLuint red, GLuint green, GLuint blue);
__declspec(dllimport) void __stdcall glColor3uiv (const GLuint *v);
__declspec(dllimport) void __stdcall glColor3us (GLushort red, GLushort green, GLushort blue);
__declspec(dllimport) void __stdcall glColor3usv (const GLushort *v);
__declspec(dllimport) void __stdcall glColor4b (GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha);
__declspec(dllimport) void __stdcall glColor4bv (const GLbyte *v);
__declspec(dllimport) void __stdcall glColor4d (GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha);
__declspec(dllimport) void __stdcall glColor4dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glColor4f (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
__declspec(dllimport) void __stdcall glColor4fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glColor4i (GLint red, GLint green, GLint blue, GLint alpha);
__declspec(dllimport) void __stdcall glColor4iv (const GLint *v);
__declspec(dllimport) void __stdcall glColor4s (GLshort red, GLshort green, GLshort blue, GLshort alpha);
__declspec(dllimport) void __stdcall glColor4sv (const GLshort *v);
__declspec(dllimport) void __stdcall glColor4ub (GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);
__declspec(dllimport) void __stdcall glColor4ubv (const GLubyte *v);
__declspec(dllimport) void __stdcall glColor4ui (GLuint red, GLuint green, GLuint blue, GLuint alpha);
__declspec(dllimport) void __stdcall glColor4uiv (const GLuint *v);
__declspec(dllimport) void __stdcall glColor4us (GLushort red, GLushort green, GLushort blue, GLushort alpha);
__declspec(dllimport) void __stdcall glColor4usv (const GLushort *v);
__declspec(dllimport) void __stdcall glColorMask (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
__declspec(dllimport) void __stdcall glColorMaterial (GLenum face, GLenum mode);
__declspec(dllimport) void __stdcall glColorPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
__declspec(dllimport) void __stdcall glCopyPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum type);
__declspec(dllimport) void __stdcall glCopyTexImage1D (GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border);
__declspec(dllimport) void __stdcall glCopyTexImage2D (GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
__declspec(dllimport) void __stdcall glCopyTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
__declspec(dllimport) void __stdcall glCopyTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
__declspec(dllimport) void __stdcall glCullFace (GLenum mode);
__declspec(dllimport) void __stdcall glDeleteLists (GLuint list, GLsizei range);
__declspec(dllimport) void __stdcall glDeleteTextures (GLsizei n, const GLuint *textures);
__declspec(dllimport) void __stdcall glDepthFunc (GLenum func);
__declspec(dllimport) void __stdcall glDepthMask (GLboolean flag);
__declspec(dllimport) void __stdcall glDepthRange (GLclampd zNear, GLclampd zFar);
__declspec(dllimport) void __stdcall glDisable (GLenum cap);
__declspec(dllimport) void __stdcall glDisableClientState (GLenum array);
__declspec(dllimport) void __stdcall glDrawArrays (GLenum mode, GLint first, GLsizei count);
__declspec(dllimport) void __stdcall glDrawBuffer (GLenum mode);
__declspec(dllimport) void __stdcall glDrawElements (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
__declspec(dllimport) void __stdcall glDrawPixels (GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
__declspec(dllimport) void __stdcall glEdgeFlag (GLboolean flag);
__declspec(dllimport) void __stdcall glEdgeFlagPointer (GLsizei stride, const GLvoid *pointer);
__declspec(dllimport) void __stdcall glEdgeFlagv (const GLboolean *flag);
__declspec(dllimport) void __stdcall glEnable (GLenum cap);
__declspec(dllimport) void __stdcall glEnableClientState (GLenum array);
__declspec(dllimport) void __stdcall glEnd (void);
__declspec(dllimport) void __stdcall glEndList (void);
__declspec(dllimport) void __stdcall glEvalCoord1d (GLdouble u);
__declspec(dllimport) void __stdcall glEvalCoord1dv (const GLdouble *u);
__declspec(dllimport) void __stdcall glEvalCoord1f (GLfloat u);
__declspec(dllimport) void __stdcall glEvalCoord1fv (const GLfloat *u);
__declspec(dllimport) void __stdcall glEvalCoord2d (GLdouble u, GLdouble v);
__declspec(dllimport) void __stdcall glEvalCoord2dv (const GLdouble *u);
__declspec(dllimport) void __stdcall glEvalCoord2f (GLfloat u, GLfloat v);
__declspec(dllimport) void __stdcall glEvalCoord2fv (const GLfloat *u);
__declspec(dllimport) void __stdcall glEvalMesh1 (GLenum mode, GLint i1, GLint i2);
__declspec(dllimport) void __stdcall glEvalMesh2 (GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2);
__declspec(dllimport) void __stdcall glEvalPoint1 (GLint i);
__declspec(dllimport) void __stdcall glEvalPoint2 (GLint i, GLint j);
__declspec(dllimport) void __stdcall glFeedbackBuffer (GLsizei size, GLenum type, GLfloat *buffer);
__declspec(dllimport) void __stdcall glFinish (void);
__declspec(dllimport) void __stdcall glFlush (void);
__declspec(dllimport) void __stdcall glFogf (GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glFogfv (GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glFogi (GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glFogiv (GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glFrontFace (GLenum mode);
__declspec(dllimport) void __stdcall glFrustum (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
__declspec(dllimport) GLuint __stdcall glGenLists (GLsizei range);
__declspec(dllimport) void __stdcall glGenTextures (GLsizei n, GLuint *textures);
__declspec(dllimport) void __stdcall glGetBooleanv (GLenum pname, GLboolean *params);
__declspec(dllimport) void __stdcall glGetClipPlane (GLenum plane, GLdouble *equation);
__declspec(dllimport) void __stdcall glGetDoublev (GLenum pname, GLdouble *params);
__declspec(dllimport) GLenum __stdcall glGetError (void);
__declspec(dllimport) void __stdcall glGetFloatv (GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetIntegerv (GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glGetLightfv (GLenum light, GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetLightiv (GLenum light, GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glGetMapdv (GLenum target, GLenum query, GLdouble *v);
__declspec(dllimport) void __stdcall glGetMapfv (GLenum target, GLenum query, GLfloat *v);
__declspec(dllimport) void __stdcall glGetMapiv (GLenum target, GLenum query, GLint *v);
__declspec(dllimport) void __stdcall glGetMaterialfv (GLenum face, GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetMaterialiv (GLenum face, GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glGetPixelMapfv (GLenum map, GLfloat *values);
__declspec(dllimport) void __stdcall glGetPixelMapuiv (GLenum map, GLuint *values);
__declspec(dllimport) void __stdcall glGetPixelMapusv (GLenum map, GLushort *values);
__declspec(dllimport) void __stdcall glGetPointerv (GLenum pname, GLvoid* *params);
__declspec(dllimport) void __stdcall glGetPolygonStipple (GLubyte *mask);
__declspec(dllimport) const GLubyte * __stdcall glGetString (GLenum name);
__declspec(dllimport) void __stdcall glGetTexEnvfv (GLenum target, GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetTexEnviv (GLenum target, GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glGetTexGendv (GLenum coord, GLenum pname, GLdouble *params);
__declspec(dllimport) void __stdcall glGetTexGenfv (GLenum coord, GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetTexGeniv (GLenum coord, GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glGetTexImage (GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels);
__declspec(dllimport) void __stdcall glGetTexLevelParameterfv (GLenum target, GLint level, GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetTexLevelParameteriv (GLenum target, GLint level, GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glGetTexParameterfv (GLenum target, GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetTexParameteriv (GLenum target, GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glHint (GLenum target, GLenum mode);
__declspec(dllimport) void __stdcall glIndexMask (GLuint mask);
__declspec(dllimport) void __stdcall glIndexPointer (GLenum type, GLsizei stride, const GLvoid *pointer);
__declspec(dllimport) void __stdcall glIndexd (GLdouble c);
__declspec(dllimport) void __stdcall glIndexdv (const GLdouble *c);
__declspec(dllimport) void __stdcall glIndexf (GLfloat c);
__declspec(dllimport) void __stdcall glIndexfv (const GLfloat *c);
__declspec(dllimport) void __stdcall glIndexi (GLint c);
__declspec(dllimport) void __stdcall glIndexiv (const GLint *c);
__declspec(dllimport) void __stdcall glIndexs (GLshort c);
__declspec(dllimport) void __stdcall glIndexsv (const GLshort *c);
__declspec(dllimport) void __stdcall glIndexub (GLubyte c);
__declspec(dllimport) void __stdcall glIndexubv (const GLubyte *c);
__declspec(dllimport) void __stdcall glInitNames (void);
__declspec(dllimport) void __stdcall glInterleavedArrays (GLenum format, GLsizei stride, const GLvoid *pointer);
__declspec(dllimport) GLboolean __stdcall glIsEnabled (GLenum cap);
__declspec(dllimport) GLboolean __stdcall glIsList (GLuint list);
__declspec(dllimport) GLboolean __stdcall glIsTexture (GLuint texture);
__declspec(dllimport) void __stdcall glLightModelf (GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glLightModelfv (GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glLightModeli (GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glLightModeliv (GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glLightf (GLenum light, GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glLightfv (GLenum light, GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glLighti (GLenum light, GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glLightiv (GLenum light, GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glLineStipple (GLint factor, GLushort pattern);
__declspec(dllimport) void __stdcall glLineWidth (GLfloat width);
__declspec(dllimport) void __stdcall glListBase (GLuint base);
__declspec(dllimport) void __stdcall glLoadIdentity (void);
__declspec(dllimport) void __stdcall glLoadMatrixd (const GLdouble *m);
__declspec(dllimport) void __stdcall glLoadMatrixf (const GLfloat *m);
__declspec(dllimport) void __stdcall glLoadName (GLuint name);
__declspec(dllimport) void __stdcall glLogicOp (GLenum opcode);
__declspec(dllimport) void __stdcall glMap1d (GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points);
__declspec(dllimport) void __stdcall glMap1f (GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points);
__declspec(dllimport) void __stdcall glMap2d (GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points);
__declspec(dllimport) void __stdcall glMap2f (GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points);
__declspec(dllimport) void __stdcall glMapGrid1d (GLint un, GLdouble u1, GLdouble u2);
__declspec(dllimport) void __stdcall glMapGrid1f (GLint un, GLfloat u1, GLfloat u2);
__declspec(dllimport) void __stdcall glMapGrid2d (GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2);
__declspec(dllimport) void __stdcall glMapGrid2f (GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2);
__declspec(dllimport) void __stdcall glMaterialf (GLenum face, GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glMaterialfv (GLenum face, GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glMateriali (GLenum face, GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glMaterialiv (GLenum face, GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glMatrixMode (GLenum mode);
__declspec(dllimport) void __stdcall glMultMatrixd (const GLdouble *m);
__declspec(dllimport) void __stdcall glMultMatrixf (const GLfloat *m);
__declspec(dllimport) void __stdcall glNewList (GLuint list, GLenum mode);
__declspec(dllimport) void __stdcall glNormal3b (GLbyte nx, GLbyte ny, GLbyte nz);
__declspec(dllimport) void __stdcall glNormal3bv (const GLbyte *v);
__declspec(dllimport) void __stdcall glNormal3d (GLdouble nx, GLdouble ny, GLdouble nz);
__declspec(dllimport) void __stdcall glNormal3dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glNormal3f (GLfloat nx, GLfloat ny, GLfloat nz);
__declspec(dllimport) void __stdcall glNormal3fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glNormal3i (GLint nx, GLint ny, GLint nz);
__declspec(dllimport) void __stdcall glNormal3iv (const GLint *v);
__declspec(dllimport) void __stdcall glNormal3s (GLshort nx, GLshort ny, GLshort nz);
__declspec(dllimport) void __stdcall glNormal3sv (const GLshort *v);
__declspec(dllimport) void __stdcall glNormalPointer (GLenum type, GLsizei stride, const GLvoid *pointer);
__declspec(dllimport) void __stdcall glOrtho (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
__declspec(dllimport) void __stdcall glPassThrough (GLfloat token);
__declspec(dllimport) void __stdcall glPixelMapfv (GLenum map, GLsizei mapsize, const GLfloat *values);
__declspec(dllimport) void __stdcall glPixelMapuiv (GLenum map, GLsizei mapsize, const GLuint *values);
__declspec(dllimport) void __stdcall glPixelMapusv (GLenum map, GLsizei mapsize, const GLushort *values);
__declspec(dllimport) void __stdcall glPixelStoref (GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glPixelStorei (GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glPixelTransferf (GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glPixelTransferi (GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glPixelZoom (GLfloat xfactor, GLfloat yfactor);
__declspec(dllimport) void __stdcall glPointSize (GLfloat size);
__declspec(dllimport) void __stdcall glPolygonMode (GLenum face, GLenum mode);
__declspec(dllimport) void __stdcall glPolygonOffset (GLfloat factor, GLfloat units);
__declspec(dllimport) void __stdcall glPolygonStipple (const GLubyte *mask);
__declspec(dllimport) void __stdcall glPopAttrib (void);
__declspec(dllimport) void __stdcall glPopClientAttrib (void);
__declspec(dllimport) void __stdcall glPopMatrix (void);
__declspec(dllimport) void __stdcall glPopName (void);
__declspec(dllimport) void __stdcall glPrioritizeTextures (GLsizei n, const GLuint *textures, const GLclampf *priorities);
__declspec(dllimport) void __stdcall glPushAttrib (GLbitfield mask);
__declspec(dllimport) void __stdcall glPushClientAttrib (GLbitfield mask);
__declspec(dllimport) void __stdcall glPushMatrix (void);
__declspec(dllimport) void __stdcall glPushName (GLuint name);
__declspec(dllimport) void __stdcall glRasterPos2d (GLdouble x, GLdouble y);
__declspec(dllimport) void __stdcall glRasterPos2dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glRasterPos2f (GLfloat x, GLfloat y);
__declspec(dllimport) void __stdcall glRasterPos2fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glRasterPos2i (GLint x, GLint y);
__declspec(dllimport) void __stdcall glRasterPos2iv (const GLint *v);
__declspec(dllimport) void __stdcall glRasterPos2s (GLshort x, GLshort y);
__declspec(dllimport) void __stdcall glRasterPos2sv (const GLshort *v);
__declspec(dllimport) void __stdcall glRasterPos3d (GLdouble x, GLdouble y, GLdouble z);
__declspec(dllimport) void __stdcall glRasterPos3dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glRasterPos3f (GLfloat x, GLfloat y, GLfloat z);
__declspec(dllimport) void __stdcall glRasterPos3fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glRasterPos3i (GLint x, GLint y, GLint z);
__declspec(dllimport) void __stdcall glRasterPos3iv (const GLint *v);
__declspec(dllimport) void __stdcall glRasterPos3s (GLshort x, GLshort y, GLshort z);
__declspec(dllimport) void __stdcall glRasterPos3sv (const GLshort *v);
__declspec(dllimport) void __stdcall glRasterPos4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
__declspec(dllimport) void __stdcall glRasterPos4dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glRasterPos4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
__declspec(dllimport) void __stdcall glRasterPos4fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glRasterPos4i (GLint x, GLint y, GLint z, GLint w);
__declspec(dllimport) void __stdcall glRasterPos4iv (const GLint *v);
__declspec(dllimport) void __stdcall glRasterPos4s (GLshort x, GLshort y, GLshort z, GLshort w);
__declspec(dllimport) void __stdcall glRasterPos4sv (const GLshort *v);
__declspec(dllimport) void __stdcall glReadBuffer (GLenum mode);
__declspec(dllimport) void __stdcall glReadPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);
__declspec(dllimport) void __stdcall glRectd (GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2);
__declspec(dllimport) void __stdcall glRectdv (const GLdouble *v1, const GLdouble *v2);
__declspec(dllimport) void __stdcall glRectf (GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2);
__declspec(dllimport) void __stdcall glRectfv (const GLfloat *v1, const GLfloat *v2);
__declspec(dllimport) void __stdcall glRecti (GLint x1, GLint y1, GLint x2, GLint y2);
__declspec(dllimport) void __stdcall glRectiv (const GLint *v1, const GLint *v2);
__declspec(dllimport) void __stdcall glRects (GLshort x1, GLshort y1, GLshort x2, GLshort y2);
__declspec(dllimport) void __stdcall glRectsv (const GLshort *v1, const GLshort *v2);
__declspec(dllimport) GLint __stdcall glRenderMode (GLenum mode);
__declspec(dllimport) void __stdcall glRotated (GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
__declspec(dllimport) void __stdcall glRotatef (GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
__declspec(dllimport) void __stdcall glScaled (GLdouble x, GLdouble y, GLdouble z);
__declspec(dllimport) void __stdcall glScalef (GLfloat x, GLfloat y, GLfloat z);
__declspec(dllimport) void __stdcall glScissor (GLint x, GLint y, GLsizei width, GLsizei height);
__declspec(dllimport) void __stdcall glSelectBuffer (GLsizei size, GLuint *buffer);
__declspec(dllimport) void __stdcall glShadeModel (GLenum mode);
__declspec(dllimport) void __stdcall glStencilFunc (GLenum func, GLint ref, GLuint mask);
__declspec(dllimport) void __stdcall glStencilMask (GLuint mask);
__declspec(dllimport) void __stdcall glStencilOp (GLenum fail, GLenum zfail, GLenum zpass);
__declspec(dllimport) void __stdcall glTexCoord1d (GLdouble s);
__declspec(dllimport) void __stdcall glTexCoord1dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glTexCoord1f (GLfloat s);
__declspec(dllimport) void __stdcall glTexCoord1fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glTexCoord1i (GLint s);
__declspec(dllimport) void __stdcall glTexCoord1iv (const GLint *v);
__declspec(dllimport) void __stdcall glTexCoord1s (GLshort s);
__declspec(dllimport) void __stdcall glTexCoord1sv (const GLshort *v);
__declspec(dllimport) void __stdcall glTexCoord2d (GLdouble s, GLdouble t);
__declspec(dllimport) void __stdcall glTexCoord2dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glTexCoord2f (GLfloat s, GLfloat t);
__declspec(dllimport) void __stdcall glTexCoord2fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glTexCoord2i (GLint s, GLint t);
__declspec(dllimport) void __stdcall glTexCoord2iv (const GLint *v);
__declspec(dllimport) void __stdcall glTexCoord2s (GLshort s, GLshort t);
__declspec(dllimport) void __stdcall glTexCoord2sv (const GLshort *v);
__declspec(dllimport) void __stdcall glTexCoord3d (GLdouble s, GLdouble t, GLdouble r);
__declspec(dllimport) void __stdcall glTexCoord3dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glTexCoord3f (GLfloat s, GLfloat t, GLfloat r);
__declspec(dllimport) void __stdcall glTexCoord3fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glTexCoord3i (GLint s, GLint t, GLint r);
__declspec(dllimport) void __stdcall glTexCoord3iv (const GLint *v);
__declspec(dllimport) void __stdcall glTexCoord3s (GLshort s, GLshort t, GLshort r);
__declspec(dllimport) void __stdcall glTexCoord3sv (const GLshort *v);
__declspec(dllimport) void __stdcall glTexCoord4d (GLdouble s, GLdouble t, GLdouble r, GLdouble q);
__declspec(dllimport) void __stdcall glTexCoord4dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glTexCoord4f (GLfloat s, GLfloat t, GLfloat r, GLfloat q);
__declspec(dllimport) void __stdcall glTexCoord4fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glTexCoord4i (GLint s, GLint t, GLint r, GLint q);
__declspec(dllimport) void __stdcall glTexCoord4iv (const GLint *v);
__declspec(dllimport) void __stdcall glTexCoord4s (GLshort s, GLshort t, GLshort r, GLshort q);
__declspec(dllimport) void __stdcall glTexCoord4sv (const GLshort *v);
__declspec(dllimport) void __stdcall glTexCoordPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
__declspec(dllimport) void __stdcall glTexEnvf (GLenum target, GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glTexEnvfv (GLenum target, GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glTexEnvi (GLenum target, GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glTexEnviv (GLenum target, GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glTexGend (GLenum coord, GLenum pname, GLdouble param);
__declspec(dllimport) void __stdcall glTexGendv (GLenum coord, GLenum pname, const GLdouble *params);
__declspec(dllimport) void __stdcall glTexGenf (GLenum coord, GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glTexGenfv (GLenum coord, GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glTexGeni (GLenum coord, GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glTexGeniv (GLenum coord, GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glTexImage1D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
__declspec(dllimport) void __stdcall glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
__declspec(dllimport) void __stdcall glTexParameterf (GLenum target, GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glTexParameterfv (GLenum target, GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glTexParameteri (GLenum target, GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glTexParameteriv (GLenum target, GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
__declspec(dllimport) void __stdcall glTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
__declspec(dllimport) void __stdcall glTranslated (GLdouble x, GLdouble y, GLdouble z);
__declspec(dllimport) void __stdcall glTranslatef (GLfloat x, GLfloat y, GLfloat z);
__declspec(dllimport) void __stdcall glVertex2d (GLdouble x, GLdouble y);
__declspec(dllimport) void __stdcall glVertex2dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glVertex2f (GLfloat x, GLfloat y);
__declspec(dllimport) void __stdcall glVertex2fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glVertex2i (GLint x, GLint y);
__declspec(dllimport) void __stdcall glVertex2iv (const GLint *v);
__declspec(dllimport) void __stdcall glVertex2s (GLshort x, GLshort y);
__declspec(dllimport) void __stdcall glVertex2sv (const GLshort *v);
__declspec(dllimport) void __stdcall glVertex3d (GLdouble x, GLdouble y, GLdouble z);
__declspec(dllimport) void __stdcall glVertex3dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glVertex3f (GLfloat x, GLfloat y, GLfloat z);
__declspec(dllimport) void __stdcall glVertex3fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glVertex3i (GLint x, GLint y, GLint z);
__declspec(dllimport) void __stdcall glVertex3iv (const GLint *v);
__declspec(dllimport) void __stdcall glVertex3s (GLshort x, GLshort y, GLshort z);
__declspec(dllimport) void __stdcall glVertex3sv (const GLshort *v);
__declspec(dllimport) void __stdcall glVertex4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
__declspec(dllimport) void __stdcall glVertex4dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glVertex4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
__declspec(dllimport) void __stdcall glVertex4fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glVertex4i (GLint x, GLint y, GLint z, GLint w);
__declspec(dllimport) void __stdcall glVertex4iv (const GLint *v);
__declspec(dllimport) void __stdcall glVertex4s (GLshort x, GLshort y, GLshort z, GLshort w);
__declspec(dllimport) void __stdcall glVertex4sv (const GLshort *v);
__declspec(dllimport) void __stdcall glVertexPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
__declspec(dllimport) void __stdcall glViewport (GLint x, GLint y, GLsizei width, GLsizei height);


typedef void (__stdcall * PFNGLARRAYELEMENTEXTPROC) (GLint i);
typedef void (__stdcall * PFNGLDRAWARRAYSEXTPROC) (GLenum mode, GLint first, GLsizei count);
typedef void (__stdcall * PFNGLVERTEXPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void (__stdcall * PFNGLNORMALPOINTEREXTPROC) (GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void (__stdcall * PFNGLCOLORPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void (__stdcall * PFNGLINDEXPOINTEREXTPROC) (GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void (__stdcall * PFNGLTEXCOORDPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void (__stdcall * PFNGLEDGEFLAGPOINTEREXTPROC) (GLsizei stride, GLsizei count, const GLboolean *pointer);
typedef void (__stdcall * PFNGLGETPOINTERVEXTPROC) (GLenum pname, GLvoid* *params);
typedef void (__stdcall * PFNGLARRAYELEMENTARRAYEXTPROC)(GLenum mode, GLsizei count, const GLvoid* pi);


typedef void (__stdcall * PFNGLDRAWRANGEELEMENTSWINPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);


typedef void (__stdcall * PFNGLADDSWAPHINTRECTWINPROC) (GLint x, GLint y, GLsizei width, GLsizei height);


typedef void (__stdcall * PFNGLCOLORTABLEEXTPROC)
    (GLenum target, GLenum internalFormat, GLsizei width, GLenum format,
     GLenum type, const GLvoid *data);
typedef void (__stdcall * PFNGLCOLORSUBTABLEEXTPROC)
    (GLenum target, GLsizei start, GLsizei count, GLenum format,
     GLenum type, const GLvoid *data);
typedef void (__stdcall * PFNGLGETCOLORTABLEEXTPROC)
    (GLenum target, GLenum format, GLenum type, GLvoid *data);
typedef void (__stdcall * PFNGLGETCOLORTABLEPARAMETERIVEXTPROC)
    (GLenum target, GLenum pname, GLint *params);
typedef void (__stdcall * PFNGLGETCOLORTABLEPARAMETERFVEXTPROC)
    (GLenum target, GLenum pname, GLfloat *params);





}
# 78 "..\\..\\..\\JUCE\\modules\\juce_opengl/juce_opengl.h" 2
# 158 "..\\..\\..\\JUCE\\modules\\juce_opengl/juce_opengl.h"
namespace juce
{

class OpenGLTexture;
class OpenGLFrameBuffer;
class OpenGLShaderProgram;


# 1 "..\\..\\..\\JUCE\\modules\\juce_opengl/geometry/juce_Quaternion.h" 1
# 28 "..\\..\\..\\JUCE\\modules\\juce_opengl/geometry/juce_Quaternion.h"
# 1 "..\\..\\..\\JUCE\\modules\\juce_opengl/geometry/juce_Vector3D.h" 1
# 32 "..\\..\\..\\JUCE\\modules\\juce_opengl/geometry/juce_Vector3D.h"
template <typename Type>
class Vector3D
{
public:
    Vector3D() noexcept : x(), y(), z() {}
    Vector3D (Type xValue, Type yValue, Type zValue) noexcept : x (xValue), y (yValue), z (zValue) {}
    Vector3D (const Vector3D& other) noexcept : x (other.x), y (other.y), z (other.z) {}
    Vector3D& operator= (Vector3D other) noexcept { x = other.x; y = other.y; z = other.z; return *this; }


    static Vector3D xAxis() noexcept { return Vector3D ((Type) 1, 0, 0); }

    static Vector3D yAxis() noexcept { return Vector3D (0, (Type) 1, 0); }

    static Vector3D zAxis() noexcept { return Vector3D (0, 0, (Type) 1); }

    Vector3D& operator+= (Vector3D other) noexcept { x += other.x; y += other.y; z += other.z; return *this; }
    Vector3D& operator-= (Vector3D other) noexcept { x -= other.x; y -= other.y; z -= other.z; return *this; }
    Vector3D& operator*= (Type scaleFactor) noexcept { x *= scaleFactor; y *= scaleFactor; z *= scaleFactor; return *this; }
    Vector3D& operator/= (Type scaleFactor) noexcept { x /= scaleFactor; y /= scaleFactor; z /= scaleFactor; return *this; }

    Vector3D operator+ (Vector3D other) const noexcept { return Vector3D (x + other.x, y + other.y, z + other.z); }
    Vector3D operator- (Vector3D other) const noexcept { return Vector3D (x - other.x, y - other.y, z - other.z); }
    Vector3D operator* (Type scaleFactor) const noexcept { return Vector3D (x * scaleFactor, y * scaleFactor, z * scaleFactor); }
    Vector3D operator/ (Type scaleFactor) const noexcept { return Vector3D (x / scaleFactor, y / scaleFactor, z / scaleFactor); }
    Vector3D operator-() const noexcept { return Vector3D (-x, -y, -z); }


    Type operator* (Vector3D other) const noexcept { return x * other.x + y * other.y + z * other.z; }


    Vector3D operator^ (Vector3D other) const noexcept { return Vector3D (y * other.z - z * other.y, z * other.x - x * other.z, x * other.y - y * other.x); }

    Type length() const noexcept { return std::sqrt (lengthSquared()); }
    Type lengthSquared() const noexcept { return x * x + y * y + z * z; }

    Vector3D normalised() const noexcept { return *this / length(); }


    bool lengthIsBelowEpsilon() const noexcept
    {
        const Type epsilon (std::numeric_limits<Type>::epsilon());
        return ! (x < -epsilon || x > epsilon || y < -epsilon || y > epsilon || z < -epsilon || z > epsilon);
    }

    Type x, y, z;
};
# 28 "..\\..\\..\\JUCE\\modules\\juce_opengl/geometry/juce_Quaternion.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_opengl/geometry/juce_Matrix3D.h" 1
# 34 "..\\..\\..\\JUCE\\modules\\juce_opengl/geometry/juce_Matrix3D.h"
template <typename Type>
class Matrix3D
{
public:

    Matrix3D() noexcept
    {
        mat[0] = (Type) 1; mat[1] = 0; mat[2] = 0; mat[3] = 0;
        mat[4] = 0; mat[5] = (Type) 1; mat[6] = 0; mat[7] = 0;
        mat[8] = 0; mat[9] = 0; mat[10] = (Type) 1; mat[11] = 0;
        mat[12] = 0; mat[13] = 0; mat[14] = 0; mat[15] = (Type) 1;
    }


    Matrix3D (const Matrix3D& other) noexcept
    {
        memcpy (mat, other.mat, sizeof (mat));
    }


    Matrix3D& operator= (const Matrix3D& other) noexcept
    {
        memcpy (mat, other.mat, sizeof (mat));
        return *this;
    }


    Matrix3D (const Type& m00, const Type& m10, const Type& m20, const Type& m30,
              const Type& m01, const Type& m11, const Type& m21, const Type& m31,
              const Type& m02, const Type& m12, const Type& m22, const Type& m32,
              const Type& m03, const Type& m13, const Type& m23, const Type& m33) noexcept
    {
        mat[0] = m00; mat[1] = m10; mat[2] = m20; mat[3] = m30;
        mat[4] = m01; mat[5] = m11; mat[6] = m21; mat[7] = m31;
        mat[8] = m02; mat[9] = m12; mat[10] = m22; mat[11] = m32;
        mat[12] = m03; mat[13] = m13; mat[14] = m23; mat[15] = m33;
    }


    Matrix3D (const Type* values) noexcept
    {
        memcpy (mat, values, sizeof (mat));
    }


    Matrix3D (const AffineTransform& transform) noexcept
    {
        mat[0] = transform.mat00; mat[1] = transform.mat10; mat[2] = 0; mat[3] = 0;
        mat[4] = transform.mat01; mat[5] = transform.mat11; mat[6] = 0; mat[7] = 0;
        mat[8] = 0; mat[9] = 0; mat[10] = (Type) 1; mat[11] = 0;
        mat[12] = transform.mat02; mat[13] = transform.mat12; mat[14] = 0; mat[15] = (Type) 1;
    }


    Matrix3D (Vector3D<Type> vector) noexcept
    {
        mat[0] = (Type) 1; mat[1] = 0; mat[2] = 0; mat[3] = 0;
        mat[4] = 0; mat[5] = (Type) 1; mat[6] = 0; mat[7] = 0;
        mat[8] = 0; mat[9] = 0; mat[10] = (Type) 1; mat[11] = 0;
        mat[12] = vector.x; mat[13] = vector.y; mat[14] = vector.z; mat[15] = (Type) 1;
    }


    static Matrix3D fromFrustum (Type left, Type right, Type bottom, Type top, Type nearDistance, Type farDistance) noexcept
    {
        return Matrix3D ((2.0f * nearDistance) / (right - left), 0.0f, 0.0f, 0.0f,
                         0.0f, (2.0f * nearDistance) / (top - bottom), 0.0f, 0.0f,
                         (right + left) / (right - left), (top + bottom) / (top - bottom), -(farDistance + nearDistance) / (farDistance - nearDistance), -1.0f,
                         0.0f, 0.0f, -(2.0f * farDistance * nearDistance) / (farDistance - nearDistance), 0.0f);
    }


    Matrix3D& operator*= (const Matrix3D& other) noexcept
    {
        return *this = *this * other;
    }


    Matrix3D operator* (const Matrix3D& other) const noexcept
    {
        const Type* const m2 = other.mat;

        return Matrix3D (mat[0] * m2[0] + mat[1] * m2[4] + mat[2] * m2[8] + mat[3] * m2[12],
                         mat[0] * m2[1] + mat[1] * m2[5] + mat[2] * m2[9] + mat[3] * m2[13],
                         mat[0] * m2[2] + mat[1] * m2[6] + mat[2] * m2[10] + mat[3] * m2[14],
                         mat[0] * m2[3] + mat[1] * m2[7] + mat[2] * m2[11] + mat[3] * m2[15],
                         mat[4] * m2[0] + mat[5] * m2[4] + mat[6] * m2[8] + mat[7] * m2[12],
                         mat[4] * m2[1] + mat[5] * m2[5] + mat[6] * m2[9] + mat[7] * m2[13],
                         mat[4] * m2[2] + mat[5] * m2[6] + mat[6] * m2[10] + mat[7] * m2[14],
                         mat[4] * m2[3] + mat[5] * m2[7] + mat[6] * m2[11] + mat[7] * m2[15],
                         mat[8] * m2[0] + mat[9] * m2[4] + mat[10] * m2[8] + mat[11] * m2[12],
                         mat[8] * m2[1] + mat[9] * m2[5] + mat[10] * m2[9] + mat[11] * m2[13],
                         mat[8] * m2[2] + mat[9] * m2[6] + mat[10] * m2[10] + mat[11] * m2[14],
                         mat[8] * m2[3] + mat[9] * m2[7] + mat[10] * m2[11] + mat[11] * m2[15],
                         mat[12] * m2[0] + mat[13] * m2[4] + mat[14] * m2[8] + mat[15] * m2[12],
                         mat[12] * m2[1] + mat[13] * m2[5] + mat[14] * m2[9] + mat[15] * m2[13],
                         mat[12] * m2[2] + mat[13] * m2[6] + mat[14] * m2[10] + mat[15] * m2[14],
                         mat[12] * m2[3] + mat[13] * m2[7] + mat[14] * m2[11] + mat[15] * m2[15]);
    }




    Matrix3D rotated (Vector3D<Type> eulerAngleRadians) const noexcept
    {
        const Type cx = std::cos (eulerAngleRadians.x), sx = std::sin (eulerAngleRadians.x),
                   cy = std::cos (eulerAngleRadians.y), sy = std::sin (eulerAngleRadians.y),
                   cz = std::cos (eulerAngleRadians.z), sz = std::sin (eulerAngleRadians.z);

        return Matrix3D ((cy * cz) + (sx * sy * sz), cx * sz, (cy * sx * sz) - (cz * sy), 0.0f,
                         (cz * sx * sy) - (cy * sz), cx * cz, (cy * cz * sx) + (sy * sz), 0.0f,
                         cx * sy, -sx, cx * cy, 0.0f,
                         0.0f, 0.0f, 0.0f, 1.0f);
    }


    Type mat[16];
};
# 29 "..\\..\\..\\JUCE\\modules\\juce_opengl/geometry/juce_Quaternion.h" 2






template <typename Type>
class Quaternion
{
public:
    Quaternion() noexcept : scalar() {}
    Quaternion (const Quaternion& other) noexcept : vector (other.vector), scalar (other.scalar) {}
    Quaternion (Vector3D<Type> vectorPart, Type scalarPart) noexcept : vector (vectorPart), scalar (scalarPart) {}
    Quaternion (Type x, Type y, Type z, Type w) noexcept : vector (x, y, z), scalar (w) {}


    static Quaternion fromAngle (Type angle, Vector3D<Type> axis) noexcept
    {
        return Quaternion (axis.normalised() * std::sin (angle / (Type) 2), std::cos (angle / (Type) 2));
    }

    Quaternion& operator= (Quaternion other) noexcept
    {
        vector = other.vector;
        scalar = other.scalar;
        return *this;
    }

    Quaternion& operator*= (Quaternion other) noexcept
    {
        const Type oldScalar (scalar);
        scalar = (scalar * other.scalar) - (vector * other.vector);
        vector = (other.vector * oldScalar) + (vector * other.scalar) + (vector ^ other.vector);
        return *this;
    }

    Type length() const noexcept { return std::sqrt (normal()); }
    Type normal() const noexcept { return scalar * scalar + vector.lengthSquared(); }

    Quaternion normalised() const noexcept
    {
        const Type len (length());
#pragma warning(push)
# 71 "..\\..\\..\\JUCE\\modules\\juce_opengl/geometry/juce_Quaternion.h"
#pragma warning(disable: 4127)
# 71 "..\\..\\..\\JUCE\\modules\\juce_opengl/geometry/juce_Quaternion.h"
 do { ; } while (false)
# 71 "..\\..\\..\\JUCE\\modules\\juce_opengl/geometry/juce_Quaternion.h"
#pragma warning(pop)
# 71 "..\\..\\..\\JUCE\\modules\\juce_opengl/geometry/juce_Quaternion.h"
;
        return Quaternion (vector / len, scalar / len);
    }


    Matrix3D<Type> getRotationMatrix() const noexcept
    {
        const Type norm (normal());
        const Type s (norm > 0 ? ((Type) 2) / norm : 0);
        const Type xs (s * vector.x), ys (s * vector.y), zs (s * vector.z);
        const Type wx (xs * scalar), wy (ys * scalar), wz (zs * scalar);
        const Type xx (xs * vector.x), xy (ys * vector.x), xz (zs * vector.x);
        const Type yy (ys * vector.y), yz (zs * vector.y), zz (zs * vector.z);

        return Matrix3D<Type> (((Type) 1) - (yy + zz), xy - wz, xz + wy, 0,
                               xy + wz, ((Type) 1) - (xx+ zz), yz - wx, 0,
                               xz - wy, yz + wx, ((Type) 1) - (xx + yy), 0,
                               0, 0, 0, (Type) 1);
    }


    Vector3D<Type> vector;


    Type scalar;
};
# 165 "..\\..\\..\\JUCE\\modules\\juce_opengl/juce_opengl.h" 2



# 1 "..\\..\\..\\JUCE\\modules\\juce_opengl/geometry/juce_Draggable3DOrientation.h" 1
# 33 "..\\..\\..\\JUCE\\modules\\juce_opengl/geometry/juce_Draggable3DOrientation.h"
class Draggable3DOrientation
{
public:
    typedef Vector3D<float> VectorType;
    typedef Quaternion<float> QuaternionType;


    Draggable3DOrientation (float objectRadius = 0.5f) noexcept
        : radius (jmax (0.1f, objectRadius)),
          quaternion (VectorType::xAxis(), 0)
    {
    }


    Draggable3DOrientation (const Quaternion<float>& quaternionToUse,
                            float objectRadius = 0.5f) noexcept
        : radius (jmax (0.1f, objectRadius)),
          quaternion (quaternionToUse)
    {
    }


    void reset (const VectorType& axis) noexcept
    {
        quaternion = QuaternionType (axis, 0);
    }






    void setViewport (const Rectangle<int>& newArea) noexcept
    {
        area = newArea;
    }




    void setRadius (float newRadius) noexcept
    {
        radius = jmax (0.1f, newRadius);
    }





    template <typename Type>
    void mouseDown (Point<Type> mousePos) noexcept
    {
        lastMouse = mousePosToProportion (mousePos.toFloat());
    }





    template <typename Type>
    void mouseDrag (Point<Type> mousePos) noexcept
    {
        const VectorType oldPos (projectOnSphere (lastMouse));
        lastMouse = mousePosToProportion (mousePos.toFloat());
        const VectorType newPos (projectOnSphere (lastMouse));

        quaternion *= rotationFromMove (oldPos, newPos);
    }




    Matrix3D<float> getRotationMatrix() const noexcept
    {
        return quaternion.getRotationMatrix();
    }


    QuaternionType& getQuaternion() noexcept
    {
        return quaternion;
    }

private:
    Rectangle<int> area;
    float radius;
    QuaternionType quaternion;
    Point<float> lastMouse;

    Point<float> mousePosToProportion (const Point<float> mousePos) const noexcept
    {
        const int scale = (jmin (area.getWidth(), area.getHeight()) / 2);



#pragma warning(push)
# 128 "..\\..\\..\\JUCE\\modules\\juce_opengl/geometry/juce_Draggable3DOrientation.h"
#pragma warning(disable: 4127)
# 128 "..\\..\\..\\JUCE\\modules\\juce_opengl/geometry/juce_Draggable3DOrientation.h"
 do { ; } while (false)
# 128 "..\\..\\..\\JUCE\\modules\\juce_opengl/geometry/juce_Draggable3DOrientation.h"
#pragma warning(pop)
# 128 "..\\..\\..\\JUCE\\modules\\juce_opengl/geometry/juce_Draggable3DOrientation.h"
;

        return Point<float> ((mousePos.x - area.getCentreX()) / scale,
                             (area.getCentreY() - mousePos.y) / scale);
    }

    VectorType projectOnSphere (const Point<float> pos) const noexcept
    {
        const float radiusSquared = radius * radius;
        const float xySquared = pos.x * pos.x + pos.y * pos.y;

        return VectorType (pos.x, pos.y,
                           xySquared < radiusSquared * 0.5f ? std::sqrt (radiusSquared - xySquared)
                                                            : (radiusSquared / (2.0f * std::sqrt (xySquared))));
    }

    QuaternionType rotationFromMove (const VectorType& from, const VectorType& to) const noexcept
    {
        VectorType rotationAxis (to ^ from);

        if (rotationAxis.lengthIsBelowEpsilon())
            rotationAxis = VectorType::xAxis();

        const float d = jlimit (-1.0f, 1.0f, (from - to).length() / (2.0f * radius));

        return QuaternionType::fromAngle (2.0f * std::asin (d), rotationAxis);
    }
};
# 168 "..\\..\\..\\JUCE\\modules\\juce_opengl/juce_opengl.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_opengl/native/juce_MissingGLDefinitions.h" 1
# 28 "..\\..\\..\\JUCE\\modules\\juce_opengl/native/juce_MissingGLDefinitions.h"
enum MissingOpenGLDefinitions
{

    GL_CLAMP_TO_EDGE = 0x812f,



    GL_NUM_EXTENSIONS = 0x821d,







    GL_DEPTH24_STENCIL8 = 0x88F0,







    GL_RGBA32F = 0x8814,



    GL_COLOR_ATTACHMENT0 = 0x8CE0,



    GL_DEPTH_ATTACHMENT = 0x8D00,



    GL_FRAMEBUFFER = 0x8D40,



    GL_FRAMEBUFFER_BINDING = 0x8CA6,



    GL_FRAMEBUFFER_COMPLETE = 0x8CD5,



    GL_RENDERBUFFER = 0x8D41,



    GL_RENDERBUFFER_DEPTH_SIZE = 0x8D54,



    GL_STENCIL_ATTACHMENT = 0x8D20,



    GL_MULTISAMPLE = 0x809D,



    GL_OPERAND0_RGB = 0x8590,
    GL_OPERAND1_RGB = 0x8591,
    GL_OPERAND0_ALPHA = 0x8598,
    GL_OPERAND1_ALPHA = 0x8599,
    GL_SRC0_RGB = 0x8580,
    GL_SRC1_RGB = 0x8581,
    GL_SRC0_ALPHA = 0x8588,
    GL_SRC1_ALPHA = 0x8589,
    GL_TEXTURE0 = 0x84C0,
    GL_TEXTURE1 = 0x84C1,
    GL_TEXTURE2 = 0x84C2,
    GL_COMBINE = 0x8570,
    GL_COMBINE_RGB = 0x8571,
    GL_COMBINE_ALPHA = 0x8572,
    GL_PREVIOUS = 0x8578,
    GL_COMPILE_STATUS = 0x8B81,
    GL_LINK_STATUS = 0x8B82,
    GL_SHADING_LANGUAGE_VERSION = 0x8B8C,
    GL_FRAGMENT_SHADER = 0x8B30,
    GL_VERTEX_SHADER = 0x8B31,
    GL_ARRAY_BUFFER = 0x8892,
    GL_ELEMENT_ARRAY_BUFFER = 0x8893,
    GL_STATIC_DRAW = 0x88E4,
    GL_DYNAMIC_DRAW = 0x88E8,
    GL_STREAM_DRAW = 0x88E0,

    WGL_NUMBER_PIXEL_FORMATS_ARB = 0x2000,
    WGL_DRAW_TO_WINDOW_ARB = 0x2001,
    WGL_ACCELERATION_ARB = 0x2003,
    WGL_SWAP_METHOD_ARB = 0x2007,
    WGL_SUPPORT_OPENGL_ARB = 0x2010,
    WGL_PIXEL_TYPE_ARB = 0x2013,
    WGL_DOUBLE_BUFFER_ARB = 0x2011,
    WGL_COLOR_BITS_ARB = 0x2014,
    WGL_RED_BITS_ARB = 0x2015,
    WGL_GREEN_BITS_ARB = 0x2017,
    WGL_BLUE_BITS_ARB = 0x2019,
    WGL_ALPHA_BITS_ARB = 0x201B,
    WGL_DEPTH_BITS_ARB = 0x2022,
    WGL_STENCIL_BITS_ARB = 0x2023,
    WGL_FULL_ACCELERATION_ARB = 0x2027,
    WGL_ACCUM_RED_BITS_ARB = 0x201E,
    WGL_ACCUM_GREEN_BITS_ARB = 0x201F,
    WGL_ACCUM_BLUE_BITS_ARB = 0x2020,
    WGL_ACCUM_ALPHA_BITS_ARB = 0x2021,
    WGL_STEREO_ARB = 0x2012,
    WGL_SAMPLE_BUFFERS_ARB = 0x2041,
    WGL_SAMPLES_ARB = 0x2042,
    WGL_TYPE_RGBA_ARB = 0x202B,
    WGL_CONTEXT_MAJOR_VERSION_ARB = 0x2091,
    WGL_CONTEXT_MINOR_VERSION_ARB = 0x2092,
    WGL_CONTEXT_PROFILE_MASK_ARB = 0x9126,





    JUCE_RGBA_FORMAT = 0x80E1

};


 typedef char GLchar;
 typedef pointer_sized_int GLsizeiptr;
 typedef pointer_sized_int GLintptr;
# 169 "..\\..\\..\\JUCE\\modules\\juce_opengl/juce_opengl.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_opengl/opengl/juce_OpenGLHelpers.h" 1
# 33 "..\\..\\..\\JUCE\\modules\\juce_opengl/opengl/juce_OpenGLHelpers.h"
class OpenGLHelpers
{
public:

    static void resetErrorState();


    static bool isContextActive();


    static void clear (Colour colour);

    static void enableScissorTest (const Rectangle<int>& clip);


    static bool isExtensionSupported (const char* extensionName);


    static void* getExtensionFunction (const char* functionName);
# 60 "..\\..\\..\\JUCE\\modules\\juce_opengl/opengl/juce_OpenGLHelpers.h"
    static String translateVertexShaderToV3 (const String&);
# 69 "..\\..\\..\\JUCE\\modules\\juce_opengl/opengl/juce_OpenGLHelpers.h"
    static String translateFragmentShaderToV3 (const String&);
};
# 170 "..\\..\\..\\JUCE\\modules\\juce_opengl/juce_opengl.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_opengl/opengl/juce_OpenGLPixelFormat.h" 1
# 35 "..\\..\\..\\JUCE\\modules\\juce_opengl/opengl/juce_OpenGLPixelFormat.h"
class OpenGLPixelFormat
{
public:






    OpenGLPixelFormat (int bitsPerRGBComponent = 8,
                       int alphaBits = 8,
                       int depthBufferBits = 16,
                       int stencilBufferBits = 0) noexcept;

    bool operator== (const OpenGLPixelFormat&) const noexcept;
    bool operator!= (const OpenGLPixelFormat&) const noexcept;


    int redBits;
    int greenBits;
    int blueBits;
    int alphaBits;

    int depthBufferBits;
    int stencilBufferBits;

    int accumulationBufferRedBits;
    int accumulationBufferGreenBits;
    int accumulationBufferBlueBits;
    int accumulationBufferAlphaBits;

    uint8 multisamplingLevel;
};
# 171 "..\\..\\..\\JUCE\\modules\\juce_opengl/juce_opengl.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_opengl/native/juce_OpenGLExtensions.h" 1
# 99 "..\\..\\..\\JUCE\\modules\\juce_opengl/native/juce_OpenGLExtensions.h"
struct OpenGLExtensionFunctions
{
    void initialise();


    typedef char GLchar;
    typedef pointer_sized_int GLsizeiptr;
    typedef pointer_sized_int GLintptr;





    typedef void (__stdcall *type_glActiveTexture) (GLenum p1); type_glActiveTexture glActiveTexture; typedef void (__stdcall *type_glBindBuffer) (GLenum p1, GLuint p2); type_glBindBuffer glBindBuffer; typedef void (__stdcall *type_glDeleteBuffers) (GLsizei p1, const GLuint* p2); type_glDeleteBuffers glDeleteBuffers; typedef void (__stdcall *type_glGenBuffers) (GLsizei p1, GLuint* p2); type_glGenBuffers glGenBuffers; typedef void (__stdcall *type_glBufferData) (GLenum p1, GLsizeiptr p2, const GLvoid* p3, GLenum p4); type_glBufferData glBufferData; typedef void (__stdcall *type_glBufferSubData) (GLenum p1, GLintptr p2, GLsizeiptr p3, const GLvoid* p4); type_glBufferSubData glBufferSubData; typedef GLuint (__stdcall *type_glCreateProgram) (); type_glCreateProgram glCreateProgram; typedef void (__stdcall *type_glDeleteProgram) (GLuint p1); type_glDeleteProgram glDeleteProgram; typedef GLuint (__stdcall *type_glCreateShader) (GLenum p1); type_glCreateShader glCreateShader; typedef void (__stdcall *type_glDeleteShader) (GLuint p1); type_glDeleteShader glDeleteShader; typedef void (__stdcall *type_glShaderSource) (GLuint p1, GLsizei p2, const GLchar** p3, const GLint* p4); type_glShaderSource glShaderSource; typedef void (__stdcall *type_glCompileShader) (GLuint p1); type_glCompileShader glCompileShader; typedef void (__stdcall *type_glAttachShader) (GLuint p1, GLuint p2); type_glAttachShader glAttachShader; typedef void (__stdcall *type_glLinkProgram) (GLuint p1); type_glLinkProgram glLinkProgram; typedef void (__stdcall *type_glUseProgram) (GLuint p1); type_glUseProgram glUseProgram; typedef void (__stdcall *type_glGetShaderiv) (GLuint p1, GLenum p2, GLint* p3); type_glGetShaderiv glGetShaderiv; typedef void (__stdcall *type_glGetShaderInfoLog) (GLuint p1, GLsizei p2, GLsizei* p3, GLchar* p4); type_glGetShaderInfoLog glGetShaderInfoLog; typedef void (__stdcall *type_glGetProgramInfoLog) (GLuint p1, GLsizei p2, GLsizei* p3, GLchar* p4); type_glGetProgramInfoLog glGetProgramInfoLog; typedef void (__stdcall *type_glGetProgramiv) (GLuint p1, GLenum p2, GLint* p3); type_glGetProgramiv glGetProgramiv; typedef GLint (__stdcall *type_glGetUniformLocation) (GLuint p1, const GLchar* p2); type_glGetUniformLocation glGetUniformLocation; typedef GLint (__stdcall *type_glGetAttribLocation) (GLuint p1, const GLchar* p2); type_glGetAttribLocation glGetAttribLocation; typedef void (__stdcall *type_glVertexAttribPointer) (GLuint p1, GLint p2, GLenum p3, GLboolean p4, GLsizei p5, const GLvoid* p6); type_glVertexAttribPointer glVertexAttribPointer; typedef void (__stdcall *type_glEnableVertexAttribArray) (GLuint p1); type_glEnableVertexAttribArray glEnableVertexAttribArray; typedef void (__stdcall *type_glDisableVertexAttribArray) (GLuint p1); type_glDisableVertexAttribArray glDisableVertexAttribArray; typedef void (__stdcall *type_glUniform1f) (GLint p1, GLfloat p2); type_glUniform1f glUniform1f; typedef void (__stdcall *type_glUniform1i) (GLint p1, GLint p2); type_glUniform1i glUniform1i; typedef void (__stdcall *type_glUniform2f) (GLint p1, GLfloat p2, GLfloat p3); type_glUniform2f glUniform2f; typedef void (__stdcall *type_glUniform3f) (GLint p1, GLfloat p2, GLfloat p3, GLfloat p4); type_glUniform3f glUniform3f; typedef void (__stdcall *type_glUniform4f) (GLint p1, GLfloat p2, GLfloat p3, GLfloat p4, GLfloat p5); type_glUniform4f glUniform4f; typedef void (__stdcall *type_glUniform4i) (GLint p1, GLint p2, GLint p3, GLint p4, GLint p5); type_glUniform4i glUniform4i; typedef void (__stdcall *type_glUniform1fv) (GLint p1, GLsizei p2, const GLfloat* p3); type_glUniform1fv glUniform1fv; typedef void (__stdcall *type_glUniformMatrix2fv) (GLint p1, GLsizei p2, GLboolean p3, const GLfloat* p4); type_glUniformMatrix2fv glUniformMatrix2fv; typedef void (__stdcall *type_glUniformMatrix3fv) (GLint p1, GLsizei p2, GLboolean p3, const GLfloat* p4); type_glUniformMatrix3fv glUniformMatrix3fv; typedef void (__stdcall *type_glUniformMatrix4fv) (GLint p1, GLsizei p2, GLboolean p3, const GLfloat* p4); type_glUniformMatrix4fv glUniformMatrix4fv;
    typedef GLboolean (__stdcall *type_glIsRenderbuffer) (GLuint p1); type_glIsRenderbuffer glIsRenderbuffer; typedef void (__stdcall *type_glBindRenderbuffer) (GLenum p1, GLuint p2); type_glBindRenderbuffer glBindRenderbuffer; typedef void (__stdcall *type_glDeleteRenderbuffers) (GLsizei p1, const GLuint* p2); type_glDeleteRenderbuffers glDeleteRenderbuffers; typedef void (__stdcall *type_glGenRenderbuffers) (GLsizei p1, GLuint* p2); type_glGenRenderbuffers glGenRenderbuffers; typedef void (__stdcall *type_glRenderbufferStorage) (GLenum p1, GLenum p2, GLsizei p3, GLsizei p4); type_glRenderbufferStorage glRenderbufferStorage; typedef void (__stdcall *type_glGetRenderbufferParameteriv) (GLenum p1, GLenum p2, GLint* p3); type_glGetRenderbufferParameteriv glGetRenderbufferParameteriv; typedef GLboolean (__stdcall *type_glIsFramebuffer) (GLuint p1); type_glIsFramebuffer glIsFramebuffer; typedef void (__stdcall *type_glBindFramebuffer) (GLenum p1, GLuint p2); type_glBindFramebuffer glBindFramebuffer; typedef void (__stdcall *type_glDeleteFramebuffers) (GLsizei p1, const GLuint* p2); type_glDeleteFramebuffers glDeleteFramebuffers; typedef void (__stdcall *type_glGenFramebuffers) (GLsizei p1, GLuint* p2); type_glGenFramebuffers glGenFramebuffers; typedef GLenum (__stdcall *type_glCheckFramebufferStatus) (GLenum p1); type_glCheckFramebufferStatus glCheckFramebufferStatus; typedef void (__stdcall *type_glFramebufferTexture2D) (GLenum p1, GLenum p2, GLenum p3, GLuint p4, GLint p5); type_glFramebufferTexture2D glFramebufferTexture2D; typedef void (__stdcall *type_glFramebufferRenderbuffer) (GLenum p1, GLenum p2, GLenum p3, GLuint p4); type_glFramebufferRenderbuffer glFramebufferRenderbuffer; typedef void (__stdcall *type_glGetFramebufferAttachmentParameteriv) (GLenum p1, GLenum p2, GLenum p3, GLint* p4); type_glGetFramebufferAttachmentParameteriv glGetFramebufferAttachmentParameteriv;
# 155 "..\\..\\..\\JUCE\\modules\\juce_opengl/native/juce_OpenGLExtensions.h"
};
# 172 "..\\..\\..\\JUCE\\modules\\juce_opengl/juce_opengl.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_opengl/opengl/juce_OpenGLRenderer.h" 1
# 36 "..\\..\\..\\JUCE\\modules\\juce_opengl/opengl/juce_OpenGLRenderer.h"
class OpenGLRenderer
{
public:
    OpenGLRenderer() {}
    virtual ~OpenGLRenderer() {}







    virtual void newOpenGLContextCreated() = 0;
# 58 "..\\..\\..\\JUCE\\modules\\juce_opengl/opengl/juce_OpenGLRenderer.h"
    virtual void renderOpenGL() = 0;
# 70 "..\\..\\..\\JUCE\\modules\\juce_opengl/opengl/juce_OpenGLRenderer.h"
    virtual void openGLContextClosing() = 0;
};
# 173 "..\\..\\..\\JUCE\\modules\\juce_opengl/juce_opengl.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_opengl/opengl/juce_OpenGLContext.h" 1
# 45 "..\\..\\..\\JUCE\\modules\\juce_opengl/opengl/juce_OpenGLContext.h"
class OpenGLContext
{
public:
    OpenGLContext();


    ~OpenGLContext();
# 61 "..\\..\\..\\JUCE\\modules\\juce_opengl/opengl/juce_OpenGLContext.h"
    void setRenderer (OpenGLRenderer*) noexcept;
# 73 "..\\..\\..\\JUCE\\modules\\juce_opengl/opengl/juce_OpenGLContext.h"
    void attachTo (Component&);





    void detach();





    bool isAttached() const noexcept;


    Component* getTargetComponent() const noexcept;


    static OpenGLContext* getContextAttachedTo (Component& component) noexcept;





    void setPixelFormat (const OpenGLPixelFormat& preferredPixelFormat) noexcept;







    void setNativeSharedContext (void* nativeContextToShareWith) noexcept;




    void setMultisamplingEnabled (bool) noexcept;


    bool areShadersAvailable() const;


    enum OpenGLVersion
    {
        defaultGLVersion = 0,
        openGL3_2
    };




    void setOpenGLVersionRequired (OpenGLVersion) noexcept;
# 140 "..\\..\\..\\JUCE\\modules\\juce_opengl/opengl/juce_OpenGLContext.h"
    void setComponentPaintingEnabled (bool shouldPaintComponent) noexcept;
# 150 "..\\..\\..\\JUCE\\modules\\juce_opengl/opengl/juce_OpenGLContext.h"
    void setContinuousRepainting (bool shouldContinuouslyRepaint) noexcept;


    void triggerRepaint();







    ReferenceCountedObject* getAssociatedObject (const char* name) const;
# 172 "..\\..\\..\\JUCE\\modules\\juce_opengl/opengl/juce_OpenGLContext.h"
    void setAssociatedObject (const char* name, ReferenceCountedObject* newObject);






    bool makeActive() const noexcept;


    bool isActive() const noexcept;




    static void deactivateCurrentContext();




    static OpenGLContext* getCurrentContext();






    void swapBuffers();
# 214 "..\\..\\..\\JUCE\\modules\\juce_opengl/opengl/juce_OpenGLContext.h"
    bool setSwapInterval (int numFramesPerSwap);




    int getSwapInterval() const;
# 229 "..\\..\\..\\JUCE\\modules\\juce_opengl/opengl/juce_OpenGLContext.h"
    double getRenderingScale() const noexcept { return currentRenderScale; }





    unsigned int getFrameBufferID() const noexcept;







    void* getRawContext() const noexcept;


    OpenGLExtensionFunctions extensions;
# 262 "..\\..\\..\\JUCE\\modules\\juce_opengl/opengl/juce_OpenGLContext.h"
    void copyTexture (const Rectangle<int>& targetClipArea,
                      const Rectangle<int>& anchorPosAndTextureSize,
                      int contextWidth, int contextHeight,
                      bool textureOriginIsBottomLeft);



    void setImageCacheSize (size_t cacheSizeBytes) noexcept;


    size_t getImageCacheSize() const noexcept;



    class NativeContext;


private:
    class CachedImage;
    class Attachment;
    NativeContext* nativeContext;
    OpenGLRenderer* renderer;
    double currentRenderScale;
    ScopedPointer<Attachment> attachment;
    OpenGLPixelFormat openGLPixelFormat;
    void* contextToShareWith;
    OpenGLVersion versionRequired;
    size_t imageCacheMaxSize;
    bool renderComponents, useMultisampling, continuousRepaint;

    CachedImage* getCachedImage() const noexcept;

    OpenGLContext (const OpenGLContext&) = delete; OpenGLContext& operator= (const OpenGLContext&) = delete;
};
# 174 "..\\..\\..\\JUCE\\modules\\juce_opengl/juce_opengl.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_opengl/opengl/juce_OpenGLFrameBuffer.h" 1
# 33 "..\\..\\..\\JUCE\\modules\\juce_opengl/opengl/juce_OpenGLFrameBuffer.h"
class OpenGLFrameBuffer
{
public:



    OpenGLFrameBuffer();


    ~OpenGLFrameBuffer();






    bool initialise (OpenGLContext& context, int width, int height);





    bool initialise (OpenGLContext& context, const Image& content);



    bool initialise (OpenGLFrameBuffer& other);




    void release();





    void saveAndRelease();




    bool reloadSavedCopy (OpenGLContext& context);



    bool isValid() const noexcept { return pimpl != nullptr; }


    int getWidth() const noexcept;


    int getHeight() const noexcept;


    GLuint getTextureID() const noexcept;



    bool makeCurrentRenderingTarget();


    void releaseAsRenderingTarget();


    GLuint getFrameBufferID() const noexcept;


    static GLuint getCurrentFrameBufferTarget() noexcept;


    void clear (Colour colour);


    void makeCurrentAndClear();





    bool readPixels (PixelARGB* targetData, const Rectangle<int>& sourceArea);





    bool writePixels (const PixelARGB* srcData, const Rectangle<int>& targetArea);

private:
    class Pimpl;
    friend struct ContainerDeletePolicy<Pimpl>;
    ScopedPointer<Pimpl> pimpl;

    class SavedState;
    friend struct ContainerDeletePolicy<SavedState>;
    ScopedPointer<SavedState> savedState;

    OpenGLFrameBuffer (const OpenGLFrameBuffer&) = delete; OpenGLFrameBuffer& operator= (const OpenGLFrameBuffer&) = delete;
};
# 175 "..\\..\\..\\JUCE\\modules\\juce_opengl/juce_opengl.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_opengl/opengl/juce_OpenGLGraphicsContext.h" 1
# 32 "..\\..\\..\\JUCE\\modules\\juce_opengl/opengl/juce_OpenGLGraphicsContext.h"
LowLevelGraphicsContext* createOpenGLGraphicsContext (OpenGLContext& target,
                                                      int width, int height);




LowLevelGraphicsContext* createOpenGLGraphicsContext (OpenGLContext& context,
                                                      OpenGLFrameBuffer& target);




LowLevelGraphicsContext* createOpenGLGraphicsContext (OpenGLContext& context,
                                                      unsigned int frameBufferID,
                                                      int width, int height);
# 56 "..\\..\\..\\JUCE\\modules\\juce_opengl/opengl/juce_OpenGLGraphicsContext.h"
struct OpenGLGraphicsContextCustomShader
{
# 69 "..\\..\\..\\JUCE\\modules\\juce_opengl/opengl/juce_OpenGLGraphicsContext.h"
    OpenGLGraphicsContextCustomShader (const String& fragmentShaderCode);


    ~OpenGLGraphicsContextCustomShader();





    OpenGLShaderProgram* getProgram (LowLevelGraphicsContext&) const;


    void fillRect (LowLevelGraphicsContext&, const Rectangle<int>& area) const;


    Result checkCompilation (LowLevelGraphicsContext&);


    const String& getFragmentShaderCode() const noexcept { return code; }

private:
    String code, hashName;

    OpenGLGraphicsContextCustomShader (const OpenGLGraphicsContextCustomShader&) = delete; OpenGLGraphicsContextCustomShader& operator= (const OpenGLGraphicsContextCustomShader&) = delete;
};
# 176 "..\\..\\..\\JUCE\\modules\\juce_opengl/juce_opengl.h" 2


# 1 "..\\..\\..\\JUCE\\modules\\juce_opengl/opengl/juce_OpenGLImage.h" 1
# 40 "..\\..\\..\\JUCE\\modules\\juce_opengl/opengl/juce_OpenGLImage.h"
class OpenGLImageType : public ImageType
{
public:
    OpenGLImageType();
    ~OpenGLImageType();

    ImagePixelData::Ptr create (Image::PixelFormat, int width, int height, bool shouldClearImage) const override;
    int getTypeID() const override;

    static OpenGLFrameBuffer* getFrameBufferFrom (const Image&);
};
# 178 "..\\..\\..\\JUCE\\modules\\juce_opengl/juce_opengl.h" 2


# 1 "..\\..\\..\\JUCE\\modules\\juce_opengl/opengl/juce_OpenGLShaderProgram.h" 1
# 32 "..\\..\\..\\JUCE\\modules\\juce_opengl/opengl/juce_OpenGLShaderProgram.h"
class OpenGLShaderProgram
{
public:
    OpenGLShaderProgram (const OpenGLContext&) noexcept;
    ~OpenGLShaderProgram() noexcept;
# 47 "..\\..\\..\\JUCE\\modules\\juce_opengl/opengl/juce_OpenGLShaderProgram.h"
    static double getLanguageVersion();
# 62 "..\\..\\..\\JUCE\\modules\\juce_opengl/opengl/juce_OpenGLShaderProgram.h"
    bool addShader (const String& shaderSourceCode, GLenum shaderType);




    bool addVertexShader (const String& shaderSourceCode);




    bool addFragmentShader (const String& shaderSourceCode);







    bool link() noexcept;


    const String& getLastError() const noexcept { return errorLog; }


    void use() const noexcept;


    void release() noexcept;







    GLint getUniformIDFromName (const char* uniformName) const noexcept;


    void setUniform (const char* uniformName, GLfloat value) noexcept;

    void setUniform (const char* uniformName, GLint value) noexcept;

    void setUniform (const char* uniformName, GLfloat x, GLfloat y) noexcept;

    void setUniform (const char* uniformName, GLfloat x, GLfloat y, GLfloat z) noexcept;

    void setUniform (const char* uniformName, GLfloat x, GLfloat y, GLfloat z, GLfloat w) noexcept;

    void setUniform (const char* uniformName, GLint x, GLint y, GLint z, GLint w) noexcept;

    void setUniform (const char* uniformName, const GLfloat* values, GLsizei numValues) noexcept;

    void setUniformMat2 (const char* uniformName, const GLfloat* values, GLint count, GLboolean transpose) noexcept;

    void setUniformMat3 (const char* uniformName, const GLfloat* values, GLint count, GLboolean transpose) noexcept;

    void setUniformMat4 (const char* uniformName, const GLfloat* values, GLint count, GLboolean transpose) noexcept;
# 128 "..\\..\\..\\JUCE\\modules\\juce_opengl/opengl/juce_OpenGLShaderProgram.h"
    struct Uniform
    {




        Uniform (const OpenGLShaderProgram& program, const char* uniformName);


        void set (GLfloat n1) const noexcept;

        void set (GLint n1) const noexcept;

        void set (GLfloat n1, GLfloat n2) const noexcept;

        void set (GLfloat n1, GLfloat n2, GLfloat n3) const noexcept;

        void set (GLfloat n1, GLfloat n2, GLfloat n3, float n4) const noexcept;

        void set (GLint n1, GLint n2, GLint n3, GLint n4) const noexcept;

        void set (const GLfloat* values, int numValues) const noexcept;

        void setMatrix2 (const GLfloat* values, GLint count, GLboolean transpose) const noexcept;

        void setMatrix3 (const GLfloat* values, GLint count, GLboolean transpose) const noexcept;

        void setMatrix4 (const GLfloat* values, GLint count, GLboolean transpose) const noexcept;




        GLint uniformID;

    private:
        const OpenGLContext& context;

        Uniform (const Uniform&) = delete; Uniform& operator= (const Uniform&) = delete;
    };






    struct Attribute
    {




        Attribute (const OpenGLShaderProgram& program, const char* attributeName);




        GLuint attributeID;
    };


    GLuint getProgramID() const noexcept;

private:
    const OpenGLContext& context;
    mutable GLuint programID;
    String errorLog;

    OpenGLShaderProgram (const OpenGLShaderProgram&) = delete; OpenGLShaderProgram& operator= (const OpenGLShaderProgram&) = delete;
};
# 180 "..\\..\\..\\JUCE\\modules\\juce_opengl/juce_opengl.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_opengl/opengl/juce_OpenGLTexture.h" 1
# 32 "..\\..\\..\\JUCE\\modules\\juce_opengl/opengl/juce_OpenGLTexture.h"
class OpenGLTexture
{
public:
    OpenGLTexture();
    ~OpenGLTexture();
# 46 "..\\..\\..\\JUCE\\modules\\juce_opengl/opengl/juce_OpenGLTexture.h"
    void loadImage (const Image& image);







    void loadARGB (const PixelARGB* pixels, int width, int height);






    void loadARGBFlipped (const PixelARGB* pixels, int width, int height);







    void loadAlpha (const uint8* pixels, int width, int height);


    void release();


    void bind() const;


    void unbind() const;


    GLuint getTextureID() const noexcept { return textureID; }

    int getWidth() const noexcept { return width; }
    int getHeight() const noexcept { return height; }




    static bool isValidSize (int width, int height);

private:
    GLuint textureID;
    int width, height;
    OpenGLContext* ownerContext;

    void create (int w, int h, const void*, GLenum, bool topLeft);

    OpenGLTexture (const OpenGLTexture&) = delete; OpenGLTexture& operator= (const OpenGLTexture&) = delete;
};
# 181 "..\\..\\..\\JUCE\\modules\\juce_opengl/juce_opengl.h" 2

# 1 "..\\..\\..\\JUCE\\modules\\juce_opengl/utils/juce_OpenGLAppComponent.h" 1
# 37 "..\\..\\..\\JUCE\\modules\\juce_opengl/utils/juce_OpenGLAppComponent.h"
class OpenGLAppComponent : public Component,
                             private OpenGLRenderer
{
public:
    OpenGLAppComponent();
    ~OpenGLAppComponent();




    int getFrameCounter() const noexcept { return frameCounter; }

    void shutdownOpenGL();




    virtual void initialise() = 0;




    virtual void shutdown() = 0;



    virtual void render() = 0;

    OpenGLContext openGLContext;

private:


    int frameCounter;

    void newOpenGLContextCreated() override;
    void renderOpenGL() override;
    void openGLContextClosing() override;

    OpenGLAppComponent (const OpenGLAppComponent&) = delete; OpenGLAppComponent& operator= (const OpenGLAppComponent&) = delete;
};
# 182 "..\\..\\..\\JUCE\\modules\\juce_opengl/juce_opengl.h" 2


}
# 25 "C:\\Users\\Cathy\\OneDrive\\JUCE Terrain\\Source/../JuceLibraryCode/JuceHeader.h" 2


# 1 "..\\..\\JuceLibraryCode/BinaryData.h" 1
# 10 "..\\..\\JuceLibraryCode/BinaryData.h"
namespace BinaryData
{
    extern const char* icon_png;
    const int icon_pngSize = 6713;


    extern const char* namedResourceList[];


    const int namedResourceListSize = 1;



    const char* getNamedResource (const char* resourceNameUTF8, int& dataSizeInBytes) throw();
}
# 27 "C:\\Users\\Cathy\\OneDrive\\JUCE Terrain\\Source/../JuceLibraryCode/JuceHeader.h" 2





 using namespace juce;



namespace ProjectInfo
{
    const char* const projectName = "JUCE Terrain";
    const char* const versionString = "1.0.0";
    const int versionNumber = 0x10000;
}
# 2 "C:\\Users\\Cathy\\OneDrive\\JUCE Terrain\\Source/ControlsOverlay.h" 2

# 1 "C:\\Users\\Cathy\\OneDrive\\JUCE Terrain\\Source/Skin.h" 1


# 1 "C:\\Users\\Cathy\\OneDrive\\JUCE Terrain\\Source/Inter.h" 1



enum class Options {
 RESET,
 OCTAVES,
 PERSISTENCE,
 WIDTH,
 HEIGHT,
 DEPTH,
 ROCKINESS,
 MODE,
 FILL,
 LINES,
 TOPC,
 FARC,
 NEARC,
 BACKGROUND_COLOR
};

class Inter {
public:
 enum class Modes {
  DEFAULT,
  STATIC,
  FLY,
  CHANGE
 };

 ~Inter(){}
 virtual void sendData(Options option, double d = 0.0, int i = 0, Modes mode = Modes::DEFAULT, Colour = Colour(0)) = 0;
 virtual bool isFree() = 0;
};

struct BackgoundColor {
 ~BackgoundColor(){}
 virtual void setColor(Colour c) = 0;
};
# 3 "C:\\Users\\Cathy\\OneDrive\\JUCE Terrain\\Source/Skin.h" 2


class Skin
 : public LookAndFeel_V3 {
public:
 Skin();
 ~Skin();

 void positionDocumentWindowButtons(DocumentWindow&,
  int titleBarX, int titleBarY,
  int titleBarW, int titleBarH,
  Button* minimiseButton,
  Button* maximiseButton,
  Button* closeButton,
  bool positionTitleBarButtonsOnLeft) override;
 Button* createDocumentWindowButton(int buttonType) override;
 void drawDocumentWindowTitleBar(DocumentWindow &window, Graphics &g, int w, int h, int titleSpaceX, int titleSpaceW, const Image *icon, bool drawTitleTextOnLeft) override;

 void drawLabel(Graphics &g, Label &l) override;
 void drawPlayButton(DrawableButton &b);
 void drawResetButton(DrawableButton &b);
 void drawDrawableButton(Graphics &g, DrawableButton &b, bool isMouseOverButton, bool isButtonDown) override;

 void drawLinearSliderBackground(Graphics &g, int x, int y, int width, int height, float sliderPos, float minSliderPos, float maxSliderPos, const Slider::SliderStyle style, Slider &slider) override;
 void drawLinearSliderThumb(Graphics& g, int x, int y, int width, int height, float sliderPos, float minSliderPos, float maxSliderPos, const Slider::SliderStyle style, Slider& slider) override;

 void drawButtonBackground(Graphics &g, Button &b, const Colour &backgroundColour, bool isMouseOverButton, bool isButtonDown) override;
 void drawButtonText(Graphics &g, TextButton &b, bool isMouseOverButton, bool isButtonDown) override;

private:
 class CircleWindowButton;

 Skin (const Skin&) = delete; Skin& operator= (const Skin&) = delete;
};

class Skin::CircleWindowButton : public Button {
public:
 CircleWindowButton(const String& name, Colour col, Colour out, Colour pathcol,
  const Path& normalShape_,
  const Path& toggledShape_) noexcept
  : Button(name),
  colour(col),
  outline(out),
  main(pathcol),
  normalShape(normalShape_),
  toggledShape(toggledShape_) {
 }

 void paintButton(Graphics& g, bool isMouseOverButton, bool isButtonDown) override;

private:
 Colour colour, outline, main;
 Path normalShape, toggledShape;

 CircleWindowButton (const CircleWindowButton&) = delete; CircleWindowButton& operator= (const CircleWindowButton&) = delete;
};
# 3 "C:\\Users\\Cathy\\OneDrive\\JUCE Terrain\\Source/ControlsOverlay.h" 2

# 1 "C:\\Users\\Cathy\\OneDrive\\JUCE Terrain\\Source/Etc.h" 1




class SliderLabel
 : public Label {
 void paint(Graphics &g) override;
};

class HelpButton
 : public TextButton {
public:
 HelpButton();
 void paint(Graphics &g) override;

private:
 int _n, _m;
 const char *_keys;
 const char *_text;
 const char *_mouseStuff;
};

class ColourChangeButton
 : public TextButton
 , public ChangeListener
{
public:
 ColourChangeButton(const String &s, Options option, Colour c);
 void clicked() override;
 void changeListenerCallback(ChangeBroadcaster* source) override;
 void setInter(Inter *i);
 void setBackgroundColorCC(BackgoundColor *bc);
 void kill();

 Colour getColor();

private:
 Inter *_shape;
 BackgoundColor *_cc;
 Colour _currColor;
 Options _opt;
};

class ColorSelectorAndBroadcaster
 : public ColourSelector{
public:
 ColorSelectorAndBroadcaster(int flags, ColourChangeButton *button);
 ~ColorSelectorAndBroadcaster();

private:
 ColourChangeButton *_parent;
};
# 4 "C:\\Users\\Cathy\\OneDrive\\JUCE Terrain\\Source/ControlsOverlay.h" 2



class ControlsOverlay
 : public Component
 , public Button::Listener
 , public Slider::Listener
 , public KeyListener{
public:
 ControlsOverlay(DocumentWindow *win, BackgoundColor *bc);
 ~ControlsOverlay();
 void resized() override;
 void buttonClicked(Button *button) override;
 void mouseDown(const MouseEvent &event) override;
 void sliderValueChanged(Slider* slider) override;
 void paint(Graphics &g) override;

 bool keyPressed(const KeyPress &key, Component *originatingComponent) override;

 void changeControlsVisible();
 void setInter(Inter *i);
 bool controlsAreVisible();

private:
 SafePointer<DocumentWindow> _window;
 Inter *_shape;
 SafePointer<DrawableButton> _play, _reset;
 Slider _octavesSlider, _widthSlider, _depthSlider, _heightSlider, _persistenceSlider, _rockinessSlider;
 SliderLabel _octavesLabel, _widthLabel, _depthLabel, _heightLabel, _persistenceLabel, _rockinessLabel;
 SliderLabel _colorLabel;
 SafePointer<TextButton> _fly, _static;
 SafePointer<TextButton> _lines, _fill;
 SafePointer<HelpButton> _help;
 ColourChangeButton *_top, *_far, *_near, *_backColor;
 Skin _skin;
 TextButton *_pressedChild;
 bool _controlsVisible;

 ControlsOverlay (const ControlsOverlay&) = delete; ControlsOverlay& operator= (const ControlsOverlay&) = delete;
};
# 2 "C:\\Users\\Cathy\\OneDrive\\JUCE Terrain\\Source/ContentComponent.h" 2


# 1 "C:\\Users\\Cathy\\OneDrive\\JUCE Terrain\\Source/Shape.h" 1

# 1 "C:\\Users\\Cathy\\OneDrive\\JUCE Terrain\\Source/PerlinNoise.h" 1


# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\ctime" 1 3
# 13 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\ctime" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\time.h" 1 3
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\time.h" 3
#pragma pack(push, 8)
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\time.h" 3
 extern "C" {
# 23 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\time.h" 3
typedef long clock_t;

struct _timespec32
{
    __time32_t tv_sec;
    long tv_nsec;
};

struct _timespec64
{
    __time64_t tv_sec;
    long tv_nsec;
};


    struct timespec
    {
        time_t tv_sec;
        long tv_nsec;
    };
# 61 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\time.h" 3
         int* __cdecl __daylight(void);





         long* __cdecl __dstbias(void);





         long* __cdecl __timezone(void);





         char** __cdecl __tzname(void);




         errno_t __cdecl _get_daylight(
          int* _Daylight
    );


         errno_t __cdecl _get_dstbias(
          long* _DaylightSavingsBias
    );


         errno_t __cdecl _get_timezone(
          long* _TimeZone
    );


         errno_t __cdecl _get_tzname(
                                 size_t* _ReturnValue,
                                 char* _Buffer,
                                 size_t _SizeInBytes,
                                 int _Index
    );
# 116 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\time.h" 3
         char* __cdecl asctime(
         struct tm const* _Tm
    );




             errno_t __cdecl asctime_s(
                                                            char* _Buffer,
                                                            size_t _SizeInBytes,
                                                            struct tm const* _Tm
        );


extern "C++" { template <size_t _Size> inline errno_t __cdecl asctime_s(char (&_Buffer)[_Size], struct tm const* _Time) throw() { return asctime_s(_Buffer, _Size, _Time); } }






         clock_t __cdecl clock(void);




         char* __cdecl _ctime32(
         __time32_t const* _Time
    );


         errno_t __cdecl _ctime32_s(
                                                        char* _Buffer,
                                                        size_t _SizeInBytes,
                                                        __time32_t const* _Time
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ctime32_s(char (&_Buffer)[_Size], __time32_t const* _Time) throw() { return _ctime32_s(_Buffer, _Size, _Time); } }
# 162 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\time.h" 3
         char* __cdecl _ctime64(
         __time64_t const* _Time
    );


         errno_t __cdecl _ctime64_s(
                                                          char* _Buffer,
                                                          size_t _SizeInBytes,
                                                          __time64_t const* _Time
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ctime64_s(char (&_Buffer)[_Size], __time64_t const* _Time) throw() { return _ctime64_s(_Buffer, _Size, _Time); } }






         double __cdecl _difftime32(
         __time32_t _Time1,
         __time32_t _Time2
    );


         double __cdecl _difftime64(
         __time64_t _Time1,
         __time64_t _Time2
    );



         struct tm* __cdecl _gmtime32(
         __time32_t const* _Time
    );


         errno_t __cdecl _gmtime32_s(
          struct tm* _Tm,
          __time32_t const* _Time
    );



         struct tm* __cdecl _gmtime64(
         __time64_t const* _Time
    );


         errno_t __cdecl _gmtime64_s(
          struct tm* _Tm,
          __time64_t const* _Time
    );



         struct tm* __cdecl _localtime32(
         __time32_t const* _Time
    );


         errno_t __cdecl _localtime32_s(
          struct tm* _Tm,
          __time32_t const* _Time
    );



         struct tm* __cdecl _localtime64(
         __time64_t const* _Time
    );


         errno_t __cdecl _localtime64_s(
          struct tm* _Tm,
          __time64_t const* _Time
    );


         __time32_t __cdecl _mkgmtime32(
            struct tm* _Tm
    );


         __time64_t __cdecl _mkgmtime64(
            struct tm* _Tm
    );


         __time32_t __cdecl _mktime32(
            struct tm* _Tm
    );


         __time64_t __cdecl _mktime64(
            struct tm* _Tm
    );



         size_t __cdecl strftime(
                                  char* _Buffer,
                                  size_t _SizeInBytes,
                                  char const* _Format,
                                  struct tm const* _Tm
    );



         size_t __cdecl _strftime_l(
                                  char* _Buffer,
                                  size_t _MaxSize,
                                  char const* _Format,
                                  struct tm const* _Tm,
                                  _locale_t _Locale
    );


         errno_t __cdecl _strdate_s(
                                                       char* _Buffer,
                                                       size_t _SizeInBytes
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strdate_s(char (&_Buffer)[_Size]) throw() { return _strdate_s(_Buffer, _Size); } }




 char* __cdecl _strdate( char *_Buffer);





         errno_t __cdecl _strtime_s(
                                                       char* _Buffer,
                                                       size_t _SizeInBytes
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strtime_s(char (&_Buffer)[_Size]) throw() { return _strtime_s(_Buffer, _Size); } }




 char* __cdecl _strtime( char *_Buffer);




         __time32_t __cdecl _time32(
              __time32_t* _Time
    );

         __time64_t __cdecl _time64(
              __time64_t* _Time
    );



         int __cdecl _timespec32_get(
          struct _timespec32* _Ts,
          int _Base
    );



         int __cdecl _timespec64_get(
          struct _timespec64* _Ts,
          int _Base
    );
# 341 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\time.h" 3
             void __cdecl _tzset(void);


    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "GetLocalTime" " " "instead. See online help for details."))
             unsigned __cdecl _getsystime(
              struct tm* _Tm
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "SetLocalTime" " " "instead. See online help for details."))
             unsigned __cdecl _setsystime(
             struct tm* _Tm,
             unsigned _Milliseconds
        );
# 475 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\time.h" 3
        static __inline char* __cdecl ctime(
                 time_t const* const _Time
            )
        {
#pragma warning(push)
#pragma warning(disable: 4996)
 return _ctime64(_Time);
#pragma warning(pop)
 }


        static __inline double __cdecl difftime(
                 time_t const _Time1,
                 time_t const _Time2
            )
        {
            return _difftime64(_Time1, _Time2);
        }


        static __inline struct tm* __cdecl gmtime(
                 time_t const* const _Time)
        {
#pragma warning(push)
#pragma warning(disable: 4996)
 return _gmtime64(_Time);
#pragma warning(pop)
 }


        static __inline struct tm* __cdecl localtime(
                 time_t const* const _Time
            )
        {
#pragma warning(push)
#pragma warning(disable: 4996)
 return _localtime64(_Time);
#pragma warning(pop)
 }


        static __inline time_t __cdecl _mkgmtime(
                    struct tm* const _Tm
            )
        {
            return _mkgmtime64(_Tm);
        }


        static __inline time_t __cdecl mktime(
                    struct tm* const _Tm
            )
        {
            return _mktime64(_Tm);
        }

        static __inline time_t __cdecl time(
                      time_t* const _Time
            )
        {
            return _time64(_Time);
        }


        static __inline int __cdecl timespec_get(
                  struct timespec* const _Ts,
                  int const _Base
            )
        {
            return _timespec64_get((struct _timespec64*)_Ts, _Base);
        }



            static __inline errno_t __cdecl ctime_s(
                                                                    char* const _Buffer,
                                                                    size_t const _SizeInBytes,
                                                                    time_t const* const _Time
                )
            {
                return _ctime64_s(_Buffer, _SizeInBytes, _Time);
            }


            static __inline errno_t __cdecl gmtime_s(
                      struct tm* const _Tm,
                      time_t const* const _Time
                )
            {
                return _gmtime64_s(_Tm, _Time);
            }


            static __inline errno_t __cdecl localtime_s(
                      struct tm* const _Tm,
                      time_t const* const _Time
                )
            {
                return _localtime64_s(_Tm, _Time);
            }
# 593 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\time.h" 3
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_tzset" ". See online help for details.")) void __cdecl tzset(void);






}
# 600 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.10240.0\\ucrt\\time.h" 3
#pragma pack(pop)
# 13 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\ctime" 2 3




namespace std {
using :: clock_t; using :: size_t;
using :: time_t; using :: tm;
using :: asctime; using :: clock; using :: ctime;
using :: difftime; using :: gmtime; using :: localtime;
using :: mktime; using :: strftime; using :: time;
}
# 3 "C:\\Users\\Cathy\\OneDrive\\JUCE Terrain\\Source/PerlinNoise.h" 2



class PerlinNoise {
public:
 PerlinNoise(double frequency = 1.0, double amplitude = 1.0, double persistence = 0.5, int octaves = 3);

 double noise(double x, double y = 0.0, double z = 0.0);
 double usingOctave(double x, double y = 0.0, double z = 0.0);

 double getFrequency();
 double getAmplitude();
 double getPersistence();
 int getOctaves();

 void setFrequency(double frequency);
 void setAmplitude(double amplitude);
 void setPersistence(double persistence);
 void setOctaves(int octaves);
 void permutate();

private:
 double fade(double t);
 double lerp(double t, double a, double b);
 double grad(int hash, double x, double y, double z);


 double _frequency;
 double _amplitude;
 double _persistence;
 int _octaves;
 int p[256];
 double _gradX[256];
 double _gradY[256];
 double _gradZ[256];

 PerlinNoise (const PerlinNoise&) = delete; PerlinNoise& operator= (const PerlinNoise&) = delete;
};
# 2 "C:\\Users\\Cathy\\OneDrive\\JUCE Terrain\\Source/Shape.h" 2



# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\thread" 1 3
# 14 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\thread" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\chrono" 1 3






# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\ratio" 1 3








#pragma pack(push,8)
#pragma warning(push, 3)



namespace std {

template<intmax_t _Val>
 struct _Abs
 {
 static constexpr intmax_t value = _Val < 0 ? -_Val : _Val;
 };


template<intmax_t _Ax,
 intmax_t _Bx,
 bool _Sfinae = false,
 bool _Good = (_Abs<_Ax>::value
  <= 9223372036854775807i64 / (_Bx == 0 ? 1 : _Abs<_Bx>::value))>
 struct _Safe_mult
  : integral_constant<intmax_t, _Ax * _Bx>
 {
 };

template<intmax_t _Ax,
 intmax_t _Bx,
 bool _Sfinae>
 struct _Safe_mult<_Ax, _Bx, _Sfinae, false>
 {
 static_assert(_Sfinae,
  "integer arithmetic overflow");
 };


template<intmax_t _Val>
 struct _Sign_of
 {
 static constexpr intmax_t value = _Val < 0 ? -1 : 1;
 };


template<intmax_t _Ax,
 intmax_t _Bx,
 bool _Good,
 bool _Also_good>
 struct _Safe_addX
 {
 static constexpr intmax_t value = _Ax + _Bx;
 };

template<intmax_t _Ax,
 intmax_t _Bx>
 struct _Safe_addX<_Ax, _Bx, false, false>
 {
 static_assert(_Always_false<_Safe_addX>::value,
  "integer arithmetic overflow");
 };

template<intmax_t _Ax,
 intmax_t _Bx>
 struct _Safe_add
 {
 static constexpr intmax_t value = _Safe_addX<_Ax, _Bx,
  _Sign_of<_Ax>::value != _Sign_of<_Bx>::value,
  (_Abs<_Ax>::value <= 9223372036854775807i64 - _Abs<_Bx>::value)>::value;
 };


template<intmax_t _Ax,
 intmax_t _Bx>
 struct _GcdX
 {
 static constexpr intmax_t value = _GcdX<_Bx, _Ax % _Bx>::value;
 };

template<intmax_t _Ax>
 struct _GcdX<_Ax, 0>
 {
 static constexpr intmax_t value = _Ax;
 };

template<intmax_t _Ax,
 intmax_t _Bx>
 struct _Gcd
 {
 static constexpr intmax_t value =
  _GcdX<_Abs<_Ax>::value, _Abs<_Bx>::value>::value;
 };

template<>
 struct _Gcd<0, 0>
 {
 static constexpr intmax_t value = 1;
 };


template<intmax_t _Nx,
 intmax_t _Dx = 1>
 struct ratio
 {
 static_assert(_Dx != 0,
  "zero denominator");
 static_assert(-9223372036854775807i64 <= _Nx,
  "numerator too negative");
 static_assert(-9223372036854775807i64 <= _Dx,
  "denominator too negative");

 static constexpr intmax_t num = _Sign_of<_Nx>::value
  * _Sign_of<_Dx>::value * _Abs<_Nx>::value / _Gcd<_Nx, _Dx>::value;

 static constexpr intmax_t den = _Abs<_Dx>::value / _Gcd<_Nx, _Dx>
  ::value;

 typedef ratio<num, den> type;
 };


template<class _Ty1,
 class _Ty2>
 struct _Are_ratios
  : false_type
 {
 };

template<intmax_t _N1,
 intmax_t _D1,
 intmax_t _N2,
 intmax_t _D2>
 struct _Are_ratios<ratio<_N1, _D1>, ratio<_N2, _D2> >
  : true_type
 {
 };


template<class _R1,
 class _R2>
 struct _Ratio_add
 {
 static_assert(_Are_ratios<_R1, _R2>::value,
  "ratio_add<R1, R2> requires R1 and R2 to be ratio<>s.");

 static constexpr intmax_t _N1 = _R1::num;
 static constexpr intmax_t _D1 = _R1::den;
 static constexpr intmax_t _N2 = _R2::num;
 static constexpr intmax_t _D2 = _R2::den;

 static constexpr intmax_t _Gx = _Gcd<_D1, _D2>::value;


 typedef typename ratio<
  _Safe_add<
   _Safe_mult<_N1, _D2 / _Gx>::value,
   _Safe_mult<_N2, _D1 / _Gx>::value
   >::value,
  _Safe_mult<_D1, _D2 / _Gx>::value
  >::type type;
 };

template<class _R1,
 class _R2>
 using ratio_add = typename _Ratio_add<_R1, _R2>::type;


template<class _R1,
 class _R2>
 struct _Ratio_subtract
 {
 static_assert(_Are_ratios<_R1, _R2>::value,
  "ratio_subtract<R1, R2> requires R1 and R2 to be ratio<>s.");

 static constexpr intmax_t _N2 = _R2::num;
 static constexpr intmax_t _D2 = _R2::den;

 typedef ratio_add<_R1, ratio<-_N2, _D2> > type;
 };

template<class _R1,
 class _R2>
 using ratio_subtract = typename _Ratio_subtract<_R1, _R2>::type;


template<class _R1,
 class _R2>
 struct _Ratio_multiply
 {
 static_assert(_Are_ratios<_R1, _R2>::value,
  "ratio_multiply<R1, R2> requires R1 and R2 to be ratio<>s.");

 static constexpr intmax_t _N1 = _R1::num;
 static constexpr intmax_t _D1 = _R1::den;
 static constexpr intmax_t _N2 = _R2::num;
 static constexpr intmax_t _D2 = _R2::den;

 static constexpr intmax_t _Gx = _Gcd<_N1, _D2>::value;
 static constexpr intmax_t _Gy = _Gcd<_N2, _D1>::value;

 typedef _Safe_mult<_N1 / _Gx, _N2 / _Gy, true> _Num;
 typedef _Safe_mult<_D1 / _Gy, _D2 / _Gx, true> _Den;
 };

template<class _R1,
 class _R2,
 bool _Sfinae = true,
 class = void>
 struct _Ratio_multiply_sfinae
 {
 static_assert(_Sfinae,
  "integer arithmetic overflow");
 };

template<class _R1,
 class _R2,
 bool _Sfinae>
 struct _Ratio_multiply_sfinae<_R1, _R2, _Sfinae, void_t<
  typename _Ratio_multiply<_R1, _R2>::_Num::type,
  typename _Ratio_multiply<_R1, _R2>::_Den::type> >
 {
 typedef ratio<
  _Ratio_multiply<_R1, _R2>::_Num::value,
  _Ratio_multiply<_R1, _R2>::_Den::value> type;
 };

template<class _R1,
 class _R2>
 using ratio_multiply = typename _Ratio_multiply_sfinae<_R1, _R2, false>
  ::type;


template<class _R1,
 class _R2>
 struct _Ratio_divide
 {
 static_assert(_Are_ratios<_R1, _R2>::value,
  "ratio_divide<R1, R2> requires R1 and R2 to be ratio<>s.");

 static constexpr intmax_t _N2 = _R2::num;
 static constexpr intmax_t _D2 = _R2::den;

 typedef ratio<_D2, _N2> _R2_inverse;
 };

template<class _R1,
 class _R2,
 bool _Sfinae = true>
 using _Ratio_divide_sfinae = typename _Ratio_multiply_sfinae<
  _R1, typename _Ratio_divide<_R1, _R2>::_R2_inverse, _Sfinae>::type;

template<class _R1,
 class _R2>
 using ratio_divide = _Ratio_divide_sfinae<_R1, _R2, false>;


template<class _R1,
 class _R2>
 struct ratio_equal
  : _Cat_base<_R1::num == _R2::num && _R1::den == _R2::den>
 {
 static_assert(_Are_ratios<_R1, _R2>::value,
  "ratio_equal<R1, R2> requires R1 and R2 to be ratio<>s.");
 };


template<class _R1,
 class _R2>
 struct ratio_not_equal
  : integral_constant<bool, !ratio_equal<_R1, _R2>::value>
 {
 static_assert(_Are_ratios<_R1, _R2>::value,
  "ratio_not_equal<R1, R2> requires R1 and R2 to be ratio<>s.");
 };


template<class _R1,
 class _R2>
 struct _Ratio_less
 {
 static constexpr intmax_t _N1 = _R1::num;
 static constexpr intmax_t _D1 = _R1::den;
 static constexpr intmax_t _N2 = _R2::num;
 static constexpr intmax_t _D2 = _R2::den;

 static constexpr intmax_t _Gn = _Gcd<_N1, _N2>::value;
 static constexpr intmax_t _Gd = _Gcd<_D1, _D2>::value;

 static constexpr intmax_t _Left = _Safe_mult<_N1 / _Gn, _D2 / _Gd>::value;
 static constexpr intmax_t _Right = _Safe_mult<_N2 / _Gn, _D1 / _Gd>::value;

 typedef integral_constant<bool, (_Left < _Right)> type;
 };

template<class _R1,
 class _R2>
 struct ratio_less
  : _Ratio_less<_R1, _R2>::type
 {
 static_assert(_Are_ratios<_R1, _R2>::value,
  "ratio_less<R1, R2> requires R1 and R2 to be ratio<>s.");
 };


template<class _R1,
 class _R2>
 struct ratio_less_equal
  : integral_constant<bool, !ratio_less<_R2, _R1>::value>
 {
 static_assert(_Are_ratios<_R1, _R2>::value,
  "ratio_less_equal<R1, R2> requires R1 and R2 to be ratio<>s.");
 };


template<class _R1,
 class _R2>
 struct ratio_greater
  : integral_constant<bool, ratio_less<_R2, _R1>::value>
 {
 static_assert(_Are_ratios<_R1, _R2>::value,
  "ratio_greater<R1, R2> requires R1 and R2 to be ratio<>s.");
 };


template<class _R1,
 class _R2>
 struct ratio_greater_equal
  : integral_constant<bool, !ratio_less<_R1, _R2>::value>
 {
 static_assert(_Are_ratios<_R1, _R2>::value,
  "ratio_greater_equal<R1, R2> requires R1 and R2 to be ratio<>s.");
 };



template<class _R1,
 class _R2>
 constexpr bool ratio_equal_v = ratio_equal<_R1, _R2>::value;
template<class _R1,
 class _R2>
 constexpr bool ratio_not_equal_v = ratio_not_equal<_R1, _R2>::value;
template<class _R1,
 class _R2>
 constexpr bool ratio_less_v = ratio_less<_R1, _R2>::value;
template<class _R1,
 class _R2>
 constexpr bool ratio_less_equal_v = ratio_less_equal<_R1, _R2>::value;
template<class _R1,
 class _R2>
 constexpr bool ratio_greater_v = ratio_greater<_R1, _R2>::value;
template<class _R1,
 class _R2>
 constexpr bool ratio_greater_equal_v = ratio_greater_equal<_R1, _R2>::value;




typedef ratio<1, 1000000000000000000LL> atto;
typedef ratio<1, 1000000000000000LL> femto;
typedef ratio<1, 1000000000000LL> pico;

typedef ratio<1, 1000000000> nano;
typedef ratio<1, 1000000> micro;
typedef ratio<1, 1000> milli;
typedef ratio<1, 100> centi;
typedef ratio<1, 10> deci;
typedef ratio<10, 1> deca;
typedef ratio<100, 1> hecto;
typedef ratio<1000, 1> kilo;
typedef ratio<1000000, 1> mega;
typedef ratio<1000000000, 1> giga;

typedef ratio<1000000000000LL, 1> tera;
typedef ratio<1000000000000000LL, 1> peta;
typedef ratio<1000000000000000000LL, 1> exa;
}

#pragma warning(pop)
#pragma pack(pop)
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\chrono" 2 3



# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\thr/xtimec.h" 1 3





# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\thr/xthrcommon.h" 1 3







#pragma pack(push,8)
#pragma warning(push, 3)
# 20 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\thr/xthrcommon.h" 3
#pragma warning(disable: 4511 4512)

extern "C" {

#pragma warning(disable: 4115 4100 4097 4245)
# 34 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\thr/xthrcommon.h" 3
typedef unsigned int _Thrd_id_t;
typedef struct
 {
 void *_Hnd;
 _Thrd_id_t _Id;
 } _Thrd_imp_t;





typedef unsigned int (__stdcall *_Thrd_callback_t)(void *);
# 74 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\thr/xthrcommon.h" 3
typedef struct _Mtx_internal_imp_t *_Mtx_imp_t;

typedef struct _Cnd_internal_imp_t *_Cnd_imp_t;
typedef int _Tss_imp_t;


              void __cdecl _Thrd_abort(const char *);
              int __cdecl _Thrd_start(_Thrd_imp_t *, _Thrd_callback_t, void *);
void _Tss_destroy(void);
# 95 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\thr/xthrcommon.h" 3
}
# 107 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\thr/xthrcommon.h" 3
#pragma warning(pop)
#pragma pack(pop)
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\thr/xtimec.h" 2 3



#pragma pack(push,8)
#pragma warning(push, 3)




extern "C" {


typedef struct xtime
 {
 __time64_t sec;
 long nsec;
 } xtime;

              int __cdecl xtime_get(xtime*, int);

              long __cdecl _Xtime_diff_to_millis(const xtime *);
              long __cdecl _Xtime_diff_to_millis2(const xtime*, const xtime *);
              long long __cdecl _Xtime_get_ticks(void);



              long long __cdecl _Query_perf_counter(void);
              long long __cdecl _Query_perf_frequency(void);


}


#pragma warning(pop)
#pragma pack(pop)
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\chrono" 2 3


#pragma pack(push,8)
#pragma warning(push, 3)



#pragma warning(disable: 4455)
#pragma warning(disable: 6326)

namespace std {
namespace chrono {

template<class _Rep>
 struct treat_as_floating_point
  : is_floating_point<_Rep>
 {
 };


template<class _Rep>
 constexpr bool treat_as_floating_point_v = treat_as_floating_point<_Rep>::value;



template<class _Rep>
 struct duration_values
 {
 static constexpr _Rep zero()
  {
  return (_Rep(0));
  }

 static constexpr _Rep (min)()
  {
  return (numeric_limits<_Rep>::lowest());
  }

 static constexpr _Rep (max)()
  {
  return ((numeric_limits<_Rep>::max)());
  }
 };


template<class _Ty>
 struct _Is_ratio
 {
 static constexpr bool value = false;
 };

template<intmax_t _R1,
 intmax_t _R2>
 struct _Is_ratio<ratio<_R1, _R2> >
 {
 static constexpr bool value = true;
 };


template<class _Rep,
 class _Period = ratio<1> >
 class duration;

template<class _Ty>
 struct _Is_duration
  : false_type
 {
 };

template<class _Rep,
 class _Period>
 struct _Is_duration<duration<_Rep, _Period> >
  : true_type
 {
 };

template<class _To,
 class _Rep,
 class _Period> inline
 constexpr typename enable_if<_Is_duration<_To>::value, _To>::type
  duration_cast(const duration<_Rep, _Period>&);

template<class _Rep,
 class _Period>
 class duration
 {
public:
 typedef duration<_Rep, _Period> _Myt;
 typedef _Rep rep;
 typedef _Period period;

 static_assert(!_Is_duration<_Rep>::value,
  "duration can't have duration as first template argument");
 static_assert(_Is_ratio<_Period>::value,
  "period not an instance of std::ratio");
 static_assert(0 < _Period::num,
  "period negative or zero");

 constexpr duration() = default;

 template<class _Rep2,
  class = typename enable_if<is_convertible<_Rep2, _Rep>::value
   && (treat_as_floating_point<_Rep>::value
    || !treat_as_floating_point<_Rep2>::value),
   void>::type>
  constexpr explicit duration(const _Rep2& _Val)
   : _MyRep(static_cast<_Rep>(_Val))
  {
  }

 template<class _Rep2,
  class _Period2,
  class = typename enable_if<treat_as_floating_point<_Rep>::value

   || (_Ratio_divide_sfinae<_Period2, _Period>::den == 1

    && !treat_as_floating_point<_Rep2>::value),
   void>::type>
  constexpr duration(const duration<_Rep2, _Period2>& _Dur)
   : _MyRep(chrono::duration_cast<_Myt>(_Dur).count())
  {
  }

 constexpr _Rep count() const
  {
  return (_MyRep);
  }

 constexpr _Myt operator+() const
  {
  return (*this);
  }

 constexpr _Myt operator-() const
  {
  return (_Myt(0 - _MyRep));
  }

 _Myt& operator++()
  {
  ++_MyRep;
  return (*this);
  }

 _Myt operator++(int)
  {
  return (_Myt(_MyRep++));
  }

 _Myt& operator--()
  {
  --_MyRep;
  return (*this);
  }

 _Myt operator--(int)
  {
  return (_Myt(_MyRep--));
  }

 _Myt& operator+=(const _Myt& _Right)
  {
  _MyRep += _Right._MyRep;
  return (*this);
  }

 _Myt& operator-=(const _Myt& _Right)
  {
  _MyRep -= _Right._MyRep;
  return (*this);
  }

 _Myt& operator*=(const _Rep& _Right)
  {
  _MyRep *= _Right;
  return (*this);
  }

 _Myt& operator/=(const _Rep& _Right)
  {
  _MyRep /= _Right;
  return (*this);
  }

 _Myt& operator%=(const _Rep& _Right)
  {
  _MyRep %= _Right;
  return (*this);
  }

 _Myt& operator%=(const _Myt& _Right)
  {
  _MyRep %= _Right.count();
  return (*this);
  }

 static constexpr _Myt zero()
  {
  return (_Myt(duration_values<_Rep>::zero()));
  }

 static constexpr _Myt (min)()
  {
  return (_Myt((duration_values<_Rep>::min)()));
  }
 static constexpr _Myt (max)()
  {
  return (_Myt((duration_values<_Rep>::max)()));
  }

private:
 _Rep _MyRep;
 };

template<class _Clock,
 class _Duration = typename _Clock::duration>
 class time_point
 {
public:
 typedef _Clock clock;
 typedef _Duration duration;
 typedef typename _Duration::rep rep;
 typedef typename _Duration::period period;

 static_assert(_Is_duration<_Duration>::value,
  "duration must be an instance of std::duration");

 constexpr time_point()
  : _MyDur(_Duration::zero())
  {
  }

 constexpr explicit time_point(const _Duration& _Other)
  : _MyDur(_Other)
  {
  }

 template<class _Duration2,
  class = typename enable_if<is_convertible<_Duration2,
   _Duration>::value,
   void>::type>
  constexpr time_point(const time_point<_Clock, _Duration2>& _Tp)
  : _MyDur(_Tp.time_since_epoch())
  {
  }

 constexpr _Duration time_since_epoch() const
  {
  return (_MyDur);
  }

 time_point& operator+=(const _Duration& _Dur)
  {
  _MyDur += _Dur;
  return (*this);
  }

 time_point& operator-=(const _Duration& _Dur)
  {
  _MyDur -= _Dur;
  return (*this);
  }

 static constexpr time_point (min)()
  {
  return (time_point((_Duration::min)()));
  }
 static constexpr time_point (max)()
  {
  return (time_point((_Duration::max)()));
  }

private:
 _Duration _MyDur;
 };
}


template<intmax_t _Ax,
 intmax_t _Bx>
 struct _Lcm
 {
 static constexpr intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
 static constexpr intmax_t value = (_Ax / _Gx) * _Bx;
 };


template<class _Rep1,
 class _Period1,
 class _Rep2,
 class _Period2>
 struct common_type<
  chrono::duration<_Rep1, _Period1>,
  chrono::duration<_Rep2, _Period2> >
 {
 typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
  ratio<_Gcd<_Period1::num, _Period2::num>::value,
   _Lcm<_Period1::den, _Period2::den>::value> > type;
 };

template<class _Clock,
 class _Duration1,
 class _Duration2>
 struct common_type<
  chrono::time_point<_Clock, _Duration1>,
  chrono::time_point<_Clock, _Duration2> >
 {
 typedef chrono::time_point<
  _Clock, typename common_type<_Duration1, _Duration2>::type> type;
 };

namespace chrono {

template<class _Rep1,
 class _Period1,
 class _Rep2,
 class _Period2> inline
 constexpr typename common_type<
  duration<_Rep1, _Period1>,
  duration<_Rep2, _Period2> >::type
  operator+(
   const duration<_Rep1, _Period1>& _Left,
   const duration<_Rep2, _Period2>& _Right)
 {
 typedef typename common_type<
  duration<_Rep1, _Period1>,
  duration<_Rep2, _Period2> >::type _CD;
 return (_CD(_CD(_Left).count() + _CD(_Right).count()));
 }

template<class _Rep1,
 class _Period1,
 class _Rep2,
 class _Period2> inline
 constexpr typename common_type<
  duration<_Rep1, _Period1>,
  duration<_Rep2, _Period2> >::type
  operator-(
   const duration<_Rep1, _Period1>& _Left,
   const duration<_Rep2, _Period2>& _Right)
 {
 typedef typename common_type<
  duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
 return (_CD(_CD(_Left).count() - _CD(_Right).count()));
 }

template<class _Rep1,
 class _Period1,
 class _Rep2> inline
 constexpr typename enable_if<is_convertible<_Rep2,
  typename common_type<_Rep1, _Rep2>::type>::value,
  duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
  operator*(
   const duration<_Rep1, _Period1>& _Left,
   const _Rep2& _Right)
 {
 typedef typename common_type<_Rep1, _Rep2>::type _CR;
 typedef duration<_CR, _Period1> _CD;
 return (_CD(_CD(_Left).count() * _Right));
 }

template<class _Rep1,
 class _Rep2,
 class _Period2> inline
 constexpr typename enable_if<is_convertible<_Rep1,
  typename common_type<_Rep1, _Rep2>::type>::value,
  duration<typename common_type<_Rep1, _Rep2>::type, _Period2> >::type
  operator*(
   const _Rep1& _Left,
   const duration<_Rep2, _Period2>& _Right)
 {
 return (_Right * _Left);
 }

template<class _CR,
 class _Period1,
 class _Rep2,
 bool = is_convertible<_Rep2, _CR>::value>
 struct _Duration_div_mod1
 {
 typedef duration<_CR, _Period1> type;
 };

template<class _CR,
 class _Period1,
 class _Rep2>
 struct _Duration_div_mod1<_CR, _Period1, _Rep2, false>
 {
 };

template<class _Rep1,
 class _Period1,
 class _Rep2,
 bool = _Is_duration<_Rep2>::value>
 struct _Duration_div_mod
 {
 };

template<class _Rep1,
 class _Period1,
 class _Rep2>
 struct _Duration_div_mod<_Rep1, _Period1, _Rep2, false>
  : _Duration_div_mod1<typename common_type<_Rep1, _Rep2>::type,
   _Period1, _Rep2>
 {
 };

template<class _Rep1,
 class _Period1,
 class _Rep2> inline
 typename _Duration_div_mod<_Rep1, _Period1, _Rep2>::type
  constexpr operator/(
   const duration<_Rep1, _Period1>& _Left,
   const _Rep2& _Right)
 {
 typedef typename common_type<_Rep1, _Rep2>::type _CR;
 typedef duration<_CR, _Period1> _CD;
 return (_CD(_CD(_Left).count() / _Right));
 }

template<class _Rep1,
 class _Period1,
 class _Rep2,
 class _Period2> inline
 constexpr typename common_type<_Rep1, _Rep2>::type
  operator/(
   const duration<_Rep1, _Period1>& _Left,
   const duration<_Rep2, _Period2>& _Right)
 {
 typedef typename common_type<
  duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
 return (_CD(_Left).count() / _CD(_Right).count());
 }

template<class _Rep1,
 class _Period1,
 class _Rep2> inline
 constexpr typename _Duration_div_mod<_Rep1, _Period1, _Rep2>::type
  operator%(
   const duration<_Rep1, _Period1>& _Left,
   const _Rep2& _Right)
 {
 typedef typename common_type<_Rep1, _Rep2>::type _CR;
 typedef duration<_CR, _Period1> _CD;
 return (_CD(_CD(_Left).count() % _Right));
 }

template<class _Rep1,
 class _Period1,
 class _Rep2,
 class _Period2> inline
 constexpr typename common_type<
  duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type
  operator%(
   const duration<_Rep1, _Period1>& _Left,
   const duration<_Rep2, _Period2>& _Right)
 {
 typedef typename common_type<
  duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
 return (_CD(_CD(_Left).count() % _CD(_Right).count()));
 }


template<class _Rep1,
 class _Period1,
 class _Rep2,
 class _Period2> inline
 constexpr bool operator==(
  const duration<_Rep1, _Period1>& _Left,
  const duration<_Rep2, _Period2>& _Right)
 {
 typedef typename common_type<
  duration<_Rep1, _Period1>,
  duration<_Rep2, _Period2> >::type _CT;
 return (_CT(_Left).count() == _CT(_Right).count());
 }

template<class _Rep1,
 class _Period1,
 class _Rep2,
 class _Period2> inline
 constexpr bool operator!=(
  const duration<_Rep1, _Period1>& _Left,
  const duration<_Rep2, _Period2>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _Rep1,
 class _Period1,
 class _Rep2,
 class _Period2> inline
 constexpr bool operator<(
  const duration<_Rep1, _Period1>& _Left,
  const duration<_Rep2, _Period2>& _Right)
 {
 typedef typename common_type<
  duration<_Rep1, _Period1>,
  duration<_Rep2, _Period2> >::type _CT;
 return (_CT(_Left).count() < _CT(_Right).count());
 }

template<class _Rep1,
 class _Period1,
 class _Rep2,
 class _Period2> inline
 constexpr bool operator<=(
  const duration<_Rep1, _Period1>& _Left,
  const duration<_Rep2, _Period2>& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _Rep1,
 class _Period1,
 class _Rep2,
 class _Period2> inline
 constexpr bool operator>(
  const duration<_Rep1, _Period1>& _Left,
  const duration<_Rep2, _Period2>& _Right)
 {
 return (_Right < _Left);
 }

template<class _Rep1,
 class _Period1,
 class _Rep2,
 class _Period2> inline
 constexpr bool operator>=(
  const duration<_Rep1, _Period1>& _Left,
  const duration<_Rep2, _Period2>& _Right)
 {
 return (!(_Left < _Right));
 }


template<class _To,
 class _Rep,
 class _Period> inline
 constexpr typename enable_if<_Is_duration<_To>::value, _To>::type
  duration_cast(const duration<_Rep, _Period>& _Dur)
 {
 typedef ratio_divide<_Period, typename _To::period> _CF;

 typedef typename _To::rep _ToRep;
 typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;
 return (_CF::num == 1 && _CF::den == 1
   ? static_cast<_To>(static_cast<_ToRep>(_Dur.count()))
  : _CF::num != 1 && _CF::den == 1
   ? static_cast<_To>(static_cast<_ToRep>(
    static_cast<_CR>(
     _Dur.count()) * static_cast<_CR>(_CF::num)))
  : _CF::num == 1 && _CF::den != 1
   ? static_cast<_To>(static_cast<_ToRep>(
    static_cast<_CR>(_Dur.count())
     / static_cast<_CR>(_CF::den)))
  : static_cast<_To>(static_cast<_ToRep>(
   static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)
    / static_cast<_CR>(_CF::den))));
 }


template<class _Dur>
 using _As_integral = duration<
  typename conditional<treat_as_floating_point<typename _Dur::rep>::value,
   intmax_t,
   typename _Dur::rep>::type,
  typename _Dur::period>;


template<class _Rep,
 class _Period,
 class _To_integral> inline
 constexpr _To_integral _Floor(const duration<_Rep, _Period>& _Dur,
  const _To_integral& _Dur_integral)
 {
 return (_Dur_integral <= _Dur
  ? _Dur_integral
  : _Dur_integral - static_cast<_To_integral>(1));
 }

template<class _To,
 class _Rep,
 class _Period> inline
 constexpr typename enable_if<_Is_duration<_To>::value, _To>::type
  floor(const duration<_Rep, _Period>& _Dur)
 {

 return (_Floor(_Dur, chrono::duration_cast<_As_integral<_To> >(_Dur)));
 }


template<class _Rep,
 class _Period,
 class _To_integral> inline
 constexpr _To_integral _Ceil(const duration<_Rep, _Period>& _Dur,
  const _To_integral& _Dur_integral)
 {
 return (_Dur <= _Dur_integral
  ? _Dur_integral
  : _Dur_integral + static_cast<_To_integral>(1));
 }

template<class _To,
 class _Rep,
 class _Period> inline
 constexpr typename enable_if<_Is_duration<_To>::value, _To>::type
  ceil(const duration<_Rep, _Period>& _Dur)
 {

 return (_Ceil(_Dur, chrono::duration_cast<_As_integral<_To> >(_Dur)));
 }


template<class _Rep> inline
 constexpr typename make_unsigned<_Rep>::type _Make_unsigned(_Rep _Val)
 {
 return (static_cast<typename make_unsigned<_Rep>::type>(_Val));
 }


template<class _Rep> inline
 constexpr bool _Is_even(_Rep _Val)
 {
 return (_Val % 2 == 0);
 }


template<class _Rep> inline
 constexpr _Rep _Bankers_divide_impl(_Rep _Truncated, _Rep _Mod,
  _Rep _Half_divisor, bool _Half_divisor_is_exact)
 {
 return (_Truncated + static_cast<_Rep>(

  _Mod > _Half_divisor

   || (_Mod == _Half_divisor

   && _Half_divisor_is_exact
   && !_Is_even(_Truncated)
  )));
 }

template<class _Rep> inline
 constexpr _Rep _Bankers_divide_tag(_Rep _Dividend, _Rep _Divisor, false_type)
 {
 return (_Bankers_divide_impl(
  _Dividend / _Divisor,
  _Dividend % _Divisor,
  _Divisor / static_cast<_Rep>(2),
  _Is_even(_Divisor)));
 }

template<class _Rep> inline
 constexpr _Rep _Bankers_divide_tag(_Rep _Dividend, _Rep _Divisor, true_type)
 {
 return (static_cast<_Rep>(duration_values<_Rep>::zero() <= _Dividend
  ? _Bankers_divide_tag(_Make_unsigned(_Dividend),
   _Make_unsigned(_Divisor), false_type())
  : duration_values<_Rep>::zero() - _Bankers_divide_tag(
   duration_values<_Rep>::zero() - _Make_unsigned(_Dividend),
   _Make_unsigned(_Divisor), false_type())));
 }

template<class _Rep> inline
 constexpr _Rep _Bankers_divide(_Rep _Dividend, _Rep _Divisor)
 {



 return (_Bankers_divide_tag(_Dividend, _Divisor, is_signed<_Rep>()));
 }


template<class _Rep> inline
 constexpr bool _Round_should_truncate(_Rep _Val, intmax_t _Val_trunc)
 {
 return (_Val - static_cast<_Rep>(_Val_trunc) < static_cast<_Rep>(_Val_trunc + 1) - _Val
  || (_Val - static_cast<_Rep>(_Val_trunc) == static_cast<_Rep>(_Val_trunc + 1) - _Val
   && _Is_even(_Val_trunc)));
 }

template<class _Rep> inline
 constexpr intmax_t _Round_fp_non_negative(_Rep _Val, intmax_t _Val_trunc)
 {
 return (_Round_should_truncate(_Val, _Val_trunc) ? _Val_trunc : _Val_trunc + 1);
 }

template<class _Rep> inline
 constexpr intmax_t _Round_fp_non_negative(_Rep _Val)
 {
 return (_Round_fp_non_negative(_Val, static_cast<intmax_t>(_Val)));
 }

template<class _Rep> inline
 constexpr _Rep _Round_fp(_Rep _Val)
 {

 static_assert(treat_as_floating_point<_Rep>::value,
  "_Round_fp needs floating input");
 return (static_cast<_Rep>(duration_values<_Rep>::zero() <= _Val
  ? _Round_fp_non_negative(_Val)
  : (duration_values<_Rep>::zero()
   - _Round_fp_non_negative(duration_values<_Rep>::zero() - _Val))
  ));
 }


template<class _To,
 class _Rep,
 class _Period> inline
 constexpr _To _Round(const duration<_Rep, _Period>& _Dur,
  false_type, false_type)
 {
 typedef ratio_divide<_Period, typename _To::period> _CF;

 typedef typename _To::rep _ToRep;
 typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;
 return (_CF::num == 1 && _CF::den == 1
   ? static_cast<_To>(static_cast<_ToRep>(_Dur.count()))
  : _CF::num != 1 && _CF::den == 1
   ? static_cast<_To>(static_cast<_ToRep>(
    static_cast<_CR>(
     _Dur.count()) * static_cast<_CR>(_CF::num)))
  : _CF::num == 1 && _CF::den != 1
   ? static_cast<_To>(static_cast<_ToRep>(_Bankers_divide(
    static_cast<_CR>(_Dur.count()), static_cast<_CR>(_CF::den))))
  : static_cast<_To>(static_cast<_ToRep>(
   _Bankers_divide(
    static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num),
    static_cast<_CR>(_CF::den)))));
 }

template<class _To,
 class _Rep,
 class _Period> inline
 constexpr _To _Round(const duration<_Rep, _Period>& _Dur,
  false_type, true_type)
 {


 typedef duration<_Rep, typename _To::period> _FloatTo;
 return (static_cast<_To>(static_cast<typename _To::rep>(
  _Round_fp(chrono::duration_cast<_FloatTo>(_Dur).count()))));
 }

template<class _To,
 class _Rep,
 class _Period,
 class _Source_integral> inline
 constexpr _To _Round(const duration<_Rep, _Period>& _Dur,
  true_type, _Source_integral)
 {

 return (static_cast<_To>(_Round_fp(chrono::duration_cast<_To>(_Dur).count())));
 }

template<class _To,
 class _Rep,
 class _Period> inline
 constexpr typename enable_if<_Is_duration<_To>::value, _To>::type
  round(const duration<_Rep, _Period>& _Dur)
 {
 return (_Round<_To>(_Dur,
  treat_as_floating_point<typename _To::rep>(),
  treat_as_floating_point<_Rep>()));
 }


template<class _Rep,
 class _Period> inline
 constexpr typename enable_if<numeric_limits<_Rep>::is_signed,
  duration<_Rep, _Period> >::type
  abs(const duration<_Rep, _Period> _Dur)
 {
 return (_Dur < duration<_Rep, _Period>::zero()
  ? duration<_Rep, _Period>::zero() - _Dur
  : _Dur);
 }


typedef duration<long long, nano> nanoseconds;
typedef duration<long long, micro> microseconds;
typedef duration<long long, milli> milliseconds;
typedef duration<long long> seconds;
typedef duration<int, ratio<60> > minutes;
typedef duration<int, ratio<3600> > hours;


template<class _Clock,
 class _Duration,
 class _Rep,
 class _Period> inline
 constexpr time_point<_Clock,
  typename common_type<_Duration, duration<_Rep, _Period> >::type>
  operator+(
   const time_point<_Clock, _Duration>& _Left,
   const duration<_Rep, _Period>& _Right)
 {
 typedef time_point<_Clock, typename common_type<
  _Duration, duration<_Rep, _Period> >::type> _RT;
 return (_RT(_Left.time_since_epoch() + _Right));
 }

template<class _Rep,
 class _Period,
 class _Clock,
 class _Duration> inline
 constexpr time_point<_Clock,
  typename common_type<duration<_Rep, _Period>, _Duration>::type>
  operator+(
   const duration<_Rep, _Period>& _Left,
   const time_point<_Clock, _Duration>& _Right)
 {
 return (_Right + _Left);
 }

template<class _Clock,
 class _Duration,
 class _Rep,
 class _Period> inline
 constexpr time_point<_Clock,
  typename common_type<_Duration, duration<_Rep, _Period> >::type>
  operator-(
   const time_point<_Clock, _Duration>& _Left,
   const duration<_Rep, _Period>& _Right)
 {
 return (_Left + (-_Right));
 }

template<class _Clock,
 class _Duration1,
 class _Duration2> inline
 constexpr typename common_type<_Duration1, _Duration2>::type
  operator-(
   const time_point<_Clock, _Duration1>& _Left,
   const time_point<_Clock, _Duration2>& _Right)
 {
 return (_Left.time_since_epoch() - _Right.time_since_epoch());
 }


template<class _Clock,
 class _Duration1,
 class _Duration2> inline
 constexpr bool operator==(
  const time_point<_Clock, _Duration1>& _Left,
  const time_point<_Clock, _Duration2>& _Right)
 {
 return (_Left.time_since_epoch() == _Right.time_since_epoch());
 }

template<class _Clock,
 class _Duration1,
 class _Duration2> inline
 constexpr bool operator!=(
  const time_point<_Clock, _Duration1>& _Left,
  const time_point<_Clock, _Duration2>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _Clock,
 class _Duration1,
 class _Duration2> inline
 constexpr bool operator<(
  const time_point<_Clock, _Duration1>& _Left,
  const time_point<_Clock, _Duration2>& _Right)
 {
 return (_Left.time_since_epoch() < _Right.time_since_epoch());
 }

template<class _Clock,
 class _Duration1,
 class _Duration2> inline
 constexpr bool operator<=(
  const time_point<_Clock, _Duration1>& _Left,
  const time_point<_Clock, _Duration2>& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _Clock,
 class _Duration1,
 class _Duration2> inline
 constexpr bool operator>(
  const time_point<_Clock, _Duration1>& _Left,
  const time_point<_Clock, _Duration2>& _Right)
 {
 return (_Right < _Left);
 }

template<class _Clock,
 class _Duration1,
 class _Duration2> inline
 constexpr bool operator>=(
  const time_point<_Clock, _Duration1>& _Left,
  const time_point<_Clock, _Duration2>& _Right)
 {
 return (!(_Left < _Right));
 }


template<class _To,
 class _Clock,
 class _Duration> inline
 constexpr typename enable_if<_Is_duration<_To>::value,
  time_point<_Clock, _To> >::type
  time_point_cast(const time_point<_Clock, _Duration>& _Time)
 {
 return (time_point<_Clock, _To>(
  chrono::duration_cast<_To>(_Time.time_since_epoch())));
 }


template<class _To,
 class _Clock,
 class _Duration> inline
 constexpr typename enable_if<_Is_duration<_To>::value,
  time_point<_Clock, _To> >::type
  floor(const time_point<_Clock, _Duration>& _Time)
 {
 return (time_point<_Clock, _To>(
  chrono::floor<_To>(_Time.time_since_epoch())));
 }


template<class _To,
 class _Clock,
 class _Duration> inline
 constexpr typename enable_if<_Is_duration<_To>::value,
  time_point<_Clock, _To> >::type
  ceil(const time_point<_Clock, _Duration>& _Time)
 {
 return (time_point<_Clock, _To>(
  chrono::ceil<_To>(_Time.time_since_epoch())));
 }


template<class _To,
 class _Clock,
 class _Duration> inline
 constexpr typename enable_if<_Is_duration<_To>::value,
  time_point<_Clock, _To> >::type
  round(const time_point<_Clock, _Duration>& _Time)
 {
 return (time_point<_Clock, _To>(
  chrono::round<_To>(_Time.time_since_epoch())));
 }


struct system_clock

 {
 typedef long long rep;

 typedef ratio_multiply<ratio<100, 1>, nano> period;

 typedef chrono::duration<rep, period> duration;
 typedef chrono::time_point<system_clock> time_point;
 static constexpr bool is_steady = false;

 static time_point now() noexcept
  {
  return (time_point(duration(_Xtime_get_ticks())));
  }

 static __time64_t to_time_t(const time_point& _Time) noexcept
  {
  return ((__time64_t)(_Time.time_since_epoch().count()
   / (long long)10000000));
  }

 static time_point from_time_t(__time64_t _Tm) noexcept
  {
  return (time_point(duration(_Tm * (long long)10000000)));
  }
 };

struct steady_clock
 {
 typedef long long rep;
 typedef nano period;
 typedef nanoseconds duration;
 typedef chrono::time_point<steady_clock> time_point;
 static constexpr bool is_steady = true;

 static time_point now() noexcept
  {
  const long long _Freq = _Query_perf_frequency();
  const long long _Ctr = _Query_perf_counter();
  static_assert(period::num == 1, "This assumes period::num == 1.");
  const long long _Whole = (_Ctr / _Freq) * period::den;
  const long long _Part = (_Ctr % _Freq) * period::den / _Freq;
  return (time_point(duration(_Whole + _Part)));
  }
 };

typedef steady_clock high_resolution_clock;
}


template<class _Rep,
 class _Period> inline
 xtime _To_xtime(const chrono::duration<_Rep, _Period>& _Rel_time)
 {
 xtime _Xt;
 if (_Rel_time <= chrono::duration<_Rep, _Period>::zero())
  {
  _Xt.sec = 0;
  _Xt.nsec = 0;
  }
 else
  {
  chrono::nanoseconds _T0 =
   chrono::system_clock::now().time_since_epoch();
  _T0 += chrono::duration_cast<chrono::nanoseconds>(_Rel_time);
  _Xt.sec = chrono::duration_cast<chrono::seconds>(_T0).count();
  _T0 -= chrono::seconds(_Xt.sec);
  _Xt.nsec = (long)_T0.count();
  }
 return (_Xt);
 }







inline namespace literals {
inline namespace chrono_literals {
inline constexpr chrono::hours operator "" h(unsigned long long _Val)
 {
 return (chrono::hours(_Val));
 }

inline constexpr chrono::duration<double, ratio<3600> > operator "" h(
 long double _Val)
 {
 return (chrono::duration<double, ratio<3600> >(_Val));
 }

inline constexpr chrono::minutes (operator "" min)(unsigned long long _Val)
 {
 return (chrono::minutes(_Val));
 }

inline constexpr chrono::duration<double, ratio<60> > (operator "" min)(
 long double _Val)
 {
 return (chrono::duration<double, ratio<60> >(_Val));
 }

inline constexpr chrono::seconds operator "" s(unsigned long long _Val)
 {
 return (chrono::seconds(_Val));
 }

inline constexpr chrono::duration<double> operator "" s(long double _Val)
 {
 return (chrono::duration<double>(_Val));
 }

inline constexpr chrono::milliseconds operator "" ms(unsigned long long _Val)
 {
 return (chrono::milliseconds(_Val));
 }

inline constexpr chrono::duration<double, milli> operator "" ms(
 long double _Val)
 {
 return (chrono::duration<double, milli>(_Val));
 }

inline constexpr chrono::microseconds operator "" us(unsigned long long _Val)
 {
 return (chrono::microseconds(_Val));
 }

inline constexpr chrono::duration<double, micro> operator "" us(
 long double _Val)
 {
 return (chrono::duration<double, micro>(_Val));
 }

inline constexpr chrono::nanoseconds operator "" ns(unsigned long long _Val)
 {
 return (chrono::nanoseconds(_Val));
 }

inline constexpr chrono::duration<double, nano> operator "" ns(
 long double _Val)
 {
 return (chrono::duration<double, nano>(_Val));
 }
}
}

namespace chrono {
 using namespace literals::chrono_literals;
}





}

#pragma warning(pop)
#pragma pack(pop)
# 14 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\thread" 2 3




# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\thr/xthread" 1 3






# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\thr/xtime" 1 3







#pragma pack(push,8)
#pragma warning(push, 3)



namespace stdext
 {
 namespace threads
  {
using ::xtime;
using ::xtime_get;
  }
 }

#pragma warning(pop)
#pragma pack(pop)
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\thr/xthread" 2 3

# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\thr/xthreads.h" 1 3
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\thr/xthreads.h" 3
#pragma pack(push,8)
#pragma warning(push, 3)



extern "C" {
enum {
 _Thrd_success,
 _Thrd_nomem,
 _Thrd_timedout,
 _Thrd_busy,
 _Thrd_error
 };


typedef _Thrd_imp_t _Thrd_t;
typedef int (*_Thrd_start_t)(void *);

              int __cdecl _Thrd_create(_Thrd_t *, _Thrd_start_t, void *);

              int __cdecl _Thrd_detach(_Thrd_t);
              void __cdecl _Thrd_exit(int);
              int __cdecl _Thrd_join(_Thrd_t, int *);
              void __cdecl _Thrd_sleep(const xtime*);
              void __cdecl _Thrd_yield(void);
              unsigned int __cdecl _Thrd_hardware_concurrency(void);
              int __cdecl _Thrd_equal(_Thrd_t, _Thrd_t);
              _Thrd_t __cdecl _Thrd_current(void);
              _Thrd_id_t __cdecl _Thrd_id(void);


typedef _Mtx_imp_t _Mtx_t;
enum {
 _Mtx_plain = 0x01,
 _Mtx_try = 0x02,
 _Mtx_timed = 0x04,
 _Mtx_recursive = 0x100
 };

              int __cdecl _Mtx_init(_Mtx_t *, int);
              void __cdecl _Mtx_destroy(_Mtx_t);
              void __cdecl _Mtx_init_in_situ(_Mtx_t, int);
              void __cdecl _Mtx_destroy_in_situ(_Mtx_t);
              int __cdecl _Mtx_current_owns(_Mtx_t);
              int __cdecl _Mtx_lock(_Mtx_t);
              int __cdecl _Mtx_trylock(_Mtx_t);
              int __cdecl _Mtx_timedlock(_Mtx_t, const xtime *);
              int __cdecl _Mtx_unlock(_Mtx_t);

              void *__cdecl _Mtx_getconcrtcs(_Mtx_t);
              void __cdecl _Mtx_clear_owner(_Mtx_t);
              void __cdecl _Mtx_reset_owner(_Mtx_t);



typedef void * _Smtx_t;
void __cdecl _Smtx_lock_exclusive(_Smtx_t *);
void __cdecl _Smtx_lock_shared(_Smtx_t *);
int __cdecl _Smtx_try_lock_exclusive(_Smtx_t *);
int __cdecl _Smtx_try_lock_shared(_Smtx_t *);
void __cdecl _Smtx_unlock_exclusive(_Smtx_t *);
void __cdecl _Smtx_unlock_shared(_Smtx_t *);


typedef _Cnd_imp_t _Cnd_t;

              int __cdecl _Cnd_init(_Cnd_t *);
              void __cdecl _Cnd_destroy(_Cnd_t);
              void __cdecl _Cnd_init_in_situ(_Cnd_t);
              void __cdecl _Cnd_destroy_in_situ(_Cnd_t);
              int __cdecl _Cnd_wait(_Cnd_t, _Mtx_t);
              int __cdecl _Cnd_timedwait(_Cnd_t,
 _Mtx_t, const xtime *);
              int __cdecl _Cnd_broadcast(_Cnd_t);
              int __cdecl _Cnd_signal(_Cnd_t);
              void __cdecl _Cnd_register_at_thread_exit(_Cnd_t,
 _Mtx_t, int *);
              void __cdecl _Cnd_unregister_at_thread_exit(_Mtx_t);
              void __cdecl _Cnd_do_broadcast_at_thread_exit(void);


typedef _Tss_imp_t _Tss_t;
typedef void (*_Tss_dtor_t)(void *);
              int __cdecl _Tss_create(_Tss_t *, _Tss_dtor_t);

              int __cdecl _Tss_delete(_Tss_t);
              int __cdecl _Tss_set(_Tss_t, void *);
              void *__cdecl _Tss_get(_Tss_t);
# 109 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\thr/xthreads.h" 3
              void __cdecl _Thrd_abort(const char *);
}

#pragma warning(pop)
#pragma pack(pop)
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\thr/xthread" 2 3





#pragma pack(push,8)
#pragma warning(push, 3)



namespace std {
enum {
 _DEVICE_OR_RESOURCE_BUSY,
 _INVALID_ARGUMENT,
 _NO_SUCH_PROCESS,
 _NOT_ENOUGH_MEMORY,
 _OPERATION_NOT_PERMITTED,
 _RESOURCE_DEADLOCK_WOULD_OCCUR,
 _RESOURCE_UNAVAILABLE_TRY_AGAIN
 };

              void __cdecl _Throw_C_error(int _Code);
              void __cdecl _Throw_Cpp_error(int _Code);

inline int _Check_C_return(int _Res)
 {
 if (_Res != _Thrd_success)
  _Throw_C_error(_Res);
 return (_Res);
 }

inline int _Check_C_return(int _Res, int _Other)
 {
 if (_Res != _Thrd_success && _Res != _Other)
  _Throw_C_error(_Res);
 return (_Res);
 }


inline int _Thrd_startX(_Thrd_imp_t *_Thr, _Thrd_callback_t _Fp, void *_Arg)
 {
 int _Res = _Thrd_start(_Thr, _Fp, _Arg);
 return (_Check_C_return(_Res != _Thrd_error ? _Res : _Thrd_nomem));
 }

inline int _Thrd_detachX(_Thrd_t _Thr)
 {
 return (_Check_C_return(_Thrd_detach(_Thr)));
 }

inline int _Thrd_joinX(_Thrd_t _Thr, int *_Res)
 {
 return (_Check_C_return(_Thrd_join(_Thr, _Res)));
 }

inline int _Mtx_initX(_Mtx_t *_Mtx, int _Type)
 {
 return (_Check_C_return(_Mtx_init(_Mtx, _Type)));
 }

inline int _Mtx_lockX(_Mtx_t _Mtx)
 {
 return (_Check_C_return(_Mtx_lock(_Mtx)));
 }

inline int _Mtx_trylockX(_Mtx_t _Mtx)
 {
 return (_Check_C_return(_Mtx_trylock(_Mtx), _Thrd_busy));
 }

inline int _Mtx_timedlockX(_Mtx_t _Mtx, const xtime *_Xt)
 {
 return (_Check_C_return(_Mtx_timedlock(_Mtx, _Xt), _Thrd_timedout));
 }

inline int _Mtx_unlockX(_Mtx_t _Mtx)
 {
 return (_Check_C_return(_Mtx_unlock(_Mtx)));
 }

inline int _Cnd_initX(_Cnd_t *_Cnd)
 {
 return (_Check_C_return(_Cnd_init(_Cnd)));
 }

inline int _Cnd_waitX(_Cnd_t _Cnd, _Mtx_t _Mtx)
 {
 return (_Check_C_return(_Cnd_wait(_Cnd, _Mtx)));
 }

inline int _Cnd_timedwaitX(_Cnd_t _Cnd,
 _Mtx_t _Mtx, const xtime *_Xt)
 {
 return (_Check_C_return(_Cnd_timedwait(_Cnd, _Mtx, _Xt), _Thrd_timedout));
 }

inline int _Cnd_broadcastX(_Cnd_t _Cnd)
 {
 return (_Check_C_return(_Cnd_broadcast(_Cnd)));
 }

inline int _Cnd_signalX(_Cnd_t _Cnd)
 {
 return (_Check_C_return(_Cnd_signal(_Cnd)));
 }

class _Auto_cnd
 {
public:
 _Auto_cnd(_Cnd_t _Cndp)
  : _Active(true), _MyCndp(_Cndp)
  {
  }

 ~_Auto_cnd() noexcept
  {
  if (_Active)
   _Cnd_destroy(_MyCndp);
   }

 void _Release()
  {
  _Active = false;
  }

private:
 bool _Active;
 _Cnd_t _MyCndp;
 };

class _Auto_mtx
 {
public:
 _Auto_mtx(_Mtx_t _Mtxp)
  : _Active(true), _MyMtxp(_Mtxp)
  {
  }

 ~_Auto_mtx() noexcept
  {
  if (_Active)
   _Mtx_destroy(_MyMtxp);
  }

 void _Release()
  {
  _Active = false;
  }

private:
 bool _Active;
 _Mtx_t _MyMtxp;
 };

#pragma warning(push)
#pragma warning(disable: 4265)
class _Pad
 {
public:
 _Pad()
  {
  _Cnd_initX(&_Cond);
  _Auto_cnd _Cnd_cleaner(_Cond);
  _Mtx_initX(&_Mtx, _Mtx_plain);
  _Auto_mtx _Mtx_cleaner(_Mtx);
  _Started = false;
  _Mtx_lockX(_Mtx);
  _Mtx_cleaner._Release();
  _Cnd_cleaner._Release();
  }

 ~_Pad() noexcept
  {
  _Auto_cnd _Cnd_cleaner(_Cond);
  _Auto_mtx _Mtx_cleaner(_Mtx);
  _Mtx_unlockX(_Mtx);
  }

 void _Launch(_Thrd_t *_Thr)
  {
  _Thrd_startX(_Thr, _Call_func, this);
  while (!_Started)
   _Cnd_waitX(_Cond, _Mtx);
  }

 void _Release()
  {
  _Mtx_lockX(_Mtx);
  _Started = true;
  _Cnd_signalX(_Cond);
  _Mtx_unlockX(_Mtx);
  }

 virtual void _Go() = 0;

private:
typedef unsigned int _Call_func_ret;


 static _Call_func_ret __stdcall _Call_func(void *_Data)
  {
  static_cast<_Pad *>(_Data)->_Go();
  _Cnd_do_broadcast_at_thread_exit();
  return (0);
  }

 _Cnd_t _Cond;
 _Mtx_t _Mtx;
 bool _Started;
 };

template<class _Target>
 class _LaunchPad final
  : public _Pad
 {
public:
 template<class _Other> inline
  _LaunchPad(_Other&& _Tgt)
  : _MyTarget(::std:: forward<_Other>(_Tgt))
  {
  }

 virtual void _Go()
  {
  _Run(this);
  }

private:
 template<size_t... _Idxs>
  static void _Execute(typename _Target::element_type& _Tup,
   integer_sequence<size_t, _Idxs...>)
  {
  ::std:: invoke(::std:: move(::std:: get<_Idxs>(_Tup))...);
  }

 static void _Run(_LaunchPad *_Ln) noexcept
  {
  _Target _Local(::std:: forward<_Target>(_Ln->_MyTarget));
  _Ln->_Release();
  _Execute(*_Local,
   make_integer_sequence<size_t,
    tuple_size<typename _Target::element_type>::value>());
  }

 _Target _MyTarget;
 };
#pragma warning(pop)

template<class _Target> inline
 void _Launch(_Thrd_t *_Thr, _Target&& _Tg)
 {
 _LaunchPad<_Target> _Launcher(::std:: forward<_Target>(_Tg));
 _Launcher._Launch(_Thr);
 }
}


#pragma warning(pop)
#pragma pack(pop)
# 18 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\thread" 2 3



#pragma pack(push,8)
#pragma warning(push, 3)



#pragma warning(disable: 4521 4522 4800)

namespace std {
class thread
 {
public:
 class id;

 typedef void *native_handle_type;

 thread() noexcept
  {
  (_Thr._Hnd = 0, _Thr._Id = 0);
  }


 template<class _Fn,
  class... _Args,
  class = typename enable_if<
   !is_same<typename decay<_Fn>::type, thread>::value>::type>
  explicit thread(_Fn&& _Fx, _Args&&... _Ax)
  {
  _Launch(&_Thr,
   ::std:: make_unique<tuple<decay_t<_Fn>, decay_t<_Args>...> >(
    ::std:: forward<_Fn>(_Fx), ::std:: forward<_Args>(_Ax)...));
  }


 ~thread() noexcept
  {
  if (joinable())
   ::std:: terminate();
  }

 thread(thread&& _Other) noexcept
  : _Thr(_Other._Thr)
  {
  (_Other._Thr._Hnd = 0, _Other._Thr._Id = 0);
  }

 thread& operator=(thread&& _Other) noexcept
  {
  return (_Move_thread(_Other));
  }

 thread(const thread&) = delete;
 thread& operator=(const thread&) = delete;

 void swap(thread& _Other) noexcept
  {
  ::std:: swap(_Thr, _Other._Thr);
  }

 bool joinable() const noexcept
  {
  return (!(_Thr._Id == 0));
  }

 void join();

 void detach()
  {
  if (!joinable())
   _Throw_Cpp_error(_INVALID_ARGUMENT);
  _Thrd_detachX(_Thr);
  (_Thr._Hnd = 0, _Thr._Id = 0);
  }

 id get_id() const noexcept;

 static unsigned int hardware_concurrency() noexcept
  {
  return (_Thrd_hardware_concurrency());
  }

 native_handle_type native_handle()
  {
  return (_Thr._Hnd);
  }

private:
 thread& _Move_thread(thread& _Other)
  {
  if (joinable())
   ::std:: terminate();
  _Thr = _Other._Thr;
  (_Other._Thr._Hnd = 0, _Other._Thr._Id = 0);
  return (*this);
  }

 _Thrd_t _Thr;
 };

 namespace this_thread {
thread::id get_id() noexcept;

inline void yield() noexcept
 {
 _Thrd_yield();
 }

inline void sleep_until(const stdext::threads::xtime *_Abs_time)
 {
 _Thrd_sleep(_Abs_time);
 }

template<class _Rep,
 class _Period> inline
 void sleep_for(const chrono::duration<_Rep, _Period>& _Rel_time)
 {
 stdext::threads::xtime _Tgt = _To_xtime(_Rel_time);
 this_thread::sleep_until(&_Tgt);
 }

template<class _Clock,
 class _Duration> inline
 void sleep_until(
  const chrono::time_point<_Clock, _Duration>& _Abs_time)
 {
 this_thread::sleep_for(_Abs_time.time_since_epoch() - _Clock::now().time_since_epoch());
 }
 }

class thread::id
 {
public:
 id() noexcept
  : _Id(0)
  {
  }

 template<class _Ch,
  class _Tr>
  basic_ostream<_Ch, _Tr>& _To_text(
   basic_ostream<_Ch, _Tr>& _Str)
  {
  return (_Str << _Id);
  }

private:
 id(_Thrd_id_t _Other_id)
  : _Id(_Other_id)
  {
  }

 size_t _Hash_id() const
  {
  return (hash<_Thrd_id_t>()(_Id));
  }

 _Thrd_id_t _Id;

 friend thread::id thread::get_id() const noexcept;
 friend thread::id this_thread::get_id() noexcept;
 friend bool operator==(thread::id _Left, thread::id _Right) noexcept;
 friend bool operator<(thread::id _Left, thread::id _Right) noexcept;
 friend struct hash<thread::id>;
 };

inline void thread::join()
 {
 if (!joinable())
  _Throw_Cpp_error(_INVALID_ARGUMENT);
 const bool _Is_null = (_Thr._Id == 0);
 if (_Is_null)
  _Throw_Cpp_error(_INVALID_ARGUMENT);
 if (get_id() == ::std:: this_thread::get_id())
  _Throw_Cpp_error(_RESOURCE_DEADLOCK_WOULD_OCCUR);
 if (_Thrd_join(_Thr, 0) != _Thrd_success)
  _Throw_Cpp_error(_NO_SUCH_PROCESS);
 (_Thr._Hnd = 0, _Thr._Id = 0);
 }

inline thread::id thread::get_id() const noexcept
 {
 return (_Thr._Id);
 }

inline thread::id this_thread::get_id() noexcept
 {
 return (_Thrd_id());
 }

inline void swap(thread& _Left, thread& _Right) noexcept
 {
 _Left.swap(_Right);
 }

inline bool operator==(thread::id _Left, thread::id _Right) noexcept
 {
 return (_Left._Id == _Right._Id);
 }

inline bool operator!=(thread::id _Left, thread::id _Right) noexcept
 {
 return (!(_Left == _Right));
 }

inline bool operator<(thread::id _Left, thread::id _Right) noexcept
 {
 return (_Left._Id < _Right._Id);
 }

inline bool operator<=(thread::id _Left, thread::id _Right) noexcept
 {
 return (!(_Right < _Left));
 }

inline bool operator>(thread::id _Left, thread::id _Right) noexcept
 {
 return (_Right < _Left);
 }

inline bool operator>=(thread::id _Left, thread::id _Right) noexcept
 {
 return (!(_Left < _Right));
 }

template<class _Ch,
 class _Tr>
 basic_ostream<_Ch, _Tr>& operator<<(
  basic_ostream<_Ch, _Tr>& _Str,
  thread::id _Id)
 {
 return (_Id._To_text(_Str));
 }


template<>
 struct hash<thread::id>
 {
 typedef thread::id argument_type;
 typedef size_t result_type;

 size_t operator()(const argument_type& _Keyval) const
  {
  return (_Keyval._Hash_id());
  }
 };
}


#pragma warning(pop)
#pragma pack(pop)
# 5 "C:\\Users\\Cathy\\OneDrive\\JUCE Terrain\\Source/Shape.h" 2

# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\mutex" 1 3
# 18 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\mutex" 3
#pragma pack(push,8)
#pragma warning(push, 3)



namespace std {

class _Mutex_base
 {
public:
 _Mutex_base(int _Flags = 0) noexcept
  {
  _Mtx_init_in_situ(_Mymtx(), _Flags | _Mtx_try);
  }

 ~_Mutex_base() noexcept
  {
  _Mtx_destroy_in_situ(_Mymtx());
  }

 _Mutex_base(const _Mutex_base&) = delete;
 _Mutex_base& operator=(const _Mutex_base&) = delete;

 void lock()
  {
  _Mtx_lockX(_Mymtx());
  }

 bool try_lock()
  {
  return (_Mtx_trylockX(_Mymtx()) == _Thrd_success);
  }

 void unlock()
  {
  _Mtx_unlockX(_Mymtx());
  }

 typedef void *native_handle_type;

 native_handle_type native_handle()

  {
  return (_Mtx_getconcrtcs(_Mymtx()));
  }

private:
 friend class condition_variable;
 friend class condition_variable_any;

 aligned_storage<48,
  4>::type _Mtx_storage;

 _Mtx_t _Mymtx() noexcept
  {
  return (reinterpret_cast<_Mtx_t>(&_Mtx_storage));
  }
 };

class mutex
 : public _Mutex_base
 {
public:
                 mutex() noexcept
  : _Mutex_base()
  {
  }

 mutex(const mutex&) = delete;
 mutex& operator=(const mutex&) = delete;
 };

class recursive_mutex
 : public _Mutex_base
 {
public:
 recursive_mutex()
  : _Mutex_base(_Mtx_recursive)
  {
  }

 bool try_lock() noexcept
  {
  return (_Mutex_base::try_lock());
  }

 recursive_mutex(const recursive_mutex&) = delete;
 recursive_mutex& operator=(const recursive_mutex&) = delete;
 };



template<class _Lock0,
 class... _LockN> inline
 int try_lock(_Lock0&, _LockN&...);

template<class _Lock0> inline
 int _Try_lock(_Lock0& _Lk0)
 {
 if (!_Lk0.try_lock())
  return (0);
 else
  return (-1);
 }

template<class _Lock0,
 class _Lock1,
 class... _LockN> inline
 int _Try_lock(_Lock0& _Lk0, _Lock1& _Lk1, _LockN&... _LkN)
 {
 int _Res;
 if (!_Lk0.try_lock())
  return (0);
 try {

  if ((_Res = ::std:: try_lock(_Lk1, _LkN...)) != -1)
   {
   _Lk0.unlock();
   ++_Res;
   }
 } catch (...) {

  _Lk0.unlock();
  throw;
 }
 return (_Res);
 }

template<class _Lock0,
 class... _LockN> inline
 int try_lock(_Lock0& _Lk0, _LockN&... _LkN)
 {
 return (_Try_lock(_Lk0, _LkN...));
 }


template<class _Lock0,
 class _Lock1,
 class... _LockN> inline
 void lock(_Lock0& _Lk0, _Lock1& _Lk1, _LockN&... _LkN)
 {
 int _Res = 0;
 while (_Res != -1)
  _Res = _Try_lock(_Lk0, _Lk1, _LkN...);
 }



struct adopt_lock_t
 {
 };

struct defer_lock_t
 {
 };

struct try_to_lock_t
 {
 };
constexpr adopt_lock_t adopt_lock{};
constexpr defer_lock_t defer_lock{};
constexpr try_to_lock_t try_to_lock{};

template<class... _Mutexes>
 class lock_guard
 {
public:
 explicit lock_guard(_Mutexes&... _Mtxes)
  : _MyMutexes(_Mtxes...)
  {
  ::std:: lock(_Mtxes...);
  }

 lock_guard(_Mutexes&... _Mtxes, adopt_lock_t)
  : _MyMutexes(_Mtxes...)
  {
  }

 ~lock_guard() noexcept
  {
  _For_each_tuple_element(
   _MyMutexes,
   [](auto& _Mutex) noexcept { _Mutex.unlock(); });
  }

 lock_guard(const lock_guard&) = delete;
 lock_guard& operator=(const lock_guard&) = delete;
private:
 tuple<_Mutexes&...> _MyMutexes;
 };

template<class _Mutex>
 class lock_guard<_Mutex>
 {
public:
 typedef _Mutex mutex_type;

 explicit lock_guard(_Mutex& _Mtx)
  : _MyMutex(_Mtx)
  {
  _MyMutex.lock();
  }

 lock_guard(_Mutex& _Mtx, adopt_lock_t)
  : _MyMutex(_Mtx)
  {
  }

 ~lock_guard() noexcept
  {
  _MyMutex.unlock();
  }

 lock_guard(const lock_guard&) = delete;
 lock_guard& operator=(const lock_guard&) = delete;
private:
 _Mutex& _MyMutex;
 };

template<>
 class lock_guard<>
 {
public:
 explicit lock_guard()
  {
  }

 lock_guard(adopt_lock_t)
  {
  }

 ~lock_guard() noexcept
  {
  }

 lock_guard(const lock_guard&) = delete;
 lock_guard& operator=(const lock_guard&) = delete;
 };

template<class _Mutex>
 class unique_lock
 {
public:
 typedef unique_lock<_Mutex> _Myt;
 typedef _Mutex mutex_type;


 unique_lock() noexcept
  : _Pmtx(0), _Owns(false)
  {
  }

 explicit unique_lock(_Mutex& _Mtx)
  : _Pmtx(&_Mtx), _Owns(false)
  {
  _Pmtx->lock();
  _Owns = true;
  }

 unique_lock(_Mutex& _Mtx, adopt_lock_t)
  : _Pmtx(&_Mtx), _Owns(true)
  {
  }

 unique_lock(_Mutex& _Mtx, defer_lock_t) noexcept
  : _Pmtx(&_Mtx), _Owns(false)
  {
  }

 unique_lock(_Mutex& _Mtx, try_to_lock_t)
  : _Pmtx(&_Mtx), _Owns(_Pmtx->try_lock())
  {
  }

 template<class _Rep,
  class _Period>
  unique_lock(_Mutex& _Mtx,
   const chrono::duration<_Rep, _Period>& _Rel_time)
  : _Pmtx(&_Mtx), _Owns(_Pmtx->try_lock_for(_Rel_time))
  {
  }

 template<class _Clock,
  class _Duration>
  unique_lock(_Mutex& _Mtx,
   const chrono::time_point<_Clock, _Duration>& _Abs_time)
  : _Pmtx(&_Mtx), _Owns(_Pmtx->try_lock_until(_Abs_time))
  {
  }

 unique_lock(_Mutex& _Mtx, const xtime *_Abs_time)
  : _Pmtx(&_Mtx), _Owns(false)
  {
  _Owns = _Pmtx->try_lock_until(_Abs_time);
  }

 unique_lock(unique_lock&& _Other) noexcept
  : _Pmtx(_Other._Pmtx), _Owns(_Other._Owns)
  {
  _Other._Pmtx = 0;
  _Other._Owns = false;
  }

 unique_lock& operator=(unique_lock&& _Other)
  {
  if (this != &_Other)
   {
   if (_Owns)
    _Pmtx->unlock();
   _Pmtx = _Other._Pmtx;
   _Owns = _Other._Owns;
   _Other._Pmtx = 0;
   _Other._Owns = false;
   }
  return (*this);
  }

 ~unique_lock() noexcept
  {
  if (_Owns)
   _Pmtx->unlock();
  }

 unique_lock(const unique_lock&) = delete;
 unique_lock& operator=(const unique_lock&) = delete;


 void lock()
  {
  _Validate();
  _Pmtx->lock();
  _Owns = true;
  }

 bool try_lock()
  {
  _Validate();
  _Owns = _Pmtx->try_lock();
  return (_Owns);
  }

 template<class _Rep,
  class _Period>
  bool try_lock_for(const chrono::duration<_Rep, _Period>& _Rel_time)
  {
  _Validate();
  _Owns = _Pmtx->try_lock_for(_Rel_time);
  return (_Owns);
  }

 template<class _Clock,
  class _Duration>
  bool try_lock_until(
   const chrono::time_point<_Clock, _Duration>& _Abs_time)
  {
  _Validate();
  _Owns = _Pmtx->try_lock_until(_Abs_time);
  return (_Owns);
  }

 bool try_lock_until(const xtime *_Abs_time)
  {
  _Validate();
  _Owns = _Pmtx->try_lock_until(_Abs_time);
  return (_Owns);
  }

 void unlock()
  {
  if (!_Pmtx || !_Owns)
   throw system_error(::std:: make_error_code(errc::operation_not_permitted));


  _Pmtx->unlock();
  _Owns = false;
  }


 void swap(unique_lock& _Other) noexcept
  {
  ::std:: swap(_Pmtx, _Other._Pmtx);
  ::std:: swap(_Owns, _Other._Owns);
  }

 _Mutex *release() noexcept
  {
  _Mutex *_Res = _Pmtx;
  _Pmtx = 0;
  _Owns = false;
  return (_Res);
  }


 bool owns_lock() const noexcept
  {
  return (_Owns);
  }

 explicit operator bool() const noexcept
  {
  return (_Owns);
  }

 _Mutex *mutex() const noexcept
  {
  return (_Pmtx);
  }

private:
 _Mutex *_Pmtx;
 bool _Owns;

 void _Validate() const
  {
  if (!_Pmtx)
   throw system_error(::std:: make_error_code(errc::operation_not_permitted));


  if (_Owns)
   throw system_error(::std:: make_error_code(errc::resource_deadlock_would_occur));

  }
 };


template<class _Mutex>
 void swap(unique_lock<_Mutex>& _Left,
  unique_lock<_Mutex>& _Right) noexcept
 {
 _Left.swap(_Right);
 }


struct once_flag
 {
 constexpr once_flag() noexcept
  : _Opaque(0)
  {
  }

 once_flag(const once_flag&) = delete;
 once_flag& operator=(const once_flag&) = delete;

 void *_Opaque;
 };


template<class... _Types,
 size_t... _Indices> inline
 auto _Invoke_stored_explicit(tuple<_Types...>&& _Tuple, integer_sequence<size_t, _Indices...>)
  -> decltype(::std:: invoke(::std:: get<_Indices>(::std:: move(_Tuple))...))
 {
 return (::std:: invoke(::std:: get<_Indices>(::std:: move(_Tuple))...));
 }


template<class... _Types> inline
 auto _Invoke_stored(tuple<_Types...>&& _Tuple)
  -> decltype(_Invoke_stored_explicit(::std:: move(_Tuple), make_integer_sequence<size_t, sizeof...(_Types)>()))
 {
 return (_Invoke_stored_explicit(::std:: move(_Tuple), make_integer_sequence<size_t, sizeof...(_Types)>()));
 }


typedef int (__stdcall *_Lambda_fp_t)(void *, void *, void **);
              int __cdecl _Execute_once(
 once_flag& _Flag, _Lambda_fp_t _Lambda_fp, void *_Pv) noexcept;

[[noreturn]] void __cdecl _XGetLastError();

template<class _Tuple,
 class _Seq,
 size_t _Idx> inline
 int __stdcall _Callback_once(void *, void *_Pv, void **)
 {
 _Tuple *_Ptup = static_cast<_Tuple *>(_Pv);

 try {

  _Invoke_stored_explicit(::std:: move(*_Ptup), _Seq());
 } catch (...) {
  auto& _Ref = ::std:: get<_Idx>(*_Ptup);
  _Ref = ::std:: current_exception();
  return (0);
 }

 return (1);
 }

template<class _Fn,
 class... _Args> inline
 void (call_once)(once_flag& _Flag, _Fn&& _Fx, _Args&&... _Ax)
 {
 typedef tuple<_Fn&&, _Args&&..., ::std:: exception_ptr&> _Tuple;
 typedef make_integer_sequence<size_t, 1 + sizeof...(_Args)> _Seq;

 ::std:: exception_ptr _Exc;
 _Tuple _Tup(::std:: forward<_Fn>(_Fx), ::std:: forward<_Args>(_Ax)..., _Exc);

 _Lambda_fp_t _Fp = &_Callback_once<_Tuple, _Seq, 1 + sizeof...(_Args)>;

 if (_Execute_once(_Flag, _Fp, ::std:: addressof(_Tup)) != 0)
  return;

 if (_Exc)
  ::std:: rethrow_exception(_Exc);

 _XGetLastError();
 }

enum class cv_status {
 no_timeout,
 timeout
 };

typedef cv_status _Cv_status;

class condition_variable
 {
public:
 typedef _Cnd_t native_handle_type;

 condition_variable()
  {
  _Cnd_init_in_situ(_Mycnd());
  }

 ~condition_variable() noexcept
  {
  _Cnd_destroy_in_situ(_Mycnd());
  }

 condition_variable(const condition_variable&) = delete;
 condition_variable& operator=(const condition_variable&) = delete;

 void notify_one() noexcept
  {
  _Cnd_signalX(_Mycnd());
  }

 void notify_all() noexcept
  {
  _Cnd_broadcastX(_Mycnd());
  }

 void wait(unique_lock<mutex>& _Lck)
  {
  _Cnd_waitX(_Mycnd(), _Lck.mutex()->_Mymtx());
  }

 template<class _Predicate>
  void wait(unique_lock<mutex>& _Lck, _Predicate _Pred)
  {
  while (!_Pred())
   wait(_Lck);
  }

 template<class _Rep,
  class _Period>
  _Cv_status wait_for(
   unique_lock<mutex>& _Lck,
   const chrono::duration<_Rep, _Period>& _Rel_time)
  {
  ::stdext:: threads::xtime _Tgt = _To_xtime(_Rel_time);
  return (wait_until(_Lck, &_Tgt));
  }

 template<class _Rep,
  class _Period,
  class _Predicate>
  bool wait_for(
   unique_lock<mutex>& _Lck,
   const chrono::duration<_Rep, _Period>& _Rel_time,
   _Predicate _Pred)
  {
  ::stdext:: threads::xtime _Tgt = _To_xtime(_Rel_time);
  return (_Wait_until1(_Lck, &_Tgt, _Pred));
  }

 template<class _Clock,
  class _Duration>
  _Cv_status wait_until(
   unique_lock<mutex>& _Lck,
   const chrono::time_point<_Clock, _Duration>& _Abs_time)
  {
  typename chrono::time_point<_Clock, _Duration>::duration
   _Rel_time = _Abs_time - _Clock::now();
  return (wait_for(_Lck, _Rel_time));
  }

 template<class _Clock,
  class _Duration,
  class _Predicate>
  bool wait_until(
   unique_lock<mutex>& _Lck,
   const chrono::time_point<_Clock, _Duration>& _Abs_time,
   _Predicate _Pred)
  {
  typename chrono::time_point<_Clock, _Duration>::duration
   _Rel_time = _Abs_time - _Clock::now();
  ::stdext:: threads::xtime _Tgt = _To_xtime(_Rel_time);
  return (_Wait_until1(_Lck, &_Tgt, _Pred));
  }

 _Cv_status wait_until(
  unique_lock<mutex>& _Lck,
  const xtime *_Abs_time)
  {
  if (!_Mtx_current_owns(_Lck.mutex()->_Mymtx()))
   _Throw_Cpp_error(_OPERATION_NOT_PERMITTED);
  int _Res = _Cnd_timedwaitX(_Mycnd(),
   _Lck.mutex()->_Mymtx(), _Abs_time);
  return (_Res == _Thrd_timedout
   ? cv_status::timeout : cv_status::no_timeout);
  }

 template<class _Predicate>
  bool wait_until(
   unique_lock<mutex>& _Lck,
   const xtime *_Abs_time,
   _Predicate _Pred)
  {
  return (_Wait_until1(_Lck, _Abs_time, _Pred));
  }

 template<class _Predicate>
  bool _Wait_until1(
   unique_lock<mutex>& _Lck,
   const xtime *_Abs_time,
   _Predicate& _Pred)
  {
  while (!_Pred())
   if (wait_until(_Lck, _Abs_time) == cv_status::timeout)
    return (_Pred());
  return (true);
  }

 native_handle_type native_handle()
  {
  return (_Mycnd());
  }

 void _Register(unique_lock<mutex>& _Lck, int *_Ready)
  {
  _Cnd_register_at_thread_exit(_Mycnd(),
   _Lck.release()->_Mymtx(), _Ready);
  }

 void _Unregister(mutex& _Mtx)
  {
  _Cnd_unregister_at_thread_exit(_Mtx._Mymtx());
  }

private:
 aligned_storage<40,
  4>::type _Cnd_storage;

 _Cnd_t _Mycnd() noexcept
  {
  return (reinterpret_cast<_Cnd_t>(&_Cnd_storage));
  }
 };

class timed_mutex
 {
public:
 timed_mutex() noexcept
  : _My_locked(0)
  {
  }

 timed_mutex(const timed_mutex&) = delete;
 timed_mutex& operator=(const timed_mutex&) = delete;

 void lock()
  {
  unique_lock<mutex> _Lock(_My_mutex);
  while (_My_locked != 0)
   _My_cond.wait(_Lock);
  _My_locked = 0xffffffff;
  }

 bool try_lock() noexcept
  {
  lock_guard<mutex> _Lock(_My_mutex);
  if (_My_locked != 0)
   return (false);
  else
   {
   _My_locked = 0xffffffff;
   return (true);
   }
  }

 void unlock()
  {
   {

   lock_guard<mutex> _Lock(_My_mutex);
   _My_locked = 0;
   }
  _My_cond.notify_one();
  }

 template<class _Rep,
  class _Period>
  bool try_lock_for(const chrono::duration<_Rep, _Period>& _Rel_time)
  {
  return (try_lock_until(chrono::steady_clock::now() + _Rel_time));
  }

 template<class _Time>
  bool _Try_lock_until(_Time _Abs_time)
  {
  unique_lock<mutex> _Lock(_My_mutex);
  if (!_My_cond.wait_until(_Lock, _Abs_time,
   [this] { return (_My_locked == 0); }))
    return (false);
  _My_locked = 0xffffffff;
  return (true);
  }

 template<class _Clock,
  class _Duration>
  bool try_lock_until(
  const chrono::time_point<_Clock, _Duration>& _Abs_time)
  {
  return (_Try_lock_until(_Abs_time));
  }

 bool try_lock_until(const xtime *_Abs_time)
  {
  return (_Try_lock_until(_Abs_time));
  }

private:
 mutex _My_mutex;
 condition_variable _My_cond;
 unsigned int _My_locked;
 };

class recursive_timed_mutex
 {
public:
 recursive_timed_mutex() noexcept
  : _My_locked(0)
  {
  }

 recursive_timed_mutex(const recursive_timed_mutex&) = delete;
 recursive_timed_mutex& operator=(const recursive_timed_mutex&) = delete;

 void lock()
  {
  thread::id _Tid = this_thread::get_id();

  unique_lock<mutex> _Lock(_My_mutex);

  if (_Tid == _My_owner)
   {
   if (_My_locked < 0xffffffff)
    ++_My_locked;
   else
    throw system_error(::std:: make_error_code(errc::device_or_resource_busy));

   }
  else
   {
   while (_My_locked != 0)
    _My_cond.wait(_Lock);
   _My_locked = 1;
   _My_owner = _Tid;
   }
  }

 bool try_lock() noexcept
  {
  thread::id _Tid = this_thread::get_id();

  lock_guard<mutex> _Lock(_My_mutex);

  if (_Tid == _My_owner)
   {
   if (_My_locked < 0xffffffff)
    ++_My_locked;
   else
    return (false);
   }
  else
   {
   if (_My_locked != 0)
    return (false);
   else
    {
    _My_locked = 1;
    _My_owner = _Tid;
    }
   }
  return (true);
 }

 void unlock()
  {
  bool _Do_notify = false;

   {
   lock_guard<mutex> _Lock(_My_mutex);
   --_My_locked;
   if (_My_locked == 0)
    {
    _Do_notify = true;
    _My_owner = thread::id();
    }
   }

  if (_Do_notify)
   _My_cond.notify_one();
  }

 template<class _Rep,
  class _Period>
  bool try_lock_for(const chrono::duration<_Rep, _Period>& _Rel_time)
  {
  return (try_lock_until(chrono::steady_clock::now() + _Rel_time));
  }

 template<class _Time>
  bool _Try_lock_until(_Time _Abs_time)
  {
  thread::id _Tid = this_thread::get_id();

  unique_lock<mutex> _Lock(_My_mutex);

  if (_Tid == _My_owner)
   {
   if (_My_locked < 0xffffffff)
    ++_My_locked;
   else
    return (false);
   }
  else
   {
   if (!_My_cond.wait_until(_Lock, _Abs_time,
    [this] { return (_My_locked == 0); }))
     return (false);
   _My_locked = 1;
   _My_owner = _Tid;
   }
  return (true);
  }

 template<class _Clock,
  class _Duration>
  bool try_lock_until(
  const chrono::time_point<_Clock, _Duration>& _Abs_time)
  {
  return (_Try_lock_until(_Abs_time));
  }

 bool try_lock_until(const xtime *_Abs_time)
  {
  return (_Try_lock_until(_Abs_time));
  }

private:
 mutex _My_mutex;
 condition_variable _My_cond;
 unsigned int _My_locked;
 thread::id _My_owner;
 };
}

#pragma warning(pop)
#pragma pack(pop)
# 6 "C:\\Users\\Cathy\\OneDrive\\JUCE Terrain\\Source/Shape.h" 2


class Shape
 : public PerlinNoise
 , public Inter{
public:
 Shape(OpenGLContext &context, OpenGLShaderProgram& shader);
 ~Shape();
 void init();
 void reset();
 void draw();

 void setWidth(const int &w);
 void setHeight(const int &h);
 void setDepth(const int &d);
 void setLocalBounds(Rectangle<int> b);
 void setRockiness(const double &newRockiness);
 void setDrawMode(const bool &shouldBeFilled);

 void sendData(Options option, double d = 0.0, int i = 0, Modes mode = Modes::DEFAULT, Colour = Colour(0)) override;
 bool isFree() override;

 int getWigth();
 int getHeight();
 int getDepth();
 double getRockiness();

 void setMode(const Modes &mode);
 void genDefaultData();
 void genData(GLfloat *&vertices, GLuint *&indices, int &verticesCount, int &indicesCount, int &w, int &d);
 void swapData();


private:
 OpenGLShaderProgram::Attribute* createAttribute(OpenGLShaderProgram& shader, const char* attribName);
 OpenGLShaderProgram::Uniform* createUniform(OpenGLShaderProgram& shader, const char* uniformName);

 Matrix3D<float> getProjectionMatrix();
 Matrix3D<float> getViewMatrix();
 Matrix3D<float> getTransMatrix();

 void freeData(GLfloat *&vertices, GLuint *&indices);
 void deleteBuffers();

 std::thread _backThread, _updThread;
 std::mutex _mutex;

 OpenGLContext &_openGLContext;
 GLfloat *_vertices, *_backVertices;
 GLuint *_indices, *_backIndices;
 int _verticesCount, _backVerticesCount;
 int _indicesCount, _backIndicesCount;
 Modes _mode;
 GLuint _vertexBuffer;
 GLuint _indexBuffer;
 int _width;
 int _depth;
 int _height;
 int _drawWidth, _updWidth, _backWidth;
 int _drawDepth, _updDepth, _backDepth;
 ScopedPointer<OpenGLShaderProgram::Attribute> _position;
 ScopedPointer<OpenGLShaderProgram::Uniform> _projectionMatrix, _viewMatrix, _trans, _offset, _top, _far, _near;
 Colour _topc, _nearc, _farc;
 Rectangle<int> _localBounds;
 double _delta;
 double _block;

 bool _drawLines;
 bool _startNewGen;
 bool _backTh, _updTh;
 int _off;

 Shape (const Shape&) = delete; Shape& operator= (const Shape&) = delete;
};
# 4 "C:\\Users\\Cathy\\OneDrive\\JUCE Terrain\\Source/ContentComponent.h" 2


class ContentComponent
 : public Component
 , private OpenGLRenderer
 , public KeyListener
 , public BackgoundColor
{
public:
 ContentComponent(DocumentWindow *win);
 ~ContentComponent();

 void paint(Graphics &g) override;
 void resized() override;

 void newOpenGLContextCreated() override;
 void renderOpenGL() override;
 void openGLContextClosing() override;

 bool keyPressed(const KeyPress &key, Component *originatingComponent) override;

 void reset();
 ControlsOverlay *getControls();

 void setColor(Colour c) override;

private:
 void createShaders();

 OpenGLContext _openGLContext;
 ScopedPointer<OpenGLShaderProgram> _shader;
 ScopedPointer<Shape> _shape;

 SafePointer<ControlsOverlay> _controlsOverlay;

 const char *_vertexShader;
 const char *_fragmentShader;

 Colour _background;

 ContentComponent (const ContentComponent&) = delete; ContentComponent& operator= (const ContentComponent&) = delete;
};
# 1 "c:\\users\\cathy\\onedrive\\juce terrain\\source\\contentcomponent.cpp" 2


ContentComponent::ContentComponent(DocumentWindow *win)
 : Component("Content")
 , _background(Colour::fromFloatRGBA(0.71f, 0.7f, 0.72f, 0.0f))
{
 _openGLContext.setRenderer(this);
 _openGLContext.attachTo(*this);
 _openGLContext.setContinuousRepainting(true);

 addAndMakeVisible(_controlsOverlay = new ControlsOverlay(win, this));
 _controlsOverlay->setAlwaysOnTop(true);
}

ContentComponent::~ContentComponent() {
 deleteAllChildren();
 _openGLContext.detach();
}

void ContentComponent::paint(Graphics &g) {
}

void ContentComponent::resized() {
 _controlsOverlay->setBounds(getLocalBounds());
}

void ContentComponent::newOpenGLContextCreated() {
 createShaders();
}

void ContentComponent::renderOpenGL() {
 OpenGLHelpers::clear(_background);

 glEnable(0x0BE2);
 glBlendFunc(0x0302, 0x0303);

 _shader->use();
 _shape->setLocalBounds(getLocalBounds());
 _shape->draw();

 _openGLContext.extensions.glBindBuffer(GL_ARRAY_BUFFER, 0);
 _openGLContext.extensions.glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
}

void ContentComponent::openGLContextClosing() {
}

bool ContentComponent::keyPressed(const KeyPress & key, Component * originatingComponent) {
 _controlsOverlay->keyPressed(key, originatingComponent);
 return true;
}

void ContentComponent::reset() {
 _shape->reset();
}

ControlsOverlay * ContentComponent::getControls() {
 return _controlsOverlay;
}

void ContentComponent::setColor(Colour c) {
 _background = c;
}

void ContentComponent::createShaders() {
 _vertexShader = "#version 330 core\n"
  "attribute vec3 position;\n"
  "varying vec4 vertexColor;\n"
  "varying vec3 pos;\n"

  "uniform mat4 proj;\n"
  "uniform mat4 view;\n"
  "uniform mat4 trans;\n"
  "uniform vec3 offset;\n"
  "uniform vec3 top;\n"
  "uniform vec3 far;\n"
  "uniform vec3 near;\n"
  "\n"

  "void main() {\n"
  "gl_Position = (proj + trans) * view * vec4(position - offset, 1.0);\n"
  "pos = vec3((position.x + 1.0) * 0.5, position.y, (position.z - offset.z));\n"

  "vertexColor = vec4(pos.y * top.x + (pos.z + 1.0) * 0.5 * near.x - pos.z * far.x, pos.y * top.y + (pos.z + 1.0) * 0.5 * near.y - pos.z * far.y, pos.y * top.z + (pos.z + 1.0) * 0.5 * near.z - pos.z * far.z, 1.0);\n"

  "}\n";

 _fragmentShader = "#version 330 core\n"
  "varying vec4 vertexColor;\n"
  "\n"
  "void main() {\n"
  "gl_FragColor = vertexColor;\n"
  "}\n";

 OpenGLShaderProgram *tempShader = new OpenGLShaderProgram(_openGLContext);
 if (tempShader->addVertexShader(OpenGLHelpers::translateVertexShaderToV3(_vertexShader))
  && tempShader->addFragmentShader(OpenGLHelpers::translateFragmentShaderToV3(_fragmentShader))
  && tempShader->link()) {
  _shader = tempShader;
  _shader->use();

  _shape = new Shape(_openGLContext, *_shader);
  _controlsOverlay->setInter(_shape);
  _shape->setWidth(500);
  _shape->setDepth(500);
  _shape->reset();
  _shape->init();
 }
 else throw 1;
}
